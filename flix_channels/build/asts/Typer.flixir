def !>(x$8555: a, f$8559: a -> Unit): a \ ef = {f$8559(x$8555); x$8555}

def ++(x$41062: a, y$41066: a): a = {<[unknown exp]>(x$41062, y$41066)}

def >>(f$8473: a -> b, g$8477: b -> c): a -> c = {
    x$8486 ->
        g$8477(f$8473(x$8486))
}

def bug!(m$8666: String): a = {<[unknown exp]>}

def cat(
    file$58346474: String,
    stdOut$58346481: Sender[String, r],
    errOut$58346496: Sender[String, r]
): Unit \ IO + IO + r = {
    let read$58346512: Result[IOError, List[String]] = Files.readLines(
        file$58346474
    );
    match matchedLines(read$58346512) {
        case (listOfAcceptedLines$58346532, _error$58346534) =>
            region reg$58306558$58346540 {
                Iterator.forEach(
                    pat$58306559$58346547 ->
                        match pat$58306559$58346547 {
                            case line$58346550 =>
                                Channel.send(line$58346550, stdOut$58346481)
                        },
                    <[unknown exp]>(
                        reg$58306558$58346540,
                        listOfAcceptedLines$58346532
                    )
                )
            };
            Channel.send("""Last Line""", stdOut$58346481);
            Channel.send("""Last Line""", errOut$58346496)
    }
}

def coerce(x$8567: t): Out[t] = {<[unknown exp]>(x$8567)}

def collectAndEnd(
    stdIn$58346849: Receiver[String, r],
    errIn$58346852: Receiver[String, r]
): (String, List[String]) \ IO + r = {
    let output$58346870: List[String] = collectChannel(
        List.empty(()),
        stdIn$58346849
    );
    let outputJoined$58346886: String = List.join("""
""", output$58346870);
    let errors$58346897: List[String] = collectChannel(
        List.empty(()),
        errIn$58346852
    );
    let uniqueErrors$58346907: List[String] = List.distinct(errors$58346897);
    (outputJoined$58346886, uniqueErrors$58346907)
}

def collectChannel(
    acc$58346965: List[String],
    rx$58346971: Receiver[String, r]
): List[String] \ IO + r = {
    let newString$58346982: String = Channel.recv(rx$58346971);
    if (<[unknown exp]>(newString$58346982, """Last Line""")) {
        acc$58346965
    } else {
        let newStringAsList$58346990: List[String] = List.Cons(
            newString$58346982,
            List.Nil
        );
        let newList$58346998: List[String] = List.append(
            acc$58346965,
            newStringAsList$58346990
        );
        collectChannel(newList$58346998, rx$58346971)
    }
}

def constant(x$8233: a): b -> a = {_$8243 -> <[unknown exp]>}

def cp(
    source$58345273: String,
    destination$58345281: String,
    stdIn$58345285: Receiver[String, r],
    stdOut$58345291: Sender[String, r],
    _errIn$58345296: Receiver[String, r],
    errOut$58345301: Sender[String, r]
): Unit \ IO + r = {
    let result$58345307: t58353714 = Files.copy(source$58345273, ?astError);
    ?astError
}

def cut(
    n$58345459: List[Int32],
    stdIn$58345466: Receiver[String, r],
    stdOut$58345474: Sender[String, r],
    errIn$58345490: Receiver[String, r],
    errOut$58345492: Sender[String, r]
): Unit \ r = {
    let input$58345502: String = Channel.recv(stdIn$58345466);
    if (<[unknown exp]>(input$58345502, """Last Line""")) {
        Channel.send(input$58345502, stdOut$58345474);
        Channel.send("""Last Line""", errOut$58345492)
    } else {
        let columns$58345532: List[String] = String.split(
            {+regex = """,""" | {}},
            input$58345502
        );
        let extraction$58345549: String = |>(
            columns$58345532,
            (
                $0$58353337 ->
                    $1$58353339 ->
                        indices($0$58353337, $1$58353339)
            )(n$58345459)
        ): String;
        Channel.send(extraction$58345549, stdOut$58345474);
        cut(
            n$58345459,
            stdIn$58345466,
            stdOut$58345474,
            errIn$58345490,
            errOut$58345492
        )
    }
}

def echo(
    stdIn$58345747: Receiver[String, r],
    stdOut$58345758: Sender[String, r],
    errIn$58345762: Receiver[String, r],
    errOut$58345771: Sender[String, r]
): Unit \ IO + IO + r = {
    let input$58345777: String = Channel.recv(stdIn$58345747);
    println(
        ("""""" + """stdIn at echo:  """) + <[unknown exp]>(input$58345777)
    );
    if (<[unknown exp]>(input$58345777, """Last Line""")) {
        Channel.send(input$58345777, stdOut$58345758);
        Channel.send("""Last Line""", errOut$58345771)
    } else {
        Channel.send(input$58345777, stdOut$58345758);
        echo(stdIn$58345747, stdOut$58345758, errIn$58345762, errOut$58345771)
    }
}

def eidentity(x$8193: a): a \ ef = {<[unknown exp]>}

def endWithError(
    errMessage$58347030: String,
    stdOut$58347037: Sender[String, r],
    errOut$58347054: Sender[String, r]
): Unit \ r = {
    Channel.send(errMessage$58347030, errOut$58347054);
    Channel.send("""Last Line""", errOut$58347054);
    Channel.send("""Last Line""", stdOut$58347037)
}

def exists(s$58346197: String): Bool \ IO = {
    let exist$58346208: Result[IOError, Bool] = Files.exists(s$58346197);
    match exist$58346208 {
        case Result.Ok(b$58346210) =>
            b$58346210
        case Result.Err(_e$58346212) =>
            false
    }
}

def flip(f$8267: a -> b -> c \ ef): b -> a -> c \ ef = {
    x$8286 ->
        y$8290 ->
            f$8267(y$8290)(x$8286)
}

def fst(p$8354: (a, b)): a = {match p$8354 {case (x$8362, _) => x$8362}}

def grep(
    pattern$58346684: String,
    rx$58346686: Receiver[String, r],
    tx$58346692: Sender[String, r]
): Unit \ IO + r = {
    let stdin$58346696: String = Channel.recv(rx$58346686);
    if (<[unknown exp]>(stdin$58346696, """Last Line""")) {
        Channel.send(stdin$58346696, tx$58346692)
    } else {
        if (<[unknown exp]>(stdin$58346696, pattern$58346684)) {
            Channel.send(stdin$58346696, tx$58346692);
            grep(pattern$58346684, rx$58346686, tx$58346692)
        } else {
            grep(pattern$58346684, rx$58346686, tx$58346692)
        }
    }
}

def head(
    n$58346759: Int32,
    rx$58346762: Receiver[String, r],
    tx$58346766: Sender[String, r]
): Unit \ IO + r = {
    let stdin$58346784: String = Channel.recv(rx$58346762);
    if (<[unknown exp]>(stdin$58346784, """Last Line""")) {
        Channel.send(stdin$58346784, tx$58346766)
    } else {
        if (<[unknown exp]>(n$58346759, 1i32)) {
            Channel.send(stdin$58346784, tx$58346766);
            Channel.send("""Last Line""", tx$58346766)
        } else {
            Channel.send(stdin$58346784, tx$58346766);
            head(<[unknown exp]>(n$58346759, 1i32), rx$58346762, tx$58346766)
        }
    }
}

def identity(x$8179: a): a = {x$8179}

def index(index$58345581: Int32, l$58345583: List[String]): String = {
    |>(
        |>(
            List.drop(index$58345581, l$58345583),
            $0$58353341 ->
                List.head($0$58353341)
        ),
        (
            $0$58353343 ->
                $1$58353345 ->
                    Option.getWithDefault($0$58353343, $1$58353345)
        )("""""")
    )
}

def indices(n$58345642: List[Int32], l$58345646: List[String]): String = {
    let columns$58345658: List[String] = region forEachYieldIteratorRegion$58306550$58345660 {
        <[unknown exp]>(
            Iterator.flatMap(
                pat$58306551$58345666 ->
                    match pat$58306551$58345666 {
                        case ind$58345673 =>
                            Iterator.singleton(
                                forEachYieldIteratorRegion$58306550$58345660,
                                index(ind$58345673, l$58345646)
                            )
                    },
                <[unknown exp]>(
                    forEachYieldIteratorRegion$58306550$58345660,
                    n$58345642
                )
            )
        )
    }: List[String];
    let result$58345701: String = List.join(""",""", columns$58345658);
    result$58345701
}

def main(_unit$58345074: Unit): Unit \ IO = {
    region rc$58345127 {
        match Channel.buffered(rc$58345127, 100i32) {
            case (stdSend1$58345148, stdRec1$58345150) =>
                match Channel.buffered(rc$58345127, 100i32) {
                    case (errSend1$58345155, errRec1$58345157) =>
                        match Channel.buffered(rc$58345127, 100i32) {
                            case (stdSend2$58345163, stdRec2$58345165) =>
                                match Channel.buffered(rc$58345127, 100i32) {
                                    case (
                                        errSend2$58345174,
                                        errRec2$58345180
                                    ) =>
                                        (
                                            spawn cat(
                                                """./test/navnetabel1.txt""",
                                                stdSend1$58345148,
                                                errSend1$58345155
                                            )
                                        ) @ rc$58345127;
                                        (
                                            spawn tail(
                                                5i32,
                                                stdRec1$58345150,
                                                stdSend2$58345163,
                                                errRec1$58345157,
                                                errSend2$58345174
                                            )
                                        ) @ rc$58345127;
                                        match collectAndEnd(
                                            stdRec2$58345165,
                                            errRec2$58345180
                                        ) {
                                            case (
                                                result$58345214,
                                                error$58345218
                                            ) =>
                                                println(
                                                    (
                                                        """""" + """StdOut: 
"""
                                                    ) + <[unknown exp]>(
                                                        result$58345214
                                                    )
                                                );
                                                println("""""");
                                                println(
                                                    (
                                                        """""" + """StdErr: 
"""
                                                    ) + <[unknown exp]>(
                                                        error$58345218
                                                    )
                                                )
                                        }
                                }
                        }
                }
        }
    }
}

def matchedLines(
    r$58346606: Result[IOError, List[String]]
): (List[String], String) = {
    match r$58346606 {
        case Result.Ok(l$58346627) =>
            (l$58346627, """""")
        case Result.Err(_e$58346640) =>
            (List.Cons("""""", List.Nil), """Cat could not find file""")
    }
}

def on(
    f$8311: b -> b -> c \ ef1,
    g$8326: a -> b,
    x$8330: a,
    y$8332: a
): c \ ef1 + ef2 = {
    f$8311(g$8326(x$8330))(g$8326(y$8332))
}

def printUnlessUnit(x$9824: a): Unit \ IO = {<[unknown exp]>}

def println(x$8586: a): Unit \ IO = {
    let getOut$8597: (Unit -> java.io.PrintStream) = _$8599 ->
        ##java.lang.System.out;
    let println$8606: (
        java.io.PrintStream -> String -> Unit \ IO
    ) = obj$$8610 ->
        a0$$8614 ->
            obj$$8610..println(a0$$8614);
    |>(
        |>(x$8586, $0$45462 -> <[unknown exp]>($0$45462)),
        println$8606(getOut$8597(()))
    )
}

def purityOf(f$10166: a -> b): Purity[a, b, ef] = {<[unknown exp]>}

def purityOf2(f$10226: a -> b -> c \ ef): Purity2[a, b, c, ef] = {
    <[unknown exp]>
}

def purityOf3(f$10271: a -> b -> (c -> d \ ef)): Purity3[a, b, c, d, ef] = {
    <[unknown exp]>
}

def snd(p$8386: (a, b)): b = {match p$8386 {case (_, y$8395) => y$8395}}

def sort(
    rx$58346366: Receiver[String, r],
    tx$58346381: Sender[String, r]
): Unit \ IO + r = {
    let list$58346397: List[String] = collectChannel(
        List.empty(()),
        rx$58346366
    );
    let sortedList$58346415: List[String] = List.sort(list$58346397);
    region reg$58306556$58346428 {
        Iterator.forEach(
            pat$58306557$58346435 ->
                match pat$58306557$58346435 {
                    case line$58346437 =>
                        Channel.send(line$58346437, tx$58346381)
                },
            <[unknown exp]>(reg$58306556$58346428, sortedList$58346415)
        )
    };
    Channel.send("""Last Line""", tx$58346381)
}

def swap(p$8404: (a, b)): (b, a) = {
    match p$8404 {case (x$8414, y$8417) => (y$8417, x$8414)}
}

def tail(
    n$58345951: Int32,
    stdIn$58345957: Receiver[String, r],
    stdOut$58345963: Sender[String, r],
    _errIn$58345967: Receiver[String, r],
    errOut$58345969: Sender[String, r]
): Unit \ IO + r = {
    let list$58345993: List[String] = collectChannel(
        List.empty(()),
        stdIn$58345957
    );
    let listLength$58346001: Int32 = List.length(list$58345993);
    if (<[unknown exp]>(1i32, n$58345951)) {
        endWithError(
            (
                (
                    """""" + """Error! Tail was called with argument *"""
                ) + <[unknown exp]>(n$58345951)
            ) + """*, but needs at least 1""",
            stdOut$58345963,
            errOut$58345969
        )
    } else {
        let newList$58346013: List[String] = List.slice(
            {+start = <[unknown exp]>(listLength$58346001, n$58345951) | {}},
            {+end = listLength$58346001 | {}},
            list$58345993
        );
        region reg$58306552$58346028 {
            Iterator.forEach(
                pat$58306553$58346036 ->
                    match pat$58306553$58346036 {
                        case line$58346047 =>
                            Channel.send(line$58346047, stdOut$58345963)
                    },
                <[unknown exp]>(reg$58306552$58346028, newList$58346013)
            )
        };
        Channel.send("""Last Line""", stdOut$58345963);
        Channel.send("""Last Line""", errOut$58345969)
    }
}

def tee(
    path$58346105: String,
    stdIn$58346112: Receiver[String, r],
    stdOut$58346119: Sender[String, r],
    errIn$58346125: Receiver[String, r],
    errOut$58346129: Sender[String, r]
): Unit \ IO + r = {
    let line$58346142: String = Channel.recv(stdIn$58346112);
    let _result$58346147: Result[IOError, Bool] = Files.append(
        path$58346105,
        line$58346142
    );
    if (<[unknown exp]>(line$58346142, """Last Line""")) {
        let err$58346160: String = Channel.recv(errIn$58346125);
        Channel.send(line$58346142, stdOut$58346119);
        Channel.send(err$58346160, errOut$58346129)
    } else {
        Channel.send(line$58346142, stdOut$58346119);
        tee(
            path$58346105,
            stdIn$58346112,
            stdOut$58346119,
            errIn$58346125,
            errOut$58346129
        )
    }
}

def touch(_$8653: Region[r]): Unit \ r = {<[unknown exp]>}

def trans(
    command$58345855: String,
    stdIn$58345857: Receiver[String, r],
    stdOut$58345865: Sender[String, r],
    errIn$58345872: Receiver[String, r],
    errOut$58345875: Sender[String, r]
): Unit \ r = {
    let input$58345887: String = Channel.recv(stdIn$58345857);
    if (<[unknown exp]>(input$58345887, """Last Line""")) {
        Channel.send(input$58345887, stdOut$58345865);
        Channel.send("""Last Line""", errOut$58345875)
    } else {
        match command$58345855 {
            case """toLowerCase""" =>
                Channel.send(
                    String.toLowerCase(input$58345887),
                    stdOut$58345865
                )
            case """toUpperCase""" =>
                Channel.send(
                    String.toUpperCase(input$58345887),
                    stdOut$58345865
                )
            case _ =>
                Channel.send(
                    (
                        (
                            """""" + """Error! Trans-function called with function """
                        ) + <[unknown exp]>(command$58345855)
                    ) + """, which is not a known command""",
                    errOut$58345875
                )
        };
        trans(
            command$58345855,
            stdIn$58345857,
            stdOut$58345865,
            errIn$58345872,
            errOut$58345875
        )
    }
}

def uniq(
    rx$58346231: Receiver[String, r],
    tx$58346239: Sender[String, r]
): Unit \ IO + r = {
    let list$58346255: List[String] = collectChannel(
        List.empty(()),
        rx$58346231
    );
    let unique$58346274: List[String] = List.distinct(list$58346255);
    region reg$58306554$58346293 {
        Iterator.forEach(
            pat$58306555$58346298 ->
                match pat$58306555$58346298 {
                    case line$58346300 =>
                        Channel.send(line$58346300, tx$58346239)
                },
            <[unknown exp]>(reg$58306554$58346293, unique$58346274)
        )
    };
    Channel.send("""Last Line""", tx$58346239)
}

def unreachable!(_unit$9792: Unit): a = {
    bug!("""Reached unreachable expression.""")
}

def wc(
    stdIn$58345330: Receiver[String, r],
    stdOut$58345335: Sender[String, r],
    _errIn$58345338: Receiver[String, r],
    errOut$58345347: Sender[String, r]
): Unit \ IO + r = {
    let list$58345353: List[String] = collectChannel(
        List.empty(()),
        stdIn$58345330
    );
    let lineCount$58345374: Int32 = List.length(list$58345353);
    let oneString$58345381: String = List.join("""""", list$58345353);
    let words$58345386: List[String] = String.words(oneString$58345381);
    let wordCount$58345397: Int32 = List.length(words$58345386);
    Channel.send(
        (
            (
                (
                    """""" + """Linecount: """
                ) + <[unknown exp]>(lineCount$58345374)
            ) + """. Wordcount: """
        ) + <[unknown exp]>(wordCount$58345397),
        stdOut$58345335
    );
    Channel.send("""Last Line""", stdOut$58345335);
    Channel.send("""Last Line""", errOut$58345347)
}

def |+|(x$20348: a, y$20350: a): a = {<[unknown exp]>(x$20348, y$20350)}

def |>(x$8509: a, f$8512: a -> b): b \ ef = {f$8512(x$8509)}

def ||>(x$8536: (a, b), f$8538: a -> b -> c \ ef): c \ ef = {
    f$8538(fst(x$8536))(snd(x$8536))
}

def Adaptor.comparator(_$159: Proxy[a]): java.util.Comparator \ IO = {
    let f1$194: (java.lang.Object -> java.lang.Object -> Int32) = o1$199 ->
        o2$205 ->
            {
                let a$207: a = <[unknown exp]>;
                let b$265: a = <[unknown exp]>;
                |>(
                    <[unknown exp]>(a$207, b$265),
                    $0$45294 ->
                        Comparison.toInt($0$45294)
                )
            };
    new ##java.util.Comparator {
        def compare (
            _this$313: java.util.Comparator,
            t$315: java.lang.Object,
            u$317: java.lang.Object
        ) =
        f1$194(t$315)(u$317)
    }
}

def Adaptor.fromCollectionToIterator(
    rc$2387: Region[r],
    proxy$2389: Proxy[a],
    col$2391: java.util.Collection
): Iterator[a, r, r] = {
    let iterator$2393: (
        java.util.Collection -> java.util.Iterator
    ) = obj$$2395 ->
        <[unknown exp]>;
    let iter$2397: java.util.Iterator = iterator$2393(col$2391);
    Adaptor.fromIterator(rc$2387, proxy$2389, iter$2397)
}

def Adaptor.fromIterator(
    rc$2300: Region[r],
    _$2303: Proxy[a],
    iter$2305: java.util.Iterator
): Iterator[a, r, r] = {
    let hasNext$2314: (java.util.Iterator -> Bool) = obj$$2316 ->
        <[unknown exp]>;
    let next$2318: (java.util.Iterator -> java.lang.Object) = obj$$2320 ->
        <[unknown exp]>;
    let step$2322: (Unit -> Option[a]) = _unit$2324 ->
        match hasNext$2314(iter$2305) {
            case true =>
                |>(
                    |>(next$2318(iter$2305), o$2326 -> <[unknown exp]>),
                    x$$45376 ->
                        Option.Some(x$$45376)
                )
            case false =>
                Option.None
        };
    let iterF$2339: (Unit -> Option[a]) = _unit$2341 ->
        <[unknown exp]>;
    Iterator.iterate(rc$2300, iterF$2339)
}

def Adaptor.fromList(l$1153: java.util.List): List[a] = {
    region rc$1155 {
        let iterator$1158: (java.util.List -> java.util.Iterator) = obj$$1163 ->
            <[unknown exp]>;
        |>(
            |>(
                iterator$1158(l$1153),
                (
                    $0$45320 ->
                        $1$45324 ->
                            $2$45328 ->
                                Adaptor.fromIterator(
                                    $0$45320,
                                    $1$45324,
                                    $2$45328
                                )
                )(rc$1155)(Proxy.Proxy: Proxy[a])
            ),
            $0$45348 ->
                Iterator.toList($0$45348)
        )
    }
}

def Adaptor.fromListToIterator(
    rc$1841: Region[r],
    prx$1843: Proxy[a],
    l$1845: java.util.List
): Iterator[a, r, r] \ r = {
    let iterator$1848: (java.util.List -> java.util.Iterator) = obj$$1850 ->
        <[unknown exp]>;
    |>(
        iterator$1848(l$1845),
        (
            $0$45350 ->
                $1$45352 ->
                    $2$45354 ->
                        Adaptor.fromIterator($0$45350, $1$45352, $2$45354)
        )(rc$1841)(prx$1843)
    )
}

def Adaptor.fromMap(m$1912: java.util.Map): Map[k, v] = {
    region rc$1914 {
        letrec step$1917: (Map[k, v] -> ((k, v)) -> Map[k, v]) = acc$1919 ->
            entry$1921 ->
                match entry$1921 {
                    case (k$1928, v$1930) =>
                        Map.insert(k$1928, v$1930, acc$1919)
                };
        |>(
            Adaptor.fromMapToIterator(rc$1914, m$1912),
            (
                $0$45370 ->
                    $1$45372 ->
                        $2$45374 ->
                            Iterator.foldLeft($0$45370, $1$45372, $2$45374)
            )(step$1917)(Map.empty(()))
        )
    }
}

def Adaptor.fromMapEntry(
    _$1073: Proxy[k],
    _$1078: Proxy[v],
    e$1080: java.util.Map$Entry
): (k, v) = {
    let getKey$1090: (java.util.Map$Entry -> java.lang.Object) = obj$$1092 ->
        <[unknown exp]>;
    let getValue$1110: (java.util.Map$Entry -> java.lang.Object) = obj$$1112 ->
        <[unknown exp]>;
    let k1$1128: java.lang.Object = getKey$1090(e$1080);
    let v1$1130: java.lang.Object = getValue$1110(e$1080);
    (<[unknown exp]>, <[unknown exp]>)
}

def Adaptor.fromMapToIterator(
    rc$1949: Region[r],
    m$1957: java.util.Map
): Iterator[(k, v), r, r] \ r = {
    let entrySet$2098: (java.util.Map -> java.util.Set) = obj$$2100 ->
        <[unknown exp]>;
    let iterator$2135: (java.util.Set -> java.util.Iterator) = obj$$2137 ->
        <[unknown exp]>;
    let hasNext$2165: (java.util.Iterator -> Bool) = obj$$2167 ->
        <[unknown exp]>;
    let next$2171: (java.util.Iterator -> java.lang.Object) = obj$$2173 ->
        <[unknown exp]>;
    let entries$2181: java.util.Set = entrySet$2098(m$1957);
    let iter$2183: java.util.Iterator = iterator$2135(entries$2181);
    let getNext$2189: (Unit -> Option[(k, v)]) = _unit$2191 ->
        match hasNext$2165(iter$2183) {
            case true =>
                let entry$2205: java.util.Map$Entry = {
                    let obj$2207: java.lang.Object = next$2171(iter$2183);
                    <[unknown exp]>
                };
                match Adaptor.fromMapEntry(
                    Proxy.Proxy: Proxy[k],
                    Proxy.Proxy: Proxy[v],
                    entry$2205
                ) {
                    case (k$2242, v$2244) =>
                        Option.Some(k$2242, v$2244)
                }
            case false =>
                Option.None
        };
    Iterator.iterate(rc$1949, getNext$2189)
}

def Adaptor.fromOptional(
    _$1007: Proxy[a],
    o$1009: java.util.Optional
): Option[a] = {
    let isPresent$1012: (java.util.Optional -> Bool) = obj$$1017 ->
        <[unknown exp]>;
    let get$1023: (java.util.Optional -> java.lang.Object) = obj$$1025 ->
        <[unknown exp]>;
    if (isPresent$1012(o$1009)) {
        let o1$1040: java.lang.Object = get$1023(o$1009);
        Option.Some(<[unknown exp]>)
    } else {
        Option.None
    }
}

def Adaptor.fromSet(l$1864: java.util.Set): Set[a] = {
    region rc$1871 {
        let iterator$1874: (java.util.Set -> java.util.Iterator) = obj$$1876 ->
            <[unknown exp]>;
        |>(
            |>(
                iterator$1874(l$1864),
                (
                    $0$45356 ->
                        $1$45358 ->
                            $2$45360 ->
                                Adaptor.fromIterator(
                                    $0$45356,
                                    $1$45358,
                                    $2$45360
                                )
                )(rc$1871)(Proxy.Proxy: Proxy[a])
            ),
            $0$45362 ->
                Iterator.toSet($0$45362)
        )
    }
}

def Adaptor.fromSetToIterator(
    rc$1890: Region[r],
    prx$1894: Proxy[a],
    s$1897: java.util.Set
): Iterator[a, r, r] \ r = {
    let iterator$1901: (java.util.Set -> java.util.Iterator) = obj$$1903 ->
        <[unknown exp]>;
    |>(
        iterator$1901(s$1897),
        (
            $0$45364 ->
                $1$45366 ->
                    $2$45368 ->
                        Adaptor.fromIterator($0$45364, $1$45366, $2$45368)
        )(rc$1890)(prx$1894)
    )
}

def Adaptor.fromStreamToIterator(
    rc$2371: Region[r],
    proxy$2373: Proxy[a],
    strm$2375: java.util.stream.Stream
): Iterator[a, r, r] = {
    let iterator$2377: (
        java.util.stream.BaseStream -> java.util.Iterator
    ) = obj$$2379 ->
        <[unknown exp]>;
    let iter$2381: java.util.Iterator = iterator$2377(<[unknown exp]>);
    Adaptor.fromIterator(rc$2371, proxy$2373, iter$2381)
}

def Adaptor.toArrayList(ma$4041: m[a]): java.util.ArrayList \ IO = {
    let newArrayList$4047: (Unit -> java.util.ArrayList) = _$4049 ->
        ##java.util.ArrayList();
    let add$4061: (
        java.util.ArrayList -> java.lang.Object -> Bool \ IO
    ) = obj$$4063 ->
        a0$$4067 ->
            obj$$4063..add(a0$$4067);
    let alist$4071: java.util.ArrayList = newArrayList$4047(());
    <[unknown exp]>(
        x$4073 ->
            discard add$4061(alist$4071)(<[unknown exp]>),
        ma$4041
    );
    alist$4071
}

def Adaptor.toLinkedList(ma$5448: m[a]): java.util.LinkedList \ IO = {
    let newLinkedList$5468: (Unit -> java.util.LinkedList) = _$5470 ->
        ##java.util.LinkedList();
    let add$5476: (
        java.util.LinkedList -> java.lang.Object -> Bool \ IO
    ) = obj$$5478 ->
        a0$$5484 ->
            obj$$5478..add(a0$$5484);
    let llist$5522: java.util.LinkedList = newLinkedList$5468(());
    <[unknown exp]>(
        x$5526 ->
            discard add$5476(llist$5522)(<[unknown exp]>),
        ma$5448
    );
    llist$5522
}

def Adaptor.toList(ma$4019: m[a]): java.util.List \ IO = {<[unknown exp]>}

def Adaptor.toMap(m$5711: Map[k, v]): java.util.Map \ IO = {<[unknown exp]>}

def Adaptor.toMapEntry(p$3976: (k, v)): java.util.Map$Entry \ IO = {
    let entry$3982: (
        java.lang.Object -> java.lang.Object -> java.util.Map$Entry \ IO
    ) = a0$$3986 ->
        a1$$3988 ->
            ##java.util.Map.entry(a0$$3986, a1$$3988);
    match p$3976 {
        case (k$3994, v$3997) =>
            entry$3982(<[unknown exp]>)(<[unknown exp]>)
    }
}

def Adaptor.toOptional(o$2401: Option[a]): java.util.Optional \ IO = {
    let empty$2409: (Unit -> java.util.Optional) = _$2413 ->
        ##java.util.Optional.empty();
    let of$3695: (java.lang.Object -> java.util.Optional) = a0$$3697 ->
        ##java.util.Optional.of(a0$$3697);
    match o$2401 {
        case Option.None =>
            empty$2409(())
        case Option.Some(a$3961) =>
            of$3695(<[unknown exp]>)
    }
}

def Adaptor.toSet(ma$5544: m[a]): java.util.Set \ IO = {<[unknown exp]>}

def Adaptor.toTreeMap(m$5731: Map[k, v]): java.util.TreeMap \ IO = {
    let newTreeMap$5738: (Unit -> java.util.TreeMap) = _$5742 ->
        ##java.util.TreeMap();
    let put$5757: (
        java.util.TreeMap ->
            java.lang.Object -> (java.lang.Object -> java.lang.Object \ IO)
    ) = obj$$5759 ->
        a0$$5763 ->
            a1$$5765 ->
                obj$$5759..put(a0$$5763, a1$$5765);
    let tmap$5771: java.util.TreeMap = newTreeMap$5738(());
    Map.forEach(
        k$5776 ->
            v$5780 ->
                discard put$5757(tmap$5771)(<[unknown exp]>)(<[unknown exp]>),
        m$5731
    );
    tmap$5771
}

def Adaptor.toTreeSet(ma$5582: m[a]): java.util.TreeSet \ IO = {
    let newTreeSet$5584: (Unit -> java.util.TreeSet) = _$5586 ->
        ##java.util.TreeSet();
    let add$5616: (
        java.util.TreeSet -> java.lang.Object -> Bool \ IO
    ) = obj$$5619 ->
        a0$$5623 ->
            obj$$5619..add(a0$$5623);
    let tset$5639: java.util.TreeSet = newTreeSet$5584(());
    <[unknown exp]>(
        x$5649 ->
            discard add$5616(tset$5639)(<[unknown exp]>),
        ma$5582
    );
    tset$5639
}

def Applicative.*>(ma$39348: m[a], mb$39350: m[b]): m[b] = {
    Applicative.productRight(ma$39348, mb$39350)
}

def Applicative.<*(ma$39321: m[a], mb$39323: m[b]): m[a] = {
    Applicative.productLeft(ma$39321, mb$39323)
}

def Applicative.<**>(ma$39285: m[a], mf$39287: m[a -> b \ ef]): m[b] \ ef = {
    <[unknown exp]>(a$39298 -> f$39300 -> f$39300(a$39298), ma$39285, mf$39287)
}

def Applicative.<*>(mf$39249: m[a -> b \ ef], ma$39259: m[a]): m[b] \ ef = {
    <[unknown exp]>(mf$39249, ma$39259)
}

def Applicative.product(fa$39021: m[a], fb$39025: m[b]): m[(a, b)] = {
    <[unknown exp]>(
        a$39027 ->
            b$39029 ->
                (a$39027, b$39029),
        fa$39021,
        fb$39025
    )
}

def Applicative.product3(
    x1$39105: m[t1],
    x2$39107: m[t2],
    x3$39110: m[t3]
): m[(t1, t2, t3)] = {
    <[unknown exp]>(
        a$39115 ->
            b$39117 ->
                c$39119 ->
                    (a$39115, b$39117, c$39119),
        x1$39105,
        x2$39107,
        x3$39110
    )
}

def Applicative.product4(
    x1$39146: m[t1],
    x2$39150: m[t2],
    x3$39152: m[t3],
    x4$39154: m[t4]
): m[(t1, t2, t3, t4)] = {
    <[unknown exp]>(
        a$39161 ->
            b$39163 ->
                c$39166 ->
                    d$39169 ->
                        (a$39161, b$39163, c$39166, d$39169),
        x1$39146,
        x2$39150,
        x3$39152,
        x4$39154
    )
}

def Applicative.product5(
    x1$39197: m[t1],
    x2$39206: m[t2],
    x3$39212: m[t3],
    x4$39214: m[t4],
    x5$39216: m[t5]
): m[(t1, t2, t3, t4, t5)] = {
    <[unknown exp]>(
        a$39226 ->
            b$39228 ->
                c$39230 ->
                    d$39232 ->
                        e$39234 ->
                            (a$39226, b$39228, c$39230, d$39232, e$39234),
        x1$39197,
        x2$39206,
        x3$39212,
        x4$39214,
        x5$39216
    )
}

def Applicative.productLeft(fa$39048: m[a], fb$39054: m[b]): m[a] = {
    <[unknown exp]>(a$39056 -> _$39058 -> a$39056, fa$39048, fb$39054)
}

def Applicative.productRight(fa$39075: m[a], fb$39077: m[b]): m[b] = {
    <[unknown exp]>(_$39079 -> b$39081 -> b$39081, fa$39075, fb$39077)
}

def Array.agreeHelper(
    f$29431: a -> a -> Bool,
    a$29440: a,
    xs$29442: List[a]
): Bool = {
    match xs$29442 {
        case List.Nil =>
            true
        case List.Cons(x$29454, rs$29456) =>
            if (
                <[unknown exp]>(
                    f$29431(x$29454)(a$29440) and f$29431(a$29440)(x$29454),
                    false
                )
            ) {
                false
            } else {
                Array.agreeHelper(f$29431, a$29440, rs$29456)
            }
    }
}

def Array.append(
    rc3$25085: Region[r3],
    a$25089: Array[a, r1],
    b$25092: Array[a, r2]
): Array[a, r3] \ r1 + r2 + r3 = {
    let len1$25096: Int32 = Array.length(a$25089);
    let len2$25098: Int32 = Array.length(b$25092);
    if (<[unknown exp]>(len1$25096, 0i32)) {
        Array.copyOfRange(rc3$25085, 0i32, len2$25098, b$25092)
    } else {
        let out$25100: Array[a, r3] = Array.copyOfRange(
            rc3$25085,
            0i32,
            <[unknown exp]>(len1$25096, len2$25098),
            a$25089
        );
        Array.updateSequence!(len1$25096, b$25092, out$25100);
        out$25100
    }
}

def Array.arrayWrites(
    pos$27365: Int32,
    sub$27371: Array[a, r1],
    out$27380: Array[a, r2]
): Int32 \ r1 + r2 = {
    Array.updateSequence!(pos$27365, sub$27371, out$27380);
    <[unknown exp]>(pos$27365, Array.length(sub$27371))
}

def Array.compare(
    a$17152: Array[v, r1],
    b$17154: Array[v, r2]
): Comparison \ r1 + r2 = {
    let len$17163: Int32 = Int32.min(
        Array.length(a$17152),
        Array.length(b$17154)
    );
    letrec loop$17165: (Int32 -> Comparison) = i$17167 ->
        if (<[unknown exp]>(i$17167, len$17163)) {
            let cmp$17172: Comparison = <[unknown exp]>(
                Array.get(i$17167, a$17152),
                Array.get(i$17167, b$17154)
            );
            if (<[unknown exp]>(cmp$17172, Comparison.EqualTo)) {
                loop$17165(<[unknown exp]>(i$17167, 1i32))
            } else {
                cmp$17172
            }
        } else {
            if (<[unknown exp]>(i$17167, Array.length(a$17152))) {
                Comparison.GreaterThan
            } else {
                if (<[unknown exp]>(i$17167, Array.length(b$17154))) {
                    Comparison.LessThan
                } else {
                    Comparison.EqualTo
                }
            }
        };
    loop$17165(0i32)
}

def Array.copyOfRange(
    _$31129: Region[r2],
    b$31136: Int32,
    e$31138: Int32,
    a$31140: Array[a, r1]
): Array[a, r2] \ r1 + r2 = {
    <[unknown exp]>
}

def Array.count(f$28307: a -> Bool, a$28312: Array[a, r]): Int32 \ ef + r = {
    Array.foldLeft(
        b$28331 ->
            x$28335 ->
                if (f$28307(x$28335)) {
                    <[unknown exp]>(b$28331, 1i32)
                } else {
                    b$28331
                },
        0i32,
        a$28312
    )
}

def Array.drop(
    rc1$28725: Region[r1],
    n$28727: Int32,
    a$28729: Array[a, r]
): Array[a, r1] \ r + r1 = {
    Array.dropLeft(rc1$28725, n$28727, a$28729)
}

def Array.dropLeft(
    rc1$28776: Region[r1],
    n$28782: Int32,
    a$28786: Array[a, r]
): Array[a, r1] \ r + r1 = {
    let len$28792: Int32 = Array.length(a$28786);
    if (<[unknown exp]>(n$28782, len$28792)) {
        [] @ rc1$28776
    } else {
        let start$28796: Int32 = if (<[unknown exp]>(n$28782, 0i32)) {
            0i32
        } else {
            n$28782
        };
        Array.copyOfRange(rc1$28776, start$28796, len$28792, a$28786)
    }
}

def Array.dropRight(
    rc1$28811: Region[r1],
    n$28813: Int32,
    a$28815: Array[a, r]
): Array[a, r1] \ r + r1 = {
    let len$28820: Int32 = Array.length(a$28815);
    if (<[unknown exp]>(n$28813, len$28820)) {
        [] @ rc1$28811
    } else {
        let end$28827: Int32 = if (<[unknown exp]>(n$28813, 0i32)) {
            len$28820
        } else {
            <[unknown exp]>(len$28820, n$28813)
        };
        Array.copyOfRange(rc1$28811, 0i32, end$28827, a$28815)
    }
}

def Array.dropWhile(
    rc1$28850: Region[r1],
    f$28855: a -> Bool,
    a$28861: Array[a, r]
): Array[a, r1] \ ef + r + r1 = {
    Array.dropWhileLeft(rc1$28850, f$28855, a$28861)
}

def Array.dropWhileLeft(
    rc1$28884: Region[r1],
    f$28886: a -> Bool,
    a$28888: Array[a, r]
): Array[a, r1] \ ef + r + r1 = {
    match Array.findIndexOfLeft(x$28897 -> !f$28886(x$28897), a$28888) {
        case Option.None =>
            [] @ rc1$28884
        case Option.Some(i$28900) =>
            Array.dropLeft(rc1$28884, i$28900, a$28888)
    }
}

def Array.dropWhileRight(
    rc1$28916: Region[r1],
    f$28918: a -> Bool,
    a$28921: Array[a, r]
): Array[a, r1] \ ef + r + r1 = {
    match Array.findIndexOfRight(x$28923 -> !f$28918(x$28923), a$28921) {
        case Option.None =>
            [] @ rc1$28916
        case Option.Some(i$28929) =>
            Array.copyOfRange(
                rc1$28916,
                0i32,
                <[unknown exp]>(i$28929, 1i32),
                a$28921
            )
    }
}

def Array.empty(rc$17238: Region[r], l$17241: Int32): Array[a, r] \ r = {
    [rc$17238 ; Reflect.default(())] @ l$17241
}

def Array.enumerator(
    rc$30408: Region[r1],
    a$30414: Array[a, r2]
): Iterator[(Int32, a), r1 + r2, r1] \ r1 = {
    |>(
        Array.iterator(rc$30408, a$30414),
        $0$47020 ->
            Iterator.zipWithIndex($0$47020)
    )
}

def Array.exists(f$28528: a -> Bool, arr$28530: Array[a, r]): Bool \ ef + r = {
    let len$28544: Int32 = Array.length(arr$28530);
    letrec loop$28548: (Int32 -> Bool) = i$28551 ->
        if (<[unknown exp]>(i$28551, len$28544)) {
            false
        } else {
            if (f$28528(Array.get(i$28551, arr$28530))) {
                true
            } else {
                loop$28548(<[unknown exp]>(i$28551, 1i32))
            }
        };
    loop$28548(0i32)
}

def Array.extractHelper(
    rc$29363: Region[r],
    f$29367: a -> a -> Bool,
    xs$29372: List[a],
    ps$29376: List[a],
    ns$29378: List[a]
): (Array[a, r], List[a]) \ r = {
    match xs$29372 {
        case List.Nil =>
            let a$29388: List[a] = List.reverse(ps$29376);
            (List.toArray(rc$29363, a$29388), List.reverse(ns$29378))
        case List.Cons(x$29396, rs$29400) =>
            if (Array.agreeHelper(f$29367, x$29396, ps$29376)) {
                Array.extractHelper(
                    rc$29363,
                    f$29367,
                    rs$29400,
                    List.Cons(x$29396, ps$29376),
                    ns$29378
                )
            } else {
                Array.extractHelper(
                    rc$29363,
                    f$29367,
                    rs$29400,
                    ps$29376,
                    List.Cons(x$29396, ns$29378)
                )
            }
    }
}

def Array.filter(
    rc1$28629: Region[r1],
    f$28631: a -> Bool,
    arr$28633: Array[a, r]
): Array[a, r1] \ ef + r + r1 = {
    let len$28635: Int32 = Array.length(arr$28633);
    if (<[unknown exp]>(len$28635, 1i32)) {
        [] @ rc1$28629
    } else {
        let out$28637: Array[a, r1] = Array.empty(rc1$28629, len$28635);
        letrec loop$28639: (
            Int32 -> Int32 -> Int32 \ r + ef + r1 + r1 + ef + r + r1 + ef + r
        ) = i$28641 ->
            j$28643 ->
                if (<[unknown exp]>(i$28641, len$28635)) {
                    j$28643
                } else {
                    let x$28645: a = Array.get(i$28641, arr$28633);
                    if (f$28631(x$28645)) {
                        Array.put(x$28645, j$28643, out$28637);
                        loop$28639(
                            <[unknown exp]>(i$28641, 1i32)
                        )(<[unknown exp]>(j$28643, 1i32))
                    } else {
                        loop$28639(<[unknown exp]>(i$28641, 1i32))(j$28643)
                    }
                };
        let endPos$28647: Int32 = loop$28639(0i32)(0i32);
        Array.copyOfRange(rc1$28629, 0i32, endPos$28647, out$28637)
    }
}

def Array.filterMap(
    rc1$29870: Region[r1],
    f$29873: a -> Option[b],
    a$29875: Array[a, r]
): Array[b, r1] \ ef + r + r1 = {
    |>(
        Array.foldRight(
            x$29887 ->
                xs$29889 ->
                    match f$29873(x$29887) {
                        case Option.None =>
                            xs$29889
                        case Option.Some(b$29893) =>
                            List.Cons(b$29893, xs$29889)
                    },
            List.Nil,
            a$29875
        ),
        ($0$47000 -> $1$47002 -> List.toArray($0$47000, $1$47002))(rc1$29870)
    )
}

def Array.find(
    f$25657: a -> Bool,
    arr$25664: Array[a, r]
): Option[a] \ ef + r = {
    Array.findLeft(f$25657, arr$25664)
}

def Array.findIndexOf(
    f$30111: a -> Bool,
    a$30115: Array[a, r]
): Option[Int32] \ ef + r = {
    Array.findIndexOfLeft(f$30111, a$30115)
}

def Array.findIndexOfLeft(
    f$30128: a -> Bool,
    a$30130: Array[a, r]
): Option[Int32] \ ef + r = {
    let len$30148: Int32 = Array.length(a$30130);
    if (<[unknown exp]>(len$30148, 1i32)) {
        Option.None
    } else {
        letrec loop$30150: (Int32 -> Int32) = i$30152 ->
            if (<[unknown exp]>(i$30152, len$30148)) {
                -1i32
            } else {
                if (f$30128(Array.get(i$30152, a$30130))) {
                    i$30152
                } else {
                    loop$30150(<[unknown exp]>(i$30152, 1i32))
                }
            };
        let i$30154: Int32 = loop$30150(0i32);
        if (<[unknown exp]>(i$30154, 0i32)) {
            Option.None
        } else {
            Option.Some(i$30154)
        }
    }
}

def Array.findIndexOfRight(
    f$30194: a -> Bool,
    a$30199: Array[a, r]
): Option[Int32] \ ef + r = {
    let len$30201: Int32 = Array.length(a$30199);
    letrec loop$30203: (Int32 -> Int32) = i$30205 ->
        if (<[unknown exp]>(i$30205, 0i32)) {
            -1i32
        } else {
            if (f$30194(Array.get(i$30205, a$30199))) {
                i$30205
            } else {
                loop$30203(<[unknown exp]>(i$30205, 1i32))
            }
        };
    let i$30207: Int32 = loop$30203(<[unknown exp]>(len$30201, 1i32));
    if (<[unknown exp]>(i$30207, 0i32)) {
        Option.None
    } else {
        Option.Some(i$30207)
    }
}

def Array.findIndices(
    rc2$30230: Region[r2],
    f$30240: a -> Bool,
    a$30246: Array[a, r1]
): Array[Int32, r2] \ ef + r1 + r2 = {
    let len$30255: Int32 = Array.length(a$30246);
    let l$30262: MutList[Int32, r2] = MutList.empty(rc2$30230);
    letrec loop$30264: (Int32 -> Unit) = i$30266 ->
        if (<[unknown exp]>(i$30266, len$30255)) {
            ()
        } else {
            if (f$30240(Array.get(i$30266, a$30246))) {
                MutList.push!(i$30266, l$30262)
            } else {
                ()
            };
            loop$30264(<[unknown exp]>(i$30266, 1i32))
        };
    loop$30264(0i32);
    MutList.toArray(rc2$30230, l$30262)
}

def Array.findLeft(
    f$25752: a -> Bool,
    arr$25754: Array[a, r]
): Option[a] \ ef + r = {
    match Array.findIndexOfLeft(f$25752, arr$25754) {
        case Option.None =>
            Option.None
        case Option.Some(i$25761) =>
            Option.Some(Array.get(i$25761, arr$25754))
    }
}

def Array.findMap(
    f$29933: a -> Option[b],
    a$29939: Array[a, r]
): Option[b] \ ef + r = {
    let len$29943: Int32 = Array.length(a$29939);
    letrec loop$29945: (Int32 -> Option[b]) = i$29947 ->
        if (<[unknown exp]>(i$29947, len$29943)) {
            Option.None
        } else {
            let x$29949: Option[b] = f$29933(Array.get(i$29947, a$29939));
            match x$29949 {
                case Option.Some(v$29951) =>
                    Option.Some(v$29951)
                case Option.None =>
                    loop$29945(<[unknown exp]>(i$29947, 1i32))
            }
        };
    loop$29945(0i32)
}

def Array.findRight(
    f$25781: a -> Bool,
    arr$25795: Array[a, r]
): Option[a] \ ef + r = {
    match Array.findIndexOfRight(x$25816 -> f$25781(x$25816), arr$25795) {
        case Option.None =>
            Option.None
        case Option.Some(i$25828) =>
            Option.Some(Array.get(i$25828, arr$25795))
    }
}

def Array.flatMap(
    rc1$26526: Region[r1],
    f$26530: a -> Array[b, r1],
    a$26538: Array[a, r]
): Array[b, r1] \ ef + r + r1 = {
    let len$26542: Int32 = Array.length(a$26538);
    |>(
        Array.init(
            rc1$26526,
            i$26544 ->
                f$26530(Array.get(i$26544, a$26538)),
            len$26542
        ),
        ($0$46870 -> $1$46872 -> Array.flatten($0$46870, $1$46872))(rc1$26526)
    )
}

def Array.flatten(
    rc1$28465: Region[r1],
    arrs$28467: Array[Array[a, r], r]
): Array[a, r1] \ r + r1 = {
    let len$28469: Int32 = Array.sumLengths(arrs$28467);
    match Array.headArrays(arrs$28467) {
        case Option.None =>
            [] @ rc1$28465
        case Option.Some(x$28477) =>
            let out$28479: Array[a, r1] = Array.repeat(
                rc1$28465,
                len$28469,
                x$28477
            );
            discard Array.foldLeft(
                pos$28481 ->
                    a$28483 ->
                        Array.arrayWrites(pos$28481, a$28483, out$28479),
                0i32,
                arrs$28467
            );
            out$28479
    }
}

def Array.fold(arr$27944: Array[a, r]): a \ r = {
    Array.foldLeft(
        $0$46938 ->
            $1$46940 ->
                <[unknown exp]>($0$46938, $1$46940),
        <[unknown exp]>(()),
        arr$27944
    )
}

def Array.fold2(
    f$29703: c -> a -> (b -> c \ ef),
    c$29713: c,
    a$29715: Array[a, r1],
    b$29717: Array[b, r2]
): c \ ef + r1 + r2 = {
    Array.foldLeft2(f$29703, c$29713, a$29715, b$29717)
}

def Array.foldLeft(
    f$27981: b -> a -> b \ ef,
    s$27983: b,
    arr$27985: Array[a, r]
): b \ ef + r = {
    let len$27987: Int32 = Array.length(arr$27985);
    letrec loop$27990: (Int32 -> b -> b \ ef + r) = i$27992 ->
        acc$27995 ->
            if (<[unknown exp]>(i$27992, len$27987)) {
                acc$27995
            } else {
                loop$27990(
                    <[unknown exp]>(i$27992, 1i32)
                )(f$27981(acc$27995)(Array.get(i$27992, arr$27985)))
            };
    loop$27990(0i32)(s$27983)
}

def Array.foldLeft2(
    f$29740: c -> a -> (b -> c \ ef),
    c$29744: c,
    a$29748: Array[a, r1],
    b$29750: Array[b, r2]
): c \ ef + r1 + r2 = {
    let lena$29752: Int32 = Array.length(a$29748);
    let lenb$29754: Int32 = Array.length(b$29750);
    letrec loop$29756: (Int32 -> c -> c \ ef + r1 + r2) = i$29758 ->
        acc$29760 ->
            if (
                <[unknown exp]>(
                    i$29758,
                    lena$29752
                ) or <[unknown exp]>(i$29758, lenb$29754)
            ) {
                acc$29760
            } else {
                loop$29756(
                    <[unknown exp]>(i$29758, 1i32)
                )(
                    f$29740(
                        acc$29760
                    )(Array.get(i$29758, a$29748))(Array.get(i$29758, b$29750))
                )
            };
    loop$29756(0i32)(c$29744)
}

def Array.foldMap(f$28143: a -> b, arr$28145: Array[a, r]): b \ ef + r = {
    Array.foldLeft(
        acc$28154 ->
            x$28158 ->
                <[unknown exp]>(acc$28154, f$28143(x$28158)),
        <[unknown exp]>(()),
        arr$28145
    )
}

def Array.foldRight(
    f$28035: a -> b -> b \ ef,
    s$28045: b,
    arr$28049: Array[a, r]
): b \ ef + r = {
    letrec loop$28052: (Int32 -> b -> b \ ef + r) = i$28054 ->
        acc$28056 ->
            if (<[unknown exp]>(i$28054, 0i32)) {
                acc$28056
            } else {
                loop$28052(
                    <[unknown exp]>(i$28054, 1i32)
                )(f$28035(Array.get(i$28054, arr$28049))(acc$28056))
            };
    loop$28052(<[unknown exp]>(Array.length(arr$28049), 1i32))(s$28045)
}

def Array.foldRight2(
    f$29805: a -> b -> (c -> c \ ef),
    c$29815: c,
    a$29817: Array[a, r1],
    b$29819: Array[b, r2]
): c \ ef + r1 + r2 = {
    letrec loop$29833: (Int32 -> Int32 -> (c -> c \ ef + r1 + r2)) = i$29835 ->
        j$29837 ->
            acc$29839 ->
                if (
                    <[unknown exp]>(
                        i$29835,
                        0i32
                    ) or <[unknown exp]>(j$29837, 0i32)
                ) {
                    acc$29839
                } else {
                    loop$29833(
                        <[unknown exp]>(i$29835, 1i32)
                    )(
                        <[unknown exp]>(j$29837, 1i32)
                    )(
                        f$29805(
                            Array.get(i$29835, a$29817)
                        )(Array.get(j$29837, b$29819))(acc$29839)
                    )
                };
    let starta$29843: Int32 = <[unknown exp]>(Array.length(a$29817), 1i32);
    let startb$29845: Int32 = <[unknown exp]>(Array.length(b$29819), 1i32);
    loop$29833(starta$29843)(startb$29845)(c$29815)
}

def Array.foldRightWithCont(
    f$28090: a -> (Unit -> b \ ef + r) -> b \ ef + r,
    z$28102: b,
    arr$28104: Array[a, r]
): b \ ef + r = {
    letrec loop$28110: (Int32 -> b) = i$28112 ->
        if (<[unknown exp]>(i$28112, Array.length(arr$28104))) {
            z$28102
        } else {
            f$28090(
                Array.get(i$28112, arr$28104)
            )(_$28114 -> loop$28110(<[unknown exp]>(i$28112, 1i32)))
        };
    loop$28110(0i32)
}

def Array.forAll(f$28594: a -> Bool, arr$28596: Array[a, r]): Bool \ ef + r = {
    let len$28600: Int32 = Array.length(arr$28596);
    letrec loop$28603: (Int32 -> Bool) = i$28605 ->
        if (<[unknown exp]>(i$28605, len$28600)) {
            true
        } else {
            if (f$28594(Array.get(i$28605, arr$28596))) {
                loop$28603(<[unknown exp]>(i$28605, 1i32))
            } else {
                false
            }
        };
    loop$28603(0i32)
}

def Array.forEach(f$30448: a -> Unit, a$30454: Array[a, r]): Unit \ ef + r = {
    let len$30456: Int32 = Array.length(a$30454);
    letrec loop$30458: (Int32 -> Unit) = i$30460 ->
        if (<[unknown exp]>(i$30460, len$30456)) {
            ()
        } else {
            f$30448(Array.get(i$30460, a$30454));
            loop$30458(<[unknown exp]>(i$30460, 1i32))
        };
    loop$30458(0i32)
}

def Array.forEachWithIndex(
    f$30482: Int32 -> a -> Unit \ ef,
    a$30484: Array[a, r]
): Unit \ ef + r = {
    let len$30486: Int32 = Array.length(a$30484);
    letrec loop$30488: (Int32 -> Unit) = i$30490 ->
        if (<[unknown exp]>(i$30490, len$30486)) {
            ()
        } else {
            f$30482(i$30490)(Array.get(i$30490, a$30484));
            loop$30488(<[unknown exp]>(i$30490, 1i32))
        };
    loop$30488(0i32)
}

def Array.forWithAccum(
    lo$31092: Int32,
    hi$31094: Int32,
    ac$31096: a,
    f$31098: Int32 -> a -> a \ ef
): a \ ef = {
    if (<[unknown exp]>(lo$31092, hi$31094)) {
        f$31098(lo$31092)(ac$31096)
    } else {
        let ac1$31108: a = f$31098(lo$31092)(ac$31096);
        Array.forWithAccum(
            <[unknown exp]>(lo$31092, 1i32),
            hi$31094,
            ac1$31108,
            f$31098
        )
    }
}

def Array.get(i$19177: Int32, a$19183: Array[a, r]): a \ r = {a$19183[i$19177]}

def Array.groupBy(
    rc1$29244: Region[r1],
    f$29246: a -> a -> Bool,
    a$29248: Array[a, r2]
): Array[Array[a, r1], r1] \ r2 + r1 = {
    let xs$29258: List[a] = Array.toList(a$29248);
    |>(
        Array.groupByHelper(rc1$29244, f$29246, xs$29258, List.Nil),
        ($0$46970 -> $1$46972 -> List.toArray($0$46970, $1$46972))(rc1$29244)
    )
}

def Array.groupByHelper(
    rc$29300: Region[r],
    f$29308: a -> a -> Bool,
    xs$29321: List[a],
    ac$29325: List[Array[a, r]]
): List[Array[a, r]] \ r = {
    match xs$29321 {
        case List.Nil =>
            List.reverse(ac$29325)
        case List.Cons(x$29331, rs$29333) =>
            match Array.extractHelper(
                rc$29300,
                f$29308,
                rs$29333,
                List.Cons(x$29331, List.Nil),
                List.Nil
            ) {
                case (rc1$29335, rc2$29337) =>
                    Array.groupByHelper(
                        rc$29300,
                        f$29308,
                        rc2$29337,
                        List.Cons(rc1$29335, ac$29325)
                    )
            }
    }
}

def Array.head(a$25019: Array[a, r]): Option[a] \ r = {
    if (<[unknown exp]>(Array.length(a$25019), 0i32)) {
        Option.Some(Array.get(0i32, a$25019))
    } else {
        Option.None
    }
}

def Array.headArrays(
    arrs$27467: Array[Array[a, r1], r2]
): Option[a] \ r1 + r2 = {
    let len$27486: Int32 = Array.length(arrs$27467);
    letrec loop$27488: (Int32 -> Option[a]) = i$27490 ->
        if (<[unknown exp]>(i$27490, len$27486)) {
            Option.None
        } else {
            match Array.head(Array.get(i$27490, arrs$27467)) {
                case Option.Some(x$27492) =>
                    Option.Some(x$27492)
                case Option.None =>
                    loop$27488(<[unknown exp]>(i$27490, 1i32))
            }
        };
    loop$27488(0i32)
}

def Array.indexOf(x$25428: a, a$25442: Array[a, r]): Option[Int32] \ r = {
    Array.indexOfLeft(x$25428, a$25442)
}

def Array.indexOfLeft(a$25487: a, arr$25489: Array[a, r]): Option[Int32] \ r = {
    letrec loop$25500: (Int32 -> Int32) = i$25503 ->
        if (<[unknown exp]>(i$25503, Array.length(arr$25489))) {
            -1i32
        } else {
            if (<[unknown exp]>(Array.get(i$25503, arr$25489), a$25487)) {
                i$25503
            } else {
                loop$25500(<[unknown exp]>(i$25503, 1i32))
            }
        };
    let i$25509: Int32 = loop$25500(0i32);
    if (<[unknown exp]>(i$25509, 0i32)) {
        Option.None
    } else {
        Option.Some(i$25509)
    }
}

def Array.indexOfRight(
    a$25574: a,
    arr$25576: Array[a, r]
): Option[Int32] \ r = {
    letrec loop$25579: (Int32 -> Int32) = i$25581 ->
        if (<[unknown exp]>(i$25581, 0i32)) {
            -1i32
        } else {
            if (<[unknown exp]>(Array.get(i$25581, arr$25576), a$25574)) {
                i$25581
            } else {
                loop$25579(<[unknown exp]>(i$25581, 1i32))
            }
        };
    let i$25583: Int32 = loop$25579(
        <[unknown exp]>(Array.length(arr$25576), 1i32)
    );
    if (<[unknown exp]>(i$25583, 0i32)) {
        Option.None
    } else {
        Option.Some(i$25583)
    }
}

def Array.indices(
    rc$25623: Region[r],
    a$25625: a,
    arr$25627: Array[a, r]
): Array[Int32, r] \ r = {
    Array.findIndices(
        rc$25623,
        b$25638 ->
            <[unknown exp]>(a$25625, b$25638),
        arr$25627
    )
}

def Array.init(
    rc$30290: Region[r],
    f$30292: Int32 -> a,
    len$30294: Int32
): Array[a, r] \ ef + r = {
    if (<[unknown exp]>(len$30294, 0i32)) {
        [] @ rc$30290
    } else {
        let x$30308: a = f$30292(0i32);
        let a$30312: Array[a, r] = Array.repeat(rc$30290, len$30294, x$30308);
        letrec loop$30314: (Int32 -> Unit) = i$30316 ->
            if (<[unknown exp]>(i$30316, len$30294)) {
                Array.put(f$30292(i$30316), i$30316, a$30312);
                loop$30314(<[unknown exp]>(i$30316, 1i32))
            } else {
                ()
            };
        loop$30314(1i32);
        a$30312
    }
}

def Array.intercalate(
    rc1$27278: Region[r1],
    sep$27286: Array[a, r],
    arrs$27288: Array[Array[a, r], r]
): Array[a, r1] \ r + r1 = {
    let count$27298: Int32 = Array.length(arrs$27288);
    let sepLength$27300: Int32 = Array.length(sep$27286);
    let sepCount$27302: Int32 = if (<[unknown exp]>(count$27298, 2i32)) {
        0i32
    } else {
        <[unknown exp]>(count$27298, 1i32)
    };
    let len$27304: Int32 = <[unknown exp]>(
        Array.sumLengths(arrs$27288),
        <[unknown exp]>(sepCount$27302, sepLength$27300)
    );
    match Array.headArrays(arrs$27288) {
        case Option.None =>
            [] @ rc1$27278
        case Option.Some(x$27319) =>
            let out$27321: Array[a, r1] = Array.repeat(
                rc1$27278,
                len$27304,
                x$27319
            );
            let overwrite$27323: (
                (Int32, Int32) ->
                    Array[a, r] -> (Int32, Int32) \ r + r1 + r + r1 + r + r1
            ) = st$27325 ->
                a$27327 ->
                    match st$27325 {
                        case (pos$27330, i$27332) =>
                            if (<[unknown exp]>(i$27332, 0i32)) {
                                let pos1$27334: Int32 = Array.arrayWrites(
                                    0i32,
                                    a$27327,
                                    out$27321
                                );
                                (pos1$27334, 1i32)
                            } else {
                                let pos1$27336: Int32 = Array.arrayWrites(
                                    pos$27330,
                                    sep$27286,
                                    out$27321
                                );
                                let pos2$27338: Int32 = Array.arrayWrites(
                                    pos1$27336,
                                    a$27327,
                                    out$27321
                                );
                                (pos2$27338, <[unknown exp]>(i$27332, 1i32))
                            }
                    };
            discard Array.foldLeft(overwrite$27323, (0i32, 0i32), arrs$27288);
            out$27321
    }
}

def Array.intersperse(
    rc1$27220: Region[r1],
    x$27223: a,
    a$27225: Array[a, r]
): Array[a, r1] \ r + r1 = {
    let len1$27234: Int32 = Array.length(a$27225);
    let len2$27236: Int32 = <[unknown exp]>(
        <[unknown exp]>(len1$27234, len1$27234),
        1i32
    );
    if (<[unknown exp]>(len2$27236, 0i32)) {
        [] @ rc1$27220
    } else {
        let b$27239: Array[a, r1] = Array.repeat(
            rc1$27220,
            len2$27236,
            x$27223
        );
        let f$27243: (Int32 -> a -> Unit \ r1) = i$27245 ->
            v$27247 ->
                {
                    let j$27249: Int32 = <[unknown exp]>(i$27245, i$27245);
                    Array.put(v$27247, j$27249, b$27239)
                };
        Array.forEachWithIndex(f$27243, a$27225);
        b$27239
    }
}

def Array.isEmpty(a$21423: Array[a, r]): Bool = {
    <[unknown exp]>(Array.length(a$21423), 0i32)
}

def Array.isInfixOf(
    a1$27697: Array[a, r1],
    a2$27699: Array[a, r2]
): Bool \ r1 + r2 = {
    let len1$27706: Int32 = Array.length(a1$27697);
    let len2$27710: Int32 = Array.length(a2$27699);
    if (<[unknown exp]>(len1$27706, len2$27710)) {
        false
    } else {
        if (<[unknown exp]>(len1$27706, 0i32)) {
            true
        } else {
            Array.isInfixOfSearch(
                a1$27697,
                a2$27699,
                len1$27706,
                len2$27710,
                0i32
            )
        }
    }
}

def Array.isInfixOfCheck(
    a1$27760: Array[a, r1],
    a2$27850: Array[a, r2],
    len1$27856: Int32,
    len2$27858: Int32,
    i$27860: Int32,
    j$27862: Int32
): Bool \ r1 + r2 = {
    if (<[unknown exp]>(i$27860, len1$27856)) {
        true
    } else {
        if (<[unknown exp]>(j$27862, len2$27858)) {
            false
        } else {
            if (
                <[unknown exp]>(
                    Array.get(i$27860, a1$27760),
                    Array.get(j$27862, a2$27850)
                )
            ) {
                Array.isInfixOfCheck(
                    a1$27760,
                    a2$27850,
                    len1$27856,
                    len2$27858,
                    <[unknown exp]>(i$27860, 1i32),
                    <[unknown exp]>(j$27862, 1i32)
                )
            } else {
                Array.isInfixOfSearch(
                    a1$27760,
                    a2$27850,
                    len1$27856,
                    len2$27858,
                    <[unknown exp]>(j$27862, 1i32)
                )
            }
        }
    }
}

def Array.isInfixOfSearch(
    a1$27728: Array[a, r1],
    a2$27730: Array[a, r2],
    len1$27732: Int32,
    len2$27734: Int32,
    j$27736: Int32
): Bool \ r1 + r2 = {
    if (<[unknown exp]>(j$27736, len2$27734)) {
        false
    } else {
        if (
            <[unknown exp]>(
                Array.get(0i32, a1$27728),
                Array.get(j$27736, a2$27730)
            )
        ) {
            Array.isInfixOfCheck(
                a1$27728,
                a2$27730,
                len1$27732,
                len2$27734,
                1i32,
                <[unknown exp]>(j$27736, 1i32)
            )
        } else {
            Array.isInfixOfSearch(
                a1$27728,
                a2$27730,
                len1$27732,
                len2$27734,
                <[unknown exp]>(j$27736, 1i32)
            )
        }
    }
}

def Array.isPrefixOf(
    a1$27643: Array[a, r1],
    a2$27649: Array[a, r2]
): Bool \ r1 + r2 = {
    let len1$27668: Int32 = Array.length(a1$27643);
    if (<[unknown exp]>(len1$27668, Array.length(a2$27649))) {
        false
    } else {
        letrec loop$27672: (Int32 -> Bool) = i$27675 ->
            if (<[unknown exp]>(i$27675, len1$27668)) {
                true
            } else {
                if (
                    <[unknown exp]>(
                        Array.get(i$27675, a1$27643),
                        Array.get(i$27675, a2$27649)
                    )
                ) {
                    false
                } else {
                    loop$27672(<[unknown exp]>(i$27675, 1i32))
                }
            };
        loop$27672(0i32)
    }
}

def Array.isSuffixOf(
    a1$27881: Array[a, r1],
    a2$27891: Array[a, r2]
): Bool \ r1 + r2 = {
    let len1$27901: Int32 = Array.length(a1$27881);
    let len2$27907: Int32 = Array.length(a2$27891);
    if (<[unknown exp]>(len1$27901, len2$27907)) {
        false
    } else {
        letrec loop$27909: (
            Int32 -> Int32 -> Bool \ r1 + r2 + r1 + r2
        ) = i$27911 ->
            j$27913 ->
                if (<[unknown exp]>(i$27911, 0i32)) {
                    true
                } else {
                    if (
                        <[unknown exp]>(
                            Array.get(i$27911, a1$27881),
                            Array.get(j$27913, a2$27891)
                        )
                    ) {
                        false
                    } else {
                        loop$27909(
                            <[unknown exp]>(i$27911, 1i32)
                        )(<[unknown exp]>(j$27913, 1i32))
                    }
                };
        loop$27909(
            <[unknown exp]>(len1$27901, 1i32)
        )(<[unknown exp]>(len2$27907, 1i32))
    }
}

def Array.iterator(
    rc$30381: Region[r1],
    a$30383: Array[a, r2]
): Iterator[a, r1 + r2, r1] \ r1 = {
    |>(
        Iterator.range(rc$30381, 0i32, Array.length(a$30383)),
        (
            $0$47016 ->
                $1$47018 ->
                    Iterator.map($0$47016, $1$47018)
        )(i$30397 -> Array.get(i$30397, a$30383))
    )
}

def Array.join(sep$30621: String, a$30625: Array[a, r]): String \ r = {
    Array.joinWith($0$47026 -> <[unknown exp]>($0$47026), sep$30621, a$30625)
}

def Array.joinWith(
    f$30656: a -> String,
    sep$30661: String,
    a$30663: Array[a, r]
): String \ ef + r = {
    region rc1$30681 {<[unknown exp]>}
}

def Array.last(a$25051: Array[a, r]): Option[a] \ r = {
    let len$25070: Int32 = Array.length(a$25051);
    if (<[unknown exp]>(len$25070, 0i32)) {
        Option.Some(Array.get(<[unknown exp]>(len$25070, 1i32), a$25051))
    } else {
        Option.None
    }
}

def Array.length(a$21460: Array[a, r]): Int32 = {a$21460..length}

def Array.map(
    rc1$26240: Region[r1],
    f$26244: a -> b,
    a$26248: Array[a, r]
): Array[b, r1] \ ef + r + r1 = {
    let len$26261: Int32 = Array.length(a$26248);
    Array.init(
        rc1$26240,
        i$26264 ->
            f$26244(Array.get(i$26264, a$26248)),
        len$26261
    )
}

def Array.mapWithIndex(
    rc1$26351: Region[r1],
    f$26357: Int32 -> a -> b \ ef,
    a$26363: Array[a, r]
): Array[b, r1] \ ef + r + r1 = {
    let len$26379: Int32 = Array.length(a$26363);
    Array.init(
        rc1$26351,
        i$26385 ->
            f$26357(i$26385)(Array.get(i$26385, a$26363)),
        len$26379
    )
}

def Array.maximum(a$25269: Array[a, r]): Option[a] \ r = {
    Array.reduceLeft(
        $0$46838 ->
            $1$46840 ->
                <[unknown exp]>($0$46838, $1$46840),
        a$25269
    )
}

def Array.maximumBy(
    cmp$25368: a -> a -> Comparison,
    a$25396: Array[a, r]
): Option[a] \ r = {
    Array.reduceLeft(
        (
            $0$46842 ->
                $1$46844 ->
                    $2$46846 ->
                        Order.maxBy($0$46842, $1$46844, $2$46846)
        )(cmp$25368),
        a$25396
    )
}

def Array.memberOf(x$25151: a, a$25154: Array[a, r]): Bool \ r = {
    Array.exists(y$25158 -> <[unknown exp]>(y$25158, x$25151), a$25154)
}

def Array.minimum(a$25166: Array[a, r]): Option[a] \ r = {
    Array.reduceLeft(
        $0$46820 ->
            $1$46822 ->
                <[unknown exp]>($0$46820, $1$46822),
        a$25166
    )
}

def Array.minimumBy(
    cmp$25201: a -> a -> Comparison,
    a$25215: Array[a, r]
): Option[a] \ r = {
    Array.reduceLeft(
        (
            $0$46826 ->
                $1$46828 ->
                    $2$46830 ->
                        Order.minBy($0$46826, $1$46828, $2$46830)
        )(cmp$25201),
        a$25215
    )
}

def Array.nonEmpty(a$21441: Array[a, r]): Bool = {!Array.isEmpty(a$21441)}

def Array.nth(i$21396: Int32, a$21398: Array[a, r]): Option[a] \ r = {
    if (
        <[unknown exp]>(
            0i32,
            i$21396
        ) and <[unknown exp]>(i$21396, Array.length(a$21398))
    ) {
        Option.Some(Array.get(i$21396, a$21398))
    } else {
        Option.None
    }
}

def Array.partition(
    rc1$28662: Region[r1],
    rc2$28664: Region[r2],
    f$28666: a -> Bool,
    a$28670: Array[a, r]
): (Array[a, r1], Array[a, r2]) \ ef + r + r1 + r2 = {
    let step$28672: (
        a -> ((List[a], List[a])) -> (List[a], List[a]) \ ef
    ) = x$28674 ->
        acc$28676 ->
            match acc$28676 {
                case (a1$28678, a2$28680) =>
                    if (f$28666(x$28674)) {
                        (List.Cons(x$28674, a1$28678), a2$28680)
                    } else {
                        (a1$28678, List.Cons(x$28674, a2$28680))
                    }
            };
    match Array.foldRight(step$28672, (List.Nil, List.Nil), a$28670) {
        case (xs$28682, ys$28684) =>
            (
                List.toArray(rc1$28662, xs$28682),
                List.toArray(rc2$28664, ys$28684)
            )
    }
}

def Array.patch(
    rc3$27101: Region[r3],
    i$27108: Int32,
    n$27110: Int32,
    a$27114: Array[a, r1],
    b$27121: Array[a, r2]
): Array[a, r3] \ r1 + r2 + r3 = {
    let len1$27129: Int32 = Array.length(a$27114);
    let size$27132: Int32 = if (<[unknown exp]>(n$27110, len1$27129)) {
        len1$27129
    } else {
        n$27110
    };
    let sub$27134: Array[a, r3] = Array.copyOfRange(
        rc3$27101,
        0i32,
        size$27132,
        a$27114
    );
    Array.updateSequence(rc3$27101, i$27108, sub$27134, b$27121)
}

def Array.patch!(
    i$27152: Int32,
    n$27154: Int32,
    a$27158: Array[a, r1],
    b$27166: Array[a, r2]
): Unit \ r1 + r2 = {
    region rc3$27172 {
        let len1$27180: Int32 = Array.length(a$27158);
        let size$27187: Int32 = if (<[unknown exp]>(n$27154, len1$27180)) {
            len1$27180
        } else {
            n$27154
        };
        let sub$27189: Array[a, rc3] = Array.copyOfRange(
            rc3$27172,
            0i32,
            size$27187,
            a$27158
        );
        Array.updateSequence!(i$27152, sub$27189, b$27166)
    }
}

def Array.put(x$20358: a, i$20362: Int32, a$20366: Array[a, r]): Unit \ r = {
    a$20366[i$20362] := x$20358
}

def Array.quicksortPartition(
    cmp$31048: a -> a -> Comparison,
    a$31050: Array[a, r],
    lo$31052: Int32,
    hi$31054: Int32
): Int32 \ r = {
    let pivot$31056: a = Array.get(hi$31054, a$31050);
    let i$31060: Int32 = Array.forWithAccum(
        lo$31052,
        hi$31054,
        lo$31052,
        j$31063 ->
            ix$31066 ->
                if (
                    <[unknown exp]>(
                        cmp$31048(Array.get(j$31063, a$31050))(pivot$31056),
                        Comparison.LessThan
                    )
                ) {
                    Array.swap!(ix$31066, j$31063, a$31050);
                    <[unknown exp]>(ix$31066, 1i32)
                } else {
                    ix$31066
                }
    );
    Array.swap!(i$31060, hi$31054, a$31050);
    i$31060
}

def Array.range(
    rc$25859: Region[r],
    b$25862: Int32,
    e$25869: Int32
): Array[Int32, r] \ r = {
    if (<[unknown exp]>(b$25862, e$25869)) {
        [] @ rc$25859
    } else {
        let f$25893: (Int32 -> Int32) = x$25896 ->
            <[unknown exp]>(x$25896, b$25862);
        Array.init(rc$25859, f$25893, <[unknown exp]>(e$25869, b$25862))
    }
}

def Array.reduceLeft(
    f$28185: a -> a -> a \ ef,
    a$28187: Array[a, r]
): Option[a] \ ef + r = {
    let len$28197: Int32 = Array.length(a$28187);
    letrec loop$28201: (Int32 -> a -> a \ ef + r) = i$28203 ->
        acc$28205 ->
            if (<[unknown exp]>(i$28203, len$28197)) {
                acc$28205
            } else {
                loop$28201(
                    <[unknown exp]>(i$28203, 1i32)
                )(f$28185(acc$28205)(Array.get(i$28203, a$28187)))
            };
    if (<[unknown exp]>(len$28197, 0i32)) {
        Option.None
    } else {
        Option.Some(loop$28201(1i32)(Array.get(0i32, a$28187)))
    }
}

def Array.reduceRight(
    f$28239: a -> a -> a \ ef,
    arr$28253: Array[a, r]
): Option[a] \ ef + r = {
    let len$28265: Int32 = Array.length(arr$28253);
    letrec loop$28267: (Int32 -> a -> a \ ef + r) = i$28269 ->
        acc$28271 ->
            if (<[unknown exp]>(i$28269, 0i32)) {
                acc$28271
            } else {
                loop$28267(
                    <[unknown exp]>(i$28269, 1i32)
                )(f$28239(Array.get(i$28269, arr$28253))(acc$28271))
            };
    if (<[unknown exp]>(len$28265, 0i32)) {
        Option.None
    } else {
        Option.Some(
            loop$28267(
                <[unknown exp]>(len$28265, 2i32)
            )(Array.get(<[unknown exp]>(len$28265, 1i32), arr$28253))
        )
    }
}

def Array.repeat(
    rc$25946: Region[r],
    n$25954: Int32,
    x$25962: a
): Array[a, r] \ r = {
    if (<[unknown exp]>(n$25954, 0i32)) {
        [] @ rc$25946
    } else {
        [rc$25946 ; x$25962] @ n$25954
    }
}

def Array.replace(
    rc1$27013: Region[r1],
    src$27023: { src = a },
    dst$27031: { dst = a },
    a$27033: Array[a, r]
): Array[a, r1] \ r + r1 = {
    Array.map(
        rc1$27013,
        e$27038 ->
            if (<[unknown exp]>(e$27038, src$27023.src)) {
                dst$27031.dst
            } else {
                e$27038
            },
        a$27033
    )
}

def Array.replace!(
    src$27057: { src = a },
    dst$27061: { dst = a },
    a$27065: Array[a, r]
): Unit \ r = {
    Array.transform!(
        e$27073 ->
            if (<[unknown exp]>(e$27073, src$27057.src)) {
                dst$27061.dst
            } else {
                e$27073
            },
        a$27065
    )
}

def Array.reverse(
    rc1$26582: Region[r1],
    a$26584: Array[a, r]
): Array[a, r1] \ r + r1 = {
    let len$26586: Int32 = Array.length(a$26584);
    let end$26588: Int32 = <[unknown exp]>(len$26586, 1i32);
    Array.init(
        rc1$26582,
        i$26590 ->
            Array.get(<[unknown exp]>(end$26588, i$26590), a$26584),
        len$26586
    )
}

def Array.reverse!(arr$26613: Array[a, r]): Unit \ r = {
    let len$26619: Int32 = Array.length(arr$26613);
    let halflen$26623: Int32 = <[unknown exp]>(len$26619, 2i32);
    letrec loop$26626: (Int32 -> Int32 -> Unit \ r) = i$26628 ->
        j$26631 ->
            if (<[unknown exp]>(i$26628, halflen$26623)) {
                ()
            } else {
                let x$26634: a = Array.get(i$26628, arr$26613);
                let y$26636: a = Array.get(j$26631, arr$26613);
                Array.put(y$26636, i$26628, arr$26613);
                Array.put(x$26634, j$26631, arr$26613);
                loop$26626(
                    <[unknown exp]>(i$26628, 1i32)
                )(<[unknown exp]>(j$26631, 1i32))
            };
    loop$26626(0i32)(<[unknown exp]>(len$26619, 1i32))
}

def Array.rotateLeft(
    rc2$26665: Region[r2],
    n$26669: Int32,
    arr$26671: Array[a, r1]
): Array[a, r2] \ r1 + r2 = {
    let len$26690: Int32 = Array.length(arr$26671);
    if (<[unknown exp]>(len$26690, 1i32)) {
        [] @ rc2$26665
    } else {
        if (<[unknown exp]>(n$26669, 0i32)) {
            Array.rotateRightHelper(rc2$26665, Int32.abs(n$26669), arr$26671)
        } else {
            Array.rotateLeftHelper(rc2$26665, n$26669, arr$26671)
        }
    }
}

def Array.rotateLeftHelper(
    rc2$26729: Region[r2],
    n$26731: Int32,
    arr$26739: Array[a, r1]
): Array[a, r2] \ r1 + r2 = {
    let len$26750: Int32 = Array.length(arr$26739);
    let f$26752: (Int32 -> a) = i$26754 ->
        {
            let i1$26757: Int32 = <[unknown exp]>(n$26731, i$26754);
            Array.get(Int32.remainder(i1$26757, len$26750), arr$26739)
        };
    Array.init(rc2$26729, f$26752, len$26750)
}

def Array.rotateRight(
    rc2$26792: Region[r2],
    n$26794: Int32,
    arr$26798: Array[a, r1]
): Array[a, r2] \ r1 + r2 = {
    if (<[unknown exp]>(Array.length(arr$26798), 1i32)) {
        [] @ rc2$26792
    } else {
        if (<[unknown exp]>(n$26794, 0i32)) {
            Array.rotateLeftHelper(rc2$26792, Int32.abs(n$26794), arr$26798)
        } else {
            Array.rotateRightHelper(rc2$26792, n$26794, arr$26798)
        }
    }
}

def Array.rotateRightHelper(
    rc2$26844: Region[r2],
    n$26849: Int32,
    a$26853: Array[a, r1]
): Array[a, r2] \ r1 + r2 = {
    let len$26865: Int32 = Array.length(a$26853);
    let n1$26867: Int32 = Int32.remainder(n$26849, len$26865);
    let start$26869: Int32 = <[unknown exp]>(len$26865, n1$26867);
    let f$26871: (Int32 -> a) = i$26873 ->
        {
            let i1$26875: Int32 = <[unknown exp]>(start$26869, i$26873);
            Array.get(Int32.remainder(i1$26875, len$26865), a$26853)
        };
    Array.init(rc2$26844, f$26871, len$26865)
}

def Array.sameElements(
    a$30354: Array[a, r1],
    b$30357: Array[a, r2]
): Bool \ r1 + r2 = {
    let alen$30362: Int32 = Array.length(a$30354);
    let blen$30364: Int32 = Array.length(b$30357);
    letrec loop$30366: (Int32 -> Bool) = i$30368 ->
        if (<[unknown exp]>(i$30368, alen$30362)) {
            true
        } else {
            if (
                <[unknown exp]>(
                    Array.get(i$30368, a$30354),
                    Array.get(i$30368, b$30357)
                )
            ) {
                false
            } else {
                loop$30366(<[unknown exp]>(i$30368, 1i32))
            }
        };
    if (<[unknown exp]>(alen$30362, blen$30364)) {loop$30366(0i32)} else {false}
}

def Array.scan(
    rc$26007: Region[r],
    f$26009: b -> a -> b \ ef,
    s$26011: b,
    arr$26013: Array[a, r]
): Array[b, r] \ ef + r = {
    Array.scanLeft(rc$26007, f$26009, s$26011, arr$26013)
}

def Array.scanLeft(
    rc$26045: Region[r],
    f$26049: b -> a -> b \ ef,
    s$26055: b,
    arr$26061: Array[a, r]
): Array[b, r] \ ef + r = {
    let len$26075: Int32 = <[unknown exp]>(Array.length(arr$26061), 1i32);
    let b$26077: Array[b, r] = Array.repeat(rc$26045, len$26075, s$26055);
    letrec loop$26079: (Int32 -> b -> Unit \ ef + r + r + r + ef) = i$26081 ->
        acc$26083 ->
            if (<[unknown exp]>(i$26081, len$26075)) {
                ()
            } else {
                let s1$26085: b = f$26049(
                    acc$26083
                )(Array.get(<[unknown exp]>(i$26081, 1i32), arr$26061));
                Array.put(s1$26085, i$26081, b$26077);
                loop$26079(<[unknown exp]>(i$26081, 1i32))(s1$26085)
            };
    loop$26079(1i32)(s$26055);
    b$26077
}

def Array.scanRight(
    rc$26175: Region[r],
    f$26177: a -> b -> b \ ef,
    s$26194: b,
    a$26201: Array[a, r]
): Array[b, r] \ ef + r = {
    let len$26207: Int32 = Array.length(a$26201);
    let b$26209: Array[b, r] = Array.repeat(
        rc$26175,
        <[unknown exp]>(len$26207, 1i32),
        s$26194
    );
    letrec loop$26211: (Int32 -> b -> Unit \ ef + r + r + r + ef) = i$26213 ->
        acc$26215 ->
            if (<[unknown exp]>(i$26213, 0i32)) {
                ()
            } else {
                let s1$26217: b = f$26177(
                    Array.get(i$26213, a$26201)
                )(acc$26215);
                Array.put(s1$26217, i$26213, b$26209);
                loop$26211(<[unknown exp]>(i$26213, 1i32))(s1$26217)
            };
    loop$26211(<[unknown exp]>(len$26207, 1i32))(s$26194);
    b$26209
}

def Array.shuffle(rnd$31439: Random, a$31441: Array[a, r]): Unit \ r + IO = {
    let len$31447: Int32 = Array.length(a$31441);
    letrec loop$31449: (Int32 -> Unit) = i$31451 ->
        if (<[unknown exp]>(i$31451, 0i32)) {
            let j$31453: Int32 = Random.nextNatWithMax(
                rnd$31439,
                <[unknown exp]>(i$31451, 1i32)
            );
            Array.swap!(i$31451, j$31453, a$31441);
            loop$31449(<[unknown exp]>(i$31451, 1i32))
        } else {
            ()
        };
    loop$31449(<[unknown exp]>(len$31447, 1i32))
}

def Array.slice(
    rc1$24587: Region[r1],
    start$24589: { start = Int32 },
    end$24591: { end = Int32 },
    a$24593: Array[a, r]
): Array[a, r1] \ r + r1 = {
    Array.copyOfRange(rc1$24587, start$24589.start, end$24591.end, a$24593)
}

def Array.sort(
    rc1$30713: Region[r1],
    a$30715: Array[a, r]
): Array[a, r1] \ r + r1 = {
    Array.sortWith(
        rc1$30713,
        $0$47036 ->
            $1$47038 ->
                <[unknown exp]>($0$47036, $1$47038),
        a$30715
    )
}

def Array.sort!(a$30810: Array[a, r]): Unit \ r = {
    Array.sortWith!(
        $0$47052 ->
            $1$47054 ->
                <[unknown exp]>($0$47052, $1$47054),
        a$30810
    )
}

def Array.sortBy(
    rc1$30745: Region[r1],
    f$30749: a -> b,
    a$30755: Array[a, r]
): Array[a, r1] \ r + r1 = {
    Array.sortWith(
        rc1$30745,
        (
            $0$47040 ->
                $1$47042 ->
                    $2$47044 ->
                        $3$47046 ->
                            on($0$47040, $1$47042, $2$47044, $3$47046)
        )($0$47048 -> $1$47050 -> <[unknown exp]>($0$47048, $1$47050))(f$30749),
        a$30755
    )
}

def Array.sortBy!(f$30836: a -> b, a$30843: Array[a, r]): Unit \ r = {
    Array.sortWith!(
        (
            $0$47056 ->
                $1$47058 ->
                    $2$47060 ->
                        $3$47062 ->
                            on($0$47056, $1$47058, $2$47060, $3$47062)
        )($0$47064 -> $1$47066 -> <[unknown exp]>($0$47064, $1$47066))(f$30836),
        a$30843
    )
}

def Array.sortWith(
    rc1$30770: Region[r1],
    cmp$30772: a -> a -> Comparison,
    a$30778: Array[a, r]
): Array[a, r1] \ r + r1 = {
    let len$30782: Int32 = Array.length(a$30778);
    let b$30788: Array[a, r1] = Array.copyOfRange(
        rc1$30770,
        0i32,
        len$30782,
        a$30778
    );
    Array.sortWith!(cmp$30772, b$30788);
    b$30788
}

def Array.sortWith!(
    cmp$30931: a -> a -> Comparison,
    a$30941: Array[a, r]
): Unit \ r = {
    Array.sortWithin!(
        cmp$30931,
        0i32,
        <[unknown exp]>(Array.length(a$30941), 1i32),
        a$30941
    )
}

def Array.sortWithin!(
    cmp$30972: a -> a -> Comparison,
    lo$30977: Int32,
    hi$30979: Int32,
    a$30981: Array[a, r]
): Unit \ r = {
    if (<[unknown exp]>(lo$30977, hi$30979)) {
        ()
    } else {
        let p$30991: Int32 = Array.quicksortPartition(
            cmp$30972,
            a$30981,
            lo$30977,
            hi$30979
        );
        Array.sortWithin!(
            cmp$30972,
            lo$30977,
            <[unknown exp]>(p$30991, 1i32),
            a$30981
        );
        Array.sortWithin!(
            cmp$30972,
            <[unknown exp]>(p$30991, 1i32),
            hi$30979,
            a$30981
        )
    }
}

def Array.span(
    rc1$28698: Region[r1],
    rc2$28702: Region[r2],
    f$28704: a -> Bool,
    a$28708: Array[a, r]
): (Array[a, r1], Array[a, r2]) \ ef + r + r1 + r2 = {
    match Array.findIndexOfLeft(x$28711 -> !f$28704(x$28711), a$28708) {
        case Option.None =>
            (
                Array.takeLeft(rc1$28698, Array.length(a$28708), a$28708),
                [] @ rc2$28702
            )
        case Option.Some(i$28713) =>
            (
                Array.takeLeft(rc1$28698, i$28713, a$28708),
                Array.dropLeft(rc2$28702, i$28713, a$28708)
            )
    }
}

def Array.sum(a$28364: Array[Int32, r]): Int32 \ r = {
    Array.foldLeft(
        acc$28367 ->
            x$28369 ->
                <[unknown exp]>(acc$28367, x$28369),
        0i32,
        a$28364
    )
}

def Array.sumLengths(arrs$27417: Array[Array[a, r1], r2]): Int32 \ r2 = {
    Array.foldLeft(
        acc$27439 ->
            a$27441 ->
                <[unknown exp]>(acc$27439, Array.length(a$27441)),
        0i32,
        arrs$27417
    )
}

def Array.sumWith(f$28406: a -> Int32, a$28413: Array[a, r]): Int32 \ ef + r = {
    Array.foldLeft(
        acc$28425 ->
            x$28427 ->
                <[unknown exp]>(acc$28425, f$28406(x$28427)),
        0i32,
        a$28413
    )
}

def Array.swap!(
    i$31017: Int32,
    j$31019: Int32,
    a$31021: Array[a, r]
): Unit \ r = {
    let x$31023: a = Array.get(i$31017, a$31021);
    let y$31025: a = Array.get(j$31019, a$31021);
    Array.put(y$31025, i$31017, a$31021);
    Array.put(x$31023, j$31019, a$31021)
}

def Array.take(
    rc1$28953: Region[r1],
    n$28955: Int32,
    a$28957: Array[a, r]
): Array[a, r1] \ r + r1 = {
    Array.takeLeft(rc1$28953, n$28955, a$28957)
}

def Array.takeLeft(
    rc1$28978: Region[r1],
    n$28983: Int32,
    a$28986: Array[a, r]
): Array[a, r1] \ r + r1 = {
    if (<[unknown exp]>(n$28983, 0i32)) {
        [] @ rc1$28978
    } else {
        let len$28999: Int32 = Array.length(a$28986);
        let end$29001: Int32 = if (<[unknown exp]>(n$28983, len$28999)) {
            len$28999
        } else {
            n$28983
        };
        Array.copyOfRange(rc1$28978, 0i32, end$29001, a$28986)
    }
}

def Array.takeRight(
    rc1$29024: Region[r1],
    n$29026: Int32,
    a$29028: Array[a, r]
): Array[a, r1] \ r + r1 = {
    if (<[unknown exp]>(n$29026, 0i32)) {
        [] @ rc1$29024
    } else {
        let len$29030: Int32 = Array.length(a$29028);
        let start$29032: Int32 = if (<[unknown exp]>(n$29026, len$29030)) {
            0i32
        } else {
            <[unknown exp]>(len$29030, n$29026)
        };
        Array.copyOfRange(rc1$29024, start$29032, len$29030, a$29028)
    }
}

def Array.takeWhile(
    rc1$29056: Region[r1],
    f$29062: a -> Bool,
    a$29064: Array[a, r]
): Array[a, r1] \ ef + r + r1 = {
    Array.takeWhileLeft(rc1$29056, f$29062, a$29064)
}

def Array.takeWhileLeft(
    rc1$29089: Region[r1],
    f$29091: a -> Bool,
    a$29121: Array[a, r]
): Array[a, r1] \ ef + r + r1 = {
    match Array.findIndexOfLeft(x$29171 -> !f$29091(x$29171), a$29121) {
        case Option.None =>
            Array.copyOfRange(rc1$29089, 0i32, Array.length(a$29121), a$29121)
        case Option.Some(i$29173) =>
            Array.takeLeft(rc1$29089, i$29173, a$29121)
    }
}

def Array.takeWhileRight(
    rc1$29195: Region[r1],
    f$29199: a -> Bool,
    a$29205: Array[a, r]
): Array[a, r1] \ ef + r + r1 = {
    match Array.findIndexOfRight(x$29223 -> !f$29199(x$29223), a$29205) {
        case Option.None =>
            Array.copyOfRange(rc1$29195, 0i32, Array.length(a$29205), a$29205)
        case Option.Some(i$29226) =>
            Array.copyOfRange(
                rc1$29195,
                <[unknown exp]>(i$29226, 1i32),
                Array.length(a$29205),
                a$29205
            )
    }
}

def Array.toChain(arr$24824: Array[a, r]): Chain[a] \ r = {
    letrec loop$24826: (
        Int32 -> Chain[a] -> Chain[a] \ r + (e93243 & r) + r
    ) = i$24828 ->
        acc$24830 ->
            if (<[unknown exp]>(i$24828, 0i32)) {
                acc$24830
            } else {
                let x$24832: a = Array.get(
                    <[unknown exp]>(i$24828, 1i32),
                    arr$24824
                );
                loop$24826(
                    <[unknown exp]>(i$24828, 1i32)
                )(Chain.cons(x$24832, acc$24830))
            };
    loop$24826(Array.length(arr$24824))(Chain.empty(()))
}

def Array.toDelayList(a$24773: Array[a, r]): DelayList[a] \ r = {
    letrec loop$24780: (Int32 -> DelayList[a] -> DelayList[a] \ r) = i$24782 ->
        acc$24788 ->
            if (<[unknown exp]>(i$24782, 0i32)) {
                acc$24788
            } else {
                loop$24780(
                    <[unknown exp]>(i$24782, 1i32)
                )(DelayList.ECons(Array.get(i$24782, a$24773), acc$24788))
            };
    loop$24780(<[unknown exp]>(Array.length(a$24773), 1i32))(DelayList.ENil)
}

def Array.toList(a$24625: Array[a, r]): List[a] \ r = {
    letrec loop$24700: (Int32 -> List[a] -> List[a] \ r) = i$24702 ->
        acc$24704 ->
            if (<[unknown exp]>(i$24702, 0i32)) {
                acc$24704
            } else {
                let x$24706: a = Array.get(
                    <[unknown exp]>(i$24702, 1i32),
                    a$24625
                );
                loop$24700(
                    <[unknown exp]>(i$24702, 1i32)
                )(List.Cons(x$24706, acc$24704))
            };
    loop$24700(Array.length(a$24625))(List.Nil)
}

def Array.toMap(a$30029: Array[(a, b), r]): Map[a, b] \ r = {
    Array.foldRight(
        x$30037 ->
            m$30039 ->
                Map.insert(fst(x$30037), snd(x$30037), m$30039),
        Map.empty(()),
        a$30029
    )
}

def Array.toMutDeque(
    rc1$24927: Region[r1],
    a$24929: Array[a, r2]
): MutDeque[a, r1] \ r2 + r1 = {
    let d$24931: MutDeque[a, r1] = MutDeque.empty(rc1$24927);
    Array.forEach(x$24933 -> MutDeque.pushBack(x$24933, d$24931), a$24929);
    d$24931
}

def Array.toMutList(
    rc1$30068: Region[r1],
    a$30070: Array[a, r2]
): MutList[a, r1] \ r2 + r1 = {
    let minCap$30081: Int32 = MutList.minCapacity(());
    let len$30083: Int32 = Array.length(a$30070);
    let c$30085: Int32 = <[unknown exp]>(len$30083, minCap$30081);
    let copy$30087: Array[a, r1] = Array.copyOfRange(
        rc1$30068,
        0i32,
        c$30085,
        a$30070
    );
    MutList.MutList(
        rc1$30068,
        (ref copy$30087) @ rc1$30068,
        (ref len$30083) @ rc1$30068
    )
}

def Array.toNec(arr$24848: Array[a, r]): Option[Nec[a]] \ r = {
    letrec loop$24864: (
        Int32 -> Nec[a] -> Nec[a] \ r + (e73361 & r) + r
    ) = i$24868 ->
        acc$24872 ->
            if (<[unknown exp]>(i$24868, 0i32)) {
                acc$24872
            } else {
                let x$24878: a = Array.get(
                    <[unknown exp]>(i$24868, 1i32),
                    arr$24848
                );
                loop$24864(
                    <[unknown exp]>(i$24868, 1i32)
                )(Nec.cons(x$24878, acc$24872))
            };
    if (Array.isEmpty(arr$24848)) {
        Option.None
    } else {
        let i$24898: Int32 = <[unknown exp]>(Array.length(arr$24848), 1i32);
        Option.Some(
            loop$24864(i$24898)(Nec.singleton(Array.get(i$24898, arr$24848)))
        )
    }
}

def Array.toNel(arr$24738: Array[a, r]): Option[Nel[a]] \ r = {
    letrec loop$24740: (
        Int32 -> Nel[a] -> Nel[a] \ r + (e77318 & r) + r
    ) = i$24742 ->
        acc$24744 ->
            if (<[unknown exp]>(i$24742, 0i32)) {
                acc$24744
            } else {
                let x$24746: a = Array.get(
                    <[unknown exp]>(i$24742, 1i32),
                    arr$24738
                );
                loop$24740(
                    <[unknown exp]>(i$24742, 1i32)
                )(Nel.cons(x$24746, acc$24744))
            };
    if (Array.isEmpty(arr$24738)) {
        Option.None
    } else {
        let i$24750: Int32 = <[unknown exp]>(Array.length(arr$24738), 1i32);
        Option.Some(
            loop$24740(i$24750)(Nel.singleton(Array.get(i$24750, arr$24738)))
        )
    }
}

def Array.toSet(a$29979: Array[a, r]): Set[a] \ r = {
    Array.foldRight(
        $0$47004 ->
            $1$47006 ->
                Set.insert($0$47004, $1$47006),
        Set.empty(()),
        a$29979
    )
}

def Array.toString(a$17196: Array[a, r]): String \ r = {
    region rc2$17203 {
        let sb$17207: StringBuilder[rc2] = StringBuilder.empty(rc2$17203);
        let first$17213: Ref[Bool, rc2] = (ref true) @ rc2$17203;
        StringBuilder.appendString!("""Array#{""", sb$17207);
        let f$17217: (a -> Unit) = x$17219 ->
            {
                if (!(deref first$17213)) {
                    StringBuilder.appendString!(""", """, sb$17207)
                } else {
                    Ref.put(false, first$17213)
                };
                StringBuilder.appendString!(
                    """""" + <[unknown exp]>(x$17219),
                    sb$17207
                )
            };
        Array.forEach(f$17217, a$17196);
        StringBuilder.appendString!("""}""", sb$17207);
        StringBuilder.toString(sb$17207)
    }
}

def Array.toVector(a$24945: Array[a, r]): Vector[a] \ r = {
    region rc$24950 {
        let arr1$24953: Array[a, rc] = Array.copyOfRange(
            rc$24950,
            0i32,
            Array.length(a$24945),
            a$24945
        );
        <[unknown exp]>
    }
}

def Array.transform!(f$26293: a -> a, arr$26302: Array[a, r]): Unit \ ef + r = {
    let len$26304: Int32 = Array.length(arr$26302);
    letrec loop$26306: (Int32 -> Unit) = i$26308 ->
        if (<[unknown exp]>(i$26308, len$26304)) {
            ()
        } else {
            Array.put(
                f$26293(Array.get(i$26308, arr$26302)),
                i$26308,
                arr$26302
            );
            loop$26306(<[unknown exp]>(i$26308, 1i32))
        };
    loop$26306(0i32)
}

def Array.transformWithIndex!(
    f$26444: Int32 -> a -> a \ ef,
    arr$26446: Array[a, r]
): Unit \ ef + r = {
    let len$26452: Int32 = Array.length(arr$26446);
    letrec loop$26454: (Int32 -> Unit) = i$26456 ->
        if (<[unknown exp]>(i$26456, len$26452)) {
            ()
        } else {
            Array.put(
                f$26444(i$26456)(Array.get(i$26456, arr$26446)),
                i$26456,
                arr$26446
            );
            loop$26454(<[unknown exp]>(i$26456, 1i32))
        };
    loop$26454(0i32)
}

def Array.transpose(
    rc3$27524: Region[r3],
    a$27528: Array[Array[a, r1], r2]
): Array[Array[a, r3], r3] \ r1 + r2 + r3 = {
    let ilen$27533: Int32 = Array.length(a$27528);
    if (<[unknown exp]>(ilen$27533, 0i32)) {
        [] @ rc3$27524
    } else {
        let jlen$27539: Int32 = Array.length(Array.get(0i32, a$27528));
        if (
            <[unknown exp]>(
                jlen$27539,
                0i32
            ) or Array.uniformHelper(a$27528, jlen$27539)
        ) {
            Array.init(
                rc3$27524,
                i$27550 ->
                    Array.copyOfRange(
                        rc3$27524,
                        0i32,
                        Array.length(Array.get(i$27550, a$27528)),
                        Array.get(i$27550, a$27528)
                    ),
                ilen$27533
            )
        } else {
            Array.init(
                rc3$27524,
                i$27555 ->
                    Array.init(
                        rc3$27524,
                        j$27557 ->
                            |>(
                                |>(
                                    a$27528,
                                    (
                                        $0$46920 ->
                                            $1$46922 ->
                                                Array.get($0$46920, $1$46922)
                                    )(j$27557)
                                ),
                                (
                                    $0$46926 ->
                                        $1$46928 ->
                                            Array.get($0$46926, $1$46928)
                                )(i$27555)
                            ),
                        ilen$27533
                    ),
                jlen$27539
            )
        }
    }
}

def Array.uniformHelper(
    a$27600: Array[Array[a, r1], r2],
    l$27610: Int32
): Bool \ r2 = {
    Array.exists(
        x$27618 ->
            <[unknown exp]>(Array.length(x$27618), l$27610),
        a$27600
    )
}

def Array.unzip(
    rc1$29616: Region[r1],
    rc2$29621: Region[r2],
    a$29623: Array[(a, b), r3]
): (Array[a, r1], Array[b, r2]) \ r1 + r2 + r3 = {
    let len$29637: Int32 = Array.length(a$29623);
    if (<[unknown exp]>(len$29637, 0i32)) {
        ([] @ rc1$29616, [] @ rc2$29621)
    } else {
        match Array.get(0i32, a$29623) {
            case (x$29639, y$29641) =>
                let arr$29643: Array[a, r1] = Array.repeat(
                    rc1$29616,
                    len$29637,
                    x$29639
                );
                let brr$29646: Array[b, r2] = Array.repeat(
                    rc2$29621,
                    len$29637,
                    y$29641
                );
                letrec loop$29650: (Int32 -> Unit) = i$29652 ->
                    if (<[unknown exp]>(i$29652, len$29637)) {
                        match Array.get(i$29652, a$29623) {
                            case (l$29656, r$29658) =>
                                Array.put(l$29656, i$29652, arr$29643);
                                Array.put(r$29658, i$29652, brr$29646);
                                loop$29650(<[unknown exp]>(i$29652, 1i32))
                        }
                    } else {
                        ()
                    };
                loop$29650(1i32);
                (arr$29643, brr$29646)
        }
    }
}

def Array.update(
    rc1$26960: Region[r1],
    i$26964: Int32,
    x$26966: a,
    a$26968: Array[a, r]
): Array[a, r1] \ r + r1 = {
    let len$26974: Int32 = Array.length(a$26968);
    let f$26976: (Int32 -> a) = ix$26980 ->
        if (<[unknown exp]>(ix$26980, i$26964)) {
            x$26966
        } else {
            Array.get(ix$26980, a$26968)
        };
    Array.init(rc1$26960, f$26976, len$26974)
}

def Array.updateSequence(
    rc3$30537: Region[r3],
    i$30539: Int32,
    sub$30541: Array[a, r1],
    a$30543: Array[a, r2]
): Array[a, r3] \ r1 + r2 + r3 = {
    let end$30552: Int32 = <[unknown exp]>(i$30539, Array.length(sub$30541));
    let f$30555: (Int32 -> a) = ix$30557 ->
        if (
            <[unknown exp]>(
                ix$30557,
                i$30539
            ) and <[unknown exp]>(ix$30557, end$30552)
        ) {
            Array.get(<[unknown exp]>(ix$30557, i$30539), sub$30541)
        } else {
            Array.get(ix$30557, a$30543)
        };
    let len$30559: Int32 = Array.length(a$30543);
    Array.init(rc3$30537, f$30555, len$30559)
}

def Array.updateSequence!(
    i$30583: Int32,
    sub$30587: Array[a, r1],
    a$30589: Array[a, r2]
): Unit \ r1 + r2 = {
    let end$30593: Int32 = <[unknown exp]>(i$30583, Array.length(sub$30587));
    let f$30595: (Int32 -> a -> Unit \ r2 + r1) = ix$30597 ->
        _$30599 ->
            if (
                <[unknown exp]>(
                    ix$30597,
                    i$30583
                ) and <[unknown exp]>(ix$30597, end$30593)
            ) {
                Array.put(
                    Array.get(<[unknown exp]>(ix$30597, i$30583), sub$30587),
                    ix$30597,
                    a$30589
                )
            } else {
                ()
            };
    Array.forEachWithIndex(f$30595, a$30589)
}

def Array.zip(
    rc3$29507: Region[r3],
    a$29509: Array[a, r1],
    b$29511: Array[b, r2]
): Array[(a, b), r3] \ r1 + r2 + r3 = {
    let len$29521: Int32 = Int32.min(
        Array.length(a$29509),
        Array.length(b$29511)
    );
    Array.init(
        rc3$29507,
        i$29523 ->
            (Array.get(i$29523, a$29509), Array.get(i$29523, b$29511)),
        len$29521
    )
}

def Array.zipWith(
    rc3$29560: Region[r3],
    f$29563: a -> b -> c \ ef,
    a$29576: Array[a, r1],
    b$29578: Array[b, r2]
): Array[c, r3] \ ef + r1 + r2 + r3 = {
    let len$29582: Int32 = Int32.min(
        Array.length(a$29576),
        Array.length(b$29578)
    );
    Array.init(
        rc3$29560,
        i$29584 ->
            f$29563(Array.get(i$29584, a$29576))(Array.get(i$29584, b$29578)),
        len$29582
    )
}

def Assert.eq(expected$18984: a, actual$18987: a): Bool = {<[unknown exp]>}

enum Benchmark {case Benchmark({ f = Unit -> Unit \ IO, name = String })}

def Benchmark.defBenchmark(
    name$15864: String,
    f$15866: Unit -> a
): Benchmark = {
    let fn$15875: (Unit -> Unit) = _unit$15877 ->
        match <[unknown exp]> {case _ => ()};
    Benchmark.Benchmark({+name = name$15864, +f = fn$15875 | {}})
}

def Benchmark.iterations(cost$16170: Int64, budget$16174: Int64): Int32 = {
    if (<[unknown exp]>(cost$16170, 0i64)) {
        Benchmark.maxIterations(())
    } else {
        Int64.clampToInt32(
            {+min = Benchmark.minIterations(()) | {}},
            {+max = Benchmark.maxIterations(()) | {}},
            <[unknown exp]>(budget$16174, cost$16170)
        )
    }
}

def Benchmark.loop(f$16145: Unit -> a, n$16152: Int32): Unit \ ef = {
    if (<[unknown exp]>(n$16152, 0i32)) {
        ()
    } else {
        discard f$16145(());
        Benchmark.loop(f$16145, <[unknown exp]>(n$16152, 1i32))
    }
}

def Benchmark.maxIterations(_unit$15812: Unit): Int32 = {1000000i32}

def Benchmark.minIterations(_unit$15788: Unit): Int32 = {1i32}

def Benchmark.printCols(_unit$16208: Unit): Unit \ IO = {
    let namePart$16210: String = String.padRight(
        40i32,
        ''' ''',
        """Benchmark"""
    );
    let iterPart$16212: String = String.padLeft(
        20i32,
        ''' ''',
        """Iterations"""
    );
    let timePart$16216: String = String.padLeft(
        20i32,
        ''' ''',
        """Time (avg)"""
    );
    println(
        (
            (
                """""" + <[unknown exp]>(namePart$16210)
            ) + <[unknown exp]>(iterPart$16212)
        ) + <[unknown exp]>(timePart$16216)
    )
}

def Benchmark.printHeader(_unit$16196: Unit): Unit \ IO = {
    println(
        """------------------------------ Running Benchmarks ------------------------------"""
    )
}

def Benchmark.printRow(s$16236: BenchmarkResult): Unit \ IO = {
    match s$16236 {
        case Benchmark.BenchmarkResult.Success(r$16241) =>
            let avgNs$16244: Int64 = <[unknown exp]>(
                r$16241.total,
                Int32.toInt64(r$16241.rounds)
            );
            let avgMs$16247: Int64 = Benchmark.toMicroSeconds(avgNs$16244);
            let namePart$16249: String = String.padRight(
                40i32,
                ''' ''',
                r$16241.name
            );
            let iterPart$16253: String = String.padLeft(
                20i32,
                ''' ''',
                """""" + <[unknown exp]>(r$16241.rounds)
            );
            let avgTimePart$16265: String = String.padLeft(
                20i32,
                ''' ''',
                ("""""" + <[unknown exp]>(avgMs$16247)) + """ us/op"""
            );
            |>(
                (
                    (
                        """""" + <[unknown exp]>(namePart$16249)
                    ) + <[unknown exp]>(iterPart$16253)
                ) + <[unknown exp]>(avgTimePart$16265),
                $0$45836 ->
                    println($0$45836)
            )
    }
}

def Benchmark.runAll(
    bs$16011: Array[(Benchmark, Int64), r],
    budget$16013: Int64
): Unit \ r + IO = {
    let budgetPerBenchmark$16025: Int64 = <[unknown exp]>(
        budget$16013,
        Int32.toInt64(Array.length(bs$16011))
    );
    |>(
        bs$16011,
        (
            $0$45830 ->
                $1$45832 ->
                    Array.forEach($0$45830, $1$45832)
        )(
            pat$76$16027 ->
                match pat$76$16027 {
                    case (b$16036, cost$16038) =>
                        let iters$16043: Int32 = Benchmark.iterations(
                            cost$16038,
                            budgetPerBenchmark$16025
                        );
                        |>(
                            Benchmark.runBenchmark(b$16036, iters$16043),
                            $0$45834 ->
                                Benchmark.printRow($0$45834)
                        )
                }
        )
    )
}

def Benchmark.runBenchmark(
    b$16051: Benchmark,
    n$16056: Int32
): BenchmarkResult \ IO = {
    let nanoTime$16064: (Unit -> Int64) = _$16066 ->
        ##java.lang.System.nanoTime();
    match b$16051 {
        case Benchmark.Benchmark(r$16076) =>
            let t$16078: Int64 = nanoTime$16064(());
            Benchmark.loop(r$16076.f, n$16056);
            let e$16082: Int64 = <[unknown exp]>(nanoTime$16064(()), t$16078);
            Benchmark.BenchmarkResult.Success(
                {+name = r$16076.name, +rounds = n$16056, +total = e$16082 | {}}
            )
    }
}

def Benchmark.runBenchmarkOnce(b$16105: Benchmark): Int64 \ IO = {
    match b$16105 {
        case Benchmark.Benchmark(r$16107) =>
            let nanoTime$16109: (Unit -> Int64) = _$16111 ->
                ##java.lang.System.nanoTime();
            let t$16118: Int64 = nanoTime$16109(());
            r$16107.f(());
            <[unknown exp]>(
                <[unknown exp]>(nanoTime$16109(()), t$16118),
                Benchmark.scaleFactor(())
            )
    }
}

def Benchmark.runWithBudget(
    bs$15906: Array[Benchmark, r],
    budget$15912: Int64
): Int32 \ IO + r = {
    region rc$15916 {
        if (<[unknown exp]>(Array.length(bs$15906), 0i32)) {
            println("""No benchmarks"""); 1i32
        } else {
            let nanoTime$15929: (Unit -> Int64) = _$15932 ->
                ##java.lang.System.nanoTime();
            let t$15937: Int64 = nanoTime$15929(());
            Benchmark.printHeader(());
            println("""""");
            let benchmarksWithEstimates$15939: Array[(Benchmark, Int64), rc] = Benchmark.warmupAndEstimate(
                rc$15916,
                bs$15906
            );
            println("""""");
            println("""""");
            Benchmark.printCols(());
            Benchmark.runAll(benchmarksWithEstimates$15939, budget$15912);
            println("""""");
            let e$15941: Int64 = <[unknown exp]>(nanoTime$15929(()), t$15937);
            println(
                (
                    (
                        (
                            (
                                """""" + """Total time elapsed: """
                            ) + <[unknown exp]>(Benchmark.toSeconds(e$15941))
                        ) + """ seconds. Time budget was: """
                    ) + <[unknown exp]>(Benchmark.toSeconds(budget$15912))
                ) + """ seconds."""
            );
            0i32
        }
    }
}

def Benchmark.scaleFactor(_unit$15825: Unit): Int64 = {2i64}

def Benchmark.toMicroSeconds(d$16285: Int64): Int64 = {
    <[unknown exp]>(d$16285, 1000i64)
}

def Benchmark.toMilliSeconds(d$16302: Int64): Int64 = {
    <[unknown exp]>(Benchmark.toMicroSeconds(d$16302), 1000i64)
}

def Benchmark.toSeconds(d$16311: Int64): Int64 = {
    <[unknown exp]>(Benchmark.toMilliSeconds(d$16311), 1000i64)
}

def Benchmark.warmupAndEstimate(
    rc1$15968: Region[r1],
    bs$15971: Array[Benchmark, r]
): Array[(Benchmark, Int64), r1] \ r1 + r + IO = {
    Console.print("""Warmup: """);
    |>(
        bs$15971,
        (
            $0$45824 ->
                $1$45826 ->
                    $2$45828 ->
                        Array.map($0$45824, $1$45826, $2$45828)
        )(
            rc1$15968
        )(
            b$15987 ->
                {
                    let time$15991: Int64 = Benchmark.runBenchmarkOnce(b$15987);
                    Console.print(""".""");
                    (b$15987, time$15991)
                }
        )
    )
}

enum Benchmark.BenchmarkResult {
    case Success({ name = String, rounds = Int32, total = Int64 })
}

def BigDecimal.abs(x$38113: BigDecimal): BigDecimal = {
    let abs$38117: (BigDecimal -> BigDecimal) = obj$$38119 ->
        <[unknown exp]>;
    abs$38117(x$38113)
}

def BigDecimal.ceil(x$38363: BigDecimal): BigDecimal = {
    let setScale$38367: (
        BigDecimal -> Int32 -> (java.math.RoundingMode -> BigDecimal)
    ) = obj$$38371 ->
        a0$$38375 ->
            a1$$38377 ->
                <[unknown exp]>;
    let getCeiling$38382: (Unit -> java.math.RoundingMode) = _$38384 ->
        <[unknown exp]>;
    setScale$38367(x$38363)(0i32)(getCeiling$38382(()))
}

def BigDecimal.compare(x$38166: BigDecimal, y$38168: BigDecimal): Int32 = {
    let compareTo$38176: (BigDecimal -> BigDecimal -> Int32) = obj$$38178 ->
        a0$$38180 ->
            <[unknown exp]>;
    compareTo$38176(x$38166)(y$38168)
}

def BigDecimal.dist(x$38155: BigDecimal, y$38157: BigDecimal): BigDecimal = {
    BigDecimal.abs(<[unknown exp]>(x$38155, y$38157))
}

def BigDecimal.floor(x$38396: BigDecimal): BigDecimal = {
    let setScale$38399: (
        BigDecimal -> Int32 -> (java.math.RoundingMode -> BigDecimal)
    ) = obj$$38401 ->
        a0$$38403 ->
            a1$$38405 ->
                <[unknown exp]>;
    let getFloor$38411: (Unit -> java.math.RoundingMode) = _$38413 ->
        <[unknown exp]>;
    setScale$38399(x$38396)(0i32)(getFloor$38411(()))
}

def BigDecimal.fromString(s$38214: String): Option[BigDecimal] = {
    try {
        let strip$38217: (String -> String) = obj$$38219 ->
            <[unknown exp]>;
        let parseBigDecimal$38221: (String -> BigDecimal) = a0$38223 ->
            <[unknown exp]>;
        Option.Some(|>(|>(s$38214, strip$38217), parseBigDecimal$38221))
    } catch {case _$38231: ##java.lang.NumberFormatException => Option.None}
}

def BigDecimal.max(x$38101: BigDecimal, y$38103: BigDecimal): BigDecimal = {
    if (<[unknown exp]>(x$38101, y$38103)) {x$38101} else {y$38103}
}

def BigDecimal.min(x$38088: BigDecimal, y$38090: BigDecimal): BigDecimal = {
    if (<[unknown exp]>(x$38088, y$38090)) {x$38088} else {y$38090}
}

def BigDecimal.numericEquals(x$38251: BigDecimal, y$38253: BigDecimal): Bool = {
    let compareTo$38260: (BigDecimal -> BigDecimal -> Int32) = obj$$38262 ->
        a0$$38264 ->
            <[unknown exp]>;
    <[unknown exp]>(compareTo$38260(x$38251)(y$38253), 0i32)
}

def BigDecimal.pow(x$38134: BigDecimal, n$38136: Int32): BigDecimal = {
    let pow$38139: (BigDecimal -> Int32 -> BigDecimal) = obj$$38141 ->
        a0$$38143 ->
            <[unknown exp]>;
    pow$38139(x$38134)(n$38136)
}

def BigDecimal.precision(x$38316: BigDecimal): Int32 = {
    let precision$38320: (BigDecimal -> Int32) = obj$$38322 ->
        <[unknown exp]>;
    precision$38320(x$38316)
}

def BigDecimal.round(x$38421: BigDecimal): BigDecimal = {
    let setScale$38425: (
        BigDecimal -> Int32 -> (java.math.RoundingMode -> BigDecimal)
    ) = obj$$38427 ->
        a0$$38429 ->
            a1$$38431 ->
                <[unknown exp]>;
    let getHalfEven$38434: (Unit -> java.math.RoundingMode) = _$38436 ->
        <[unknown exp]>;
    setScale$38425(x$38421)(0i32)(getHalfEven$38434(()))
}

def BigDecimal.scale(x$38291: BigDecimal): Int32 = {
    let scale$38295: (BigDecimal -> Int32) = obj$$38297 ->
        <[unknown exp]>;
    scale$38295(x$38291)
}

def BigDecimal.signum(x$38194: BigDecimal): Int32 = {
    let signum$38198: (BigDecimal -> Int32) = obj$$38200 ->
        <[unknown exp]>;
    signum$38198(x$38194)
}

def BigDecimal.toBigInt(x$38603: BigDecimal): BigInt = {
    let toBigInteger$38616: (BigDecimal -> BigInt) = obj$$38620 ->
        <[unknown exp]>;
    toBigInteger$38616(x$38603)
}

def BigDecimal.toPlainString(x$38239: BigDecimal): String = {
    let toPlainString$38241: (BigDecimal -> String) = obj$$38243 ->
        <[unknown exp]>;
    toPlainString$38241(x$38239)
}

def BigDecimal.tryToFloat32(x$38656: BigDecimal): Option[Float32] = {
    let floatValue$38663: (BigDecimal -> Float32) = obj$$38665 ->
        <[unknown exp]>;
    let d$38686: Float32 = floatValue$38663(x$38656);
    if (Float32.isFinite(d$38686)) {Option.Some(d$38686)} else {Option.None}
}

def BigDecimal.tryToFloat64(x$38705: BigDecimal): Option[Float64] = {
    let doubleValue$38713: (BigDecimal -> Float64) = obj$$38715 ->
        <[unknown exp]>;
    let d$38720: Float64 = doubleValue$38713(x$38705);
    if (Float64.isFinite(d$38720)) {Option.Some(d$38720)} else {Option.None}
}

def BigDecimal.tryToInt16(x$38481: BigDecimal): Option[Int16] = {
    |>(
        BigDecimal.tryToInt32(x$38481),
        (
            $0$46746 ->
                $1$46748 ->
                    Option.flatMap($0$46746, $1$46748)
        )($0$46750 -> Int32.tryToInt16($0$46750))
    )
}

def BigDecimal.tryToInt32(x$38500: BigDecimal): Option[Int32] = {
    let intValue$38505: (BigDecimal -> Int32) = obj$$38507 ->
        <[unknown exp]>;
    if (
        <[unknown exp]>(
            x$38500,
            Int32.toBigDecimal(Int32.minValue(()))
        ) or <[unknown exp]>(x$38500, Int32.toBigDecimal(Int32.maxValue(())))
    ) {
        Option.None
    } else {
        Option.Some(intValue$38505(x$38500))
    }
}

def BigDecimal.tryToInt64(x$38545: BigDecimal): Option[Int64] = {
    let longValue$38551: (BigDecimal -> Int64) = obj$$38553 ->
        <[unknown exp]>;
    if (
        <[unknown exp]>(
            x$38545,
            Int64.toBigDecimal(Int64.minValue(()))
        ) or <[unknown exp]>(x$38545, Int64.toBigDecimal(Int64.maxValue(())))
    ) {
        Option.None
    } else {
        Option.Some(longValue$38551(x$38545))
    }
}

def BigDecimal.tryToInt8(x$38445: BigDecimal): Option[Int8] = {
    |>(
        BigDecimal.tryToInt32(x$38445),
        (
            $0$46740 ->
                $1$46742 ->
                    Option.flatMap($0$46740, $1$46742)
        )($0$46744 -> Int32.tryToInt8($0$46744))
    )
}

def BigInt.abs(x$247: BigInt): BigInt = {
    if (<[unknown exp]>(x$247, 0ii)) {x$247} else {<[unknown exp]>(x$247)}
}

def BigInt.bitwiseAnd(x$419: BigInt, y$421: BigInt): BigInt = {
    let and$423: (BigInt -> BigInt -> BigInt) = obj$$425 ->
        a0$$427 ->
            <[unknown exp]>;
    and$423(x$419)(y$421)
}

def BigInt.bitwiseNot(x$429: BigInt): BigInt = {
    let bNot$431: (BigInt -> BigInt) = obj$$433 ->
        <[unknown exp]>;
    bNot$431(x$429)
}

def BigInt.bitwiseOr(x$435: BigInt, y$437: BigInt): BigInt = {
    let or$439: (BigInt -> BigInt -> BigInt) = obj$$441 ->
        a0$$443 ->
            <[unknown exp]>;
    or$439(x$435)(y$437)
}

def BigInt.bitwiseXor(x$445: BigInt, y$447: BigInt): BigInt = {
    let xor$449: (BigInt -> BigInt -> BigInt) = obj$$451 ->
        a0$$453 ->
            <[unknown exp]>;
    xor$449(x$445)(y$447)
}

def BigInt.clamp(
    x$1415: BigInt,
    minimum$1417: BigInt,
    maximum$1419: BigInt
): BigInt = {
    if (<[unknown exp]>(x$1415, minimum$1417)) {
        minimum$1417
    } else {
        if (<[unknown exp]>(x$1415, maximum$1419)) {maximum$1419} else {x$1415}
    }
}

def BigInt.clampToFloat32(
    x$1614: BigInt,
    minimum$1617: Float32,
    maximum$1625: Float32
): Float32 = {
    let newBigDecimal$1631: (BigInt -> BigDecimal) = a0$1635 ->
        <[unknown exp]>;
    let floatValue$1641: (BigDecimal -> Float32) = obj$$1643 ->
        <[unknown exp]>;
    let step$1645: (Unit -> Option[Float32]) = _unit$1647 ->
        <[unknown exp]>(
            pat$7$1654 ->
                match pat$7$1654 {
                    case f32min$1663 =>
                        <[unknown exp]>(
                            pat$6$1667 ->
                                match pat$6$1667 {
                                    case f32max$1671 =>
                                        <[unknown exp]>(
                                            {
                                                let x1$1675: BigInt = BigInt.clamp(
                                                    x$1614,
                                                    f32min$1663,
                                                    f32max$1671
                                                );
                                                let xd$1679: BigDecimal = newBigDecimal$1631(
                                                    x1$1675
                                                );
                                                floatValue$1641(xd$1679)
                                            }
                                        )
                                },
                            Float32.tryToBigInt(maximum$1625)
                        )
                },
            Float32.tryToBigInt(minimum$1617)
        );
    match step$1645(()) {
        case Option.None =>
            Float32.nan(())
        case Option.Some(d$1687) =>
            d$1687
    }
}

def BigInt.clampToFloat64(
    x$1689: BigInt,
    minimum$1691: Float64,
    maximum$1693: Float64
): Float64 = {
    let newBigDecimal$1695: (BigInt -> BigDecimal) = a0$1697 ->
        <[unknown exp]>;
    let doubleValue$1699: (BigDecimal -> Float64) = obj$$1701 ->
        <[unknown exp]>;
    let step$1703: (Unit -> Option[Float64]) = _unit$1705 ->
        <[unknown exp]>(
            pat$9$1707 ->
                match pat$9$1707 {
                    case f64min$1709 =>
                        <[unknown exp]>(
                            pat$8$1711 ->
                                match pat$8$1711 {
                                    case f64max$1713 =>
                                        <[unknown exp]>(
                                            {
                                                let x1$1715: BigInt = BigInt.clamp(
                                                    x$1689,
                                                    f64min$1709,
                                                    f64max$1713
                                                );
                                                let xd$1717: BigDecimal = newBigDecimal$1695(
                                                    x1$1715
                                                );
                                                doubleValue$1699(xd$1717)
                                            }
                                        )
                                },
                            Float64.tryToBigInt(maximum$1693)
                        )
                },
            Float64.tryToBigInt(minimum$1691)
        );
    match step$1703(()) {
        case Option.None =>
            Float64.nan(())
        case Option.Some(d$1719) =>
            d$1719
    }
}

def BigInt.clampToInt16(
    x$1469: BigInt,
    minimum$1471: Int16,
    maximum$1475: Int16
): Int16 = {
    let shortValueExact$1485: (BigInt -> Int16) = obj$$1489 ->
        <[unknown exp]>;
    let minii$1497: BigInt = Int16.toBigInt(minimum$1471);
    let maxii$1499: BigInt = Int16.toBigInt(maximum$1475);
    try {
        shortValueExact$1485(BigInt.clamp(x$1469, minii$1497, maxii$1499))
    } catch {case _$1509: ##java.lang.ArithmeticException => minimum$1471}
}

def BigInt.clampToInt32(
    x$1523: BigInt,
    minimum$1526: Int32,
    maximum$1529: Int32
): Int32 = {
    let intValueExact$1531: (BigInt -> Int32) = obj$$1533 ->
        <[unknown exp]>;
    let minii$1535: BigInt = Int32.toBigInt(minimum$1526);
    let maxii$1537: BigInt = Int32.toBigInt(maximum$1529);
    try {
        intValueExact$1531(BigInt.clamp(x$1523, minii$1535, maxii$1537))
    } catch {case _$1545: ##java.lang.ArithmeticException => minimum$1526}
}

def BigInt.clampToInt64(
    x$1565: BigInt,
    minimum$1567: Int64,
    maximum$1569: Int64
): Int64 = {
    let longValueExact$1573: (BigInt -> Int64) = obj$$1579 ->
        <[unknown exp]>;
    let minii$1593: BigInt = Int64.toBigInt(minimum$1567);
    let maxii$1595: BigInt = Int64.toBigInt(maximum$1569);
    try {
        longValueExact$1573(BigInt.clamp(x$1565, minii$1593, maxii$1595))
    } catch {case _$1607: ##java.lang.ArithmeticException => minimum$1567}
}

def BigInt.clampToInt8(
    x$1429: BigInt,
    minimum$1431: Int8,
    maximum$1433: Int8
): Int8 = {
    let byteValueExact$1441: (BigInt -> Int8) = obj$$1443 ->
        <[unknown exp]>;
    let minii$1449: BigInt = Int8.toBigInt(minimum$1431);
    let maxii$1451: BigInt = Int8.toBigInt(maximum$1433);
    try {
        byteValueExact$1441(BigInt.clamp(x$1429, minii$1449, maxii$1451))
    } catch {case _$1455: ##java.lang.ArithmeticException => minimum$1431}
}

def BigInt.clearBit(x$385: BigInt, position$387: Int32): BigInt = {
    BigInt.bitwiseAnd(
        x$385,
        BigInt.bitwiseNot(BigInt.leftShift(1ii, position$387))
    )
}

def BigInt.compare(x$367: BigInt, y$369: BigInt): Int32 = {
    if (<[unknown exp]>(x$367, y$369)) {
        0i32
    } else {
        if (<[unknown exp]>(x$367, y$369)) {-1i32} else {1i32}
    }
}

def BigInt.dist(x$363: BigInt, y$365: BigInt): BigInt = {
    BigInt.abs(<[unknown exp]>(x$363, y$365))
}

def BigInt.flipBit(x$389: BigInt, position$391: Int32): BigInt = {
    BigInt.bitwiseXor(x$389, BigInt.leftShift(1ii, position$391))
}

def BigInt.fromString(s$457: String): Option[BigInt] = {
    try {
        let strip$459: (String -> String) = obj$$461 ->
            <[unknown exp]>;
        let parseBigInt$463: (String -> BigInt) = a0$465 ->
            <[unknown exp]>;
        Option.Some(|>(|>(s$457, strip$459), parseBigInt$463))
    } catch {case _$495: ##java.lang.NumberFormatException => Option.None}
}

def BigInt.gcd(x$377: BigInt, y$379: BigInt): BigInt = {
    if (<[unknown exp]>(y$379, 0ii)) {
        BigInt.abs(x$377)
    } else {
        BigInt.gcd(y$379, BigInt.remainder(x$377, y$379))
    }
}

def BigInt.getBit(x$373: BigInt, position$375: Int32): Int32 = {
    if (
        <[unknown exp]>(
            BigInt.remainder(BigInt.rightShift(x$373, position$375), 2ii),
            0ii
        )
    ) {
        0i32
    } else {
        1i32
    }
}

def BigInt.leftShift(x$399: BigInt, y$401: Int32): BigInt = {
    let shiftLeft$403: (BigInt -> Int32 -> BigInt) = obj$$405 ->
        a0$$407 ->
            <[unknown exp]>;
    shiftLeft$403(x$399)(y$401)
}

def BigInt.log2(x$393: BigInt): Int32 = {
    let bitLength$395: (BigInt -> Int32) = obj$$397 ->
        <[unknown exp]>;
    bitLength$395(x$393)
}

def BigInt.max(x$243: BigInt, y$245: BigInt): BigInt = {
    if (<[unknown exp]>(x$243, y$245)) {x$243} else {y$245}
}

def BigInt.min(x$160: BigInt, y$184: BigInt): BigInt = {
    if (<[unknown exp]>(x$160, y$184)) {x$160} else {y$184}
}

def BigInt.modulo(x$343: BigInt, n$345: BigInt): BigInt = {
    let remainder$347: (BigInt -> BigInt -> BigInt) = obj$$349 ->
        a0$$351 ->
            <[unknown exp]>;
    if (<[unknown exp]>(n$345, 0ii)) {
        0ii
    } else {
        remainder$347(
            <[unknown exp]>(remainder$347(x$343)(n$345), n$345)
        )(n$345)
    }
}

def BigInt.pow(x$249: BigInt, n$251: Int32): BigInt = {
    let pow$253: (BigInt -> Int32 -> BigInt) = obj$$255 ->
        a0$$257 ->
            <[unknown exp]>;
    pow$253(x$249)(n$251)
}

def BigInt.remainder(x$353: BigInt, n$355: BigInt): BigInt = {
    let remainder$357: (BigInt -> BigInt -> BigInt) = obj$$359 ->
        a0$$361 ->
            <[unknown exp]>;
    if (<[unknown exp]>(n$355, 0ii)) {0ii} else {remainder$357(x$353)(n$355)}
}

def BigInt.rightShift(x$409: BigInt, y$411: Int32): BigInt = {
    let shiftRight$413: (BigInt -> Int32 -> BigInt) = obj$$415 ->
        a0$$417 ->
            <[unknown exp]>;
    shiftRight$413(x$409)(y$411)
}

def BigInt.setBit(x$381: BigInt, position$383: Int32): BigInt = {
    BigInt.bitwiseOr(x$381, BigInt.leftShift(1ii, position$383))
}

def BigInt.signum(x$371: BigInt): Int32 = {BigInt.compare(x$371, 0ii)}

def BigInt.toBigDecimal(x$1397: BigInt): BigDecimal = {
    let fromBigInteger$1401: (BigInt -> BigDecimal) = a0$1403 ->
        <[unknown exp]>;
    fromBigInteger$1401(x$1397)
}

def BigInt.toString(x$455: BigInt): String = {<[unknown exp]>(x$455)}

def BigInt.tryToFloat32(x$1246: BigInt): Option[Float32] = {
    let newBigDecimal$1256: (BigInt -> BigDecimal) = a0$1261 ->
        <[unknown exp]>;
    let floatValue$1270: (BigDecimal -> Float32) = obj$$1274 ->
        <[unknown exp]>;
    let xd$1276: BigDecimal = newBigDecimal$1256(x$1246);
    let d$1278: Float32 = floatValue$1270(xd$1276);
    <[unknown exp]>(
        pat$3$1280 ->
            match pat$3$1280 {
                case f32min$1286 =>
                    <[unknown exp]>(
                        pat$2$1290 ->
                            match pat$2$1290 {
                                case f32max$1294 =>
                                    if (
                                        <[unknown exp]>(
                                            f32min$1286,
                                            x$1246
                                        ) and <[unknown exp]>(
                                            x$1246,
                                            f32max$1294
                                        )
                                    ) {
                                        <[unknown exp]>(d$1278)
                                    } else {
                                        <[unknown exp]>(())
                                    }
                            },
                        Float32.tryToBigInt(Float32.maxValue(()))
                    )
            },
        Float32.tryToBigInt(Float32.minValue(()))
    )
}

def BigInt.tryToFloat64(x$1319: BigInt): Option[Float64] = {
    let newBigDecimal$1329: (BigInt -> BigDecimal) = a0$1331 ->
        <[unknown exp]>;
    let doubleValue$1340: (BigDecimal -> Float64) = obj$$1344 ->
        <[unknown exp]>;
    let xd$1357: BigDecimal = newBigDecimal$1329(x$1319);
    let d$1360: Float64 = doubleValue$1340(xd$1357);
    <[unknown exp]>(
        pat$5$1366 ->
            match pat$5$1366 {
                case f64min$1370 =>
                    <[unknown exp]>(
                        pat$4$1372 ->
                            match pat$4$1372 {
                                case f64max$1374 =>
                                    if (
                                        <[unknown exp]>(
                                            f64min$1370,
                                            x$1319
                                        ) and <[unknown exp]>(
                                            x$1319,
                                            f64max$1374
                                        )
                                    ) {
                                        <[unknown exp]>(d$1360)
                                    } else {
                                        <[unknown exp]>(())
                                    }
                            },
                        Float64.tryToBigInt(Float64.maxValue(()))
                    )
            },
        Float64.tryToBigInt(Float64.minValue(()))
    )
}

def BigInt.tryToInt16(x$1118: BigInt): Option[Int16] = {
    let shortValueExact$1132: (BigInt -> Int16) = obj$$1134 ->
        <[unknown exp]>;
    try {
        Option.Some(shortValueExact$1132(x$1118))
    } catch {case _$1148: ##java.lang.ArithmeticException => Option.None}
}

def BigInt.tryToInt32(x$1174: BigInt): Option[Int32] = {
    let intValueExact$1183: (BigInt -> Int32) = obj$$1189 ->
        <[unknown exp]>;
    try {
        Option.Some(intValueExact$1183(x$1174))
    } catch {case _$1207: ##java.lang.ArithmeticException => Option.None}
}

def BigInt.tryToInt64(x$1211: BigInt): Option[Int64] = {
    let longValueExact$1213: (BigInt -> Int64) = obj$$1217 ->
        <[unknown exp]>;
    try {
        Option.Some(longValueExact$1213(x$1211))
    } catch {case _$1234: ##java.lang.ArithmeticException => Option.None}
}

def BigInt.tryToInt8(x$1048: BigInt): Option[Int8] = {
    let byteValueExact$1050: (BigInt -> Int8) = obj$$1055 ->
        <[unknown exp]>;
    try {
        Option.Some(byteValueExact$1050(x$1048))
    } catch {case _$1088: ##java.lang.ArithmeticException => Option.None}
}

def Bool.<==>(x$21056: Bool, y$21058: Bool): Bool = {
    <[unknown exp]>(x$21056, y$21058)
}

def Bool.==>(x$21028: Bool, y$21032: Bool): Bool = {(!x$21028) or y$21032}

def Bool.→(x$20976: Bool, y$20981: Bool): Bool = {Bool.∨(!x$20976, y$20981)}

def Bool.↔(x$20991: Bool, y$20998: Bool): Bool = {
    Bool.∧(Bool.→(x$20991, y$20998), Bool.→(y$20998, x$20991))
}

def Bool.∧(x$20927: Bool, y$20929: Bool): Bool = {x$20927 and y$20929}

def Bool.∨(x$20955: Bool, y$20958: Bool): Bool = {x$20955 or y$20958}

def Bool.⊕(x$21008: Bool, y$21010: Bool): Bool = {
    Bool.∧(Bool.∨(x$21008, y$21010), !Bool.∧(x$21008, y$21010))
}

def Boxable.box(x$3940: a): Boxed = {<[unknown exp]>}

def Boxable.lift1(f$7485: t1 -> t): Boxed -> Boxed = {
    b1$7491 ->
        Boxable.box(f$7485(Boxable.unbox(b1$7491)))
}

def Boxable.lift1X1(
    f$7958: i1 -> Vector[o1]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$7960 ->
        {
            let g$7962: (o1 -> Vector[Boxed]) = pat$34$7964 ->
                match pat$34$7964 {case o1$7966 => [|Boxable.box(o1$7966)|]};
            Vector.map(g$7962, f$7958(Boxable.unbox(Vector.get(0i32, v$7960))))
        }
}

def Boxable.lift1X2(
    f$9784: i1 -> Vector[(o1, o2)]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$9814 ->
        {
            let g$9816: ((o1, o2) -> Vector[Boxed]) = pat$35$9818 ->
                match pat$35$9818 {
                    case (o1$9822, o2$9825) =>
                        [|Boxable.box(o1$9822), Boxable.box(o2$9825)|]
                };
            Vector.map(g$9816, f$9784(Boxable.unbox(Vector.get(0i32, v$9814))))
        }
}

def Boxable.lift1X3(
    f$9882: i1 -> Vector[(o1, o2, o3)]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$9898 ->
        {
            let g$9904: ((o1, o2, o3) -> Vector[Boxed]) = pat$36$9906 ->
                match pat$36$9906 {
                    case (o1$9908, o2$9910, o3$9913) =>
                        [|
                            Boxable.box(o1$9908),
                            Boxable.box(o2$9910),
                            Boxable.box(o3$9913)
                        |]
                };
            Vector.map(g$9904, f$9882(Boxable.unbox(Vector.get(0i32, v$9898))))
        }
}

def Boxable.lift1X4(
    f$9967: i1 -> Vector[(o1, o2, o3, o4)]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$9995 ->
        {
            let g$9997: ((o1, o2, o3, o4) -> Vector[Boxed]) = pat$37$9999 ->
                match pat$37$9999 {
                    case (o1$10003, o2$10006, o3$10009, o4$10012) =>
                        [|
                            Boxable.box(o1$10003),
                            Boxable.box(o2$10006),
                            Boxable.box(o3$10009),
                            Boxable.box(o4$10012)
                        |]
                };
            Vector.map(g$9997, f$9967(Boxable.unbox(Vector.get(0i32, v$9995))))
        }
}

def Boxable.lift1X5(
    f$10064: i1 -> Vector[(o1, o2, o3, o4, o5)]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10087 ->
        {
            let g$10092: (
                (o1, o2, o3, o4, o5) -> Vector[Boxed]
            ) = pat$38$10095 ->
                match pat$38$10095 {
                    case (o1$10104, o2$10110, o3$10112, o4$10114, o5$10116) =>
                        [|
                            Boxable.box(o1$10104),
                            Boxable.box(o2$10110),
                            Boxable.box(o3$10112),
                            Boxable.box(o4$10114),
                            Boxable.box(o5$10116)
                        |]
                };
            Vector.map(
                g$10092,
                f$10064(Boxable.unbox(Vector.get(0i32, v$10087)))
            )
        }
}

def Boxable.lift1b(f$7702: t1 -> Bool): Boxed -> Bool = {
    b1$7713 ->
        f$7702(Boxable.unbox(b1$7713))
}

def Boxable.lift2(f$7513: t1 -> t2 -> t): Boxed -> Boxed -> Boxed = {
    b1$7524 ->
        b2$7526 ->
            Boxable.box(f$7513(Boxable.unbox(b1$7524))(Boxable.unbox(b2$7526)))
}

def Boxable.lift2X1(
    f$10185: i1 -> i2 -> Vector[o1]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10208 ->
        {
            let g$10210: (o1 -> Vector[Boxed]) = pat$39$10212 ->
                match pat$39$10212 {case o1$10216 => [|Boxable.box(o1$10216)|]};
            Vector.map(
                g$10210,
                f$10185(
                    Boxable.unbox(Vector.get(0i32, v$10208))
                )(Boxable.unbox(Vector.get(1i32, v$10208)))
            )
        }
}

def Boxable.lift2X2(
    f$10248: i1 -> i2 -> Vector[(o1, o2)]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10275 ->
        {
            let g$10279: ((o1, o2) -> Vector[Boxed]) = pat$40$10281 ->
                match pat$40$10281 {
                    case (o1$10283, o2$10285) =>
                        [|Boxable.box(o1$10283), Boxable.box(o2$10285)|]
                };
            Vector.map(
                g$10279,
                f$10248(
                    Boxable.unbox(Vector.get(0i32, v$10275))
                )(Boxable.unbox(Vector.get(1i32, v$10275)))
            )
        }
}

def Boxable.lift2X3(
    f$10313: i1 -> i2 -> Vector[(o1, o2, o3)]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10334 ->
        {
            let g$10340: ((o1, o2, o3) -> Vector[Boxed]) = pat$41$10342 ->
                match pat$41$10342 {
                    case (o1$10345, o2$10347, o3$10349) =>
                        [|
                            Boxable.box(o1$10345),
                            Boxable.box(o2$10347),
                            Boxable.box(o3$10349)
                        |]
                };
            Vector.map(
                g$10340,
                f$10313(
                    Boxable.unbox(Vector.get(0i32, v$10334))
                )(Boxable.unbox(Vector.get(1i32, v$10334)))
            )
        }
}

def Boxable.lift2X4(
    f$10391: i1 -> i2 -> Vector[(o1, o2, o3, o4)]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10408 ->
        {
            let g$10412: ((o1, o2, o3, o4) -> Vector[Boxed]) = pat$42$10415 ->
                match pat$42$10415 {
                    case (o1$10418, o2$10420, o3$10422, o4$10424) =>
                        [|
                            Boxable.box(o1$10418),
                            Boxable.box(o2$10420),
                            Boxable.box(o3$10422),
                            Boxable.box(o4$10424)
                        |]
                };
            Vector.map(
                g$10412,
                f$10391(
                    Boxable.unbox(Vector.get(0i32, v$10408))
                )(Boxable.unbox(Vector.get(1i32, v$10408)))
            )
        }
}

def Boxable.lift2X5(
    f$10465: i1 -> i2 -> Vector[(o1, o2, o3, o4, o5)]
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10491 ->
        {
            let g$10499: (
                (o1, o2, o3, o4, o5) -> Vector[Boxed]
            ) = pat$43$10501 ->
                match pat$43$10501 {
                    case (o1$10505, o2$10511, o3$10513, o4$10515, o5$10517) =>
                        [|
                            Boxable.box(o1$10505),
                            Boxable.box(o2$10511),
                            Boxable.box(o3$10513),
                            Boxable.box(o4$10515),
                            Boxable.box(o5$10517)
                        |]
                };
            Vector.map(
                g$10499,
                f$10465(
                    Boxable.unbox(Vector.get(0i32, v$10491))
                )(Boxable.unbox(Vector.get(1i32, v$10491)))
            )
        }
}

def Boxable.lift2b(f$7728: t1 -> t2 -> Bool): Boxed -> Boxed -> Bool = {
    b1$7736 ->
        b2$7740 ->
            f$7728(Boxable.unbox(b1$7736))(Boxable.unbox(b2$7740))
}

def Boxable.lift3(
    f$7552: t1 -> t2 -> (t3 -> t)
): Boxed -> Boxed -> (Boxed -> Boxed) = {
    b1$7559 ->
        b2$7563 ->
            b3$7570 ->
                Boxable.box(
                    f$7552(
                        Boxable.unbox(b1$7559)
                    )(Boxable.unbox(b2$7563))(Boxable.unbox(b3$7570))
                )
}

def Boxable.lift3X1(
    f$10584: i1 -> i2 -> (i3 -> Vector[o1])
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10618 ->
        {
            let g$10622: (o1 -> Vector[Boxed]) = pat$44$10624 ->
                match pat$44$10624 {case o1$10628 => [|Boxable.box(o1$10628)|]};
            Vector.map(
                g$10622,
                f$10584(
                    Boxable.unbox(Vector.get(0i32, v$10618))
                )(
                    Boxable.unbox(Vector.get(1i32, v$10618))
                )(Boxable.unbox(Vector.get(2i32, v$10618)))
            )
        }
}

def Boxable.lift3X2(
    f$10669: i1 -> i2 -> (i3 -> Vector[(o1, o2)])
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10699 ->
        {
            let g$10706: ((o1, o2) -> Vector[Boxed]) = pat$45$10709 ->
                match pat$45$10709 {
                    case (o1$10722, o2$10727) =>
                        [|Boxable.box(o1$10722), Boxable.box(o2$10727)|]
                };
            Vector.map(
                g$10706,
                f$10669(
                    Boxable.unbox(Vector.get(0i32, v$10699))
                )(
                    Boxable.unbox(Vector.get(1i32, v$10699))
                )(Boxable.unbox(Vector.get(2i32, v$10699)))
            )
        }
}

def Boxable.lift3X3(
    f$10768: i1 -> i2 -> (i3 -> Vector[(o1, o2, o3)])
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10776 ->
        {
            let g$10778: ((o1, o2, o3) -> Vector[Boxed]) = pat$46$10780 ->
                match pat$46$10780 {
                    case (o1$10785, o2$10789, o3$10791) =>
                        [|
                            Boxable.box(o1$10785),
                            Boxable.box(o2$10789),
                            Boxable.box(o3$10791)
                        |]
                };
            Vector.map(
                g$10778,
                f$10768(
                    Boxable.unbox(Vector.get(0i32, v$10776))
                )(
                    Boxable.unbox(Vector.get(1i32, v$10776))
                )(Boxable.unbox(Vector.get(2i32, v$10776)))
            )
        }
}

def Boxable.lift3X4(
    f$10892: i1 -> i2 -> (i3 -> Vector[(o1, o2, o3, o4)])
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$10906 ->
        {
            let g$10908: ((o1, o2, o3, o4) -> Vector[Boxed]) = pat$47$10911 ->
                match pat$47$10911 {
                    case (o1$10921, o2$10923, o3$10927, o4$10929) =>
                        [|
                            Boxable.box(o1$10921),
                            Boxable.box(o2$10923),
                            Boxable.box(o3$10927),
                            Boxable.box(o4$10929)
                        |]
                };
            Vector.map(
                g$10908,
                f$10892(
                    Boxable.unbox(Vector.get(0i32, v$10906))
                )(
                    Boxable.unbox(Vector.get(1i32, v$10906))
                )(Boxable.unbox(Vector.get(2i32, v$10906)))
            )
        }
}

def Boxable.lift3X5(
    f$10995: i1 -> i2 -> (i3 -> Vector[(o1, o2, o3, o4, o5)])
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$11041 ->
        {
            let g$11048: (
                (o1, o2, o3, o4, o5) -> Vector[Boxed]
            ) = pat$48$11052 ->
                match pat$48$11052 {
                    case (o1$11059, o2$11063, o3$11065, o4$11069, o5$11071) =>
                        [|
                            Boxable.box(o1$11059),
                            Boxable.box(o2$11063),
                            Boxable.box(o3$11065),
                            Boxable.box(o4$11069),
                            Boxable.box(o5$11071)
                        |]
                };
            Vector.map(
                g$11048,
                f$10995(
                    Boxable.unbox(Vector.get(0i32, v$11041))
                )(
                    Boxable.unbox(Vector.get(1i32, v$11041))
                )(Boxable.unbox(Vector.get(2i32, v$11041)))
            )
        }
}

def Boxable.lift3b(
    f$7762: t1 -> t2 -> (t3 -> Bool)
): Boxed -> Boxed -> (Boxed -> Bool) = {
    b1$7778 ->
        b2$7780 ->
            b3$7786 ->
                f$7762(
                    Boxable.unbox(b1$7778)
                )(Boxable.unbox(b2$7780))(Boxable.unbox(b3$7786))
}

def Boxable.lift4(
    f$7599: t1 -> t2 -> (t3 -> (t4 -> t))
): Boxed -> Boxed -> (Boxed -> (Boxed -> Boxed)) = {
    b1$7617 ->
        b2$7619 ->
            b3$7623 ->
                b4$7626 ->
                    Boxable.box(
                        f$7599(
                            Boxable.unbox(b1$7617)
                        )(
                            Boxable.unbox(b2$7619)
                        )(Boxable.unbox(b3$7623))(Boxable.unbox(b4$7626))
                    )
}

def Boxable.lift4X1(
    f$11133: i1 -> i2 -> (i3 -> (i4 -> Vector[o1]))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$11146 ->
        {
            let g$11148: (o1 -> Vector[Boxed]) = pat$49$11150 ->
                match pat$49$11150 {case o1$11153 => [|Boxable.box(o1$11153)|]};
            Vector.map(
                g$11148,
                f$11133(
                    Boxable.unbox(Vector.get(0i32, v$11146))
                )(
                    Boxable.unbox(Vector.get(1i32, v$11146))
                )(
                    Boxable.unbox(Vector.get(2i32, v$11146))
                )(Boxable.unbox(Vector.get(3i32, v$11146)))
            )
        }
}

def Boxable.lift4X2(
    f$11215: i1 -> i2 -> (i3 -> (i4 -> Vector[(o1, o2)]))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$11280 ->
        {
            let g$11287: ((o1, o2) -> Vector[Boxed]) = pat$50$11293 ->
                match pat$50$11293 {
                    case (o1$11303, o2$11307) =>
                        [|Boxable.box(o1$11303), Boxable.box(o2$11307)|]
                };
            Vector.map(
                g$11287,
                f$11215(
                    Boxable.unbox(Vector.get(0i32, v$11280))
                )(
                    Boxable.unbox(Vector.get(1i32, v$11280))
                )(
                    Boxable.unbox(Vector.get(2i32, v$11280))
                )(Boxable.unbox(Vector.get(3i32, v$11280)))
            )
        }
}

def Boxable.lift4X3(
    f$11370: i1 -> i2 -> (i3 -> (i4 -> Vector[(o1, o2, o3)]))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$11388 ->
        {
            let g$11395: ((o1, o2, o3) -> Vector[Boxed]) = pat$51$11397 ->
                match pat$51$11397 {
                    case (o1$11399, o2$11403, o3$11405) =>
                        [|
                            Boxable.box(o1$11399),
                            Boxable.box(o2$11403),
                            Boxable.box(o3$11405)
                        |]
                };
            Vector.map(
                g$11395,
                f$11370(
                    Boxable.unbox(Vector.get(0i32, v$11388))
                )(
                    Boxable.unbox(Vector.get(1i32, v$11388))
                )(
                    Boxable.unbox(Vector.get(2i32, v$11388))
                )(Boxable.unbox(Vector.get(3i32, v$11388)))
            )
        }
}

def Boxable.lift4X4(
    f$11476: i1 -> i2 -> (i3 -> (i4 -> Vector[(o1, o2, o3, o4)]))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$11506 ->
        {
            let g$11515: ((o1, o2, o3, o4) -> Vector[Boxed]) = pat$52$11517 ->
                match pat$52$11517 {
                    case (o1$11521, o2$11523, o3$11525, o4$11527) =>
                        [|
                            Boxable.box(o1$11521),
                            Boxable.box(o2$11523),
                            Boxable.box(o3$11525),
                            Boxable.box(o4$11527)
                        |]
                };
            Vector.map(
                g$11515,
                f$11476(
                    Boxable.unbox(Vector.get(0i32, v$11506))
                )(
                    Boxable.unbox(Vector.get(1i32, v$11506))
                )(
                    Boxable.unbox(Vector.get(2i32, v$11506))
                )(Boxable.unbox(Vector.get(3i32, v$11506)))
            )
        }
}

def Boxable.lift4X5(
    f$11608: i1 -> i2 -> (i3 -> (i4 -> Vector[(o1, o2, o3, o4, o5)]))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$11661 ->
        {
            let g$11667: (
                (o1, o2, o3, o4, o5) -> Vector[Boxed]
            ) = pat$54$11673 ->
                match pat$54$11673 {
                    case (o1$11675, o2$11678, o3$11681, o4$11684, o5$11687) =>
                        [|
                            Boxable.box(o1$11675),
                            Boxable.box(o2$11678),
                            Boxable.box(o3$11681),
                            Boxable.box(o4$11684),
                            Boxable.box(o5$11687)
                        |]
                };
            Vector.map(
                g$11667,
                f$11608(
                    Boxable.unbox(Vector.get(0i32, v$11661))
                )(
                    Boxable.unbox(Vector.get(1i32, v$11661))
                )(
                    Boxable.unbox(Vector.get(2i32, v$11661))
                )(Boxable.unbox(Vector.get(3i32, v$11661)))
            )
        }
}

def Boxable.lift4b(
    f$7810: t1 -> t2 -> (t3 -> (t4 -> Bool))
): Boxed -> Boxed -> (Boxed -> (Boxed -> Bool)) = {
    b1$7831 ->
        b2$7839 ->
            b3$7846 ->
                b4$7849 ->
                    f$7810(
                        Boxable.unbox(b1$7831)
                    )(
                        Boxable.unbox(b2$7839)
                    )(Boxable.unbox(b3$7846))(Boxable.unbox(b4$7849))
}

def Boxable.lift5(
    f$7659: t1 -> t2 -> (t3 -> (t4 -> (t5 -> t)))
): Boxed -> Boxed -> (Boxed -> (Boxed -> (Boxed -> Boxed))) = {
    b1$7674 ->
        b2$7676 ->
            b3$7678 ->
                b4$7684 ->
                    b5$7686 ->
                        Boxable.box(
                            f$7659(
                                Boxable.unbox(b1$7674)
                            )(
                                Boxable.unbox(b2$7676)
                            )(
                                Boxable.unbox(b3$7678)
                            )(Boxable.unbox(b4$7684))(Boxable.unbox(b5$7686))
                        )
}

def Boxable.lift5X1(
    f$11772: i1 -> i2 -> (i3 -> (i4 -> (i5 -> Vector[o1])))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$11796 ->
        {
            let g$11798: (o1 -> Vector[Boxed]) = pat$55$11802 ->
                match pat$55$11802 {case o1$11816 => [|Boxable.box(o1$11816)|]};
            Vector.map(
                g$11798,
                f$11772(
                    Boxable.unbox(Vector.get(0i32, v$11796))
                )(
                    Boxable.unbox(Vector.get(1i32, v$11796))
                )(
                    Boxable.unbox(Vector.get(2i32, v$11796))
                )(
                    Boxable.unbox(Vector.get(3i32, v$11796))
                )(Boxable.unbox(Vector.get(4i32, v$11796)))
            )
        }
}

def Boxable.lift5X2(
    f$11896: i1 -> i2 -> (i3 -> (i4 -> (i5 -> Vector[(o1, o2)])))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$11924 ->
        {
            let g$11928: ((o1, o2) -> Vector[Boxed]) = pat$56$11931 ->
                match pat$56$11931 {
                    case (o1$11937, o2$11939) =>
                        [|Boxable.box(o1$11937), Boxable.box(o2$11939)|]
                };
            Vector.map(
                g$11928,
                f$11896(
                    Boxable.unbox(Vector.get(0i32, v$11924))
                )(
                    Boxable.unbox(Vector.get(1i32, v$11924))
                )(
                    Boxable.unbox(Vector.get(2i32, v$11924))
                )(
                    Boxable.unbox(Vector.get(3i32, v$11924))
                )(Boxable.unbox(Vector.get(4i32, v$11924)))
            )
        }
}

def Boxable.lift5X3(
    f$11979: i1 -> i2 -> (i3 -> (i4 -> (i5 -> Vector[(o1, o2, o3)])))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$11988 ->
        {
            let g$11992: ((o1, o2, o3) -> Vector[Boxed]) = pat$57$11996 ->
                match pat$57$11996 {
                    case (o1$12008, o2$12012, o3$12014) =>
                        [|
                            Boxable.box(o1$12008),
                            Boxable.box(o2$12012),
                            Boxable.box(o3$12014)
                        |]
                };
            Vector.map(
                g$11992,
                f$11979(
                    Boxable.unbox(Vector.get(0i32, v$11988))
                )(
                    Boxable.unbox(Vector.get(1i32, v$11988))
                )(
                    Boxable.unbox(Vector.get(2i32, v$11988))
                )(
                    Boxable.unbox(Vector.get(3i32, v$11988))
                )(Boxable.unbox(Vector.get(4i32, v$11988)))
            )
        }
}

def Boxable.lift5X4(
    f$12090: i1 -> i2 -> (i3 -> (i4 -> (i5 -> Vector[(o1, o2, o3, o4)])))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$12110 ->
        {
            let g$12125: ((o1, o2, o3, o4) -> Vector[Boxed]) = pat$58$12127 ->
                match pat$58$12127 {
                    case (o1$12132, o2$12134, o3$12136, o4$12138) =>
                        [|
                            Boxable.box(o1$12132),
                            Boxable.box(o2$12134),
                            Boxable.box(o3$12136),
                            Boxable.box(o4$12138)
                        |]
                };
            Vector.map(
                g$12125,
                f$12090(
                    Boxable.unbox(Vector.get(0i32, v$12110))
                )(
                    Boxable.unbox(Vector.get(1i32, v$12110))
                )(
                    Boxable.unbox(Vector.get(2i32, v$12110))
                )(
                    Boxable.unbox(Vector.get(3i32, v$12110))
                )(Boxable.unbox(Vector.get(4i32, v$12110)))
            )
        }
}

def Boxable.lift5X5(
    f$12222: i1 -> i2 -> (i3 -> (i4 -> (i5 -> Vector[(o1, o2, o3, o4, o5)])))
): Vector[Boxed] -> Vector[Vector[Boxed]] = {
    v$12228 ->
        {
            let g$12233: (
                (o1, o2, o3, o4, o5) -> Vector[Boxed]
            ) = pat$59$12235 ->
                match pat$59$12235 {
                    case (o1$12239, o2$12241, o3$12243, o4$12246, o5$12248) =>
                        [|
                            Boxable.box(o1$12239),
                            Boxable.box(o2$12241),
                            Boxable.box(o3$12243),
                            Boxable.box(o4$12246),
                            Boxable.box(o5$12248)
                        |]
                };
            Vector.map(
                g$12233,
                f$12222(
                    Boxable.unbox(Vector.get(0i32, v$12228))
                )(
                    Boxable.unbox(Vector.get(1i32, v$12228))
                )(
                    Boxable.unbox(Vector.get(2i32, v$12228))
                )(
                    Boxable.unbox(Vector.get(3i32, v$12228))
                )(Boxable.unbox(Vector.get(4i32, v$12228)))
            )
        }
}

def Boxable.lift5b(
    f$7872: t1 -> t2 -> (t3 -> (t4 -> (t5 -> Bool)))
): Boxed -> Boxed -> (Boxed -> (Boxed -> (Boxed -> Bool))) = {
    b1$7896 ->
        b2$7904 ->
            b3$7912 ->
                b4$7916 ->
                    b5$7919 ->
                        f$7872(
                            Boxable.unbox(b1$7896)
                        )(
                            Boxable.unbox(b2$7904)
                        )(
                            Boxable.unbox(b3$7912)
                        )(Boxable.unbox(b4$7916))(Boxable.unbox(b5$7919))
}

def Boxable.unbox(x$7371: Boxed): a = {<[unknown exp]>}

enum Boxed {
    case BoxedInt32(Int32)
    case BoxedInt8(Int8)
    case BoxedInt16(Int16)
    case BoxedChar(Char)
    case BoxedFloat32(Float32)
    case BoxedBool(Bool)
    case BoxedObject(
        java.lang.Object,
        java.lang.Object -> (java.lang.Object -> Comparison)
    )
    case BoxedFloat64(Float64)
    case BoxedInt64(Int64)
}

enum Chain[t] {case Empty(Unit) case One(t) case Chain(Chain[t], Chain[t])}

def Chain.ap(f$13676: Chain[a -> b \ ef], x$13684: Chain[a]): Chain[b] \ ef = {
    letrec loop$13697: (
        ViewLeft[a -> b \ ef] -> Chain[b] -> Chain[b] \ (e115745 & ef) + ef
    ) = g$13699 ->
        acc$13703 ->
            match g$13699 {
                case Chain.ViewLeft.NoneLeft =>
                    acc$13703
                case Chain.ViewLeft.SomeLeft(h$13705, xs$13709) =>
                    loop$13697(
                        Chain.viewLeft(xs$13709)
                    )(Chain.append(acc$13703, Chain.map(h$13705, x$13684)))
            };
    loop$13697(Chain.viewLeft(f$13676))(Chain.empty(()))
}

def Chain.append(c1$14013: Chain[a], c2$14015: Chain[a]): Chain[a] = {
    match (c1$14013, c2$14015) {
        case (Chain.Empty, c$14029) =>
            c$14029
        case (c$14031, Chain.Empty) =>
            c$14031
        case _ =>
            Chain.Chain(c1$14013, c2$14015)
    }
}

def Chain.compare(c1$16239: Chain[a], c2$16243: Chain[a]): Comparison = {
    letrec loop$16251: (ViewLeft[a] -> ViewLeft[a] -> Comparison) = v1$16254 ->
        v2$16258 ->
            match (v1$16254, v2$16258) {
                case (Chain.ViewLeft.SomeLeft(_, _), Chain.ViewLeft.NoneLeft) =>
                    Comparison.GreaterThan
                case (Chain.ViewLeft.NoneLeft, Chain.ViewLeft.NoneLeft) =>
                    Comparison.EqualTo
                case (Chain.ViewLeft.NoneLeft, Chain.ViewLeft.SomeLeft(_, _)) =>
                    Comparison.LessThan
                case (
                    Chain.ViewLeft.SomeLeft(l$16274, ls$16276),
                    Chain.ViewLeft.SomeLeft(r$16278, rs$16280)
                ) =>
                    match <[unknown exp]>(l$16274, r$16278) {
                        case Comparison.EqualTo =>
                            loop$16251(
                                Chain.viewLeft(ls$16276)
                            )(Chain.viewLeft(rs$16280))
                        case cmp$16283 =>
                            cmp$16283
                    }
            };
    loop$16251(Chain.viewLeft(c1$16239))(Chain.viewLeft(c2$16243))
}

def Chain.cons(x$13784: a, c$13793: Chain[a]): Chain[a] = {
    match c$13793 {
        case Chain.Empty =>
            Chain.One(x$13784)
        case _ =>
            Chain.Chain(Chain.One(x$13784), c$13793)
    }
}

def Chain.count(f$14655: a -> Bool, c$14657: Chain[a]): Int32 \ ef = {
    letrec loop$14659: (Chain[a] -> Int32 -> Int32 \ ef) = cc$14661 ->
        acc$14663 ->
            match Chain.viewLeft(cc$14661) {
                case Chain.ViewLeft.NoneLeft =>
                    acc$14663
                case Chain.ViewLeft.SomeLeft(a$14665, rs$14667) =>
                    if (f$14655(a$14665)) {
                        loop$14659(rs$14667)(<[unknown exp]>(acc$14663, 1i32))
                    } else {
                        loop$14659(rs$14667)(acc$14663)
                    }
            };
    loop$14659(c$14657)(0i32)
}

def Chain.dropLeft(n$15025: Int32, c$15030: Chain[a]): Chain[a] = {
    if (<[unknown exp]>(n$15025, 0i32)) {
        c$15030
    } else {
        match Chain.viewLeft(c$15030) {
            case Chain.ViewLeft.NoneLeft =>
                Chain.Empty
            case Chain.ViewLeft.SomeLeft(_, xs$15039) =>
                Chain.dropLeft(<[unknown exp]>(n$15025, 1i32), xs$15039)
        }
    }
}

def Chain.dropRight(n$15068: Int32, c$15072: Chain[a]): Chain[a] = {
    if (<[unknown exp]>(n$15068, 0i32)) {
        c$15072
    } else {
        match Chain.viewRight(c$15072) {
            case Chain.ViewRight.NoneRight =>
                Chain.Empty
            case Chain.ViewRight.SomeRight(xs$15076, _) =>
                Chain.dropRight(<[unknown exp]>(n$15068, 1i32), xs$15076)
        }
    }
}

def Chain.dropWhileLeft(
    f$15098: a -> Bool,
    c$15101: Chain[a]
): Chain[a] \ ef = {
    match Chain.viewLeft(c$15101) {
        case Chain.ViewLeft.SomeLeft(x$15115, xs$15117) =>
            if (f$15098(x$15115)) {
                Chain.dropWhileLeft(f$15098, xs$15117)
            } else {
                c$15101
            }
        case Chain.ViewLeft.NoneLeft =>
            c$15101
    }
}

def Chain.dropWhileRight(
    f$15153: a -> Bool,
    c$15157: Chain[a]
): Chain[a] \ ef = {
    match Chain.viewRight(c$15157) {
        case Chain.ViewRight.SomeRight(xs$15165, x$15167) =>
            if (f$15153(x$15167)) {
                Chain.dropWhileRight(f$15153, xs$15165)
            } else {
                c$15157
            }
        case Chain.ViewRight.NoneRight =>
            c$15157
    }
}

def Chain.empty(_unit$13625: Unit): Chain[a] = {Chain.Empty}

def Chain.enumerator(
    rc$16122: Region[r],
    c$16130: Chain[a]
): Iterator[(Int32, a), r, r] \ r = {
    |>(
        Chain.iterator(rc$16122, c$16130),
        $0$45993 ->
            Iterator.zipWithIndex($0$45993)
    )
}

def Chain.equals(c1$16204: Chain[a], c2$16206: Chain[a]): Bool = {
    match (Chain.viewLeft(c1$16204), Chain.viewLeft(c2$16206)) {
        case (Chain.ViewLeft.NoneLeft, Chain.ViewLeft.NoneLeft) =>
            true
        case (
            Chain.ViewLeft.SomeLeft(x$16218, xs$16223),
            Chain.ViewLeft.SomeLeft(y$16226, ys$16229)
        ) if <[unknown exp]>(x$16218, y$16226) =>
            Chain.equals(xs$16223, ys$16229)
        case _ =>
            false
    }
}

def Chain.exists(f$14749: a -> Bool, c$14751: Chain[a]): Bool \ ef = {
    match Chain.viewLeft(c$14751) {
        case Chain.ViewLeft.NoneLeft =>
            false
        case Chain.ViewLeft.SomeLeft(x$14755, xs$14757) =>
            f$14749(x$14755) or Chain.exists(f$14749, xs$14757)
    }
}

def Chain.filter(f$14806: a -> Bool, c$14808: Chain[a]): Chain[a] \ ef = {
    letrec loop$14818: (Chain[a] -> Chain[a] -> Chain[a] \ ef) = cc$14820 ->
        acc$14822 ->
            match Chain.viewLeft(cc$14820) {
                case Chain.ViewLeft.NoneLeft =>
                    acc$14822
                case Chain.ViewLeft.SomeLeft(a$14827, rs$14829) =>
                    if (f$14806(a$14827)) {
                        loop$14818(rs$14829)(Chain.snoc(acc$14822, a$14827))
                    } else {
                        loop$14818(rs$14829)(acc$14822)
                    }
            };
    loop$14818(c$14808)(Chain.Empty)
}

def Chain.filterMap(
    f$15313: a -> Option[b],
    c$15316: Chain[a]
): Chain[b] \ ef = {
    let step$15322: (Chain[b] -> a -> Chain[b] \ ef) = acc$15324 ->
        x$15326 ->
            match f$15313(x$15326) {
                case Option.None =>
                    acc$15324
                case Option.Some(v$15330) =>
                    Chain.snoc(acc$15324, v$15330)
            };
    Chain.foldLeft(step$15322, Chain.empty(()), c$15316)
}

def Chain.find(f$14179: a -> Bool, c$14187: Chain[a]): Option[a] = {
    Chain.findLeft(f$14179, c$14187)
}

def Chain.findLeft(f$14194: a -> Bool, c$14196: Chain[a]): Option[a] = {
    match Chain.viewLeft(c$14196) {
        case Chain.ViewLeft.NoneLeft =>
            Option.None
        case Chain.ViewLeft.SomeLeft(x$14209, rs$14211) =>
            if (f$14194(x$14209)) {
                Option.Some(x$14209)
            } else {
                Chain.findLeft(f$14194, rs$14211)
            }
    }
}

def Chain.findMap(
    f$15345: a -> Option[b],
    c$15347: Chain[a]
): Option[b] \ ef = {
    match Chain.viewLeft(c$15347) {
        case Chain.ViewLeft.NoneLeft =>
            Option.None
        case Chain.ViewLeft.SomeLeft(x$15364, xs$15367) =>
            match f$15345(x$15364) {
                case Option.None =>
                    Chain.findMap(f$15345, xs$15367)
                case Option.Some(v$15371) =>
                    Option.Some(v$15371)
            }
    }
}

def Chain.findRight(f$14227: a -> Bool, c$14229: Chain[a]): Option[a] = {
    match Chain.viewRight(c$14229) {
        case Chain.ViewRight.NoneRight =>
            Option.None
        case Chain.ViewRight.SomeRight(rs$14231, x$14233) =>
            if (f$14227(x$14233)) {
                Option.Some(x$14233)
            } else {
                Chain.findRight(f$14227, rs$14231)
            }
    }
}

def Chain.flatMap(f$14557: a -> Chain[b], c$14559: Chain[a]): Chain[b] \ ef = {
    letrec loop$14561: (Chain[a] -> Chain[b] -> Chain[b] \ ef) = cc$14563 ->
        acc$14567 ->
            match Chain.viewLeft(cc$14563) {
                case Chain.ViewLeft.NoneLeft =>
                    acc$14567
                case Chain.ViewLeft.SomeLeft(a$14571, rs$14573) =>
                    loop$14561(
                        rs$14573
                    )(Chain.append(acc$14567, f$14557(a$14571)))
            };
    loop$14561(c$14559)(Chain.Empty)
}

def Chain.flatten(c$14735: Chain[Chain[a]]): Chain[a] = {
    Chain.foldLeft(
        $0$45868 ->
            $1$45870 ->
                Chain.append($0$45868, $1$45870),
        Chain.empty(()),
        c$14735
    )
}

def Chain.foldLeft(
    f$14852: b -> a -> b \ ef,
    s$14857: b,
    c$14859: Chain[a]
): b \ ef = {
    match Chain.viewLeft(c$14859) {
        case Chain.ViewLeft.NoneLeft =>
            s$14857
        case Chain.ViewLeft.SomeLeft(x$14867, xs$14871) =>
            Chain.foldLeft(f$14852, f$14852(s$14857)(x$14867), xs$14871)
    }
}

def Chain.foldMap(f$14988: a -> b, c$14990: Chain[a]): b \ ef = {
    Chain.foldLeft(
        acc$15003 ->
            x$15007 ->
                <[unknown exp]>(acc$15003, f$14988(x$15007)),
        <[unknown exp]>(()),
        c$14990
    )
}

def Chain.foldRight(
    f$14892: a -> b -> b \ ef,
    s$14896: b,
    c$14900: Chain[a]
): b \ ef = {
    match Chain.viewRight(c$14900) {
        case Chain.ViewRight.NoneRight =>
            s$14896
        case Chain.ViewRight.SomeRight(xs$14912, x$14914) =>
            Chain.foldRight(f$14892, f$14892(x$14914)(s$14896), xs$14912)
    }
}

def Chain.foldRightWithCont(
    f$14935: a -> (Unit -> b \ ef) -> b \ ef,
    z$14941: b,
    c$14943: Chain[a]
): b \ ef = {
    match Chain.viewLeft(c$14943) {
        case Chain.ViewLeft.NoneLeft =>
            z$14941
        case Chain.ViewLeft.SomeLeft(x$14953, xs$14955) =>
            f$14935(
                x$14953
            )(_$14957 -> Chain.foldRightWithCont(f$14935, z$14941, xs$14955))
    }
}

def Chain.forAll(f$14777: a -> Bool, c$14784: Chain[a]): Bool \ ef = {
    match Chain.viewLeft(c$14784) {
        case Chain.ViewLeft.NoneLeft =>
            true
        case Chain.ViewLeft.SomeLeft(x$14789, xs$14792) =>
            f$14777(x$14789) and Chain.forAll(f$14777, xs$14792)
    }
}

def Chain.forEach(f$15770: a -> Unit, c$15773: Chain[a]): Unit \ ef = {
    match Chain.viewLeft(c$15773) {
        case Chain.ViewLeft.NoneLeft =>
            ()
        case Chain.ViewLeft.SomeLeft(x$15779, xs$15781) =>
            f$15770(x$15779); Chain.forEach(f$15770, xs$15781)
    }
}

def Chain.forEachWithIndex(
    f$15793: Int32 -> a -> Unit \ ef,
    c$15800: Chain[a]
): Unit \ ef = {
    letrec loop$15804: (
        ViewLeft[a] -> Int32 -> Unit \ ef + ((e80018 + ef) & ef)
    ) = v$15806 ->
        i$15808 ->
            match v$15806 {
                case Chain.ViewLeft.NoneLeft =>
                    ()
                case Chain.ViewLeft.SomeLeft(x$15815, xs$15817) =>
                    f$15793(i$15808)(x$15815);
                    loop$15804(
                        Chain.viewLeft(xs$15817)
                    )(<[unknown exp]>(i$15808, 1i32))
            };
    loop$15804(Chain.viewLeft(c$15800))(0i32)
}

def Chain.head(c$13856: Chain[a]): Option[a] = {
    match Chain.viewLeft(c$13856) {
        case Chain.ViewLeft.SomeLeft(x$13864, _) =>
            Option.Some(x$13864)
        case _ =>
            Option.None
    }
}

def Chain.indexOf(a$14129: a, c$14131: Chain[a]): Option[Int32] = {
    letrec loop$14139: (ViewLeft[a] -> Int32 -> Option[Int32]) = v$14141 ->
        acc$14145 ->
            match v$14141 {
                case Chain.ViewLeft.NoneLeft =>
                    Option.None
                case Chain.ViewLeft.SomeLeft(x$14151, xs$14155) =>
                    if (<[unknown exp]>(x$14151, a$14129)) {
                        Option.Some(acc$14145)
                    } else {
                        loop$14139(
                            Chain.viewLeft(xs$14155)
                        )(<[unknown exp]>(acc$14145, 1i32))
                    }
            };
    loop$14139(Chain.viewLeft(c$14131))(0i32)
}

def Chain.init(c$13963: Chain[a]): Option[Chain[a]] = {
    match Chain.viewRight(c$13963) {
        case Chain.ViewRight.SomeRight(rs$13973, _) =>
            Option.Some(rs$13973)
        case _ =>
            Option.None
    }
}

def Chain.intersperse(a$14609: a, c$14613: Chain[a]): Chain[a] = {
    letrec loop$14621: (Chain[a] -> Chain[a] -> Chain[a]) = cc$14623 ->
        acc$14625 ->
            match Chain.viewLeft(cc$14623) {
                case Chain.ViewLeft.NoneLeft =>
                    acc$14625
                case Chain.ViewLeft.SomeLeft(x$14631, rs$14633) =>
                    loop$14621(
                        rs$14633
                    )(Chain.snoc(Chain.snoc(acc$14625, a$14609), x$14631))
            };
    match Chain.viewLeft(c$14613) {
        case Chain.ViewLeft.NoneLeft =>
            Chain.Empty
        case Chain.ViewLeft.SomeLeft(x$14635, rs$14637) =>
            loop$14621(rs$14637)(Chain.singleton(x$14635))
    }
}

def Chain.isEmpty(c$13738: Chain[a]): Bool = {
    match c$13738 {case Chain.Empty => true case _ => false}
}

def Chain.iterator(
    rc$16062: Region[r],
    c$16069: Chain[a]
): Iterator[a, r, r] \ r = {
    let cursor$16080: Ref[ViewLeft[a], r] = (
        ref Chain.viewLeft(c$16069)
    ) @ rc$16062;
    let next$16087: (Unit -> Option[a]) = _unit$16089 ->
        match deref cursor$16080 {
            case Chain.ViewLeft.NoneLeft =>
                Option.None
            case Chain.ViewLeft.SomeLeft(x$16097, xs$16099) =>
                Ref.put(Chain.viewLeft(xs$16099), cursor$16080);
                Option.Some(x$16097)
        };
    Iterator.iterate(rc$16062, next$16087)
}

def Chain.join(sep$16504: String, c$16508: Chain[a]): String = {
    <[unknown exp]>(sep$16504, c$16508)
}

def Chain.joinWith(
    f$16521: a -> String,
    sep$16523: String,
    c$16525: Chain[a]
): String \ ef = {
    <[unknown exp]>(f$16521, sep$16523, c$16525)
}

def Chain.last(c$13904: Chain[a]): Option[a] = {
    match Chain.viewRight(c$13904) {
        case Chain.ViewRight.SomeRight(_, x$13925) =>
            Option.Some(x$13925)
        case _ =>
            Option.None
    }
}

def Chain.length(c$13986: Chain[a]): Int32 = {
    Chain.foldRight(
        _$13993 ->
            acc$13995 ->
                <[unknown exp]>(acc$13995, 1i32),
        0i32,
        c$13986
    )
}

def Chain.map(f$14480: a -> b, c$14486: Chain[a]): Chain[b] \ ef = {
    letrec loop$14491: (Chain[a] -> Chain[b] -> Chain[b] \ ef) = cc$14495 ->
        acc$14497 ->
            match Chain.viewLeft(cc$14495) {
                case Chain.ViewLeft.NoneLeft =>
                    acc$14497
                case Chain.ViewLeft.SomeLeft(a$14499, rs$14501) =>
                    loop$14491(
                        rs$14501
                    )(Chain.snoc(acc$14497, f$14480(a$14499)))
            };
    loop$14491(c$14486)(Chain.Empty)
}

def Chain.mapAccumLeft(
    f$15622: s -> a -> (s, b) \ ef,
    start$15627: s,
    c$15630: Chain[a]
): (s, Chain[b]) \ ef = {
    letrec loop$15638: (
        s ->
            Chain[a] -> ((((s, Chain[b])) -> (s, Chain[b])) -> (s, Chain[b]) \ ef)
    ) = s1$15641 ->
        cc$15643 ->
            k$15645 ->
                match Chain.viewLeft(cc$15643) {
                    case Chain.ViewLeft.NoneLeft =>
                        k$15645((s1$15641, Chain.empty(())))
                    case Chain.ViewLeft.SomeLeft(a$15649, rs$15651) =>
                        match f$15622(s1$15641)(a$15649) {
                            case (s2$15653, b$15655) =>
                                loop$15638(
                                    s2$15653
                                )(
                                    rs$15651
                                )(
                                    pat$74$15657 ->
                                        match pat$74$15657 {
                                            case (s3$15659, ks$15663) =>
                                                k$15645(
                                                    (
                                                        s3$15659,
                                                        Chain.cons(
                                                            b$15655,
                                                            ks$15663
                                                        )
                                                    )
                                                )
                                        }
                                )
                        }
                };
    loop$15638(start$15627)(c$15630)($0$45947 -> identity($0$45947))
}

def Chain.mapAccumRight(
    f$15705: s -> a -> (s, b) \ ef,
    start$15710: s,
    c$15714: Chain[a]
): (s, Chain[b]) \ ef = {
    letrec loop$15718: (
        s ->
            Chain[a] -> ((((s, Chain[b])) -> (s, Chain[b])) -> (s, Chain[b]) \ ef)
    ) = s1$15723 ->
        cc$15728 ->
            k$15731 ->
                match Chain.viewRight(cc$15728) {
                    case Chain.ViewRight.NoneRight =>
                        k$15731((s1$15723, Chain.empty(())))
                    case Chain.ViewRight.SomeRight(rs$15736, a$15739) =>
                        match f$15705(s1$15723)(a$15739) {
                            case (s2$15743, b$15745) =>
                                loop$15718(
                                    s2$15743
                                )(
                                    rs$15736
                                )(
                                    pat$77$15747 ->
                                        match pat$77$15747 {
                                            case (s3$15749, ks$15751) =>
                                                k$15731(
                                                    (
                                                        s3$15749,
                                                        Chain.snoc(
                                                            ks$15751,
                                                            b$15745
                                                        )
                                                    )
                                                )
                                        }
                                )
                        }
                };
    loop$15718(start$15710)(c$15714)($0$45965 -> identity($0$45965))
}

def Chain.mapWithIndex(
    f$14510: Int32 -> a -> b \ ef,
    c$14520: Chain[a]
): Chain[b] \ ef = {
    letrec loop$14528: (
        Chain[a] -> Int32 -> (Chain[b] -> Chain[b] \ ef + ((e86691 + ef) & ef))
    ) = cc$14532 ->
        i$14534 ->
            acc$14536 ->
                match Chain.viewLeft(cc$14532) {
                    case Chain.ViewLeft.NoneLeft =>
                        acc$14536
                    case Chain.ViewLeft.SomeLeft(x$14542, rs$14544) =>
                        let a$14546: b = f$14510(i$14534)(x$14542);
                        loop$14528(
                            rs$14544
                        )(
                            <[unknown exp]>(i$14534, 1i32)
                        )(Chain.snoc(acc$14536, a$14546))
                };
    loop$14528(c$14520)(0i32)(Chain.Empty)
}

def Chain.memberOf(a$14115: a, c$14118: Chain[a]): Bool = {
    match Chain.viewLeft(c$14118) {
        case Chain.ViewLeft.NoneLeft =>
            false
        case Chain.ViewLeft.SomeLeft(
            x$14121,
            _
        ) if <[unknown exp]>(x$14121, a$14115) =>
            true
        case Chain.ViewLeft.SomeLeft(_, xs$14126) =>
            Chain.memberOf(a$14115, xs$14126)
    }
}

def Chain.nonEmpty(c$13749: Chain[a]): Bool = {!Chain.isEmpty(c$13749)}

def Chain.range(b$14261: Int32, e$14269: Int32): Chain[Int32] = {
    letrec loop$14279: (Int32 -> Chain[Int32] -> Chain[Int32]) = i$14283 ->
        acc$14285 ->
            if (<[unknown exp]>(i$14283, e$14269)) {
                acc$14285
            } else {
                loop$14279(
                    <[unknown exp]>(i$14283, 1i32)
                )(Chain.snoc(acc$14285, i$14283))
            };
    loop$14279(b$14261)(Chain.empty(()))
}

def Chain.repeat(n$14310: Int32, a$14320: a): Chain[a] = {
    letrec loop$14330: (Int32 -> Chain[a] -> Chain[a]) = i$14332 ->
        acc$14334 ->
            if (<[unknown exp]>(i$14332, 0i32)) {
                acc$14334
            } else {
                loop$14330(
                    <[unknown exp]>(i$14332, 1i32)
                )(Chain.cons(a$14320, acc$14334))
            };
    loop$14330(n$14310)(Chain.Empty)
}

def Chain.reverse(c$14588: Chain[a]): Chain[a] = {
    letrec loop$14590: (Chain[a] -> Chain[a] -> Chain[a]) = cc$14592 ->
        acc$14594 ->
            match Chain.viewLeft(cc$14592) {
                case Chain.ViewLeft.NoneLeft =>
                    acc$14594
                case Chain.ViewLeft.SomeLeft(a$14596, rs$14598) =>
                    loop$14590(rs$14598)(Chain.cons(a$14596, acc$14594))
            };
    loop$14590(c$14588)(Chain.Empty)
}

def Chain.scan(
    f$14348: b -> a -> b \ ef,
    s$14355: b,
    c$14357: Chain[a]
): Chain[b] \ ef = {
    Chain.scanLeft(f$14348, s$14355, c$14357)
}

def Chain.scanLeft(
    f$14373: b -> a -> b \ ef,
    s$14377: b,
    c$14381: Chain[a]
): Chain[b] \ ef = {
    letrec loop$14383: (
        b -> Chain[a] -> (Chain[b] -> Chain[b] \ ef + (e84862 & ef) + ef)
    ) = a$14385 ->
        cc$14387 ->
            acc$14389 ->
                match Chain.viewLeft(cc$14387) {
                    case Chain.ViewLeft.NoneLeft =>
                        acc$14389
                    case Chain.ViewLeft.SomeLeft(x$14393, xs$14396) =>
                        let aa$14398: b = f$14373(a$14385)(x$14393);
                        loop$14383(
                            aa$14398
                        )(xs$14396)(Chain.snoc(acc$14389, aa$14398))
                };
    loop$14383(s$14377)(c$14381)(Chain.singleton(s$14377))
}

def Chain.scanRight(
    f$14417: a -> b -> b \ ef,
    s$14420: b,
    c$14426: Chain[a]
): Chain[b] \ ef = {
    letrec loop$14438: (
        b -> Chain[a] -> (Chain[b] -> Chain[b] \ ef + (e75247 & ef) + ef)
    ) = a$14442 ->
        cc$14447 ->
            acc$14452 ->
                match Chain.viewRight(cc$14447) {
                    case Chain.ViewRight.NoneRight =>
                        acc$14452
                    case Chain.ViewRight.SomeRight(xs$14456, x$14458) =>
                        let aa$14462: b = f$14417(x$14458)(a$14442);
                        loop$14438(
                            aa$14462
                        )(xs$14456)(Chain.cons(aa$14462, acc$14452))
                };
    loop$14438(s$14420)(c$14426)(Chain.singleton(s$14420))
}

def Chain.sequence(c$16419: Chain[m[a]]): m[Chain[a]] = {
    letrec loop$16432: (
        ViewLeft[m[a]] -> m[Chain[a]] -> m[Chain[a]]
    ) = v$16435 ->
        acc$16439 ->
            match v$16435 {
                case Chain.ViewLeft.NoneLeft =>
                    acc$16439
                case Chain.ViewLeft.SomeLeft(x$16447, rs$16449) =>
                    loop$16432(
                        Chain.viewLeft(rs$16449)
                    )(Chain.snocA(acc$16439, x$16447))
            };
    loop$16432(Chain.viewLeft(c$16419))(<[unknown exp]>(Chain.empty(())))
}

def Chain.shuffle(rnd$16592: Random, c$16594: Chain[a]): Chain[a] \ IO = {
    region rc$16601 {
        |>(
            !>(
                Chain.toArray(rc$16601, c$16594),
                (
                    $0$46037 ->
                        $1$46039 ->
                            Array.shuffle($0$46037, $1$46039)
                )(rnd$16592)
            ),
            $0$46041 ->
                Array.toChain($0$46041)
        )
    }
}

def Chain.singleton(x$13652: a): Chain[a] = {Chain.One(x$13652)}

def Chain.snoc(c$13817: Chain[a], x$13825: a): Chain[a] = {
    match c$13817 {
        case Chain.Empty =>
            Chain.One(x$13825)
        case _ =>
            Chain.Chain(c$13817, Chain.One(x$13825))
    }
}

def Chain.snocA(mxs$16391: f[Chain[a]], mx$16398: f[a]): f[Chain[a]] = {
    <[unknown exp]>(
        <[unknown exp]>(
            xs$16406 ->
                x$16408 ->
                    Chain.snoc(xs$16406, x$16408),
            mxs$16391
        ),
        mx$16398
    )
}

def Chain.sort(c$16300: Chain[a]): Chain[a] = {
    region rc$16308 {
        |>(
            !>(
                Chain.toArray(rc$16308, c$16300),
                $0$46013 ->
                    Array.sort!($0$46013)
            ),
            $0$46015 ->
                Array.toChain($0$46015)
        )
    }
}

def Chain.sortBy(f$16325: a -> b, c$16331: Chain[a]): Chain[a] = {
    region rc$16335 {
        |>(
            !>(
                Chain.toArray(rc$16335, c$16331),
                (
                    $0$46023 ->
                        $1$46025 ->
                            Array.sortBy!($0$46023, $1$46025)
                )(f$16325)
            ),
            $0$46027 ->
                Array.toChain($0$46027)
        )
    }
}

def Chain.sortWith(
    cmp$16355: a -> a -> Comparison,
    c$16362: Chain[a]
): Chain[a] = {
    region rc$16370 {
        |>(
            !>(
                Chain.toArray(rc$16370, c$16362),
                (
                    $0$46029 ->
                        $1$46031 ->
                            Array.sortWith!($0$46029, $1$46031)
                )(cmp$16355)
            ),
            $0$46033 ->
                Array.toChain($0$46033)
        )
    }
}

def Chain.sum(c$14673: Chain[Int32]): Int32 = {<[unknown exp]>(c$14673)}

def Chain.sumWith(f$14705: a -> Int32, c$14713: Chain[a]): Int32 \ ef = {
    <[unknown exp]>(f$14705, c$14713)
}

def Chain.takeLeft(n$15177: Int32, c$15179: Chain[a]): Chain[a] = {
    letrec loop$15183: (
        Int32 -> Chain[a] -> (Chain[a] -> Chain[a])
    ) = i$15185 ->
        cc$15187 ->
            acc$15189 ->
                match Chain.viewLeft(cc$15187) {
                    case Chain.ViewLeft.NoneLeft =>
                        acc$15189
                    case _ if <[unknown exp]>(i$15185, 1i32) =>
                        acc$15189
                    case Chain.ViewLeft.SomeLeft(a$15196, rs$15202) =>
                        loop$15183(
                            <[unknown exp]>(i$15185, 1i32)
                        )(rs$15202)(Chain.snoc(acc$15189, a$15196))
                };
    if (<[unknown exp]>(n$15177, 0i32)) {
        Chain.Empty
    } else {
        loop$15183(n$15177)(c$15179)(Chain.Empty)
    }
}

def Chain.takeRight(n$15226: Int32, c$15230: Chain[a]): Chain[a] = {
    letrec loop$15237: (
        Int32 -> Chain[a] -> (Chain[a] -> Chain[a])
    ) = i$15240 ->
        cc$15242 ->
            acc$15244 ->
                match Chain.viewRight(cc$15242) {
                    case Chain.ViewRight.NoneRight =>
                        acc$15244
                    case _ if <[unknown exp]>(i$15240, 1i32) =>
                        acc$15244
                    case Chain.ViewRight.SomeRight(rs$15246, a$15248) =>
                        loop$15237(
                            <[unknown exp]>(i$15240, 1i32)
                        )(rs$15246)(Chain.cons(a$15248, acc$15244))
                };
    if (<[unknown exp]>(n$15226, 0i32)) {
        Chain.Empty
    } else {
        loop$15237(n$15226)(c$15230)(Chain.Empty)
    }
}

def Chain.takeWhileLeft(
    f$15260: a -> Bool,
    c$15266: Chain[a]
): Chain[a] \ ef = {
    letrec loop$15270: (
        Chain[a] -> Chain[a] -> Chain[a] \ ef + ((e82984 + ef) & ef)
    ) = cc$15272 ->
        acc$15274 ->
            match Chain.viewLeft(cc$15272) {
                case Chain.ViewLeft.NoneLeft =>
                    acc$15274
                case Chain.ViewLeft.SomeLeft(a$15276, rs$15278) =>
                    if (f$15260(a$15276)) {
                        loop$15270(rs$15278)(Chain.snoc(acc$15274, a$15276))
                    } else {
                        acc$15274
                    }
            };
    loop$15270(c$15266)(Chain.Empty)
}

def Chain.takeWhileRight(
    f$15288: a -> Bool,
    c$15291: Chain[a]
): Chain[a] \ ef = {
    letrec loop$15294: (
        Chain[a] -> Chain[a] -> Chain[a] \ ef + ((e57273 + ef) & ef)
    ) = cc$15296 ->
        acc$15298 ->
            match Chain.viewRight(cc$15296) {
                case Chain.ViewRight.NoneRight =>
                    acc$15298
                case Chain.ViewRight.SomeRight(rs$15300, a$15302) =>
                    if (f$15288(a$15302)) {
                        loop$15294(rs$15300)(Chain.cons(a$15302, acc$15298))
                    } else {
                        acc$15298
                    }
            };
    loop$15294(c$15291)(Chain.Empty)
}

def Chain.toArray(rc$15978: Region[r], c$15982: Chain[a]): Array[a, r] \ r = {
    match Chain.head(c$15982) {
        case Option.None =>
            [] @ rc$15978
        case Option.Some(_) =>
            let arr$16001: Array[a, r] = Array.empty(
                rc$15978,
                Chain.length(c$15982)
            );
            Chain.forEach(
                pat$78$16003 ->
                    match pat$78$16003 {
                        case (i$16005, b$16008) =>
                            Array.put(b$16008, i$16005, arr$16001)
                    },
                Chain.zipWithIndex(c$15982)
            );
            arr$16001
    }
}

def Chain.toList(c$15834: Chain[a]): List[a] = {
    Chain.foldRight(
        x$15844 ->
            acc$15849 ->
                List.Cons(x$15844, acc$15849),
        List.Nil,
        c$15834
    )
}

def Chain.toMap(c$15948: Chain[(a, b)]): Map[a, b] = {
    Chain.foldRight(
        x$15957 ->
            acc$15960 ->
                Map.insert(fst(x$15957), snd(x$15957), acc$15960),
        Map.empty(()),
        c$15948
    )
}

def Chain.toMutDeque(
    rc$15858: Region[r],
    c$15860: Chain[a]
): MutDeque[a, r] \ r = {
    let d$15869: MutDeque[a, r] = MutDeque.empty(rc$15858);
    Chain.forEach(x$15872 -> MutDeque.pushBack(x$15872, d$15869), c$15860);
    d$15869
}

def Chain.toMutList(
    rc$15888: Region[r],
    c$15890: Chain[a]
): MutList[a, r] \ r = {
    region rc2$15899 {
        Array.toMutList(rc$15888, Chain.toArray(rc2$15899, c$15890))
    }
}

def Chain.toNec(c$16179: Chain[a]): Option[Nec[a]] = {
    match Chain.viewLeft(c$16179) {
        case Chain.ViewLeft.NoneLeft =>
            Option.None
        case Chain.ViewLeft.SomeLeft(x$16187, rs$16189) =>
            |>(
                Chain.foldLeft(
                    $0$46001 ->
                        $1$46003 ->
                            Nec.snoc($0$46001, $1$46003),
                    Nec.singleton(x$16187),
                    rs$16189
                ),
                x$$46005 ->
                    Option.Some(x$$46005)
            )
    }
}

def Chain.toNel(c$16148: Chain[a]): Option[Nel[a]] = {
    match Chain.viewLeft(c$16148) {
        case Chain.ViewLeft.NoneLeft =>
            Option.None
        case Chain.ViewLeft.SomeLeft(x$16158, rs$16160) =>
            |>(
                Nel.Nel(x$16158, Chain.toList(rs$16160)),
                x$$45997 ->
                    Option.Some(x$$45997)
            )
    }
}

def Chain.toSet(c$15913: Chain[a]): Set[a] = {
    Chain.foldRight(
        x$15921 ->
            acc$15926 ->
                Set.insert(x$15921, acc$15926),
        Set.empty(()),
        c$15913
    )
}

def Chain.toVector(c$16016: Chain[a]): Vector[a] = {
    region rc$16029 {
        let arr$16034: Array[a, rc] = Array.empty(
            rc$16029,
            Chain.length(c$16016)
        );
        Chain.forEachWithIndex(
            i$16041 ->
                x$16045 ->
                    Array.put(x$16045, i$16041, arr$16034),
            c$16016
        );
        Array.toVector(arr$16034)
    }
}

def Chain.traverse(f$16474: a -> m[b], c$16479: Chain[a]): m[Chain[b]] \ ef = {
    letrec loop$16483: (
        ViewLeft[a] -> m[Chain[b]] -> m[Chain[b]] \ (e122600 & ef) + ef
    ) = v$16487 ->
        acc$16490 ->
            match v$16487 {
                case Chain.ViewLeft.NoneLeft =>
                    acc$16490
                case Chain.ViewLeft.SomeLeft(x$16494, rs$16496) =>
                    loop$16483(
                        Chain.viewLeft(rs$16496)
                    )(Chain.snocA(acc$16490, f$16474(x$16494)))
            };
    loop$16483(Chain.viewLeft(c$16479))(<[unknown exp]>(Chain.empty(())))
}

def Chain.unzip(c$15600: Chain[(a, b)]): (Chain[a], Chain[b]) = {
    letrec loop$15602: (
        Chain[(a, b)] -> Chain[a] -> (Chain[b] -> (Chain[a], Chain[b]))
    ) = cc$15604 ->
        acc1$15606 ->
            acc2$15608 ->
                match Chain.viewLeft(cc$15604) {
                    case Chain.ViewLeft.NoneLeft =>
                        (acc1$15606, acc2$15608)
                    case Chain.ViewLeft.SomeLeft(
                        (a$15610, b$15612),
                        rs$15614
                    ) =>
                        loop$15602(
                            rs$15614
                        )(
                            Chain.snoc(acc1$15606, a$15610)
                        )(Chain.snoc(acc2$15608, b$15612))
                };
    loop$15602(c$15600)(Chain.empty(()))(Chain.empty(()))
}

def Chain.viewLeft(c$14045: Chain[a]): ViewLeft[a] = {
    letrec loop$14050: (
        Chain[a] -> Chain[a] -> ((ViewLeft[a] -> ViewLeft[a]) -> ViewLeft[a])
    ) = cc$14052 ->
        acc$14054 ->
            k$14056 ->
                match cc$14052 {
                    case Chain.Empty =>
                        k$14056(Chain.ViewLeft.NoneLeft)
                    case Chain.One(x$14060) =>
                        k$14056(Chain.ViewLeft.SomeLeft(x$14060, acc$14054))
                    case Chain.Chain(l$14067, r$14069) =>
                        loop$14050(
                            l$14067
                        )(Chain.append(r$14069, acc$14054))(k$14056)
                };
    loop$14050(c$14045)(Chain.Empty)($0$45820 -> identity($0$45820))
}

def Chain.viewRight(c$14078: Chain[a]): ViewRight[a] = {
    letrec loop$14091: (
        Chain[a] -> Chain[a] -> ((ViewRight[a] -> ViewRight[a]) -> ViewRight[a])
    ) = cc$14093 ->
        acc$14097 ->
            k$14099 ->
                match cc$14093 {
                    case Chain.Empty =>
                        k$14099(Chain.ViewRight.NoneRight)
                    case Chain.One(x$14101) =>
                        k$14099(Chain.ViewRight.SomeRight(acc$14097, x$14101))
                    case Chain.Chain(l$14103, r$14105) =>
                        loop$14091(
                            r$14105
                        )(Chain.append(acc$14097, l$14103))(k$14099)
                };
    loop$14091(c$14078)(Chain.Empty)($0$45822 -> identity($0$45822))
}

def Chain.zip(c1$15395: Chain[a], c2$15402: Chain[b]): Chain[(a, b)] = {
    letrec loop$15418: (
        Chain[a] -> Chain[b] -> (Chain[(a, b)] -> Chain[(a, b)])
    ) = cc1$15420 ->
        cc2$15424 ->
            acc$15428 ->
                match (Chain.viewLeft(cc1$15420), Chain.viewLeft(cc2$15424)) {
                    case (
                        Chain.ViewLeft.SomeLeft(a$15434, rs$15436),
                        Chain.ViewLeft.SomeLeft(b$15438, qs$15440)
                    ) =>
                        loop$15418(
                            rs$15436
                        )(qs$15440)(Chain.snoc(acc$15428, (a$15434, b$15438)))
                    case _ =>
                        acc$15428
                };
    loop$15418(c1$15395)(c2$15402)(Chain.empty(()))
}

def Chain.zipWith(
    f$15455: a -> b -> c \ ef,
    c1$15459: Chain[a],
    c2$15464: Chain[b]
): Chain[c] \ ef = {
    letrec loop$15472: (
        Chain[a] -> Chain[b] -> (Chain[c] -> Chain[c] \ (e68059 & ef) + ef)
    ) = cc1$15474 ->
        cc2$15476 ->
            acc$15480 ->
                match (Chain.viewLeft(cc1$15474), Chain.viewLeft(cc2$15476)) {
                    case (
                        Chain.ViewLeft.SomeLeft(a$15487, rs$15491),
                        Chain.ViewLeft.SomeLeft(b$15494, qs$15496)
                    ) =>
                        loop$15472(
                            rs$15491
                        )(
                            qs$15496
                        )(Chain.snoc(acc$15480, f$15455(a$15487)(b$15494)))
                    case _ =>
                        acc$15480
                };
    loop$15472(c1$15459)(c2$15464)(Chain.empty(()))
}

def Chain.zipWithA(
    f$15529: a -> b -> m[c] \ ef,
    xs$15538: Chain[a],
    ys$15545: Chain[b]
): m[Chain[c]] \ ef = {
    <[unknown exp]>
}

def Chain.zipWithIndex(c$16542: Chain[a]): Chain[(Int32, a)] = {
    letrec loop$16546: (
        Chain[a] -> Chain[(Int32, a)] -> (Int32 -> Chain[(Int32, a)])
    ) = cc$16548 ->
        acc$16551 ->
            i$16555 ->
                match Chain.viewLeft(cc$16548) {
                    case Chain.ViewLeft.NoneLeft =>
                        acc$16551
                    case Chain.ViewLeft.SomeLeft(a$16561, rs$16563) =>
                        loop$16546(
                            rs$16563
                        )(
                            Chain.snoc(acc$16551, (i$16555, a$16561))
                        )(<[unknown exp]>(i$16555, 1i32))
                };
    loop$16546(c$16542)(Chain.Empty)(0i32)
}

enum Chain.ViewLeft[t] {case NoneLeft(Unit) case SomeLeft(t, Chain[t])}

enum Chain.ViewRight[t] {case NoneRight(Unit) case SomeRight(Chain[t], t)}

def Channel.buffered(
    rc$40905: Region[r],
    n$40910: Int32
): (Sender[t, r], Receiver[t, r]) \ r = {
    let m$40930: Int32 = if (<[unknown exp]>(n$40910, 0i32)) {
        0i32
    } else {
        n$40910
    };
    <[unknown exp]>
}

def Channel.recv(receiver$42871: Receiver[t, r]): t \ r = {<[unknown exp]>}

def Channel.send(m$43429: t, sender$43433: Sender[t, r]): Unit \ r = {
    <[unknown exp]>
}

def Channel.timeout(
    rc$44181: Region[r],
    d$44185: Duration
): Receiver[Unit, r] \ r + IO = {
    match Channel.unbuffered(rc$44181) {
        case (tx$44196, rx$44198) =>
            (
                spawn {Thread.sleep(d$44185); Channel.send((), tx$44196)}
            ) @ rc$44181;
            rx$44198
    }
}

def Channel.unbuffered(
    rc$42847: Region[r]
): (Sender[t, r], Receiver[t, r]) \ r = {
    Channel.buffered(rc$42847, 0i32)
}

def Channel.unsafeSend(m$44170: t, sender$44172: Sender[t, r]): Unit \ r = {
    <[unknown exp]>
}

def Char.charValue(c$4833: java.lang.Character): Char = {
    let charValue$4839: (java.lang.Character -> Char) = obj$$4843 ->
        <[unknown exp]>;
    charValue$4839(c$4833)
}

def Char.digit(radix$4763: { radix = Int32 }, c$4765: Char): Option[Int32] = {
    let digit$4769: (Char -> Int32 -> Int32) = a0$$4771 ->
        a1$$4773 ->
            <[unknown exp]>;
    match digit$4769(c$4765)(radix$4763.radix) {
        case i$4777 if <[unknown exp]>(i$4777, 0i32) =>
            Option.None
        case i$4779 =>
            Option.Some(i$4779)
    }
}

def Char.forDigit(
    radix$4785: { radix = Int32 },
    n$4788: Int32
): Option[Char] = {
    let forDigit$4794: (Int32 -> Int32 -> Char) = a0$$4796 ->
        a1$$4798 ->
            <[unknown exp]>;
    match forDigit$4794(n$4788)(radix$4785.radix) {
        case c$4815 if <[unknown exp]>(c$4815, ''' ''') =>
            Option.None
        case c$4821 =>
            Option.Some(c$4821)
    }
}

def Char.getNumericValue(c$4724: Char): Option[Int32] = {
    let getNumericValue$4731: (Char -> Int32) = a0$$4740 ->
        <[unknown exp]>;
    match getNumericValue$4731(c$4724) {
        case i$4752 if <[unknown exp]>(i$4752, 0i32) =>
            Option.None
        case i$4755 =>
            Option.Some(i$4755)
    }
}

def Char.isAscii(c$2095: Char): Bool = {<[unknown exp]>(c$2095, '''''')}

def Char.isAsciiDigit(c$3706: Char): Bool = {
    Char.isAscii(c$3706) and Char.isDigit(c$3706)
}

def Char.isDefined(c$3856: Char): Bool = {
    let isDefined$3862: (Char -> Bool) = a0$$3866 ->
        <[unknown exp]>;
    isDefined$3862(c$3856)
}

def Char.isDigit(c$3687: Char): Bool = {
    let isDigit$3689: (Char -> Bool) = a0$$3691 ->
        <[unknown exp]>;
    isDigit$3689(c$3687)
}

def Char.isHexDigit(c$3732: Char): Bool = {
    match c$3732 {
        case i$3739 if <[unknown exp]>(
            '''0''',
            i$3739
        ) and <[unknown exp]>(i$3739, '''9''') =>
            true
        case i$3747 if <[unknown exp]>(
            '''A''',
            i$3747
        ) and <[unknown exp]>(i$3747, '''F''') =>
            true
        case i$3753 if <[unknown exp]>(
            '''a''',
            i$3753
        ) and <[unknown exp]>(i$3753, '''f''') =>
            true
        case _ =>
            false
    }
}

def Char.isISOControl(c$3875: Char): Bool = {
    let isISOControl$3881: (Char -> Bool) = a0$$3883 ->
        <[unknown exp]>;
    isISOControl$3881(c$3875)
}

def Char.isLetter(c$2103: Char): Bool = {
    let isLetter$2108: (Char -> Bool) = a0$$2114 ->
        <[unknown exp]>;
    isLetter$2108(c$2103)
}

def Char.isLetterOrDigit(c$3693: Char): Bool = {
    let isLetterOrDigit$3699: (Char -> Bool) = a0$$3701 ->
        <[unknown exp]>;
    isLetterOrDigit$3699(c$3693)
}

def Char.isLowerCase(c$3765: Char): Bool = {
    let isLowerCase$3771: (Char -> Bool) = a0$$3773 ->
        <[unknown exp]>;
    isLowerCase$3771(c$3765)
}

def Char.isMirrored(c$3897: Char): Bool = {
    let isMirrored$3899: (Char -> Bool) = a0$$3901 ->
        <[unknown exp]>;
    isMirrored$3899(c$3897)
}

def Char.isOctDigit(c$3724: Char): Bool = {
    <[unknown exp]>('''0''', c$3724) and <[unknown exp]>(c$3724, '''7''')
}

def Char.isSurrogate(c$3917: Char): Bool = {
    let isSurrogate$3920: (Char -> Bool) = a0$$3925 ->
        <[unknown exp]>;
    isSurrogate$3920(c$3917)
}

def Char.isSurrogatePair(
    high$3935: { high = Char },
    low$3938: { low = Char }
): Bool = {
    let isSurrogatePair$3943: (Char -> Char -> Bool) = a0$$3945 ->
        a1$$3947 ->
            <[unknown exp]>;
    isSurrogatePair$3943(high$3935.high)(low$3938.low)
}

def Char.isTitleCase(c$3818: Char): Bool = {
    let isTitleCase$3820: (Char -> Bool) = a0$$3823 ->
        <[unknown exp]>;
    isTitleCase$3820(c$3818)
}

def Char.isUpperCase(c$3786: Char): Bool = {
    let isUpperCase$3792: (Char -> Bool) = a0$$3794 ->
        <[unknown exp]>;
    isUpperCase$3792(c$3786)
}

def Char.isWhiteSpace(c$3832: Char): Bool = {
    let isWhitespace$3834: (Char -> Bool) = a0$$3836 ->
        <[unknown exp]>;
    isWhitespace$3834(c$3832)
}

def Char.maxValue(_unit$4713: Unit): Char = {'''￿'''}

def Char.minValue(_unit$4706: Unit): Char = {''' '''}

def Char.toBmpCodePoint(c$4635: Char): Int32 = {<[unknown exp]>}

def Char.toLowerCase(c$4507: Char): Char = {
    let toLowerCase$4523: (Char -> Char) = a0$$4525 ->
        <[unknown exp]>;
    toLowerCase$4523(c$4507)
}

def Char.toString(c$4691: Char): String = {<[unknown exp]>(c$4691)}

def Char.toSupplementaryCodePoint(
    high$4645: { high = Char },
    low$4647: { low = Char }
): Int32 = {
    let toCodePoint$4653: (Char -> Char -> Int32) = a0$$4657 ->
        a1$$4661 ->
            <[unknown exp]>;
    toCodePoint$4653(high$4645.high)(low$4647.low)
}

def Char.toTitleCase(c$4601: Char): Char = {
    let toTitleCase$4610: (Char -> Char) = a0$$4612 ->
        <[unknown exp]>;
    toTitleCase$4610(c$4601)
}

def Char.toUpperCase(c$4564: Char): Char = {
    let toUpperCase$4570: (Char -> Char) = a0$$4572 ->
        <[unknown exp]>;
    toUpperCase$4570(c$4564)
}

def Char.valueOf(c$4866: Char): java.lang.Character = {
    let valueOf$4872: (Char -> java.lang.Character) = a0$$4876 ->
        <[unknown exp]>;
    valueOf$4872(c$4866)
}

def CodePoint.charCount(cp$39969: Int32): Int32 = {
    let charCount$39976: (Int32 -> Int32) = a0$$39979 ->
        <[unknown exp]>;
    charCount$39976(cp$39969)
}

def CodePoint.getName(cp$39900: Int32): Option[String] = {
    try {
        let getName$39914: (Int32 -> String) = a0$$39916 ->
            <[unknown exp]>;
        |>(getName$39914(cp$39900), $0$46884 -> Object.toOption($0$46884))
    } catch {case _$39933: ##java.lang.Exception => Option.None}
}

def CodePoint.getNumericValue(cp$39937: Int32): Option[Int32] = {
    let getNumericValue$39945: (Int32 -> Int32) = a0$$39947 ->
        <[unknown exp]>;
    match getNumericValue$39945(cp$39937) {
        case i$39955 if <[unknown exp]>(i$39955, 0i32) =>
            Option.None
        case i$39963 =>
            Option.Some(i$39963)
    }
}

def CodePoint.highSurrogate(cp$40210: Int32): Option[Char] = {
    let highSurrogate$40212: (Int32 -> Char) = a0$$40214 ->
        <[unknown exp]>;
    if (CodePoint.isSupplementaryCodePoint(cp$40210)) {
        Option.Some(highSurrogate$40212(cp$40210))
    } else {
        Option.None
    }
}

def CodePoint.isAlphabetic(cp$39640: Int32): Bool = {
    let isAlphabetic$39646: (Int32 -> Bool) = a0$$39648 ->
        <[unknown exp]>;
    isAlphabetic$39646(cp$39640)
}

def CodePoint.isAscii(cp$39432: Int32): Bool = {
    <[unknown exp]>(0i32, cp$39432) and <[unknown exp]>(cp$39432, 128i32)
}

def CodePoint.isAsciiDigit(cp$39511: Int32): Bool = {
    CodePoint.isAscii(cp$39511) and CodePoint.isDigit(cp$39511)
}

def CodePoint.isBmpCodePoint(cp$39677: Int32): Bool = {
    let isBmpCodePoint$39685: (Int32 -> Bool) = a0$$39687 ->
        <[unknown exp]>;
    isBmpCodePoint$39685(cp$39677)
}

def CodePoint.isDefined(cp$39695: Int32): Bool = {
    let isDefined$39704: (Int32 -> Bool) = a0$$39706 ->
        <[unknown exp]>;
    isDefined$39704(cp$39695)
}

def CodePoint.isDigit(cp$39464: Int32): Bool = {
    let isDigit$39467: (Int32 -> Bool) = a0$$39469 ->
        <[unknown exp]>;
    isDigit$39467(cp$39464)
}

def CodePoint.isHexDigit(cp$39521: Int32): Bool = {
    match cp$39521 {
        case i$39527 if <[unknown exp]>(
            48i32,
            i$39527
        ) and <[unknown exp]>(i$39527, 57i32) =>
            true
        case i$39529 if <[unknown exp]>(
            65i32,
            i$39529
        ) and <[unknown exp]>(i$39529, 70i32) =>
            true
        case i$39540 if <[unknown exp]>(
            97i32,
            i$39540
        ) and <[unknown exp]>(i$39540, 102i32) =>
            true
        case _ =>
            false
    }
}

def CodePoint.isISOControl(cp$39745: Int32): Bool = {
    let isISOControl$39753: (Int32 -> Bool) = a0$$39758 ->
        <[unknown exp]>;
    isISOControl$39753(cp$39745)
}

def CodePoint.isIdeographic(cp$39717: Int32): Bool = {
    let isIdeographic$39723: (Int32 -> Bool) = a0$$39725 ->
        <[unknown exp]>;
    isIdeographic$39723(cp$39717)
}

def CodePoint.isLetter(cp$39446: Int32): Bool = {
    let isLetter$39452: (Int32 -> Bool) = a0$$39454 ->
        <[unknown exp]>;
    isLetter$39452(cp$39446)
}

def CodePoint.isLetterOrDigit(cp$39492: Int32): Bool = {
    let isLetterOrDigit$39498: (Int32 -> Bool) = a0$$39500 ->
        <[unknown exp]>;
    isLetterOrDigit$39498(cp$39492)
}

def CodePoint.isLowerCase(cp$39557: Int32): Bool = {
    let isLowerCase$39562: (Int32 -> Bool) = a0$$39564 ->
        <[unknown exp]>;
    isLowerCase$39562(cp$39557)
}

def CodePoint.isMirrored(cp$39768: Int32): Bool = {
    let isMirrored$39770: (Int32 -> Bool) = a0$$39772 ->
        <[unknown exp]>;
    isMirrored$39770(cp$39768)
}

def CodePoint.isOctDigit(cp$39518: Int32): Bool = {
    <[unknown exp]>(48i32, cp$39518) and <[unknown exp]>(cp$39518, 55i32)
}

def CodePoint.isSupplementaryCodePoint(cp$39785: Int32): Bool = {
    let isSupplementaryCodePoint$39792: (Int32 -> Bool) = a0$$39794 ->
        <[unknown exp]>;
    isSupplementaryCodePoint$39792(cp$39785)
}

def CodePoint.isTitleCase(cp$39597: Int32): Bool = {
    let isTitleCase$39605: (Int32 -> Bool) = a0$$39607 ->
        <[unknown exp]>;
    isTitleCase$39605(cp$39597)
}

def CodePoint.isUpperCase(cp$39575: Int32): Bool = {
    let isUpperCase$39586: (Int32 -> Bool) = a0$$39588 ->
        <[unknown exp]>;
    isUpperCase$39586(cp$39575)
}

def CodePoint.isValidCodePoint(cp$39803: Int32): Bool = {
    let isValidCodePoint$39807: (Int32 -> Bool) = a0$$39809 ->
        <[unknown exp]>;
    isValidCodePoint$39807(cp$39803)
}

def CodePoint.isWhiteSpace(cp$39618: Int32): Bool = {
    let isWhitespace$39625: (Int32 -> Bool) = a0$$39629 ->
        <[unknown exp]>;
    isWhitespace$39625(cp$39618)
}

def CodePoint.lowSurrogate(cp$40233: Int32): Option[Char] = {
    let lowSurrogate$40239: (Int32 -> Char) = a0$$40241 ->
        <[unknown exp]>;
    if (CodePoint.isSupplementaryCodePoint(cp$40233)) {
        Option.Some(lowSurrogate$40239(cp$40233))
    } else {
        Option.None
    }
}

def CodePoint.maxValue(_unit$39413: Unit): Int32 = {
    let get_MAX_CODE_POINT$39422: (Unit -> Int32) = _$39424 ->
        <[unknown exp]>;
    get_MAX_CODE_POINT$39422(())
}

def CodePoint.minValue(_unit$39372: Unit): Int32 = {
    let get_MIN_CODE_POINT$39380: (Unit -> Int32) = _$39383 ->
        <[unknown exp]>;
    get_MIN_CODE_POINT$39380(())
}

def CodePoint.toBmpChar(cp$40077: Int32): Option[Char] = {
    try {
        region rc$40079 {
            let toChars$40082: (
                Int32 -> Array[Char, rc] -> (Int32 -> Int32 \ rc)
            ) = a0$$40084 ->
                a1$$40087 ->
                    a2$$40090 ->
                        <[unknown exp]>;
            let arr$40094: Array[Char, rc] = Array.empty(rc$40079, 2i32);
            let i$40098: Int32 = toChars$40082(cp$40077)(arr$40094)(0i32);
            if (<[unknown exp]>(i$40098, 1i32)) {
                Array.nth(0i32, arr$40094)
            } else {
                Option.None
            }
        }
    } catch {case _$40104: ##java.lang.Exception => Option.None}
}

def CodePoint.toChars(cp$40005: Int32): Option[Vector[Char]] = {
    try {
        region rc$40020 {
            let toChars$40025: (
                Int32 -> Array[Char, rc] -> (Int32 -> Int32 \ rc)
            ) = a0$$40027 ->
                a1$$40031 ->
                    a2$$40037 ->
                        <[unknown exp]>;
            let arr$40055: Array[Char, rc] = Array.empty(rc$40020, 2i32);
            let size$40057: Int32 = toChars$40025(cp$40005)(arr$40055)(0i32);
            |>(
                |>(
                    Array.toVector(arr$40055),
                    (
                        $0$46892 ->
                            $1$46894 ->
                                Vector.takeLeft($0$46892, $1$46894)
                    )(size$40057)
                ),
                x$$46896 ->
                    Option.Some(x$$46896)
            )
        }
    } catch {case _$40061: ##java.lang.Throwable => Option.None}
}

def CodePoint.toLowerCase(cp$39837: Int32): Int32 = {
    let toLowerCase$39841: (Int32 -> Int32) = a0$$39843 ->
        <[unknown exp]>;
    toLowerCase$39841(cp$39837)
}

def CodePoint.toString(cp$40179: Int32): String = {
    try {
        let toString$40191: (Int32 -> String) = a0$$40193 ->
            <[unknown exp]>;
        toString$40191(cp$40179)
    } catch {case _$40202: ##java.lang.Exception => """"""}
}

def CodePoint.toSupplementaryChars(cp$40117: Int32): Option[(Char, Char)] = {
    try {
        region rc$40127 {
            let toChars$40130: (
                Int32 -> Array[Char, rc] -> (Int32 -> Int32 \ rc)
            ) = a0$$40132 ->
                a1$$40134 ->
                    a2$$40139 ->
                        <[unknown exp]>;
            let arr$40165: Array[Char, rc] = Array.empty(rc$40127, 2i32);
            let i$40167: Int32 = toChars$40130(cp$40117)(arr$40165)(0i32);
            if (<[unknown exp]>(i$40167, 2i32)) {
                Option.Some(
                    Array.get(0i32, arr$40165),
                    Array.get(1i32, arr$40165)
                )
            } else {
                Option.None
            }
        }
    } catch {case _$40174: ##java.lang.Exception => Option.None}
}

def CodePoint.toTitleCase(cp$39879: Int32): Int32 = {
    let toTitleCase$39881: (Int32 -> Int32) = a0$$39883 ->
        <[unknown exp]>;
    toTitleCase$39881(cp$39879)
}

def CodePoint.toUpperCase(cp$39845: Int32): Int32 = {
    let toUpperCase$39850: (Int32 -> Int32) = a0$$39852 ->
        <[unknown exp]>;
    toUpperCase$39850(cp$39845)
}

enum Comparison {case LessThan(Unit) case EqualTo(Unit) case GreaterThan(Unit)}

def Comparison.fromInt32(i$3912: Int32): Comparison = {
    if (<[unknown exp]>(i$3912, 0i32)) {
        Comparison.LessThan
    } else {
        if (<[unknown exp]>(i$3912, 0i32)) {
            Comparison.EqualTo
        } else {
            Comparison.GreaterThan
        }
    }
}

def Comparison.toInt(c$3891: Comparison): Int32 = {
    match c$3891 {
        case Comparison.LessThan =>
            -1i32
        case Comparison.EqualTo =>
            0i32
        case Comparison.GreaterThan =>
            1i32
    }
}

def Concurrent.Channel.addGetter(
    l$21835: ReentrantLock,
    cond$21838: Condition,
    c$21840: MpmcAdmin
): Unit \ IO = {
    match c$21840 {
        case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
            _,
            _,
            _,
            _,
            _,
            waitingGetters$21842,
            _,
            _
        ) =>
            MutList.push!((l$21835, cond$21838), waitingGetters$21842)
    }
}

def Concurrent.Channel.awaitAvailableSpace(c$21680: MpmcAdmin): Unit \ IO = {
    match c$21680 {
        case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
            _,
            _,
            _,
            maxSize$21683,
            size$21685,
            _,
            _,
            waitingPutters$21687
        ) =>
            if (<[unknown exp]>(deref size$21685, maxSize$21683)) {
                Concurrent.Channel.awaitCondition(waitingPutters$21687);
                Concurrent.Channel.awaitAvailableSpace(c$21680)
            } else {
                ()
            }
    }
}

def Concurrent.Channel.awaitCondition(c$21895: Condition): Unit \ IO = {
    Concurrent.Condition.await(c$21895)
}

def Concurrent.Channel.fairness(_unit$21673: Unit): Bool = {false}

def Concurrent.Channel.get(c$21579: Mpmc[a, Static]): a \ IO = {
    match Concurrent.Channel.mpmcAdmin(c$21579) {
        case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
            _,
            channelLock$21581,
            _,
            _,
            _,
            _,
            _,
            _
        ) =>
            Concurrent.ReentrantLock.lock(channelLock$21581);
            Concurrent.Channel.getHelper(c$21579)
    }
}

def Concurrent.Channel.getHelper(c$21709: Mpmc[a, Static]): a \ IO = {
    match c$21709 {
        case Concurrent.Channel.Mpmc.Mpmc(admin$21716, elementDeque$21718) =>
            match admin$21716 {
                case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
                    _,
                    channelLock$21720,
                    _,
                    _,
                    size$21722,
                    waitingGetters$21724,
                    _,
                    _
                ) =>
                    let optionalElement$21726: Option[a] = MutDeque.popFront(
                        elementDeque$21718
                    );
                    match optionalElement$21726 {
                        case Option.None =>
                            let conditionLock$21730: ReentrantLock = Concurrent.ReentrantLock.newLock(
                                Concurrent.Channel.fairness(())
                            );
                            Concurrent.ReentrantLock.lock(conditionLock$21730);
                            let condition$21735: Condition = Concurrent.ReentrantLock.newCondition(
                                conditionLock$21730
                            );
                            MutList.push!(
                                (conditionLock$21730, condition$21735),
                                waitingGetters$21724
                            );
                            Concurrent.Channel.unlock(channelLock$21720);
                            Concurrent.Channel.awaitCondition(condition$21735);
                            Concurrent.ReentrantLock.lock(channelLock$21720);
                            Concurrent.Channel.unlock(conditionLock$21730);
                            Concurrent.Channel.getHelper(c$21709)
                        case Option.Some(e$21745) =>
                            Ref.put(
                                <[unknown exp]>(deref size$21722, 1i32),
                                size$21722
                            );
                            Concurrent.Channel.onGetComplete(admin$21716);
                            e$21745
                    }
            }
    }
}

def Concurrent.Channel.mpmcAdmin(c$21097: Mpmc[a, Static]): MpmcAdmin = {
    match c$21097 {
        case Concurrent.Channel.Mpmc.Mpmc(admin$21113, _) =>
            admin$21113
    }
}

def Concurrent.Channel.newChannel(
    bufferSize$21138: Int32
): Mpmc[a, Static] \ IO = {
    let newId$21149: (Unit -> Int64) = _$21152 ->
        ##dev.flix.runtime.Global.newId();
    let _bufferCheck$21163: Unit = if (
        <[unknown exp]>(bufferSize$21138, 0i32)
    ) {
        bug!("""bufferSize < 0""")
    } else {
        ()
    };
    let unBuffered$21168: Bool = <[unknown exp]>(bufferSize$21138, 0i32);
    let reentrantLock$21170: ReentrantLock = Concurrent.ReentrantLock.newLock(
        Concurrent.Channel.fairness(())
    );
    let size$21172: Ref[Int32, IO] = (ref 0i32) @ <[region]>;
    Concurrent.Channel.Mpmc.Mpmc(
        Concurrent.Channel.MpmcAdmin.MpmcAdmin(
            newId$21149(()),
            reentrantLock$21170,
            unBuffered$21168,
            if (unBuffered$21168) {1i32} else {bufferSize$21138},
            size$21172,
            MutList.empty(<[region]>),
            Concurrent.CyclicBarrier.newCyclicBarrier(2i32),
            Concurrent.ReentrantLock.newCondition(reentrantLock$21170)
        ),
        MutDeque.empty(<[region]>)
    )
}

def Concurrent.Channel.newChannelTuple(
    bufferSize$21515: Int32
): (Mpmc[a, Static], Mpmc[a, Static]) \ IO = {
    let c$21520: Mpmc[a, IO] = Concurrent.Channel.newChannel(bufferSize$21515);
    (c$21520, c$21520)
}

def Concurrent.Channel.onGetComplete(c$21874: MpmcAdmin): Unit \ IO = {
    match c$21874 {
        case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
            _,
            channelLock$21882,
            unBuffered$21886,
            _,
            _,
            _,
            rendezvous$21888,
            waitingPutters$21890
        ) =>
            if (unBuffered$21886) {
                discard Concurrent.CyclicBarrier.awaitBarrier(rendezvous$21888)
            } else {
                ()
            };
            Concurrent.Channel.signalCondition(waitingPutters$21890);
            Concurrent.Channel.unlock(channelLock$21882)
    }
}

def Concurrent.Channel.put(e$21527: a, c$21529: Mpmc[a, Static]): Unit \ IO = {
    match c$21529 {
        case Concurrent.Channel.Mpmc.Mpmc(admin$21536, elementDeque$21538) =>
            match admin$21536 {
                case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
                    _,
                    channelLock$21542,
                    unBuffered$21544,
                    _,
                    size$21546,
                    _,
                    rendezvous$21548,
                    _
                ) =>
                    Concurrent.ReentrantLock.lock(channelLock$21542);
                    Concurrent.Channel.awaitAvailableSpace(admin$21536);
                    MutDeque.pushBack(e$21527, elementDeque$21538);
                    Ref.put(
                        <[unknown exp]>(deref size$21546, 1i32),
                        size$21546
                    );
                    Concurrent.Channel.signalGetters(admin$21536);
                    Concurrent.Channel.unlock(channelLock$21542);
                    if (unBuffered$21544) {
                        discard Concurrent.CyclicBarrier.awaitBarrier(
                            rendezvous$21548
                        )
                    } else {
                        ()
                    }
            }
    }
}

def Concurrent.Channel.selectFrom(
    channels$21633: List[MpmcAdmin],
    blocking$21638: Bool
): (Int32, List[ReentrantLock]) \ IO = {
    let selectLock$21640: ReentrantLock = Concurrent.ReentrantLock.newLock(
        Concurrent.Channel.fairness(())
    );
    let selectCondition$21644: Condition = Concurrent.ReentrantLock.newCondition(
        selectLock$21640
    );
    let sortedLocks$21648: List[ReentrantLock] = |>(
        |>(
            channels$21633,
            (
                $0$46208 ->
                    $1$46210 ->
                        List.sortBy($0$46208, $1$46210)
            )(
                pat$145$21650 ->
                    match pat$145$21650 {
                        case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
                            id$21652,
                            _,
                            _,
                            _,
                            _,
                            _,
                            _,
                            _
                        ) =>
                            id$21652
                    }
            )
        ),
        (
            $0$46212 ->
                $1$46214 ->
                    List.map($0$46212, $1$46214)
        )(
            pat$146$21655 ->
                match pat$146$21655 {
                    case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
                        _,
                        rlock$21657,
                        _,
                        _,
                        _,
                        _,
                        _,
                        _
                    ) =>
                        rlock$21657
                }
        )
    );
    Concurrent.Channel.selectHelper(
        channels$21633,
        blocking$21638,
        sortedLocks$21648,
        selectLock$21640,
        selectCondition$21644
    )
}

def Concurrent.Channel.selectHelper(
    channels$21782: List[MpmcAdmin],
    blocking$21787: Bool,
    sortedLocks$21789: List[ReentrantLock],
    selectLock$21791: ReentrantLock,
    selectCondition$21794: Condition
): (Int32, List[ReentrantLock]) \ IO = {
    List.forEach(
        $0$46226 ->
            Concurrent.ReentrantLock.lock($0$46226),
        sortedLocks$21789
    );
    Concurrent.ReentrantLock.lock(selectLock$21791);
    let index$21807: Option[Int32] = |>(
        |>(
            |>(
                channels$21782,
                (
                    $0$46228 ->
                        $1$46230 ->
                            List.mapWithIndex($0$46228, $1$46230)
                )(
                    i$21811 ->
                        pat$147$21813 ->
                            match pat$147$21813 {
                                case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
                                    _,
                                    _,
                                    _,
                                    _,
                                    size$21815,
                                    _,
                                    _,
                                    _
                                ) =>
                                    (
                                        <[unknown exp]>(deref size$21815, 0i32),
                                        i$21811
                                    )
                            }
                )
            ),
            (
                $0$46232 ->
                    $1$46234 ->
                        List.findLeft($0$46232, $1$46234)
            )(
                pat$148$21817 ->
                    match pat$148$21817 {case (b$21819, _) => b$21819}
            )
        ),
        (
            $0$46236 ->
                $1$46238 ->
                    Option.map($0$46236, $1$46238)
        )($0$46240 -> snd($0$46240))
    );
    match index$21807 {
        case Option.Some(i$21827) =>
            (
                i$21827,
                List.append(
                    sortedLocks$21789,
                    List.Cons(selectLock$21791, List.Nil)
                )
            )
        case Option.None =>
            if (blocking$21787) {
                List.forEach(
                    (
                        $0$46242 ->
                            $1$46244 ->
                                $2$46246 ->
                                    Concurrent.Channel.addGetter(
                                        $0$46242,
                                        $1$46244,
                                        $2$46246
                                    )
                    )(selectLock$21791)(selectCondition$21794),
                    channels$21782
                );
                List.forEach(
                    $0$46248 ->
                        Concurrent.Channel.unlock($0$46248),
                    sortedLocks$21789
                );
                Concurrent.Channel.awaitCondition(selectCondition$21794);
                Concurrent.Channel.unlock(selectLock$21791);
                Concurrent.Channel.selectHelper(
                    channels$21782,
                    blocking$21787,
                    sortedLocks$21789,
                    selectLock$21791,
                    selectCondition$21794
                )
            } else {
                |>(
                    List.append(
                        sortedLocks$21789,
                        List.Cons(selectLock$21791, List.Nil)
                    ),
                    (
                        $0$46250 ->
                            $1$46252 ->
                                List.forEach($0$46250, $1$46252)
                    )($0$46254 -> Concurrent.Channel.unlock($0$46254))
                );
                (-1i32, List.Nil)
            }
    }
}

def Concurrent.Channel.signalCondition(c$21908: Condition): Unit \ IO = {
    match Concurrent.Condition.signalAll(c$21908) {
        case Result.Ok(_) =>
            ()
        case Result.Err(_) =>
            bug!("""Implementation error: lock not held""")
    }
}

def Concurrent.Channel.signalGetters(c$21851: MpmcAdmin): Unit \ IO = {
    match c$21851 {
        case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
            _,
            _,
            _,
            _,
            _,
            waitingGetters$21857,
            _,
            _
        ) =>
            let signalLockConditionPair$21859: (
                (ReentrantLock, Condition) -> Unit
            ) = pat$149$21861 ->
                match pat$149$21861 {
                    case (conditionLock$21863, condition$21866) =>
                        Concurrent.ReentrantLock.lock(conditionLock$21863);
                        Concurrent.Channel.signalCondition(condition$21866);
                        Concurrent.Channel.unlock(conditionLock$21863)
                };
            MutList.forEach(
                signalLockConditionPair$21859,
                waitingGetters$21857
            );
            MutList.clear!(waitingGetters$21857)
    }
}

def Concurrent.Channel.unlock(l$21915: ReentrantLock): Unit \ IO = {
    match Concurrent.ReentrantLock.unlock(l$21915) {
        case Result.Ok(_) =>
            ()
        case Result.Err(_) =>
            bug!("""Implementation error: lock not held""")
    }
}

def Concurrent.Channel.unsafeGetAndUnlock(
    c$21594: Mpmc[a, Static],
    locks$21596: List[ReentrantLock]
): a \ IO = {
    match c$21594 {
        case Concurrent.Channel.Mpmc.Mpmc(admin$21599, elementDeque$21603) =>
            match admin$21599 {
                case Concurrent.Channel.MpmcAdmin.MpmcAdmin(
                    _,
                    channelLock$21607,
                    _,
                    _,
                    size$21609,
                    _,
                    _,
                    _
                ) =>
                    Concurrent.ReentrantLock.lock(channelLock$21607);
                    let optionalElement$21611: Option[a] = MutDeque.popFront(
                        elementDeque$21603
                    );
                    let value$21613: a = match optionalElement$21611 {
                        case Option.None =>
                            bug!(
                                """assertiveGet could not retrieve channel element"""
                            )
                        case Option.Some(element$21615) =>
                            Ref.put(
                                <[unknown exp]>(deref size$21609, 1i32),
                                size$21609
                            );
                            Concurrent.Channel.onGetComplete(admin$21599);
                            element$21615
                    };
                    List.forEach(
                        $0$46206 ->
                            Concurrent.Channel.unlock($0$46206),
                        locks$21596
                    );
                    value$21613
            }
    }
}

enum Concurrent.Channel.Mpmc[a, _r] {case Mpmc(MpmcAdmin, MutDeque[a, Static])}

enum Concurrent.Channel.MpmcAdmin {
    case MpmcAdmin(
        Int64,
        ReentrantLock,
        Bool,
        Int32,
        Ref[Int32, Static],
        MutList[(ReentrantLock, Condition), Static],
        CyclicBarrier,
        Condition
    )
}

enum Concurrent.Condition {case Condition(java.util.concurrent.locks.Condition)}

def Concurrent.Condition.await(condition$165: Condition): Unit \ IO = {
    let await$209: (java.util.concurrent.locks.Condition -> Unit) = obj$$211 ->
        obj$$211..await();
    match condition$165 {
        case Concurrent.Condition.Condition(c$277) =>
            await$209(c$277)
    }
}

def Concurrent.Condition.awaitTimeout(
    condition$323: Condition,
    timeout$325: Int64
): Int64 \ IO = {
    let awaitNanos$327: (
        java.util.concurrent.locks.Condition -> Int64 -> Int64 \ IO
    ) = obj$$329 ->
        a0$$331 ->
            obj$$329..awaitNanos(a0$$331);
    match condition$323 {
        case Concurrent.Condition.Condition(c$333) =>
            awaitNanos$327(c$333)(timeout$325)
    }
}

def Concurrent.Condition.signal(
    condition$335: Condition
): Result[java.lang.IllegalMonitorStateException, Unit] \ IO = {
    let signal$337: (java.util.concurrent.locks.Condition -> Unit) = obj$$339 ->
        obj$$339..signal();
    match condition$335 {
        case Concurrent.Condition.Condition(c$341) =>
            try {
                Result.Ok(signal$337(c$341))
            } catch {
                case e$489: ##java.lang.IllegalMonitorStateException =>
                    Result.Err(e$489)
            }
    }
}

def Concurrent.Condition.signalAll(
    condition$1053: Condition
): Result[java.lang.IllegalMonitorStateException, Unit] \ IO = {
    let signalAll$1072: (
        java.util.concurrent.locks.Condition -> Unit
    ) = obj$$1076 ->
        obj$$1076..signalAll();
    match condition$1053 {
        case Concurrent.Condition.Condition(c$1104) =>
            try {
                Result.Ok(signalAll$1072(c$1104))
            } catch {
                case e$1126: ##java.lang.IllegalMonitorStateException =>
                    Result.Err(e$1126)
            }
    }
}

enum Concurrent.CyclicBarrier {
    case CyclicBarrier(java.util.concurrent.CyclicBarrier)
}

def Concurrent.CyclicBarrier.awaitBarrier(
    barrier$6200: CyclicBarrier
): Int32 \ IO = {
    let await$6210: (java.util.concurrent.CyclicBarrier -> Int32) = obj$$6213 ->
        obj$$6213..await();
    match barrier$6200 {
        case Concurrent.CyclicBarrier.CyclicBarrier(b$6220) =>
            await$6210(b$6220)
    }
}

def Concurrent.CyclicBarrier.newCyclicBarrier(
    parties$6170: Int32
): CyclicBarrier \ IO = {
    let newBarrier$6172: (
        Int32 -> java.util.concurrent.CyclicBarrier
    ) = a0$6174 ->
        ##java.util.concurrent.CyclicBarrier(a0$6174);
    Concurrent.CyclicBarrier.CyclicBarrier(newBarrier$6172(parties$6170))
}

enum Concurrent.ReentrantLock {
    case ReentrantLock(java.util.concurrent.locks.ReentrantLock)
}

def Concurrent.ReentrantLock.isFair(lock$16460: ReentrantLock): Bool = {
    let isFair$16468: (
        java.util.concurrent.locks.ReentrantLock -> Bool
    ) = obj$$16472 ->
        <[unknown exp]>;
    match lock$16460 {
        case Concurrent.ReentrantLock.ReentrantLock(l$16481) =>
            isFair$16468(l$16481)
    }
}

def Concurrent.ReentrantLock.lock(lock$16501: ReentrantLock): Unit \ IO = {
    let lockIt$16506: (
        java.util.concurrent.locks.ReentrantLock -> Unit
    ) = obj$$16510 ->
        obj$$16510..lock();
    match lock$16501 {
        case Concurrent.ReentrantLock.ReentrantLock(l$16512) =>
            lockIt$16506(l$16512)
    }
}

def Concurrent.ReentrantLock.lockInterruptibly(
    lock$16519: ReentrantLock
): Result[java.lang.InterruptedException, Unit] \ IO = {
    let lockInterruptibly$16527: (
        java.util.concurrent.locks.ReentrantLock -> Unit
    ) = obj$$16531 ->
        obj$$16531..lockInterruptibly();
    match lock$16519 {
        case Concurrent.ReentrantLock.ReentrantLock(l$16537) =>
            try {
                Result.Ok(lockInterruptibly$16527(l$16537))
            } catch {
                case e$16539: ##java.lang.InterruptedException =>
                    Result.Err(e$16539)
            }
    }
}

def Concurrent.ReentrantLock.newCondition(
    lock$16544: ReentrantLock
): Condition \ IO = {
    let newCondition$16557: (
        java.util.concurrent.locks.ReentrantLock ->
            java.util.concurrent.locks.Condition
    ) = obj$$16559 ->
        obj$$16559..newCondition();
    match lock$16544 {
        case Concurrent.ReentrantLock.ReentrantLock(l$16576) =>
            Concurrent.Condition.Condition(newCondition$16557(l$16576))
    }
}

def Concurrent.ReentrantLock.newLock(fair$16428: Bool): ReentrantLock \ IO = {
    let reentrantLock$16443: (
        Bool -> java.util.concurrent.locks.ReentrantLock
    ) = a0$16445 ->
        ##java.util.concurrent.locks.ReentrantLock(a0$16445);
    Concurrent.ReentrantLock.ReentrantLock(reentrantLock$16443(fair$16428))
}

def Concurrent.ReentrantLock.tryLock(lock$16596: ReentrantLock): Bool \ IO = {
    let tryLock$16604: (
        java.util.concurrent.locks.ReentrantLock -> Bool
    ) = obj$$16606 ->
        obj$$16606..tryLock();
    match lock$16596 {
        case Concurrent.ReentrantLock.ReentrantLock(l$16613) =>
            tryLock$16604(l$16613)
    }
}

def Concurrent.ReentrantLock.tryLockNanos(
    lock$16636: ReentrantLock,
    nanosTimeout$16638: Int64
): Result[java.lang.InterruptedException, Bool] \ IO = {
    let tryLock$16645: (
        java.util.concurrent.locks.ReentrantLock ->
            Int64 -> (java.util.concurrent.TimeUnit -> Bool \ IO)
    ) = obj$$16651 ->
        a0$$16655 ->
            a1$$16657 ->
                obj$$16651..tryLock(a0$$16655, a1$$16657);
    let nano$16666: (Unit -> java.util.concurrent.TimeUnit) = _$16669 ->
        ##java.util.concurrent.TimeUnit.NANOSECONDS;
    match lock$16636 {
        case Concurrent.ReentrantLock.ReentrantLock(l$16671) =>
            try {
                Result.Ok(
                    tryLock$16645(l$16671)(nanosTimeout$16638)(nano$16666(()))
                )
            } catch {
                case e$16673: ##java.lang.InterruptedException =>
                    Result.Err(e$16673)
            }
    }
}

def Concurrent.ReentrantLock.unlock(
    lock$16684: ReentrantLock
): Result[java.lang.IllegalMonitorStateException, Unit] \ IO = {
    let unlock$16692: (
        java.util.concurrent.locks.ReentrantLock -> Unit
    ) = obj$$16694 ->
        obj$$16694..unlock();
    match lock$16684 {
        case Concurrent.ReentrantLock.ReentrantLock(l$16702) =>
            try {
                Result.Ok(unlock$16692(l$16702))
            } catch {
                case e$16704: ##java.lang.IllegalMonitorStateException =>
                    Result.Err(e$16704)
            }
    }
}

def Console.applyFontStyle(s$6877: a, style$6879: (String, String)): String = {
    let esc$6885: String = Console.escape(());
    let reset$6889: String = Console.reset(());
    match Console.colorSupport(()) {
        case Console.ColorSupport.None =>
            <[unknown exp]>(s$6877)
        case Console.ColorSupport.Ansi =>
            <[unknown exp]>(
                <[unknown exp]>(
                    <[unknown exp]>(
                        <[unknown exp]>(esc$6885, fst(style$6879)),
                        <[unknown exp]>(s$6877)
                    ),
                    esc$6885
                ),
                reset$6889
            )
        case Console.ColorSupport.TrueColor =>
            <[unknown exp]>(
                <[unknown exp]>(
                    <[unknown exp]>(
                        <[unknown exp]>(esc$6885, snd(style$6879)),
                        <[unknown exp]>(s$6877)
                    ),
                    esc$6885
                ),
                reset$6889
            )
    }
}

def Console.bgBlack(s$7301: a): String = {
    Console.rgb(
        |>(Console.Ansi.BackgroundBlack, $0$45546 -> Console.toRGB($0$45546)),
        <[unknown exp]>(s$7301),
        {+isFg = false | {}}
    )
}

def Console.bgBlackBright(s$7432: a): String = {
    Console.rgb(
        |>(
            Console.Ansi.BackgroundBrightBlack,
            $0$45562 ->
                Console.toRGB($0$45562)
        ),
        <[unknown exp]>(s$7432),
        {+isFg = false | {}}
    )
}

def Console.bgBlue(s$7353: a): String = {
    Console.rgb(
        |>(Console.Ansi.BackgroundBlue, $0$45554 -> Console.toRGB($0$45554)),
        <[unknown exp]>(s$7353),
        {+isFg = false | {}}
    )
}

def Console.bgBlueBright(s$7520: a): String = {
    Console.rgb(
        |>(
            Console.Ansi.BackgroundBrightBlue,
            $0$45570 ->
                Console.toRGB($0$45570)
        ),
        <[unknown exp]>(s$7520),
        {+isFg = false | {}}
    )
}

def Console.bgCyan(s$7390: a): String = {
    Console.rgb(
        |>(Console.Ansi.BackgroundCyan, $0$45558 -> Console.toRGB($0$45558)),
        <[unknown exp]>(s$7390),
        {+isFg = false | {}}
    )
}

def Console.bgCyanBright(s$7555: a): String = {
    Console.rgb(
        |>(
            Console.Ansi.BackgroundBrightCyan,
            $0$45574 ->
                Console.toRGB($0$45574)
        ),
        <[unknown exp]>(s$7555),
        {+isFg = false | {}}
    )
}

def Console.bgGreen(s$7325: a): String = {
    Console.rgb(
        |>(Console.Ansi.BackgroundGreen, $0$45550 -> Console.toRGB($0$45550)),
        <[unknown exp]>(s$7325),
        {+isFg = false | {}}
    )
}

def Console.bgGreenBright(s$7479: a): String = {
    Console.rgb(
        |>(
            Console.Ansi.BackgroundBrightGreen,
            $0$45566 ->
                Console.toRGB($0$45566)
        ),
        <[unknown exp]>(s$7479),
        {+isFg = false | {}}
    )
}

def Console.bgMagenta(s$7378: a): String = {
    Console.rgb(
        |>(Console.Ansi.BackgroundMagenta, $0$45556 -> Console.toRGB($0$45556)),
        <[unknown exp]>(s$7378),
        {+isFg = false | {}}
    )
}

def Console.bgMagentaBright(s$7531: a): String = {
    Console.rgb(
        |>(
            Console.Ansi.BackgroundBrightMagenta,
            $0$45572 ->
                Console.toRGB($0$45572)
        ),
        <[unknown exp]>(s$7531),
        {+isFg = false | {}}
    )
}

def Console.bgRed(s$7314: a): String = {
    Console.rgb(
        |>(Console.Ansi.BackgroundRed, $0$45548 -> Console.toRGB($0$45548)),
        <[unknown exp]>(s$7314),
        {+isFg = false | {}}
    )
}

def Console.bgRedBright(s$7461: a): String = {
    Console.rgb(
        |>(
            Console.Ansi.BackgroundBrightRed,
            $0$45564 ->
                Console.toRGB($0$45564)
        ),
        <[unknown exp]>(s$7461),
        {+isFg = false | {}}
    )
}

def Console.bgWhite(s$7400: a): String = {
    Console.rgb(
        |>(Console.Ansi.BackgroundWhite, $0$45560 -> Console.toRGB($0$45560)),
        <[unknown exp]>(s$7400),
        {+isFg = false | {}}
    )
}

def Console.bgWhiteBright(s$7581: a): String = {
    Console.rgb(
        |>(
            Console.Ansi.BackgroundBrightWhite,
            $0$45576 ->
                Console.toRGB($0$45576)
        ),
        <[unknown exp]>(s$7581),
        {+isFg = false | {}}
    )
}

def Console.bgYellow(s$7340: a): String = {
    Console.rgb(
        |>(Console.Ansi.BackgroundYellow, $0$45552 -> Console.toRGB($0$45552)),
        <[unknown exp]>(s$7340),
        {+isFg = false | {}}
    )
}

def Console.bgYellowBright(s$7498: a): String = {
    Console.rgb(
        |>(
            Console.Ansi.BackgroundBrightYellow,
            $0$45568 ->
                Console.toRGB($0$45568)
        ),
        <[unknown exp]>(s$7498),
        {+isFg = false | {}}
    )
}

def Console.black(s$7155: a): String = {
    Console.rgb(
        |>(Console.Ansi.Black, $0$45520 -> Console.toRGB($0$45520)),
        <[unknown exp]>(s$7155),
        {+isFg = true | {}}
    )
}

def Console.blackBright(s$7180: a): String = {
    Console.rgb(
        |>(Console.Ansi.BrightBlack, $0$45522 -> Console.toRGB($0$45522)),
        <[unknown exp]>(s$7180),
        {+isFg = true | {}}
    )
}

def Console.blink(s$6820: a): String = {
    let blink$6823: (String, String) = ("""[5m""", """[38;2;5m""");
    Console.applyFontStyle(s$6820, blink$6823)
}

def Console.blue(s$7080: a): String = {
    Console.rgb(
        |>(Console.Ansi.Blue, $0$45506 -> Console.toRGB($0$45506)),
        <[unknown exp]>(s$7080),
        {+isFg = true | {}}
    )
}

def Console.blueBright(s$7246: a): String = {
    Console.rgb(
        |>(Console.Ansi.BrightBlue, $0$45530 -> Console.toRGB($0$45530)),
        <[unknown exp]>(s$7246),
        {+isFg = true | {}}
    )
}

def Console.bold(s$6768: a): String = {
    let bold$6772: (String, String) = ("""[1m""", """[38;2;1m""");
    Console.applyFontStyle(s$6768, bold$6772)
}

def Console.colorSupport(_unit$8025: Unit): ColorSupport = {
    if (Console.isTrueColorTerminal(()) or Console.isWindowsTerminal(())) {
        Console.ColorSupport.TrueColor
    } else {
        if (Console.isAnsiTerminal(())) {
            Console.ColorSupport.Ansi
        } else {
            Console.ColorSupport.None
        }
    }
}

def Console.console(_unit$7010: Unit): Option[java.io.Console] \ IO = {
    let getConsole$7020: (Unit -> java.io.Console) = _$7022 ->
        ##java.lang.System.console();
    |>(getConsole$7020(()), $0$45504 -> Object.toOption($0$45504))
}

def Console.cyan(s$7096: a): String = {
    Console.rgb(
        |>(Console.Ansi.Cyan, $0$45508 -> Console.toRGB($0$45508)),
        <[unknown exp]>(s$7096),
        {+isFg = true | {}}
    )
}

def Console.cyanBright(s$7273: a): String = {
    Console.rgb(
        |>(Console.Ansi.BrightCyan, $0$45538 -> Console.toRGB($0$45538)),
        <[unknown exp]>(s$7273),
        {+isFg = true | {}}
    )
}

def Console.distanceSquared(
    c1$7822: (Int32, Int32, Int32),
    c2$7824: (Int32, Int32, Int32)
): Int32 = {
    match c1$7822 {
        case (r1$7837, g1$7841, b1$7843) =>
            match c2$7824 {
                case (r2$7850, g2$7853, b2$7856) =>
                    <[unknown exp]>(
                        <[unknown exp]>(
                            <[unknown exp]>(
                                <[unknown exp]>(r1$7837, r2$7850),
                                <[unknown exp]>(r1$7837, r2$7850)
                            ),
                            <[unknown exp]>(
                                <[unknown exp]>(g1$7841, g2$7853),
                                <[unknown exp]>(g1$7841, g2$7853)
                            )
                        ),
                        <[unknown exp]>(
                            <[unknown exp]>(b1$7843, b2$7856),
                            <[unknown exp]>(b1$7843, b2$7856)
                        )
                    )
            }
    }
}

def Console.downsample(
    c$7730: (Int32, Int32, Int32),
    isFg$7732: Bool
): Int32 = {
    let candidates$7734: List[Ansi] = if (isFg$7732) {
        List.Cons(
            Console.Ansi.Black,
            List.Cons(
                Console.Ansi.Red,
                List.Cons(
                    Console.Ansi.Green,
                    List.Cons(
                        Console.Ansi.Yellow,
                        List.Cons(
                            Console.Ansi.Blue,
                            List.Cons(
                                Console.Ansi.Magenta,
                                List.Cons(
                                    Console.Ansi.Cyan,
                                    List.Cons(
                                        Console.Ansi.White,
                                        List.Cons(
                                            Console.Ansi.BrightBlack,
                                            List.Cons(
                                                Console.Ansi.BrightRed,
                                                List.Cons(
                                                    Console.Ansi.BrightGreen,
                                                    List.Cons(
                                                        Console.Ansi.BrightYellow,
                                                        List.Cons(
                                                            Console.Ansi.BrightBlue,
                                                            List.Cons(
                                                                Console.Ansi.BrightMagenta,
                                                                List.Cons(
                                                                    Console.Ansi.BrightCyan,
                                                                    List.Cons(
                                                                        Console.Ansi.BrightWhite,
                                                                        List.Nil
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    } else {
        List.Cons(
            Console.Ansi.BackgroundBlack,
            List.Cons(
                Console.Ansi.BackgroundRed,
                List.Cons(
                    Console.Ansi.BackgroundGreen,
                    List.Cons(
                        Console.Ansi.BackgroundYellow,
                        List.Cons(
                            Console.Ansi.BackgroundBlue,
                            List.Cons(
                                Console.Ansi.BackgroundMagenta,
                                List.Cons(
                                    Console.Ansi.BackgroundCyan,
                                    List.Cons(
                                        Console.Ansi.BackgroundWhite,
                                        List.Cons(
                                            Console.Ansi.BackgroundBrightBlack,
                                            List.Cons(
                                                Console.Ansi.BackgroundBrightRed,
                                                List.Cons(
                                                    Console.Ansi.BackgroundBrightGreen,
                                                    List.Cons(
                                                        Console.Ansi.BackgroundBrightYellow,
                                                        List.Cons(
                                                            Console.Ansi.BackgroundBrightBlue,
                                                            List.Cons(
                                                                Console.Ansi.BackgroundBrightMagenta,
                                                                List.Cons(
                                                                    Console.Ansi.BackgroundBrightCyan,
                                                                    List.Cons(
                                                                        Console.Ansi.BackgroundBrightWhite,
                                                                        List.Nil
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    };
    |>(
        Console.nearest(
            c$7730,
            Console.Ansi.BackgroundBlack,
            Int32.maxValue(()),
            candidates$7734
        ),
        $0$45578 ->
            Console.toAnsi($0$45578)
    )
}

def Console.escape(_unit$7982: Unit): String = {Char.toString('''''')}

def Console.flush(_unit$6747: Unit): Unit \ IO = {
    let consoleFlush$6749: (java.io.Console -> Unit) = obj$$6751 ->
        obj$$6751..flush();
    |>(
        Console.console(()),
        (
            $0$45482 ->
                $1$45484 ->
                    Option.forEach($0$45482, $1$45484)
        )(consoleFlush$6749)
    )
}

def Console.formatAnsi(color$7863: Int32, s$7865: String): String = {
    let esc$7874: String = Console.escape(());
    <[unknown exp]>(
        <[unknown exp]>(
            <[unknown exp]>(
                <[unknown exp]>(
                    <[unknown exp]>(
                        <[unknown exp]>(esc$7874, """["""),
                        Int32.toString(color$7863)
                    ),
                    """m"""
                ),
                s$7865
            ),
            esc$7874
        ),
        """[0m"""
    )
}

def Console.formatTrueColor(
    c$7898: (Int32, Int32, Int32),
    s$7908: String,
    isFg$7914: Bool
): String = {
    match c$7898 {
        case (r$7934, g$7938, b$7940) =>
            let esc$7944: String = Console.escape(());
            let red$7946: String = Int32.toString(r$7934);
            let gre$7948: String = Int32.toString(g$7938);
            let blu$7950: String = Int32.toString(b$7940);
            if (isFg$7914) {
                <[unknown exp]>(
                    <[unknown exp]>(
                        <[unknown exp]>(
                            <[unknown exp]>(
                                <[unknown exp]>(
                                    <[unknown exp]>(
                                        <[unknown exp]>(
                                            <[unknown exp]>(
                                                <[unknown exp]>(
                                                    <[unknown exp]>(
                                                        esc$7944,
                                                        """[38;2;"""
                                                    ),
                                                    red$7946
                                                ),
                                                """;"""
                                            ),
                                            gre$7948
                                        ),
                                        """;"""
                                    ),
                                    blu$7950
                                ),
                                """m"""
                            ),
                            s$7908
                        ),
                        esc$7944
                    ),
                    """[0m"""
                )
            } else {
                <[unknown exp]>(
                    <[unknown exp]>(
                        <[unknown exp]>(
                            <[unknown exp]>(
                                <[unknown exp]>(
                                    <[unknown exp]>(
                                        <[unknown exp]>(
                                            <[unknown exp]>(
                                                <[unknown exp]>(
                                                    <[unknown exp]>(
                                                        esc$7944,
                                                        """[48;2;"""
                                                    ),
                                                    red$7946
                                                ),
                                                """;"""
                                            ),
                                            gre$7948
                                        ),
                                        """;"""
                                    ),
                                    blu$7950
                                ),
                                """m"""
                            ),
                            s$7908
                        ),
                        esc$7944
                    ),
                    """[0m"""
                )
            }
    }
}

def Console.green(s$7113: a): String = {
    Console.rgb(
        |>(Console.Ansi.Green, $0$45510 -> Console.toRGB($0$45510)),
        <[unknown exp]>(s$7113),
        {+isFg = true | {}}
    )
}

def Console.greenBright(s$7221: a): String = {
    Console.rgb(
        |>(Console.Ansi.BrightGreen, $0$45526 -> Console.toRGB($0$45526)),
        <[unknown exp]>(s$7221),
        {+isFg = true | {}}
    )
}

def Console.hasConsole(_unit$6607: Unit): Bool \ IO = {
    let console$6611: (Unit -> java.io.Console) = _$6613 ->
        ##java.lang.System.console();
    !Object.isNull(console$6611(()))
}

def Console.hex(hexCode$6909: String, s$6911: a): String = {
    let text$6921: String = <[unknown exp]>(s$6911);
    let hexOpt$6925: Option[String] = <[unknown exp]>(
        pat$33$6929 ->
            match pat$33$6929 {
                case hex$6935 =>
                    if (<[unknown exp]>(String.length(hex$6935), 6i32)) {
                        <[unknown exp]>(
                            pat$32$6937 ->
                                match pat$32$6937 {
                                    case r$6940 =>
                                        <[unknown exp]>(
                                            pat$31$6948 ->
                                                match pat$31$6948 {
                                                    case g$6954 =>
                                                        <[unknown exp]>(
                                                            pat$30$6956 ->
                                                                match pat$30$6956 {
                                                                    case b$6959 =>
                                                                        <[unknown exp]>(
                                                                            Console.rgb(
                                                                                (
                                                                                    r$6940,
                                                                                    g$6954,
                                                                                    b$6959
                                                                                ),
                                                                                text$6921,
                                                                                {
                                                                                    +isFg = true |
                                                                                    {}
                                                                                }
                                                                            )
                                                                        )
                                                                },
                                                            |>(
                                                                String.slice(
                                                                    {
                                                                        +start = 4i32 |
                                                                        {}
                                                                    },
                                                                    {
                                                                        +end = 6i32 |
                                                                        {}
                                                                    },
                                                                    hex$6935
                                                                ),
                                                                $0$45494 ->
                                                                    Console.stringToHex(
                                                                        $0$45494
                                                                    )
                                                            )
                                                        )
                                                },
                                            |>(
                                                String.slice(
                                                    {+start = 2i32 | {}},
                                                    {+end = 4i32 | {}},
                                                    hex$6935
                                                ),
                                                $0$45496 ->
                                                    Console.stringToHex(
                                                        $0$45496
                                                    )
                                            )
                                        )
                                },
                            |>(
                                String.sliceLeft({+end = 2i32 | {}}, hex$6935),
                                $0$45498 ->
                                    Console.stringToHex($0$45498)
                            )
                        )
                    } else {
                        <[unknown exp]>(())
                    }
            },
        String.stripPrefix({+substr = """#""" | {}}, hexCode$6909)
    ): Option[String];
    |>(
        hexOpt$6925,
        (
            $0$45500 ->
                $1$45502 ->
                    Option.getWithDefault($0$45500, $1$45502)
        )(text$6921)
    )
}

def Console.invisible(s$6858: a): String = {
    let invisible$6865: (String, String) = ("""[8m""", """[38;2;8m""");
    Console.applyFontStyle(s$6858, invisible$6865)
}

def Console.isAnsiTerminal(_unit$8027: Unit): Bool = {
    |>(
        Environment.getVar("""TERM"""),
        (
            $0$45598 ->
                $1$45600 ->
                    Option.exists($0$45598, $1$45600)
        )(
            p$8036 ->
                {
                    let keywords$8038: List[String] = List.Cons(
                        """256""",
                        List.Cons(
                            """ansi""",
                            List.Cons(
                                """xterm""",
                                List.Cons("""screen""", List.Nil)
                            )
                        )
                    );
                    List.exists(
                        s$8040 ->
                            String.contains({+substr = s$8040 | {}}, p$8036),
                        keywords$8038
                    )
                }
        )
    )
}

def Console.isTrueColorTerminal(_unit$8057: Unit): Bool = {
    |>(
        Environment.getVar("""COLORTERM"""),
        (
            $0$45608 ->
                $1$45610 ->
                    Option.exists($0$45608, $1$45610)
        )(p$8061 -> <[unknown exp]>(p$8061, """truecolor"""))
    )
}

def Console.isWindowsTerminal(_unit$8074: Unit): Bool = {
    !|>(
        Environment.getVar("""WT_SESSION"""),
        $0$45612 ->
            Option.isEmpty($0$45612)
    )
}

def Console.italic(s$6780: a): String = {
    let italic$6787: (String, String) = ("""[3m""", """[38;2;3m""");
    Console.applyFontStyle(s$6780, italic$6787)
}

def Console.magenta(s$7119: a): String = {
    Console.rgb(
        |>(Console.Ansi.Magenta, $0$45512 -> Console.toRGB($0$45512)),
        <[unknown exp]>(s$7119),
        {+isFg = true | {}}
    )
}

def Console.magentaBright(s$7259: a): String = {
    Console.rgb(
        |>(Console.Ansi.BrightMagenta, $0$45536 -> Console.toRGB($0$45536)),
        <[unknown exp]>(s$7259),
        {+isFg = true | {}}
    )
}

def Console.nearest(
    target$7782: (Int32, Int32, Int32),
    bestCandidate$7788: Ansi,
    bestDistance$7790: Int32,
    candidates$7794: List[Ansi]
): Ansi = {
    match candidates$7794 {
        case List.Nil =>
            bestCandidate$7788
        case List.Cons(currentCandidate$7798, remainingCandidates$7800) =>
            let currentDistance$7802: Int32 = Console.distanceSquared(
                target$7782,
                Console.toRGB(currentCandidate$7798)
            );
            if (<[unknown exp]>(currentDistance$7802, bestDistance$7790)) {
                Console.nearest(
                    target$7782,
                    currentCandidate$7798,
                    currentDistance$7802,
                    remainingCandidates$7800
                )
            } else {
                Console.nearest(
                    target$7782,
                    bestCandidate$7788,
                    bestDistance$7790,
                    remainingCandidates$7800
                )
            }
    }
}

def Console.print(x$6689: a): Unit \ IO = {
    let writer$6696: (java.io.Console -> java.io.PrintWriter) = obj$$6699 ->
        obj$$6699..writer();
    let printWriterPrint$6710: (
        java.io.PrintWriter -> String -> Unit \ IO
    ) = obj$$6712 ->
        a0$$6716 ->
            obj$$6712..print(a0$$6716);
    |>(
        Console.console(()),
        (
            $0$45470 ->
                $1$45472 ->
                    Option.forEach($0$45470, $1$45472)
        )(
            c$6719 ->
                printWriterPrint$6710(
                    writer$6696(c$6719)
                )(<[unknown exp]>(x$6689))
        )
    )
}

def Console.println(x$6723: a): Unit \ IO = {
    let writer$6730: (java.io.Console -> java.io.PrintWriter) = obj$$6734 ->
        obj$$6734..writer();
    let printWriterPrintln$6736: (
        java.io.PrintWriter -> String -> Unit \ IO
    ) = obj$$6738 ->
        a0$$6740 ->
            obj$$6738..println(a0$$6740);
    |>(
        Console.console(()),
        (
            $0$45478 ->
                $1$45480 ->
                    Option.forEach($0$45478, $1$45480)
        )(
            c$6743 ->
                printWriterPrintln$6736(
                    writer$6730(c$6743)
                )(<[unknown exp]>(x$6723))
        )
    )
}

def Console.readLine(_unit$6638: Unit): Result[String, String] \ IO = {
    let consoleReadLine$6642: (java.io.Console -> String) = obj$$6644 ->
        obj$$6644..readLine();
    try {
        match Console.console(()) {
            case Option.Some(c$6651) =>
                let line$6653: String = consoleReadLine$6642(c$6651);
                if (Object.isNull(line$6653)) {
                    Result.Err("""EOF""")
                } else {
                    Result.Ok(line$6653)
                }
            case Option.None =>
                Result.Err("""No JVM console""")
        }
    } catch {
        case e$6665: ##java.io.IOError =>
            let getMessage$6667: (java.lang.Throwable -> String) = obj$$6672 ->
                obj$$6672..getMessage();
            Result.Err(getMessage$6667(<[unknown exp]>))
    }
}

def Console.red(s$7126: a): String = {
    Console.rgb(
        |>(Console.Ansi.Red, $0$45514 -> Console.toRGB($0$45514)),
        <[unknown exp]>(s$7126),
        {+isFg = true | {}}
    )
}

def Console.redBright(s$7199: a): String = {
    Console.rgb(
        |>(Console.Ansi.BrightRed, $0$45524 -> Console.toRGB($0$45524)),
        <[unknown exp]>(s$7199),
        {+isFg = true | {}}
    )
}

def Console.reset(_unit$7993: Unit): String = {"""[0m"""}

def Console.reversed(s$6836: a): String = {
    let reversed$6842: (String, String) = ("""[7m""", """[38;2;7m""");
    Console.applyFontStyle(s$6836, reversed$6842)
}

def Console.rgb(
    c$7058: (Int32, Int32, Int32),
    s$7061: String,
    opts$7063: { isFg = Bool }
): String = {
    match Console.colorSupport(()) {
        case Console.ColorSupport.None =>
            s$7061
        case Console.ColorSupport.Ansi =>
            let color$7073: Int32 = Console.downsample(c$7058, opts$7063.isFg);
            Console.formatAnsi(color$7073, s$7061)
        case Console.ColorSupport.TrueColor =>
            Console.formatTrueColor(c$7058, s$7061, opts$7063.isFg)
    }
}

def Console.stringToHex(hexNo$7032: String): Option[Int32] = {
    let parseInt$7034: (String -> Int32 -> Int32) = a0$$7036 ->
        a1$$7038 ->
            <[unknown exp]>;
    try {
        Option.Some(parseInt$7034(hexNo$7032)(16i32))
    } catch {case _$7046: ##java.lang.NumberFormatException => Option.None}
}

def Console.toAnsi(c$7613: Ansi): Int32 = {
    match c$7613 {
        case Console.Ansi.Black =>
            30i32
        case Console.Ansi.Red =>
            31i32
        case Console.Ansi.Green =>
            32i32
        case Console.Ansi.Yellow =>
            33i32
        case Console.Ansi.Blue =>
            34i32
        case Console.Ansi.Magenta =>
            35i32
        case Console.Ansi.Cyan =>
            36i32
        case Console.Ansi.White =>
            37i32
        case Console.Ansi.BrightBlack =>
            90i32
        case Console.Ansi.BrightRed =>
            91i32
        case Console.Ansi.BrightGreen =>
            92i32
        case Console.Ansi.BrightYellow =>
            93i32
        case Console.Ansi.BrightBlue =>
            94i32
        case Console.Ansi.BrightMagenta =>
            95i32
        case Console.Ansi.BrightCyan =>
            96i32
        case Console.Ansi.BrightWhite =>
            97i32
        case Console.Ansi.BackgroundBlack =>
            40i32
        case Console.Ansi.BackgroundRed =>
            41i32
        case Console.Ansi.BackgroundGreen =>
            42i32
        case Console.Ansi.BackgroundYellow =>
            43i32
        case Console.Ansi.BackgroundBlue =>
            44i32
        case Console.Ansi.BackgroundMagenta =>
            45i32
        case Console.Ansi.BackgroundCyan =>
            46i32
        case Console.Ansi.BackgroundWhite =>
            47i32
        case Console.Ansi.BackgroundBrightBlack =>
            100i32
        case Console.Ansi.BackgroundBrightRed =>
            101i32
        case Console.Ansi.BackgroundBrightGreen =>
            102i32
        case Console.Ansi.BackgroundBrightYellow =>
            103i32
        case Console.Ansi.BackgroundBrightBlue =>
            104i32
        case Console.Ansi.BackgroundBrightMagenta =>
            105i32
        case Console.Ansi.BackgroundBrightCyan =>
            106i32
        case Console.Ansi.BackgroundBrightWhite =>
            107i32
    }
}

def Console.toRGB(c$7644: Ansi): (Int32, Int32, Int32) = {
    match c$7644 {
        case Console.Ansi.Black =>
            (1i32, 1i32, 1i32)
        case Console.Ansi.Red =>
            (222i32, 56i32, 43i32)
        case Console.Ansi.Green =>
            (57i32, 181i32, 74i32)
        case Console.Ansi.Yellow =>
            (255i32, 199i32, 6i32)
        case Console.Ansi.Blue =>
            (0i32, 111i32, 184i32)
        case Console.Ansi.Magenta =>
            (118i32, 38i32, 113i32)
        case Console.Ansi.Cyan =>
            (44i32, 181i32, 233i32)
        case Console.Ansi.White =>
            (204i32, 204i32, 204i32)
        case Console.Ansi.BrightBlack =>
            (128i32, 128i32, 128i32)
        case Console.Ansi.BrightRed =>
            (255i32, 0i32, 0i32)
        case Console.Ansi.BrightGreen =>
            (0i32, 255i32, 0i32)
        case Console.Ansi.BrightYellow =>
            (255i32, 255i32, 0i32)
        case Console.Ansi.BrightBlue =>
            (0i32, 0i32, 255i32)
        case Console.Ansi.BrightMagenta =>
            (255i32, 0i32, 255i32)
        case Console.Ansi.BrightCyan =>
            (0i32, 255i32, 255i32)
        case Console.Ansi.BrightWhite =>
            (255i32, 255i32, 255i32)
        case Console.Ansi.BackgroundBlack =>
            (1i32, 1i32, 1i32)
        case Console.Ansi.BackgroundRed =>
            (222i32, 56i32, 43i32)
        case Console.Ansi.BackgroundGreen =>
            (57i32, 181i32, 74i32)
        case Console.Ansi.BackgroundYellow =>
            (255i32, 199i32, 6i32)
        case Console.Ansi.BackgroundBlue =>
            (0i32, 111i32, 184i32)
        case Console.Ansi.BackgroundMagenta =>
            (118i32, 38i32, 113i32)
        case Console.Ansi.BackgroundCyan =>
            (44i32, 181i32, 233i32)
        case Console.Ansi.BackgroundWhite =>
            (204i32, 204i32, 204i32)
        case Console.Ansi.BackgroundBrightBlack =>
            (128i32, 128i32, 128i32)
        case Console.Ansi.BackgroundBrightRed =>
            (255i32, 0i32, 0i32)
        case Console.Ansi.BackgroundBrightGreen =>
            (0i32, 255i32, 0i32)
        case Console.Ansi.BackgroundBrightYellow =>
            (255i32, 255i32, 0i32)
        case Console.Ansi.BackgroundBrightBlue =>
            (0i32, 0i32, 255i32)
        case Console.Ansi.BackgroundBrightMagenta =>
            (255i32, 0i32, 255i32)
        case Console.Ansi.BackgroundBrightCyan =>
            (0i32, 255i32, 255i32)
        case Console.Ansi.BackgroundBrightWhite =>
            (255i32, 255i32, 255i32)
    }
}

def Console.underline(s$6799: a): String = {
    let underline$6805: (String, String) = ("""[4m""", """[38;2;4m""");
    Console.applyFontStyle(s$6799, underline$6805)
}

def Console.white(s$7150: a): String = {
    Console.rgb(
        |>(Console.Ansi.White, $0$45518 -> Console.toRGB($0$45518)),
        <[unknown exp]>(s$7150),
        {+isFg = true | {}}
    )
}

def Console.whiteBright(s$7289: a): String = {
    Console.rgb(
        |>(Console.Ansi.BrightWhite, $0$45540 -> Console.toRGB($0$45540)),
        <[unknown exp]>(s$7289),
        {+isFg = true | {}}
    )
}

def Console.yellow(s$7137: a): String = {
    Console.rgb(
        |>(Console.Ansi.Yellow, $0$45516 -> Console.toRGB($0$45516)),
        <[unknown exp]>(s$7137),
        {+isFg = true | {}}
    )
}

def Console.yellowBright(s$7230: a): String = {
    Console.rgb(
        |>(Console.Ansi.BrightYellow, $0$45528 -> Console.toRGB($0$45528)),
        <[unknown exp]>(s$7230),
        {+isFg = true | {}}
    )
}

enum Console.Ansi {
    case BackgroundBlack(Unit)
    case White(Unit)
    case BrightWhite(Unit)
    case BackgroundBrightRed(Unit)
    case BrightBlack(Unit)
    case Black(Unit)
    case BackgroundBrightYellow(Unit)
    case BackgroundYellow(Unit)
    case BrightRed(Unit)
    case BrightBlue(Unit)
    case BackgroundBlue(Unit)
    case Cyan(Unit)
    case BrightMagenta(Unit)
    case BackgroundBrightWhite(Unit)
    case BrightYellow(Unit)
    case BackgroundCyan(Unit)
    case BackgroundBrightCyan(Unit)
    case BackgroundMagenta(Unit)
    case BackgroundBrightBlue(Unit)
    case BackgroundBrightMagenta(Unit)
    case BrightCyan(Unit)
    case Red(Unit)
    case Yellow(Unit)
    case BackgroundBrightBlack(Unit)
    case BackgroundWhite(Unit)
    case Magenta(Unit)
    case Green(Unit)
    case BrightGreen(Unit)
    case Blue(Unit)
    case BackgroundGreen(Unit)
    case BackgroundRed(Unit)
    case BackgroundBrightGreen(Unit)
}

enum Console.ColorSupport {case None(Unit) case Ansi(Unit) case TrueColor(Unit)}

def Debug.debugWithPrefix(prefix$36101: String, x$36103: a): a \ IO = {
    let getOut$36105: (Unit -> java.io.PrintStream) = _$36107 ->
        ##java.lang.System.out;
    let println$36109: (
        java.io.PrintStream -> String -> Unit \ IO
    ) = obj$$36111 ->
        a0$$36113 ->
            obj$$36111..println(a0$$36113);
    println$36109(
        getOut$36105(())
    )(("""""" + <[unknown exp]>(prefix$36101)) + Debug.stringify(x$36103));
    x$36103
}

def Debug.escape(s$36172: String): String = {
    let jReplace$36178: (
        String -> java.lang.CharSequence -> (java.lang.CharSequence -> String)
    ) = obj$$36180 ->
        a0$$36182 ->
            a1$$36186 ->
                <[unknown exp]>;
    letrec replace$36191: (
        String -> String -> (String -> String)
    ) = src$36195 ->
        dst$36197 ->
            subject$36199 ->
                jReplace$36178(
                    subject$36199
                )(<[unknown exp]>)(<[unknown exp]>): String;
    |>(
        |>(
            |>(
                |>(
                    |>(
                        |>(s$36172, replace$36191("""\""")("""\\""")),
                        replace$36191("""
""")("""\n""")
                    ),
                    replace$36191("""""")("""\r""")
                ),
                replace$36191(""""""")("""\"""")
            ),
            replace$36191("""'""")("""\'""")
        ),
        replace$36191("""	""")("""\t""")
    )
}

def Debug.stringify(x$36234: a): String = {
    let isNull$36249: (java.lang.Object -> Bool) = a0$$36252 ->
        <[unknown exp]>;
    <[unknown exp]>
}

enum DelayList[a] {
    case ENil(Unit)
    case ECons(a, DelayList[a])
    case LCons(a, Lazy[DelayList[a]])
    case LList(Lazy[DelayList[a]])
}

def DelayList.ap(
    f$17838: DelayList[a -> b \ ef],
    l$17843: DelayList[a]
): DelayList[b] \ ef = {
    DelayList.flatMap(g$17851 -> DelayList.map(g$17851, l$17843), f$17838)
}

def DelayList.append(
    l1$16676: DelayList[a],
    l2$16682: DelayList[a]
): DelayList[a] = {
    match l1$16676 {
        case DelayList.ENil =>
            l2$16682
        case DelayList.ECons(x$16688, xs$16690) =>
            DelayList.LCons(x$16688, lazy DelayList.append(xs$16690, l2$16682))
        case DelayList.LCons(x$16696, xs$16698) =>
            DelayList.LCons(
                x$16696,
                lazy DelayList.append(force xs$16698, l2$16682)
            )
        case DelayList.LList(xs$16700) =>
            DelayList.LList(lazy DelayList.append(force xs$16700, l2$16682))
    }
}

def DelayList.consA(
    mx$20359: f[a],
    ml$20364: f[DelayList[a]]
): f[DelayList[a]] = {
    <[unknown exp]>(
        <[unknown exp]>(
            x$20372 ->
                xs$20374 ->
                    DelayList.ECons(x$20372, xs$20374),
            mx$20359
        ),
        ml$20364
    )
}

def DelayList.count(f$16718: a -> Bool, l$16722: DelayList[a]): Int32 \ ef = {
    DelayList.foldLeft(
        i$16732 ->
            x$16738 ->
                if (f$16718(x$16738)) {
                    <[unknown exp]>(i$16732, 1i32)
                } else {
                    i$16732
                },
        0i32,
        l$16722
    )
}

def DelayList.drop(n$19280: Int32, l$19284: DelayList[a]): DelayList[a] = {
    letrec loop$19308: (Int32 -> DelayList[a] -> DelayList[a]) = i$19310 ->
        ll$19312 ->
            if (<[unknown exp]>(i$19310, 1i32)) {
                ll$19312
            } else {
                match ll$19312 {
                    case DelayList.ENil =>
                        ll$19312
                    case DelayList.ECons(_, xs$19314) =>
                        loop$19308(<[unknown exp]>(i$19310, 1i32))(xs$19314)
                    case DelayList.LCons(_, xs$19316) =>
                        loop$19308(
                            <[unknown exp]>(i$19310, 1i32)
                        )(force xs$19316)
                    case DelayList.LList(xs$19324) =>
                        loop$19308(i$19310)(force xs$19324)
                }
            };
    DelayList.LList(lazy loop$19308(n$19280)(l$19284))
}

def DelayList.dropWhile(
    f$19349: a -> Bool,
    l$19351: DelayList[a]
): DelayList[a] \ ef = {
    match purityOf(f$19349) {
        case Purity.Pure(g$19355) =>
            DelayList.dropWhileL(g$19355, l$19351)
        case Purity.Impure(g$19358) =>
            DelayList.dropWhileE(g$19358, l$19351)
    }
}

def DelayList.dropWhileE(
    f$19428: a -> Bool,
    l$19430: DelayList[a]
): DelayList[a] \ ef = {
    match l$19430 {
        case DelayList.ENil =>
            DelayList.ENil
        case DelayList.ECons(x$19439, xs$19441) =>
            if (f$19428(x$19439)) {
                DelayList.dropWhileE(f$19428, xs$19441)
            } else {
                l$19430
            }
        case DelayList.LCons(x$19446, xs$19449) =>
            if (f$19428(x$19446)) {
                DelayList.dropWhileE(f$19428, force xs$19449)
            } else {
                l$19430
            }
        case DelayList.LList(xs$19455) =>
            DelayList.dropWhileE(f$19428, force xs$19455)
    }
}

def DelayList.dropWhileL(
    f$19370: a -> Bool,
    l$19372: DelayList[a]
): DelayList[a] = {
    letrec loop$19379: (DelayList[a] -> DelayList[a]) = ll$19382 ->
        match ll$19382 {
            case DelayList.ENil =>
                DelayList.ENil
            case DelayList.ECons(x$19391, xs$19395) =>
                if (f$19370(x$19391)) {loop$19379(xs$19395)} else {ll$19382}
            case DelayList.LCons(x$19401, xs$19405) =>
                if (f$19370(x$19401)) {
                    loop$19379(force xs$19405)
                } else {
                    ll$19382
                }
            case DelayList.LList(xs$19407) =>
                loop$19379(force xs$19407)
        };
    DelayList.LList(lazy loop$19379(l$19372))
}

def DelayList.empty(_unit$16456: Unit): DelayList[a] = {DelayList.ENil}

def DelayList.enumerator(
    rc$20060: Region[r],
    l$20064: DelayList[a]
): Iterator[(Int32, a), r, r] \ r = {
    |>(
        DelayList.iterator(rc$20060, l$20064),
        $0$46104 ->
            Iterator.zipWithIndex($0$46104)
    )
}

def DelayList.exists(f$16842: a -> Bool, l$16852: DelayList[a]): Bool \ ef = {
    match l$16852 {
        case DelayList.ENil =>
            false
        case DelayList.ECons(x$16856, xs$16859) =>
            if (f$16842(x$16856)) {
                true
            } else {
                DelayList.exists(f$16842, xs$16859)
            }
        case DelayList.LCons(x$16866, xs$16868) =>
            if (f$16842(x$16866)) {
                true
            } else {
                DelayList.exists(f$16842, force xs$16868)
            }
        case DelayList.LList(xs$16870) =>
            DelayList.exists(f$16842, force xs$16870)
    }
}

def DelayList.filter(
    f$18383: a -> Bool,
    l$18387: DelayList[a]
): DelayList[a] \ ef = {
    match purityOf(f$18383) {
        case Purity.Pure(g$18394) =>
            DelayList.filterL(g$18394, l$18387)
        case Purity.Impure(g$18398) =>
            DelayList.filterE(g$18398, l$18387)
    }
}

def DelayList.filterE(
    f$18456: a -> Bool,
    l$18460: DelayList[a]
): DelayList[a] \ ef = {
    letrec loop$18462: (
        DelayList[a] -> (DelayList[a] -> DelayList[a]) -> DelayList[a] \ ef
    ) = ll$18465 ->
        k$18467 ->
            match ll$18465 {
                case DelayList.ENil =>
                    k$18467(DelayList.ENil)
                case DelayList.ECons(x$18469, xs$18471) =>
                    if (f$18456(x$18469)) {
                        loop$18462(
                            xs$18471
                        )(
                            ks$18473 ->
                                k$18467(DelayList.ECons(x$18469, ks$18473))
                        )
                    } else {
                        loop$18462(xs$18471)(k$18467)
                    }
                case DelayList.LCons(x$18480, xs$18482) =>
                    if (f$18456(x$18480)) {
                        loop$18462(
                            force xs$18482
                        )(
                            ks$18490 ->
                                k$18467(DelayList.ECons(x$18480, ks$18490))
                        )
                    } else {
                        loop$18462(force xs$18482)(k$18467)
                    }
                case DelayList.LList(xs$18492) =>
                    loop$18462(force xs$18492)(k$18467)
            };
    loop$18462(l$18460)($0$45989 -> identity($0$45989))
}

def DelayList.filterL(
    f$18413: a -> Bool,
    l$18415: DelayList[a]
): DelayList[a] = {
    match l$18415 {
        case DelayList.ENil =>
            DelayList.ENil
        case DelayList.ECons(x$18420, xs$18422) =>
            if (f$18413(x$18420)) {
                DelayList.LCons(
                    x$18420,
                    lazy DelayList.filterL(f$18413, xs$18422)
                )
            } else {
                DelayList.LList(lazy DelayList.filterL(f$18413, xs$18422))
            }
        case DelayList.LCons(x$18428, xs$18431) =>
            if (f$18413(x$18428)) {
                DelayList.LCons(
                    x$18428,
                    lazy DelayList.filterL(f$18413, force xs$18431)
                )
            } else {
                DelayList.LList(lazy DelayList.filterL(f$18413, force xs$18431))
            }
        case DelayList.LList(xs$18439) =>
            DelayList.LList(lazy DelayList.filterL(f$18413, force xs$18439))
    }
}

def DelayList.filterMap(
    f$18505: a -> Option[b],
    l$18509: DelayList[a]
): DelayList[b] \ ef = {
    match purityOf(f$18505) {
        case Purity.Pure(g$18517) =>
            DelayList.filterMapL(g$18517, l$18509)
        case Purity.Impure(g$18520) =>
            DelayList.filterMapE(g$18520, l$18509)
    }
}

def DelayList.filterMapE(
    f$18605: a -> Option[b],
    l$18614: DelayList[a]
): DelayList[b] \ ef = {
    letrec loop$18626: (
        DelayList[a] -> (DelayList[b] -> DelayList[b]) -> DelayList[b] \ ef
    ) = ll$18632 ->
        k$18638 ->
            match ll$18632 {
                case DelayList.ENil =>
                    k$18638(DelayList.ENil)
                case DelayList.ECons(x$18640, xs$18642) =>
                    match f$18605(x$18640) {
                        case Option.None =>
                            loop$18626(xs$18642)(k$18638)
                        case Option.Some(v$18645) =>
                            loop$18626(
                                xs$18642
                            )(
                                ks$18647 ->
                                    k$18638(DelayList.ECons(v$18645, ks$18647))
                            )
                    }
                case DelayList.LCons(x$18653, xs$18655) =>
                    match f$18605(x$18653) {
                        case Option.None =>
                            loop$18626(force xs$18655)(k$18638)
                        case Option.Some(v$18671) =>
                            loop$18626(
                                force xs$18655
                            )(
                                ks$18674 ->
                                    k$18638(DelayList.ECons(v$18671, ks$18674))
                            )
                    }
                case DelayList.LList(xs$18681) =>
                    loop$18626(force xs$18681)(k$18638)
            };
    loop$18626(l$18614)($0$46009 -> identity($0$46009))
}

def DelayList.filterMapL(
    f$18535: a -> Option[b],
    l$18539: DelayList[a]
): DelayList[b] = {
    letrec loop$18541: (DelayList[a] -> DelayList[b]) = ll$18543 ->
        match ll$18543 {
            case DelayList.ENil =>
                DelayList.ENil
            case DelayList.ECons(x$18551, xs$18553) =>
                match f$18535(x$18551) {
                    case Option.None =>
                        loop$18541(xs$18553)
                    case Option.Some(v$18558) =>
                        DelayList.LCons(v$18558, lazy loop$18541(xs$18553))
                }
            case DelayList.LCons(x$18571, xs$18573) =>
                match f$18535(x$18571) {
                    case Option.None =>
                        loop$18541(force xs$18573)
                    case Option.Some(v$18577) =>
                        DelayList.LCons(
                            v$18577,
                            lazy loop$18541(force xs$18573)
                        )
                }
            case DelayList.LList(xs$18579) =>
                DelayList.LList(lazy loop$18541(force xs$18579))
        };
    DelayList.LList(lazy loop$18541(l$18539))
}

def DelayList.findLeft(
    f$18724: a -> Bool,
    l$18728: DelayList[a]
): Option[a] \ ef = {
    match l$18728 {
        case DelayList.ENil =>
            Option.None
        case DelayList.ECons(x$18741, xs$18746) =>
            if (f$18724(x$18741)) {
                Option.Some(x$18741)
            } else {
                DelayList.findLeft(f$18724, xs$18746)
            }
        case DelayList.LCons(x$18757, xs$18761) =>
            if (f$18724(x$18757)) {
                Option.Some(x$18757)
            } else {
                DelayList.findLeft(f$18724, force xs$18761)
            }
        case DelayList.LList(xs$18764) =>
            DelayList.findLeft(f$18724, force xs$18764)
    }
}

def DelayList.findMap(
    f$18890: a -> Option[b],
    l$18899: DelayList[a]
): Option[b] \ ef = {
    match l$18899 {
        case DelayList.ENil =>
            Option.None
        case DelayList.ECons(x$18909, xs$18911) =>
            match f$18890(x$18909) {
                case Option.None =>
                    DelayList.findMap(f$18890, xs$18911)
                case Option.Some(v$18921) =>
                    Option.Some(v$18921)
            }
        case DelayList.LCons(x$18929, xs$18931) =>
            match f$18890(x$18929) {
                case Option.None =>
                    DelayList.findMap(f$18890, force xs$18931)
                case Option.Some(v$18933) =>
                    Option.Some(v$18933)
            }
        case DelayList.LList(xs$18935) =>
            DelayList.findMap(f$18890, force xs$18935)
    }
}

def DelayList.findRight(
    f$18793: a -> Bool,
    l$18795: DelayList[a]
): Option[a] \ ef = {
    letrec loop$18797: (
        DelayList[a] ->
            (Unit -> Option[a] \ (e112655 & ef) + ef) -> Option[a] \ ef + ef + ef + (e112655 & ef) + ef
    ) = ll$18805 ->
        k$18812 ->
            match ll$18805 {
                case DelayList.ENil =>
                    k$18812(())
                case DelayList.ECons(x$18825, xs$18827) =>
                    loop$18797(
                        xs$18827
                    )(
                        _unit$18835 ->
                            if (f$18793(x$18825)) {
                                Option.Some(x$18825)
                            } else {
                                k$18812(())
                            }
                    )
                case DelayList.LCons(x$18839, xs$18845) =>
                    loop$18797(
                        force xs$18845
                    )(
                        _unit$18854 ->
                            if (f$18793(x$18839)) {
                                Option.Some(x$18839)
                            } else {
                                k$18812(())
                            }
                    )
                case DelayList.LList(xs$18874) =>
                    loop$18797(force xs$18874)(k$18812)
            };
    loop$18797(l$18795)(constant(Option.None))
}

def DelayList.flatMap(
    f$17653: a -> DelayList[b],
    l$17662: DelayList[a]
): DelayList[b] \ ef = {
    match purityOf(f$17653) {
        case Purity.Pure(g$17673) =>
            DelayList.flatMapL(g$17673, l$17662)
        case Purity.Impure(g$17687) =>
            DelayList.flatMapE(g$17687, l$17662)
    }
}

def DelayList.flatMapE(
    f$17751: a -> DelayList[b],
    l$17754: DelayList[a]
): DelayList[b] \ ef = {
    letrec loop$17762: (
        DelayList[a] -> (DelayList[b] -> DelayList[b]) -> DelayList[b] \ ef
    ) = ll$17764 ->
        k$17766 ->
            match ll$17764 {
                case DelayList.ENil =>
                    k$17766(DelayList.ENil)
                case DelayList.ECons(x$17774, xs$17776) =>
                    let xs1$17778: DelayList[b] = f$17751(x$17774);
                    loop$17762(
                        xs$17776
                    )(
                        ks$17782 ->
                            k$17766(DelayList.append(xs1$17778, ks$17782))
                    )
                case DelayList.LCons(x$17784, xs$17787) =>
                    let xs1$17792: DelayList[b] = f$17751(x$17784);
                    loop$17762(
                        force xs$17787
                    )(
                        ks$17798 ->
                            k$17766(DelayList.append(xs1$17792, ks$17798))
                    )
                case DelayList.LList(xs$17800) =>
                    loop$17762(force xs$17800)(k$17766)
            };
    loop$17762(l$17754)($0$45917 -> identity($0$45917))
}

def DelayList.flatMapL(
    f$17698: a -> DelayList[b],
    l$17704: DelayList[a]
): DelayList[b] = {
    match l$17704 {
        case DelayList.ENil =>
            DelayList.ENil
        case DelayList.ECons(x$17708, xs$17712) =>
            DelayList.append(
                f$17698(x$17708),
                DelayList.LList(lazy DelayList.flatMapL(f$17698, xs$17712))
            )
        case DelayList.LCons(x$17717, xs$17721) =>
            DelayList.append(
                f$17698(x$17717),
                DelayList.LList(
                    lazy DelayList.flatMapL(f$17698, force xs$17721)
                )
            )
        case DelayList.LList(xs$17725) =>
            DelayList.LList(lazy DelayList.flatMapL(f$17698, force xs$17725))
    }
}

def DelayList.flatten(l$16786: DelayList[DelayList[a]]): DelayList[a] = {
    match l$16786 {
        case DelayList.ENil =>
            DelayList.ENil
        case DelayList.ECons(x$16802, xs$16804) =>
            DelayList.append(
                x$16802,
                DelayList.LList(lazy DelayList.flatten(xs$16804))
            )
        case DelayList.LCons(x$16810, xs$16812) =>
            DelayList.append(
                x$16810,
                DelayList.LList(lazy DelayList.flatten(force xs$16812))
            )
        case DelayList.LList(xs$16816) =>
            DelayList.LList(lazy DelayList.flatten(force xs$16816))
    }
}

def DelayList.foldLeft(
    f$17967: b -> a -> b \ ef,
    s$17970: b,
    l$17976: DelayList[a]
): b \ ef = {
    match l$17976 {
        case DelayList.ENil =>
            s$17970
        case DelayList.ECons(x$17980, xs$17984) =>
            DelayList.foldLeft(f$17967, f$17967(s$17970)(x$17980), xs$17984)
        case DelayList.LCons(x$17987, xs$17992) =>
            DelayList.foldLeft(
                f$17967,
                f$17967(s$17970)(x$17987),
                force xs$17992
            )
        case DelayList.LList(xs$17996) =>
            DelayList.foldLeft(f$17967, s$17970, force xs$17996)
    }
}

def DelayList.foldMap(f$18159: a -> b, l$18162: DelayList[a]): b \ ef = {
    DelayList.foldLeft(
        acc$18167 ->
            x$18170 ->
                <[unknown exp]>(acc$18167, f$18159(x$18170)),
        <[unknown exp]>(()),
        l$18162
    )
}

def DelayList.foldRight(
    f$18018: a -> b -> b \ ef,
    s$18026: b,
    l$18030: DelayList[a]
): b \ ef = {
    letrec loop$18035: (
        DelayList[a] ->
            (b -> b \ (e123673 & ef) + ef) -> b \ ef + ef + ef + (e123673 & ef) + ef
    ) = ll$18037 ->
        k$18039 ->
            match ll$18037 {
                case DelayList.ENil =>
                    k$18039(s$18026)
                case DelayList.ECons(x$18041, xs$18043) =>
                    loop$18035(
                        xs$18043
                    )(ks$18047 -> k$18039(f$18018(x$18041)(ks$18047)))
                case DelayList.LCons(x$18055, xs$18057) =>
                    loop$18035(
                        force xs$18057
                    )(ks$18059 -> k$18039(f$18018(x$18055)(ks$18059)))
                case DelayList.LList(xs$18063) =>
                    loop$18035(force xs$18063)(k$18039)
            };
    loop$18035(l$18030)($0$45931 -> eidentity($0$45931))
}

def DelayList.foldRightWithCont(
    f$18086: a -> (Unit -> b \ ef) -> b \ ef,
    z$18099: b,
    l$18101: DelayList[a]
): b \ ef = {
    letrec loop$18106: (DelayList[a] -> b) = ll$18108 ->
        match ll$18108 {
            case DelayList.ENil =>
                z$18099
            case DelayList.ECons(x$18112, xs$18117) =>
                f$18086(x$18112)(_$18123 -> loop$18106(xs$18117))
            case DelayList.LCons(x$18134, xs$18137) =>
                f$18086(x$18134)(_$18139 -> loop$18106(force xs$18137))
            case DelayList.LList(xs$18143) =>
                loop$18106(force xs$18143)
        };
    loop$18106(l$18101)
}

def DelayList.forAll(f$16905: a -> Bool, l$16913: DelayList[a]): Bool \ ef = {
    match l$16913 {
        case DelayList.ENil =>
            true
        case DelayList.ECons(x$16923, xs$16925) =>
            if (f$16905(x$16923)) {
                DelayList.forAll(f$16905, xs$16925)
            } else {
                false
            }
        case DelayList.LCons(x$16942, xs$16946) =>
            if (f$16905(x$16942)) {
                DelayList.forAll(f$16905, force xs$16946)
            } else {
                false
            }
        case DelayList.LList(xs$16955) =>
            DelayList.forAll(f$16905, force xs$16955)
    }
}

def DelayList.forEach(f$18195: a -> Unit, l$18205: DelayList[a]): Unit \ ef = {
    match l$18205 {
        case DelayList.ENil =>
            ()
        case DelayList.ECons(x$18211, xs$18215) =>
            f$18195(x$18211); DelayList.forEach(f$18195, xs$18215)
        case DelayList.LCons(x$18220, xs$18224) =>
            f$18195(x$18220); DelayList.forEach(f$18195, force xs$18224)
        case DelayList.LList(xs$18234) =>
            DelayList.forEach(f$18195, force xs$18234)
    }
}

def DelayList.forEachWithIndex(
    f$18255: Int32 -> a -> Unit \ ef,
    l$18259: DelayList[a]
): Unit \ ef = {
    region rc$18261 {
        let ix$18264: Ref[Int32, rc] = (ref 0i32) @ rc$18261;
        let f1$18266: (a -> Unit) = x$18268 ->
            {
                let i$18271: Int32 = deref ix$18264;
                f$18255(i$18271)(x$18268);
                Ref.put(<[unknown exp]>(i$18271, 1i32), ix$18264)
            };
        DelayList.forEach(f1$18266, l$18259)
    }
}

def DelayList.head(l$16515: DelayList[a]): Option[a] = {
    match l$16515 {
        case DelayList.ENil =>
            Option.None
        case DelayList.ECons(x$16528, _) =>
            Option.Some(x$16528)
        case DelayList.LCons(x$16533, _) =>
            Option.Some(x$16533)
        case DelayList.LList(xs$16535) =>
            DelayList.head(force xs$16535)
    }
}

def DelayList.intercalate(
    l1$18980: DelayList[a],
    l2$18983: DelayList[DelayList[a]]
): DelayList[a] = {
    match l2$18983 {
        case DelayList.ENil =>
            DelayList.ENil
        case DelayList.ECons(x$18989, xs$18993) =>
            if (DelayList.isEmpty(xs$18993)) {
                x$18989
            } else {
                DelayList.append(
                    DelayList.append(x$18989, l1$18980),
                    DelayList.intercalate(l1$18980, xs$18993)
                )
            }
        case DelayList.LCons(x$18995, xs$18997) =>
            if (DelayList.isEmpty(force xs$18997)) {
                x$18995
            } else {
                DelayList.append(
                    DelayList.append(x$18995, l1$18980),
                    DelayList.intercalate(l1$18980, force xs$18997)
                )
            }
        case DelayList.LList(xs$19005) =>
            DelayList.LList(
                lazy DelayList.intercalate(l1$18980, force xs$19005)
            )
    }
}

def DelayList.intersperse(x$18942: a, l$18946: DelayList[a]): DelayList[a] = {
    match l$18946 {
        case DelayList.ENil =>
            DelayList.ENil
        case DelayList.ECons(x1$18952, xs$18955) =>
            if (DelayList.isEmpty(xs$18955)) {
                l$18946
            } else {
                DelayList.LCons(
                    x1$18952,
                    lazy DelayList.LCons(
                        x$18942,
                        lazy DelayList.intersperse(x$18942, xs$18955)
                    )
                )
            }
        case DelayList.LCons(x1$18965, xs$18969) =>
            if (DelayList.isEmpty(force xs$18969)) {
                l$18946
            } else {
                DelayList.LCons(
                    x1$18965,
                    lazy DelayList.LCons(
                        x$18942,
                        lazy DelayList.intersperse(x$18942, force xs$18969)
                    )
                )
            }
        case DelayList.LList(xs$18974) =>
            DelayList.LList(lazy DelayList.intersperse(x$18942, force xs$18974))
    }
}

def DelayList.isEmpty(l$16477: DelayList[a]): Bool = {
    match l$16477 {
        case DelayList.ENil =>
            true
        case DelayList.LList(xs$16484) =>
            DelayList.isEmpty(force xs$16484)
        case _ =>
            false
    }
}

def DelayList.iterator(
    rc$19998: Region[r],
    l$20003: DelayList[a]
): Iterator[a, r, r] \ r = {
    let cursor$20017: Ref[DelayList[a], r] = (ref l$20003) @ rc$19998;
    let next$20019: (Unit -> Option[a]) = _unit$20021 ->
        match DelayList.head(deref cursor$20017) {
            case Option.None =>
                Option.None
            case Option.Some(x$20031) =>
                Ref.put(DelayList.tail(deref cursor$20017), cursor$20017);
                Option.Some(x$20031)
        };
    Iterator.iterate(rc$19998, next$20019)
}

def DelayList.join(sep$20322: String, l$20324: DelayList[a]): String = {
    <[unknown exp]>(sep$20322, l$20324)
}

def DelayList.joinWith(
    f$20339: a -> String,
    sep$20341: String,
    l$20345: DelayList[a]
): String \ ef = {
    <[unknown exp]>(f$20339, sep$20341, l$20345)
}

def DelayList.last(l$16552: DelayList[a]): Option[a] = {
    match l$16552 {
        case DelayList.ENil =>
            Option.None
        case DelayList.ECons(x$16568, xs$16571) =>
            if (DelayList.isEmpty(xs$16571)) {
                Option.Some(x$16568)
            } else {
                DelayList.last(xs$16571)
            }
        case DelayList.LCons(x$16579, xs$16581) =>
            if (DelayList.isEmpty(force xs$16581)) {
                Option.Some(x$16579)
            } else {
                DelayList.last(force xs$16581)
            }
        case DelayList.LList(xs$16587) =>
            DelayList.last(force xs$16587)
    }
}

def DelayList.length(l$16642: DelayList[a]): Int32 = {
    letrec loop$16646: (DelayList[a] -> Int32 -> Int32) = ll$16649 ->
        acc$16653 ->
            match ll$16649 {
                case DelayList.ENil =>
                    acc$16653
                case DelayList.ECons(_, xs$16659) =>
                    loop$16646(xs$16659)(<[unknown exp]>(acc$16653, 1i32))
                case DelayList.LCons(_, xs$16661) =>
                    loop$16646(force xs$16661)(<[unknown exp]>(acc$16653, 1i32))
                case DelayList.LList(xs$16663) =>
                    loop$16646(force xs$16663)(acc$16653)
            };
    loop$16646(l$16642)(0i32)
}

def DelayList.map(f$17195: a -> b, l$17199: DelayList[a]): DelayList[b] \ ef = {
    match purityOf(f$17195) {
        case Purity.Pure(g$17215) =>
            DelayList.mapL(g$17215, l$17199)
        case Purity.Impure(g$17220) =>
            DelayList.mapE(g$17220, l$17199)
    }
}

def DelayList.mapE(
    f$17272: a -> b,
    l$17274: DelayList[a]
): DelayList[b] \ ef = {
    letrec loop$17277: (
        DelayList[a] -> (DelayList[b] -> DelayList[b]) -> DelayList[b] \ ef
    ) = ll$17281 ->
        k$17285 ->
            match ll$17281 {
                case DelayList.ENil =>
                    k$17285(DelayList.ENil)
                case DelayList.ECons(x$17291, xs$17293) =>
                    let x1$17296: b = f$17272(x$17291);
                    loop$17277(
                        xs$17293
                    )(ks$17303 -> k$17285(DelayList.ECons(x1$17296, ks$17303)))
                case DelayList.LCons(x$17311, xs$17313) =>
                    let x1$17315: b = f$17272(x$17311);
                    loop$17277(
                        force xs$17313
                    )(ks$17319 -> k$17285(DelayList.ECons(x1$17315, ks$17319)))
                case DelayList.LList(xs$17328) =>
                    loop$17277(force xs$17328)(k$17285)
            };
    loop$17277(l$17274)($0$45889 -> identity($0$45889))
}

def DelayList.mapL(f$17230: a -> b, l$17234: DelayList[a]): DelayList[b] = {
    match l$17234 {
        case DelayList.ENil =>
            DelayList.ENil
        case DelayList.ECons(x$17245, xs$17247) =>
            DelayList.LCons(
                f$17230(x$17245),
                lazy DelayList.mapL(f$17230, xs$17247)
            )
        case DelayList.LCons(x$17251, xs$17254) =>
            DelayList.LCons(
                f$17230(x$17251),
                lazy DelayList.mapL(f$17230, force xs$17254)
            )
        case DelayList.LList(xs$17258) =>
            DelayList.LList(lazy DelayList.mapL(f$17230, force xs$17258))
    }
}

def DelayList.mapWithIndex(
    f$17337: Int32 -> a -> b \ ef,
    l$17339: DelayList[a]
): DelayList[b] \ ef = {
    match purityOf2(f$17337) {
        case Purity2.Pure(g$17344) =>
            DelayList.mapWithIndexL(g$17344, l$17339)
        case Purity2.Impure(g$17347) =>
            DelayList.mapWithIndexE(g$17347, l$17339)
    }
}

def DelayList.mapWithIndexE(
    f$17485: Int32 -> a -> b \ ef,
    l$17499: DelayList[a]
): DelayList[b] \ ef = {
    letrec loop$17513: (
        DelayList[a] ->
            Int32 -> ((DelayList[b] -> DelayList[b]) -> DelayList[b] \ ef)
    ) = ll$17516 ->
        i$17522 ->
            k$17526 ->
                match ll$17516 {
                    case DelayList.ENil =>
                        k$17526(DelayList.ENil)
                    case DelayList.ECons(x$17528, xs$17532) =>
                        let x1$17535: b = f$17485(i$17522)(x$17528);
                        loop$17513(
                            xs$17532
                        )(
                            <[unknown exp]>(i$17522, 1i32)
                        )(
                            ks$17539 ->
                                k$17526(DelayList.ECons(x1$17535, ks$17539))
                        )
                    case DelayList.LCons(x$17546, xs$17549) =>
                        let x1$17555: b = f$17485(i$17522)(x$17546);
                        loop$17513(
                            force xs$17549
                        )(
                            <[unknown exp]>(i$17522, 1i32)
                        )(
                            ks$17563 ->
                                k$17526(DelayList.ECons(x1$17555, ks$17563))
                        )
                    case DelayList.LList(xs$17571) =>
                        loop$17513(force xs$17571)(i$17522)(k$17526)
                };
    loop$17513(l$17499)(0i32)($0$45895 -> identity($0$45895))
}

def DelayList.mapWithIndexL(
    f$17371: Int32 -> a -> b,
    l$17383: DelayList[a]
): DelayList[b] = {
    letrec loop$17395: (DelayList[a] -> Int32 -> DelayList[b]) = ll$17399 ->
        i$17402 ->
            match ll$17399 {
                case DelayList.ENil =>
                    DelayList.ENil
                case DelayList.ECons(x$17417, xs$17420) =>
                    DelayList.LCons(
                        f$17371(i$17402)(x$17417),
                        lazy loop$17395(
                            xs$17420
                        )(<[unknown exp]>(i$17402, 1i32))
                    )
                case DelayList.LCons(x$17436, xs$17440) =>
                    DelayList.LCons(
                        f$17371(i$17402)(x$17436),
                        lazy loop$17395(
                            force xs$17440
                        )(<[unknown exp]>(i$17402, 1i32))
                    )
                case DelayList.LList(xs$17453) =>
                    DelayList.LList(lazy loop$17395(force xs$17453)(i$17402))
            };
    DelayList.LList(lazy loop$17395(l$17383)(0i32))
}

def DelayList.maximum(l$17082: DelayList[a]): Option[a] = {
    DelayList.reduceLeft(
        $0$45858 ->
            $1$45860 ->
                <[unknown exp]>($0$45858, $1$45860),
        l$17082
    )
}

def DelayList.maximumBy(
    cmp$17099: a -> a -> Comparison,
    l$17103: DelayList[a]
): Option[a] = {
    DelayList.reduceLeft(
        (
            $0$45862 ->
                $1$45864 ->
                    $2$45866 ->
                        Order.maxBy($0$45862, $1$45864, $2$45866)
        )(cmp$17099),
        l$17103
    )
}

def DelayList.memberOf(x$16974: a, l$16979: DelayList[a]): Bool = {
    match l$16979 {
        case DelayList.ENil =>
            false
        case DelayList.ECons(x1$16995, xs$16997) =>
            if (<[unknown exp]>(x1$16995, x$16974)) {
                true
            } else {
                DelayList.memberOf(x$16974, xs$16997)
            }
        case DelayList.LCons(x1$17001, xs$17003) =>
            if (<[unknown exp]>(x1$17001, x$16974)) {
                true
            } else {
                DelayList.memberOf(x$16974, force xs$17003)
            }
        case DelayList.LList(xs$17006) =>
            DelayList.memberOf(x$16974, force xs$17006)
    }
}

def DelayList.minimum(l$17032: DelayList[a]): Option[a] = {
    DelayList.reduceLeft(
        $0$45839 ->
            $1$45842 ->
                <[unknown exp]>($0$45839, $1$45842),
        l$17032
    )
}

def DelayList.minimumBy(
    cmp$17067: a -> a -> Comparison,
    l$17070: DelayList[a]
): Option[a] = {
    DelayList.reduceLeft(
        (
            $0$45848 ->
                $1$45850 ->
                    $2$45852 ->
                        Order.minBy($0$45848, $1$45850, $2$45852)
        )(cmp$17067),
        l$17070
    )
}

def DelayList.nonEmpty(l$16499: DelayList[a]): Bool = {
    !DelayList.isEmpty(l$16499)
}

def DelayList.partition(
    f$19013: a -> Bool,
    l$19015: DelayList[a]
): (DelayList[a], DelayList[a]) \ ef = {
    letrec loop$19023: (
        DelayList[a] ->
            (((DelayList[a], DelayList[a])) -> (DelayList[a], DelayList[a])) -> (DelayList[a], DelayList[a]) \ ef
    ) = ll$19025 ->
        k$19029 ->
            match ll$19025 {
                case DelayList.ENil =>
                    k$19029((DelayList.ENil, DelayList.ENil))
                case DelayList.ECons(x$19031, xs$19033) =>
                    if (f$19013(x$19031)) {
                        loop$19023(
                            xs$19033
                        )(
                            pat$86$19035 ->
                                match pat$86$19035 {
                                    case (ks$19037, ls$19039) =>
                                        k$19029(
                                            (
                                                DelayList.ECons(
                                                    x$19031,
                                                    ks$19037
                                                ),
                                                ls$19039
                                            )
                                        )
                                }
                        )
                    } else {
                        loop$19023(
                            xs$19033
                        )(
                            pat$87$19045 ->
                                match pat$87$19045 {
                                    case (ks$19047, ls$19049) =>
                                        k$19029(
                                            (
                                                ks$19047,
                                                DelayList.ECons(
                                                    x$19031,
                                                    ls$19049
                                                )
                                            )
                                        )
                                }
                        )
                    }
                case DelayList.LCons(x$19057, xs$19059) =>
                    if (f$19013(x$19057)) {
                        loop$19023(
                            force xs$19059
                        )(
                            pat$88$19061 ->
                                match pat$88$19061 {
                                    case (ks$19065, ls$19067) =>
                                        k$19029(
                                            (
                                                DelayList.ECons(
                                                    x$19057,
                                                    ks$19065
                                                ),
                                                ls$19067
                                            )
                                        )
                                }
                        )
                    } else {
                        loop$19023(
                            force xs$19059
                        )(
                            pat$89$19069 ->
                                match pat$89$19069 {
                                    case (ks$19071, ls$19073) =>
                                        k$19029(
                                            (
                                                ks$19071,
                                                DelayList.ECons(
                                                    x$19057,
                                                    ls$19073
                                                )
                                            )
                                        )
                                }
                        )
                    }
                case DelayList.LList(xs$19079) =>
                    loop$19023(force xs$19079)(k$19029)
            };
    loop$19023(l$19015)($0$46043 -> identity($0$46043))
}

def DelayList.range(b$17125: Int32, e$17127: Int32): DelayList[Int32] = {
    letrec loop$17137: (Int32 -> DelayList[Int32]) = i$17139 ->
        if (<[unknown exp]>(i$17139, e$17127)) {
            DelayList.ENil
        } else {
            DelayList.LCons(
                i$17139,
                lazy loop$17137(<[unknown exp]>(i$17139, 1i32))
            )
        };
    DelayList.LList(lazy loop$17137(b$17125))
}

def DelayList.reduceLeft(
    f$18291: a -> a -> a \ ef,
    l$18295: DelayList[a]
): Option[a] \ ef = {
    match l$18295 {
        case DelayList.ENil =>
            Option.None
        case DelayList.ECons(x$18301, xs$18303) =>
            Option.Some(DelayList.foldLeft(f$18291, x$18301, xs$18303))
        case DelayList.LCons(x$18305, xs$18307) =>
            Option.Some(DelayList.foldLeft(f$18291, x$18305, force xs$18307))
        case DelayList.LList(xs$18312) =>
            DelayList.reduceLeft(f$18291, force xs$18312)
    }
}

def DelayList.reduceRight(
    f$18329: a -> a -> a \ ef,
    l$18336: DelayList[a]
): Option[a] \ ef = {
    letrec loop$18338: (
        DelayList[a] ->
            (a -> a \ (e111229 & ef) + ef) -> a \ ef + (e111229 & ef) + ef + ef + (e111229 & ef) + ef + ef
    ) = ll$18340 ->
        k$18342 ->
            match ll$18340 {
                case DelayList.ECons(x$18344, xs$18346) =>
                    if (DelayList.isEmpty(xs$18346)) {
                        k$18342(x$18344)
                    } else {
                        loop$18338(
                            xs$18346
                        )(ks$18352 -> k$18342(f$18329(x$18344)(ks$18352)))
                    }
                case DelayList.LCons(x$18356, xs$18360) =>
                    if (DelayList.isEmpty(force xs$18360)) {
                        k$18342(x$18356)
                    } else {
                        loop$18338(
                            force xs$18360
                        )(ks$18366 -> k$18342(f$18329(x$18356)(ks$18366)))
                    }
                case DelayList.LList(xs$18369) =>
                    loop$18338(force xs$18369)(k$18342)
                case _ =>
                    unreachable!(())
            };
    if (DelayList.isEmpty(l$18336)) {
        Option.None
    } else {
        Option.Some(loop$18338(l$18336)($0$45983 -> eidentity($0$45983)))
    }
}

def DelayList.repeat(x$17147: a): DelayList[a] = {
    DelayList.LCons(x$17147, lazy DelayList.repeat(x$17147))
}

def DelayList.replace(
    src$17927: { src = a },
    dst$17934: { dst = a },
    l$17936: DelayList[a]
): DelayList[a] = {
    DelayList.map(
        e$17942 ->
            if (<[unknown exp]>(src$17927.src, e$17942)) {
                dst$17934.dst
            } else {
                e$17942
            },
        l$17936
    )
}

def DelayList.reverse(l$17874: DelayList[a]): DelayList[a] = {
    letrec loop$17878: (
        DelayList[a] -> DelayList[a] -> DelayList[a]
    ) = ll$17880 ->
        acc$17882 ->
            match ll$17880 {
                case DelayList.ENil =>
                    acc$17882
                case DelayList.ECons(x$17887, xs$17889) =>
                    loop$17878(xs$17889)(DelayList.ECons(x$17887, acc$17882))
                case DelayList.LCons(x$17893, xs$17895) =>
                    loop$17878(
                        force xs$17895
                    )(DelayList.ECons(x$17893, acc$17882))
                case DelayList.LList(xs$17902) =>
                    loop$17878(force xs$17902)(acc$17882)
            };
    DelayList.LList(lazy loop$17878(l$17874)(DelayList.ENil))
}

def DelayList.sequence(l$20382: DelayList[m[a]]): m[DelayList[a]] = {
    letrec loop$20388: (
        DelayList[m[a]] ->
            (m[DelayList[a]] -> m[DelayList[a]]) -> m[DelayList[a]]
    ) = ll$20390 ->
        k$20395 ->
            match ll$20390 {
                case DelayList.ENil =>
                    k$20395(<[unknown exp]>(DelayList.ENil))
                case DelayList.ECons(mx$20397, xs$20399) =>
                    loop$20388(
                        xs$20399
                    )(ks$20401 -> k$20395(DelayList.consA(mx$20397, ks$20401)))
                case DelayList.LCons(mx$20411, xs$20413) =>
                    loop$20388(
                        force xs$20413
                    )(ks$20415 -> k$20395(DelayList.consA(mx$20411, ks$20415)))
                case DelayList.LList(xs$20417) =>
                    loop$20388(force xs$20417)(k$20395)
            };
    loop$20388(l$20382)($0$46150 -> identity($0$46150))
}

def DelayList.shuffle(
    rnd$20505: Random,
    l$20507: DelayList[a]
): DelayList[a] \ IO = {
    region rc$20521 {
        |>(
            !>(
                DelayList.toArray(rc$20521, l$20507),
                (
                    $0$46154 ->
                        $1$46156 ->
                            Array.shuffle($0$46154, $1$46156)
                )(rnd$20505)
            ),
            $0$46158 ->
                Array.toDelayList($0$46158)
        )
    }
}

def DelayList.singleton(x$17822: a): DelayList[a] = {
    DelayList.ECons(x$17822, DelayList.ENil)
}

def DelayList.span(
    f$19095: a -> Bool,
    l$19097: DelayList[a]
): (DelayList[a], DelayList[a]) \ ef = {
    match purityOf(f$19095) {
        case Purity.Pure(g$19105) =>
            DelayList.spanL(g$19105, l$19097)
        case Purity.Impure(g$19112) =>
            DelayList.spanE(g$19112, l$19097)
    }
}

def DelayList.spanE(
    f$19201: a -> Bool,
    l$19204: DelayList[a]
): (DelayList[a], DelayList[a]) \ ef = {
    letrec loop$19209: (
        DelayList[a] ->
            (((DelayList[a], DelayList[a])) -> (DelayList[a], DelayList[a])) -> (DelayList[a], DelayList[a]) \ ef
    ) = ll$19211 ->
        k$19215 ->
            match ll$19211 {
                case DelayList.ENil =>
                    k$19215((DelayList.ENil, DelayList.ENil))
                case DelayList.ECons(x$19223, xs$19225) =>
                    if (f$19201(x$19223)) {
                        loop$19209(
                            xs$19225
                        )(
                            pat$91$19227 ->
                                match pat$91$19227 {
                                    case (ks$19232, ls$19236) =>
                                        k$19215(
                                            (
                                                DelayList.ECons(
                                                    x$19223,
                                                    ks$19232
                                                ),
                                                ls$19236
                                            )
                                        )
                                }
                        )
                    } else {
                        k$19215((DelayList.ENil, l$19204))
                    }
                case DelayList.LCons(x$19241, xs$19243) =>
                    if (f$19201(x$19241)) {
                        loop$19209(
                            force xs$19243
                        )(
                            pat$92$19245 ->
                                match pat$92$19245 {
                                    case (ks$19248, ls$19251) =>
                                        k$19215(
                                            (
                                                DelayList.ECons(
                                                    x$19241,
                                                    ks$19248
                                                ),
                                                ls$19251
                                            )
                                        )
                                }
                        )
                    } else {
                        k$19215((DelayList.ENil, l$19204))
                    }
                case DelayList.LList(xs$19262) =>
                    loop$19209(force xs$19262)(k$19215)
            };
    loop$19209(l$19204)($0$46047 -> identity($0$46047))
}

def DelayList.spanL(
    f$19121: a -> Bool,
    l$19130: DelayList[a]
): (DelayList[a], DelayList[a]) = {
    match l$19130 {
        case DelayList.ENil =>
            (DelayList.ENil, DelayList.ENil)
        case DelayList.ECons(x$19141, xs$19143) =>
            if (f$19121(x$19141)) {
                let t$19149: Lazy[(DelayList[a], DelayList[a])] = lazy DelayList.spanL(
                    f$19121,
                    xs$19143
                );
                (
                    DelayList.LCons(x$19141, lazy fst(force t$19149)),
                    DelayList.LList(lazy snd(force t$19149))
                )
            } else {
                (DelayList.ENil, l$19130)
            }
        case DelayList.LCons(x$19157, xs$19159) =>
            if (f$19121(x$19157)) {
                let t$19165: Lazy[(DelayList[a], DelayList[a])] = lazy DelayList.spanL(
                    f$19121,
                    force xs$19159
                );
                (
                    DelayList.LCons(x$19157, lazy fst(force t$19165)),
                    DelayList.LList(lazy snd(force t$19165))
                )
            } else {
                (DelayList.ENil, l$19130)
            }
        case DelayList.LList(xs$19175) =>
            DelayList.spanL(f$19121, force xs$19175)
    }
}

def DelayList.startFrom(n$17171: Int32): DelayList[Int32] = {
    letrec loop$17185: (Int32 -> DelayList[Int32]) = i$17187 ->
        DelayList.LCons(
            i$17187,
            lazy loop$17185(<[unknown exp]>(i$17187, 1i32))
        );
    DelayList.LList(lazy loop$17185(n$17171))
}

def DelayList.sum(l$16752: DelayList[Int32]): Int32 = {<[unknown exp]>(l$16752)}

def DelayList.sumWith(
    f$16769: a -> Int32,
    l$16773: DelayList[a]
): Int32 \ ef = {
    <[unknown exp]>(f$16769, l$16773)
}

def DelayList.tail(l$16599: DelayList[a]): DelayList[a] = {
    match l$16599 {
        case DelayList.ENil =>
            DelayList.ENil
        case DelayList.ECons(_, xs$16611) =>
            xs$16611
        case DelayList.LCons(_, xs$16615) =>
            DelayList.LList(xs$16615)
        case DelayList.LList(xs$16619) =>
            DelayList.LList(lazy DelayList.tail(force xs$16619))
    }
}

def DelayList.take(n$19488: Int32, l$19491: DelayList[a]): DelayList[a] = {
    letrec loop$19494: (Int32 -> DelayList[a] -> DelayList[a]) = i$19496 ->
        ll$19498 ->
            if (<[unknown exp]>(i$19496, 0i32)) {
                DelayList.ENil
            } else {
                match ll$19498 {
                    case DelayList.ENil =>
                        DelayList.ENil
                    case DelayList.ECons(x$19504, xs$19506) =>
                        DelayList.LCons(
                            x$19504,
                            lazy loop$19494(
                                <[unknown exp]>(i$19496, 1i32)
                            )(xs$19506)
                        )
                    case DelayList.LCons(x$19511, xs$19514) =>
                        DelayList.LCons(
                            x$19511,
                            lazy loop$19494(
                                <[unknown exp]>(i$19496, 1i32)
                            )(force xs$19514)
                        )
                    case DelayList.LList(xs$19522) =>
                        loop$19494(i$19496)(force xs$19522)
                }
            };
    DelayList.LList(lazy loop$19494(n$19488)(l$19491))
}

def DelayList.takeWhile(
    f$19542: a -> Bool,
    l$19553: DelayList[a]
): DelayList[a] \ ef = {
    match purityOf(f$19542) {
        case Purity.Pure(g$19565) =>
            DelayList.takeWhileL(g$19565, l$19553)
        case Purity.Impure(g$19569) =>
            DelayList.takeWhileE(g$19569, l$19553)
    }
}

def DelayList.takeWhileE(
    f$19615: a -> Bool,
    l$19617: DelayList[a]
): DelayList[a] \ ef = {
    letrec loop$19626: (
        DelayList[a] -> (DelayList[a] -> DelayList[a]) -> DelayList[a] \ ef
    ) = ll$19628 ->
        k$19630 ->
            match ll$19628 {
                case DelayList.ENil =>
                    k$19630(DelayList.ENil)
                case DelayList.ECons(x$19634, xs$19636) =>
                    if (f$19615(x$19634)) {
                        loop$19626(
                            xs$19636
                        )(
                            ks$19641 ->
                                k$19630(DelayList.ECons(x$19634, ks$19641))
                        )
                    } else {
                        k$19630(DelayList.ENil)
                    }
                case DelayList.LCons(x$19645, xs$19647) =>
                    if (f$19615(x$19645)) {
                        loop$19626(
                            force xs$19647
                        )(
                            ks$19651 ->
                                k$19630(DelayList.ECons(x$19645, ks$19651))
                        )
                    } else {
                        k$19630(DelayList.ENil)
                    }
                case DelayList.LList(xs$19660) =>
                    loop$19626(force xs$19660)(k$19630)
            };
    loop$19626(l$19617)($0$46083 -> identity($0$46083))
}

def DelayList.takeWhileL(
    f$19583: a -> Bool,
    l$19589: DelayList[a]
): DelayList[a] = {
    letrec loop$19594: (DelayList[a] -> DelayList[a]) = ll$19596 ->
        match ll$19596 {
            case DelayList.ENil =>
                DelayList.ENil
            case DelayList.ECons(x$19599, xs$19601) =>
                if (f$19583(x$19599)) {
                    DelayList.LCons(x$19599, lazy loop$19594(xs$19601))
                } else {
                    DelayList.ENil
                }
            case DelayList.LCons(x$19603, xs$19605) =>
                if (f$19583(x$19603)) {
                    DelayList.LCons(x$19603, lazy loop$19594(force xs$19605))
                } else {
                    DelayList.ENil
                }
            case DelayList.LList(xs$19607) =>
                loop$19594(force xs$19607)
        };
    DelayList.LList(lazy loop$19594(l$19589))
}

def DelayList.toArray(
    rc$19910: Region[r],
    l$19912: DelayList[a]
): Array[a, r] \ r = {
    let a$19914: Array[a, r] = Array.empty(rc$19910, DelayList.length(l$19912));
    DelayList.forEach(
        pat$93$19916 ->
            match pat$93$19916 {
                case (i$19919, y$19921) =>
                    Array.put(y$19921, i$19919, a$19914)
            },
        DelayList.zipWithIndex(l$19912)
    );
    a$19914
}

def DelayList.toList(l$20089: DelayList[a]): List[a] = {
    letrec loop$20093: (
        DelayList[a] -> (List[a] -> List[a]) -> List[a]
    ) = ll$20095 ->
        k$20097 ->
            match ll$20095 {
                case DelayList.ENil =>
                    k$20097(List.Nil)
                case DelayList.ECons(x$20099, xs$20102) =>
                    loop$20093(
                        xs$20102
                    )(ks$20104 -> k$20097(List.Cons(x$20099, ks$20104)))
                case DelayList.LCons(x$20110, xs$20112) =>
                    loop$20093(
                        force xs$20112
                    )(ks$20114 -> k$20097(List.Cons(x$20110, ks$20114)))
                case DelayList.LList(xs$20124) =>
                    loop$20093(force xs$20124)(k$20097)
            };
    loop$20093(l$20089)($0$46106 -> identity($0$46106))
}

def DelayList.toMap(l$20221: DelayList[(a, b)]): Map[a, b] = {
    letrec loop$20246: (
        DelayList[(a, b)] -> Map[a, b] -> Map[a, b]
    ) = ll$20248 ->
        acc$20252 ->
            match ll$20248 {
                case DelayList.ENil =>
                    acc$20252
                case DelayList.ECons((k$20254, v$20256), xs$20258) =>
                    loop$20246(
                        xs$20258
                    )(Map.insert(k$20254, v$20256, acc$20252))
                case DelayList.LCons((k$20260, v$20262), xs$20265) =>
                    loop$20246(
                        force xs$20265
                    )(Map.insert(k$20260, v$20262, acc$20252))
                case DelayList.LList(xs$20271) =>
                    loop$20246(force xs$20271)(acc$20252)
            };
    loop$20246(l$20221)(Map.empty(()))
}

def DelayList.toMutDeque(
    rc$20178: Region[r],
    l$20182: DelayList[a]
): MutDeque[a, r] \ r = {
    let d$20192: MutDeque[a, r] = MutDeque.empty(rc$20178);
    DelayList.forEach(x$20194 -> MutDeque.pushBack(x$20194, d$20192), l$20182);
    d$20192
}

def DelayList.toMutList(
    rc$20144: Region[r],
    l$20148: DelayList[a]
): MutList[a, r] \ r = {
    region rc2$20164 {
        Array.toMutList(rc$20144, DelayList.toArray(rc2$20164, l$20148))
    }
}

def DelayList.toSet(l$20284: DelayList[a]): Set[a] = {
    letrec loop$20289: (DelayList[a] -> Set[a] -> Set[a]) = ll$20291 ->
        acc$20293 ->
            match ll$20291 {
                case DelayList.ENil =>
                    acc$20293
                case DelayList.ECons(x$20298, xs$20302) =>
                    loop$20289(xs$20302)(Set.insert(x$20298, acc$20293))
                case DelayList.LCons(x$20304, xs$20306) =>
                    loop$20289(force xs$20306)(Set.insert(x$20304, acc$20293))
                case DelayList.LList(xs$20308) =>
                    loop$20289(force xs$20308)(acc$20293)
            };
    loop$20289(l$20284)(Set.empty(()))
}

def DelayList.toString(l$16415: DelayList[a]): String = {
    region rc$16421 {
        let sb$16424: StringBuilder[rc] = StringBuilder.empty(rc$16421);
        StringBuilder.appendString!("""DelayList(""", sb$16424);
        DelayList.forEachWithIndex(
            i$16426 ->
                x$16430 ->
                    if (<[unknown exp]>(i$16426, 0i32)) {
                        StringBuilder.appendString!(
                            """""" + <[unknown exp]>(x$16430),
                            sb$16424
                        )
                    } else {
                        StringBuilder.appendString!(
                            ("""""" + """, """) + <[unknown exp]>(x$16430),
                            sb$16424
                        )
                    },
            l$16415
        );
        StringBuilder.appendString!(""")""", sb$16424);
        StringBuilder.toString(sb$16424)
    }
}

def DelayList.toVector(l$19947: DelayList[a]): Vector[a] = {
    region rc$19963 {
        let arr$19968: Array[a, rc] = Array.empty(
            rc$19963,
            DelayList.length(l$19947)
        );
        DelayList.forEach(
            pat$94$19975 ->
                match pat$94$19975 {
                    case (i$19983, x$19986) =>
                        Array.put(x$19986, i$19983, arr$19968)
                },
            DelayList.zipWithIndex(l$19947)
        );
        Array.toVector(arr$19968)
    }
}

def DelayList.traverse(
    f$20442: a -> m[b],
    l$20444: DelayList[a]
): m[DelayList[b]] \ ef = {
    letrec loop$20453: (
        DelayList[a] ->
            (m[DelayList[b]] -> m[DelayList[b]]) -> m[DelayList[b]] \ ef
    ) = ll$20455 ->
        k$20457 ->
            match ll$20455 {
                case DelayList.ENil =>
                    k$20457(<[unknown exp]>(DelayList.ENil))
                case DelayList.ECons(x$20463, xs$20468) =>
                    let ans$20475: m[b] = f$20442(x$20463);
                    loop$20453(
                        xs$20468
                    )(ks$20477 -> k$20457(DelayList.consA(ans$20475, ks$20477)))
                case DelayList.LCons(x$20479, xs$20481) =>
                    let ans$20483: m[b] = f$20442(x$20479);
                    loop$20453(
                        force xs$20481
                    )(ks$20485 -> k$20457(DelayList.consA(ans$20483, ks$20485)))
                case DelayList.LList(xs$20489) =>
                    loop$20453(force xs$20489)(k$20457)
            };
    loop$20453(l$20444)($0$46152 -> identity($0$46152))
}

def DelayList.zip(
    l1$19685: DelayList[a],
    l2$19695: DelayList[b]
): DelayList[(a, b)] = {
    letrec loop$19713: (
        DelayList[a] -> DelayList[b] -> DelayList[(a, b)]
    ) = ll1$19717 ->
        ll2$19719 ->
            match (ll1$19717, ll2$19719) {
                case (DelayList.ENil, _) =>
                    DelayList.ENil
                case (_, DelayList.ENil) =>
                    DelayList.ENil
                case (
                    DelayList.ECons(x$19728, xs$19730),
                    DelayList.ECons(y$19732, ys$19734)
                ) =>
                    DelayList.LCons(
                        (x$19728, y$19732),
                        lazy loop$19713(xs$19730)(ys$19734)
                    )
                case (
                    DelayList.ECons(x$19739, xs$19741),
                    DelayList.LCons(y$19743, ys$19745)
                ) =>
                    DelayList.LCons(
                        (x$19739, y$19743),
                        lazy loop$19713(xs$19741)(force ys$19745)
                    )
                case (
                    DelayList.LCons(x$19750, xs$19752),
                    DelayList.ECons(y$19754, ys$19756)
                ) =>
                    DelayList.LCons(
                        (x$19750, y$19754),
                        lazy loop$19713(force xs$19752)(ys$19756)
                    )
                case (
                    DelayList.LCons(x$19765, xs$19767),
                    DelayList.LCons(y$19769, ys$19771)
                ) =>
                    DelayList.LCons(
                        (x$19765, y$19769),
                        lazy loop$19713(force xs$19767)(force ys$19771)
                    )
                case (DelayList.LList(xs$19780), DelayList.LList(ys$19782)) =>
                    DelayList.LList(
                        lazy loop$19713(force xs$19780)(force ys$19782)
                    )
                case (xs$19784, DelayList.LList(ys$19789)) =>
                    DelayList.LList(lazy loop$19713(xs$19784)(force ys$19789))
                case (DelayList.LList(xs$19796), ys$19798) =>
                    DelayList.LList(lazy loop$19713(force xs$19796)(ys$19798))
            };
    match (l1$19685, l2$19695) {
        case (DelayList.ENil, _) =>
            DelayList.ENil
        case (_, DelayList.ENil) =>
            DelayList.ENil
        case _ =>
            DelayList.LList(lazy loop$19713(l1$19685)(l2$19695))
    }
}

def DelayList.zipWith(
    f$19829: a -> b -> c \ ef,
    l1$19834: DelayList[a],
    l2$19839: DelayList[b]
): DelayList[c] \ ef = {
    DelayList.map(
        x$19843 ->
            f$19829(fst(x$19843))(snd(x$19843)),
        DelayList.zip(l1$19834, l2$19839)
    )
}

def DelayList.zipWithIndex(l$19861: DelayList[a]): DelayList[(Int32, a)] = {
    letrec loop$19868: (
        DelayList[a] -> Int32 -> DelayList[(Int32, a)]
    ) = ll$19870 ->
        i$19872 ->
            match ll$19870 {
                case DelayList.ENil =>
                    DelayList.ENil
                case DelayList.ECons(x$19875, xs$19877) =>
                    DelayList.LCons(
                        (i$19872, x$19875),
                        lazy loop$19868(
                            xs$19877
                        )(<[unknown exp]>(i$19872, 1i32))
                    )
                case DelayList.LCons(x$19880, xs$19882) =>
                    DelayList.LCons(
                        (i$19872, x$19880),
                        lazy loop$19868(
                            force xs$19882
                        )(<[unknown exp]>(i$19872, 1i32))
                    )
                case DelayList.LList(xs$19886) =>
                    DelayList.LList(lazy loop$19868(force xs$19886)(i$19872))
            };
    loop$19868(l$19861)(0i32)
}

enum DelayMap[k, v] {case DMap(RedBlackTree[k, Lazy[v]])}

def DelayMap.adjust(
    f$21586: v -> v,
    k$21589: k,
    m$21591: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    DelayMap.adjustWithKey(
        _$21600 ->
            v1$21605 ->
                f$21586(v1$21605),
        k$21589,
        m$21591
    )
}

def DelayMap.adjustWithKey(
    f$21625: k -> v -> v \ ef,
    k$21631: k,
    m$21635: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    DelayMap.updateWithKey(
        k1$21642 ->
            v$21645 ->
                Option.Some(f$21625(k1$21642)(v$21645)),
        k$21631,
        m$21635
    )
}

def DelayMap.count(
    f$15446: k -> v -> Bool \ ef,
    m$15449: DelayMap[k, v]
): Int32 \ ef = {
    letrec c$15457: (Unit -> Int32) = _unit$15461 ->
        DelayMap.foldLeftWithKey(
            b$15466 ->
                k$15468 ->
                    v$15470 ->
                        if (f$15446(k$15468)(v$15470)) {
                            <[unknown exp]>(b$15466, 1i32)
                        } else {
                            b$15466
                        },
            0i32,
            m$15449
        );
    match purityOf2(f$15446) {
        case Purity2.Pure(g$15482) =>
            if (DelayMap.useParallelEvaluation(m$15449)) {
                let h$15486: (k -> Lazy[v] -> Bool) = k$15490 ->
                    v$15497 ->
                        g$15482(k$15490)(force v$15497);
                match m$15449 {
                    case DelayMap.DMap(t$15500) =>
                        RedBlackTree.parCount(
                            <[unknown exp]>(DelayMap.threads(()), 1i32),
                            h$15486,
                            t$15500
                        )
                }
            } else {
                c$15457(())
            }
        case Purity2.Impure(_) =>
            c$15457(())
    }
}

def DelayMap.empty(_unit$14203: Unit): DelayMap[k, v] = {
    DelayMap.DMap(RedBlackTree.empty(()))
}

def DelayMap.filter(
    f$20707: v -> Bool,
    m$20715: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    DelayMap.filterWithKey(_$20723 -> v$20728 -> f$20707(v$20728), m$20715)
}

def DelayMap.filterWithKey(
    f$20746: k -> v -> Bool \ ef,
    m$20749: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    DelayMap.foldLeftWithKey(
        acc$20755 ->
            k$20757 ->
                v$20759 ->
                    if (f$20746(k$20757)(v$20759)) {
                        DelayMap.insert(k$20757, v$20759, acc$20755)
                    } else {
                        acc$20755
                    },
        DelayMap.empty(()),
        m$20749
    )
}

def DelayMap.foldLeft(
    f$21086: b -> v -> b \ ef,
    s$21088: b,
    m$21090: DelayMap[k, v]
): b \ ef = {
    DelayMap.foldLeftWithKey(
        acc$21098 ->
            _$21103 ->
                v$21107 ->
                    f$21086(acc$21098)(v$21107),
        s$21088,
        m$21090
    )
}

def DelayMap.foldLeftWithKey(
    f$21127: b -> k -> (v -> b \ ef),
    s$21129: b,
    m$21131: DelayMap[k, v]
): b \ ef = {
    match DelayMap.parallelForce(m$21131) {
        case _ =>
            match m$21131 {
                case DelayMap.DMap(t$21148) =>
                    let f1$21154: (b -> k -> (Lazy[v] -> b \ ef)) = b$21156 ->
                        k$21158 ->
                            v$21160 ->
                                f$21127(b$21156)(k$21158)(force v$21160);
                    RedBlackTree.foldLeft(f1$21154, s$21129, t$21148)
            }
    }
}

def DelayMap.foldRight(
    f$21182: v -> b -> b \ ef,
    s$21191: b,
    m$21194: DelayMap[k, v]
): b \ ef = {
    DelayMap.foldRightWithKey(
        _$21200 ->
            v$21204 ->
                acc$21208 ->
                    f$21182(v$21204)(acc$21208),
        s$21191,
        m$21194
    )
}

def DelayMap.foldRightWithCont(
    f$21268: v -> (Unit -> b \ ef) -> b \ ef,
    z$21270: b,
    m$21272: DelayMap[k, v]
): b \ ef = {
    DelayMap.foldRightWithKeyCont(
        _$21276 ->
            v$21278 ->
                c$21281 ->
                    f$21268(v$21278)(c$21281),
        z$21270,
        m$21272
    )
}

def DelayMap.foldRightWithKey(
    f$21222: k -> v -> (b -> b \ ef),
    s$21226: b,
    m$21228: DelayMap[k, v]
): b \ ef = {
    match DelayMap.parallelForce(m$21228) {
        case _ =>
            match m$21228 {
                case DelayMap.DMap(t$21232) =>
                    let f1$21234: (k -> Lazy[v] -> (b -> b \ ef)) = k1$21236 ->
                        v1$21238 ->
                            b1$21242 ->
                                f$21222(k1$21236)(force v1$21238)(b1$21242);
                    RedBlackTree.foldRight(f1$21234, s$21226, t$21232)
            }
    }
}

def DelayMap.foldRightWithKeyCont(
    f$21304: k -> v -> ((Unit -> b \ ef) -> b \ ef),
    s$21314: b,
    m$21318: DelayMap[k, v]
): b \ ef = {
    match DelayMap.parallelForce(m$21318) {
        case _ =>
            match m$21318 {
                case DelayMap.DMap(t$21320) =>
                    let f1$21323: (
                        k -> Lazy[v] -> ((Unit -> b \ ef) -> b \ ef)
                    ) = k1$21326 ->
                        v1$21328 ->
                            c$21330 ->
                                f$21304(k1$21326)(force v1$21328)(c$21330);
                    RedBlackTree.foldRightWithCont(f1$21323, s$21314, t$21320)
            }
    }
}

def DelayMap.forEach(
    f$22046: k -> v -> Unit \ ef,
    m$22050: DelayMap[k, v]
): Unit \ ef = {
    match DelayMap.parallelForce(m$22050) {
        case _ =>
            match m$22050 {
                case DelayMap.DMap(t$22061) =>
                    let f1$22066: (k -> Lazy[v] -> Unit \ ef) = k$22069 ->
                        v$22072 ->
                            f$22046(k$22069)(force v$22072);
                    RedBlackTree.forEach(f1$22066, t$22061)
            }
    }
}

def DelayMap.forEachWithIndex(
    f$22089: Int32 -> k -> (v -> Unit \ ef),
    m$22094: DelayMap[k, v]
): Unit \ ef = {
    region rc$22103 {
        let ix$22106: Ref[Int32, rc] = (ref 0i32) @ rc$22103;
        let f1$22110: (k -> v -> Unit \ rc + ef + rc) = k$22114 ->
            v$22116 ->
                {
                    let i$22118: Int32 = deref ix$22106;
                    f$22089(i$22118)(k$22114)(v$22116);
                    Ref.put(<[unknown exp]>(i$22118, 1i32), ix$22106)
                };
        DelayMap.forEach(f1$22110, m$22094)
    }
}

def DelayMap.forceAll(m$18179: DelayMap[k, v]): Unit = {<[unknown exp]>}

def DelayMap.get(k$15306: k, m$15308: DelayMap[k, v]): Option[v] = {
    match m$15308 {
        case DelayMap.DMap(t$15320) =>
            match RedBlackTree.get(k$15306, t$15320) {
                case Option.None =>
                    Option.None
                case Option.Some(x$15328) =>
                    Option.Some(force x$15328)
            }
    }
}

def DelayMap.getWithDefault(
    k$15406: k,
    d$15409: v,
    m$15414: DelayMap[k, v]
): v = {
    Option.getWithDefault(d$15409, DelayMap.get(k$15406, m$15414))
}

def DelayMap.insert(
    k$14514: k,
    v$14516: v,
    m$14518: DelayMap[k, v]
): DelayMap[k, v] = {
    match m$14518 {
        case DelayMap.DMap(t$14575) =>
            DelayMap.DMap(RedBlackTree.insert(k$14514, lazy v$14516, t$14575))
    }
}

def DelayMap.insertWith(
    f$17731: v -> v -> v \ ef,
    k$17740: k,
    v$17744: v,
    m$17746: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    DelayMap.insertWithKey(
        _$17756 ->
            v1$17758 ->
                v2$17760 ->
                    f$17731(v1$17758)(v2$17760),
        k$17740,
        v$17744,
        m$17746
    )
}

def DelayMap.insertWithKey(
    f$17796: k -> v -> (v -> v \ ef),
    k$17802: k,
    v$17804: v,
    m$17806: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    match purityOf3(f$17796) {
        case Purity3.Pure(g$17816) =>
            DelayMap.insertWithKeyL(g$17816, k$17802, v$17804, m$17806)
        case Purity3.Impure(g$17820) =>
            DelayMap.insertWithKeyE(g$17820, k$17802, v$17804, m$17806)
    }
}

def DelayMap.insertWithKeyE(
    f$17900: k -> v -> (v -> v \ ef),
    k$17908: k,
    v$17910: v,
    m$17912: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    match m$17912 {
        case DelayMap.DMap(t$17919) =>
            let f1$17921: (
                k -> Lazy[v] -> (Lazy[v] -> Lazy[v] \ ef)
            ) = k1$17923 ->
                v1$17926 ->
                    v2$17930 ->
                        {
                            let x$17932: v = f$17900(
                                k1$17923
                            )(force v1$17926)(force v2$17930);
                            lazy x$17932
                        };
            DelayMap.DMap(
                RedBlackTree.insertWith(
                    f1$17921,
                    k$17908,
                    lazy v$17910,
                    t$17919
                )
            )
    }
}

def DelayMap.insertWithKeyL(
    f$17833: k -> v -> (v -> v),
    k$17845: k,
    v$17847: v,
    m$17849: DelayMap[k, v]
): DelayMap[k, v] = {
    match m$17849 {
        case DelayMap.DMap(t$17853) =>
            let f1$17855: (k -> Lazy[v] -> (Lazy[v] -> Lazy[v])) = k1$17859 ->
                v1$17861 ->
                    v2$17863 ->
                        lazy f$17833(k1$17859)(force v1$17861)(force v2$17863);
            DelayMap.DMap(
                RedBlackTree.insertWith(
                    f1$17855,
                    k$17845,
                    lazy v$17847,
                    t$17853
                )
            )
    }
}

def DelayMap.isEmpty(m$14367: DelayMap[k, v]): Bool = {
    match m$14367 {case DelayMap.DMap(t$14378) => RedBlackTree.isEmpty(t$14378)}
}

def DelayMap.iterator(
    rc$21937: Region[r],
    m$21940: DelayMap[a, b]
): Iterator[(a, b), r, r] \ r = {
    match m$21940 {
        case DelayMap.DMap(t$21946) =>
            |>(
                RedBlackTree.iterator(rc$21937, t$21946),
                (
                    $0$46140 ->
                        $1$46142 ->
                            Iterator.map($0$46140, $1$46142)
                )(
                    pat$119$21956 ->
                        match pat$119$21956 {
                            case (k$21965, v$21967) =>
                                (k$21965, force v$21967)
                        }
                )
            )
    }
}

def DelayMap.joinKeys(sep$22338: String, m$22342: DelayMap[k, v]): String = {
    match m$22342 {
        case DelayMap.DMap(t$22360) =>
            RedBlackTree.joinKeys(sep$22338, t$22360)
    }
}

def DelayMap.joinValues(sep$22393: String, m$22397: DelayMap[k, v]): String = {
    DelayMap.joinWith(
        _$22399 ->
            v$22402 ->
                <[unknown exp]>(v$22402),
        sep$22393,
        m$22397
    )
}

def DelayMap.joinWith(
    f$22429: k -> v -> String \ ef,
    sep$22439: String,
    m$22441: DelayMap[k, v]
): String \ ef = {
    match DelayMap.parallelForce(m$22441) {
        case _ =>
            match m$22441 {
                case DelayMap.DMap(t$22448) =>
                    RedBlackTree.joinWith(
                        k$22454 ->
                            v$22459 ->
                                f$22429(k$22454)(force v$22459),
                        sep$22439,
                        t$22448
                    )
            }
    }
}

def DelayMap.keysOf(m$17623: DelayMap[k, v]): Set[k] = {
    DelayMap.foldLeftWithKey(
        acc$17639 ->
            k$17643 ->
                _$17645 ->
                    Set.insert(k$17643, acc$17639),
        Set.empty(()),
        m$17623
    )
}

def DelayMap.map(
    f$17956: v1 -> v2,
    m$17962: DelayMap[k, v1]
): DelayMap[k, v2] \ ef = {
    DelayMap.mapWithKey(_$17971 -> v$17974 -> f$17956(v$17974), m$17962)
}

def DelayMap.mapWithKey(
    f$18002: k -> v1 -> v2 \ ef,
    m$18012: DelayMap[k, v1]
): DelayMap[k, v2] \ ef = {
    match purityOf2(f$18002) {
        case Purity2.Pure(g$18020) =>
            DelayMap.mapWithKeyL(g$18020, m$18012)
        case Purity2.Impure(g$18022) =>
            DelayMap.mapWithKeyE(g$18022, m$18012)
    }
}

def DelayMap.mapWithKeyE(
    f$18097: k -> v1 -> v2 \ ef,
    m$18104: DelayMap[k, v1]
): DelayMap[k, v2] \ ef = {
    let g$18113: (k -> Lazy[v1] -> Lazy[v2] \ ef) = k$18116 ->
        v$18120 ->
            {let x1$18126: v2 = f$18097(k$18116)(force v$18120); lazy x1$18126};
    match DelayMap.parallelForce(m$18104) {
        case _ =>
            match m$18104 {
                case DelayMap.DMap(t$18140) =>
                    DelayMap.DMap(RedBlackTree.mapWithKey(g$18113, t$18140))
            }
    }
}

def DelayMap.mapWithKeyL(
    f$18053: k -> v1 -> v2,
    m$18061: DelayMap[k, v1]
): DelayMap[k, v2] = {
    match m$18061 {
        case DelayMap.DMap(t$18067) =>
            let g$18069: (k -> Lazy[v1] -> Lazy[v2]) = k$18073 ->
                v$18076 ->
                    lazy f$18053(k$18073)(force v$18076);
            DelayMap.DMap(RedBlackTree.mapWithKey(g$18069, t$18067))
    }
}

def DelayMap.maximumKey(m$17341: DelayMap[k, v]): Option[(k, v)] = {
    match m$17341 {
        case DelayMap.DMap(t$17343) =>
            match RedBlackTree.maximumKey(t$17343) {
                case Option.None =>
                    Option.None
                case Option.Some(k$17349, v$17351) =>
                    Option.Some(k$17349, force v$17351)
            }
    }
}

def DelayMap.maximumKeyBy(
    cmp$17374: k -> k -> Comparison \ ef,
    m$17381: DelayMap[k, v]
): Option[(k, v)] \ ef = {
    letrec max$17393: (Unit -> Option[(k, v)]) = _unit$17397 ->
        DelayMap.reduceLeftWithKey(
            kl$17401 ->
                vl$17405 ->
                    kr$17409 ->
                        vr$17412 ->
                            if (
                                <[unknown exp]>(
                                    cmp$17374(kl$17401)(kr$17409),
                                    Comparison.GreaterThan
                                )
                            ) {
                                (kl$17401, vl$17405)
                            } else {
                                (kr$17409, vr$17412)
                            },
            m$17381
        );
    match purityOf2(cmp$17374) {
        case Purity2.Pure(g$17422) =>
            if (DelayMap.useParallelEvaluation(m$17381)) {
                let h$17426: (
                    k -> Lazy[v] -> (k -> (Lazy[v] -> Comparison))
                ) = kl$17429 ->
                    _$17432 ->
                        kr$17434 ->
                            _$17437 ->
                                g$17422(kl$17429)(kr$17434);
                match m$17381 {
                    case DelayMap.DMap(t$17442) =>
                        let res$17444: Option[(k, Lazy[v])] = RedBlackTree.parMaximumBy(
                            <[unknown exp]>(DelayMap.threads(()), 1i32),
                            h$17426,
                            t$17442
                        );
                        match res$17444 {
                            case Option.None =>
                                Option.None
                            case Option.Some(k$17454, v$17459) =>
                                Option.Some(k$17454, force v$17459)
                        }
                }
            } else {
                max$17393(())
            }
        case Purity2.Impure(_) =>
            max$17393(())
    }
}

def DelayMap.maximumValue(m$17478: DelayMap[k, v]): Option[(k, v)] = {
    DelayMap.maximumValueBy(
        x$17490 ->
            y$17493 ->
                <[unknown exp]>(x$17490, y$17493),
        m$17478
    )
}

def DelayMap.maximumValueBy(
    cmp$17524: v -> v -> Comparison \ ef,
    m$17531: DelayMap[k, v]
): Option[(k, v)] \ ef = {
    letrec max$17543: (Unit -> Option[(k, v)]) = _unit$17545 ->
        DelayMap.reduceLeftWithKey(
            kl$17551 ->
                vl$17553 ->
                    kr$17557 ->
                        vr$17559 ->
                            if (
                                <[unknown exp]>(
                                    cmp$17524(vl$17553)(vr$17559),
                                    Comparison.GreaterThan
                                )
                            ) {
                                (kl$17551, vl$17553)
                            } else {
                                (kr$17557, vr$17559)
                            },
            m$17531
        );
    match purityOf2(cmp$17524) {
        case Purity2.Pure(g$17567) =>
            if (DelayMap.useParallelEvaluation(m$17531)) {
                let h$17573: (
                    k -> Lazy[v] -> (k -> (Lazy[v] -> Comparison))
                ) = _$17575 ->
                    vl$17577 ->
                        _$17579 ->
                            vr$17581 ->
                                g$17567(force vl$17577)(force vr$17581);
                match m$17531 {
                    case DelayMap.DMap(t$17586) =>
                        let res$17588: Option[(k, Lazy[v])] = RedBlackTree.parMaximumBy(
                            <[unknown exp]>(DelayMap.threads(()), 1i32),
                            h$17573,
                            t$17586
                        );
                        match res$17588 {
                            case Option.None =>
                                Option.None
                            case Option.Some(k$17596, v$17598) =>
                                Option.Some(k$17596, force v$17598)
                        }
                }
            } else {
                max$17543(())
            }
        case Purity2.Impure(_) =>
            max$17543(())
    }
}

def DelayMap.memberOf(k$15525: k, m$15531: DelayMap[k, v]): Bool = {
    match m$15531 {
        case DelayMap.DMap(t$15547) =>
            RedBlackTree.memberOf(k$15525, t$15547)
    }
}

def DelayMap.minimumKey(m$15587: DelayMap[k, v]): Option[(k, v)] = {
    match m$15587 {
        case DelayMap.DMap(t$15592) =>
            match RedBlackTree.minimumKey(t$15592) {
                case Option.None =>
                    Option.None
                case Option.Some(k$15594, v$15596) =>
                    Option.Some(k$15594, force v$15596)
            }
    }
}

def DelayMap.minimumKeyBy(
    cmp$15636: k -> k -> Comparison \ ef,
    m$15647: DelayMap[k, v]
): Option[(k, v)] \ ef = {
    letrec min$15660: (Unit -> Option[(k, v)]) = _unit$15665 ->
        DelayMap.reduceLeftWithKey(
            kl$15667 ->
                vl$15671 ->
                    kr$15674 ->
                        vr$15678 ->
                            if (
                                <[unknown exp]>(
                                    cmp$15636(kl$15667)(kr$15674),
                                    Comparison.LessThan
                                )
                            ) {
                                (kl$15667, vl$15671)
                            } else {
                                (kr$15674, vr$15678)
                            },
            m$15647
        );
    match purityOf2(cmp$15636) {
        case Purity2.Pure(g$15684) =>
            if (DelayMap.useParallelEvaluation(m$15647)) {
                let h$15686: (
                    k -> Lazy[v] -> (k -> (Lazy[v] -> Comparison))
                ) = kl$15688 ->
                    _$15690 ->
                        kr$15693 ->
                            _$15696 ->
                                g$15684(kl$15688)(kr$15693);
                match m$15647 {
                    case DelayMap.DMap(t$15700) =>
                        let res$15704: Option[(k, Lazy[v])] = RedBlackTree.parMinimumBy(
                            <[unknown exp]>(DelayMap.threads(()), 1i32),
                            h$15686,
                            t$15700
                        );
                        match res$15704 {
                            case Option.None =>
                                Option.None
                            case Option.Some(k$15708, v$15712) =>
                                Option.Some(k$15708, force v$15712)
                        }
                }
            } else {
                min$15660(())
            }
        case Purity2.Impure(_) =>
            min$15660(())
    }
}

def DelayMap.minimumValue(m$15756: DelayMap[k, v]): Option[(k, v)] = {
    DelayMap.minimumValueBy(
        x$15758 ->
            y$15762 ->
                <[unknown exp]>(x$15758, y$15762),
        m$15756
    )
}

def DelayMap.minimumValueBy(
    cmp$15802: v -> v -> Comparison \ ef,
    m$15811: DelayMap[k, v]
): Option[(k, v)] \ ef = {
    letrec min$15819: (Unit -> Option[(k, v)]) = _unit$15821 ->
        DelayMap.reduceLeftWithKey(
            kl$15823 ->
                vl$15827 ->
                    kr$15829 ->
                        vr$15831 ->
                            if (
                                <[unknown exp]>(
                                    cmp$15802(vl$15827)(vr$15831),
                                    Comparison.LessThan
                                )
                            ) {
                                (kl$15823, vl$15827)
                            } else {
                                (kr$15829, vr$15831)
                            },
            m$15811
        );
    match purityOf2(cmp$15802) {
        case Purity2.Pure(g$15841) =>
            if (DelayMap.useParallelEvaluation(m$15811)) {
                let h$15843: (
                    k -> Lazy[v] -> (k -> (Lazy[v] -> Comparison))
                ) = _$15847 ->
                    vl$15853 ->
                        _$15970 ->
                            vr$16155 ->
                                g$15841(force vl$15853)(force vr$16155);
                match m$15811 {
                    case DelayMap.DMap(t$17283) =>
                        let res$17287: Option[(k, Lazy[v])] = RedBlackTree.parMinimumBy(
                            <[unknown exp]>(DelayMap.threads(()), 1i32),
                            h$15843,
                            t$17283
                        );
                        match res$17287 {
                            case Option.None =>
                                Option.None
                            case Option.Some(k$17299, v$17301) =>
                                Option.Some(k$17299, force v$17301)
                        }
                }
            } else {
                min$15819(())
            }
        case Purity2.Impure(_) =>
            min$15819(())
    }
}

def DelayMap.nonEmpty(m$14464: DelayMap[k, v]): Bool = {
    !DelayMap.isEmpty(m$14464)
}

def DelayMap.parallelForce(m$18153: DelayMap[k, v]): Unit = {
    if (DelayMap.useParallelEvaluation(m$18153)) {
        DelayMap.forceAll(m$18153)
    } else {
        ()
    }
}

def DelayMap.reduceLeft(
    f$21341: v -> v -> v \ ef,
    m$21361: DelayMap[k, v]
): Option[v] \ ef = {
    |>(
        DelayMap.reduceLeftWithKey(
            k$21369 ->
                v1$21373 ->
                    _$21377 ->
                        v2$21379 ->
                            (k$21369, f$21341(v1$21373)(v2$21379)),
            m$21361
        ),
        (
            $0$46108 ->
                $1$46110 ->
                    Option.map($0$46108, $1$46110)
        )($0$46112 -> snd($0$46112))
    )
}

def DelayMap.reduceLeftWithKey(
    f$21392: k -> v -> (k -> (v -> (k, v) \ ef)),
    m$21400: DelayMap[k, v]
): Option[(k, v)] \ ef = {
    match DelayMap.parallelForce(m$21400) {
        case _ =>
            match m$21400 {
                case DelayMap.DMap(t$21405) =>
                    let f1$21407: (
                        k -> Lazy[v] -> (k -> (Lazy[v] -> (k, Lazy[v]) \ ef))
                    ) = k1$21411 ->
                        v1$21413 ->
                            k2$21416 ->
                                v2$21420 ->
                                    match f$21392(
                                        k1$21411
                                    )(
                                        force v1$21413
                                    )(k2$21416)(force v2$21420) {
                                        case (k$21427, v$21429) =>
                                            (k$21427, lazy v$21429)
                                    };
                    match RedBlackTree.reduceLeft(f1$21407, t$21405) {
                        case Option.Some(k$21431, v$21435) =>
                            Option.Some(k$21431, force v$21435)
                        case Option.None =>
                            Option.None
                    }
            }
    }
}

def DelayMap.reduceRight(
    f$21454: v -> v -> v \ ef,
    m$21466: DelayMap[k, v]
): Option[v] \ ef = {
    |>(
        DelayMap.reduceRightWithKey(
            k$21478 ->
                v1$21480 ->
                    _$21482 ->
                        v2$21484 ->
                            (k$21478, f$21454(v1$21480)(v2$21484)),
            m$21466
        ),
        (
            $0$46114 ->
                $1$46116 ->
                    Option.map($0$46114, $1$46116)
        )($0$46118 -> snd($0$46118))
    )
}

def DelayMap.reduceRightWithKey(
    f$21503: k -> v -> (k -> (v -> (k, v) \ ef)),
    m$21532: DelayMap[k, v]
): Option[(k, v)] \ ef = {
    match DelayMap.parallelForce(m$21532) {
        case _ =>
            match m$21532 {
                case DelayMap.DMap(t$21550) =>
                    let f1$21552: (
                        k -> Lazy[v] -> (k -> (Lazy[v] -> (k, Lazy[v]) \ ef))
                    ) = k1$21555 ->
                        v1$21559 ->
                            k2$21562 ->
                                v2$21564 ->
                                    match f$21503(
                                        k1$21555
                                    )(
                                        force v1$21559
                                    )(k2$21562)(force v2$21564) {
                                        case (k$21566, v$21568) =>
                                            (k$21566, lazy v$21568)
                                    };
                    match RedBlackTree.reduceRight(f1$21552, t$21550) {
                        case Option.Some(k$21574, v$21576) =>
                            Option.Some(k$21574, force v$21576)
                        case Option.None =>
                            Option.None
                    }
            }
    }
}

def DelayMap.remove(k$17696: k, m$17700: DelayMap[k, v]): DelayMap[k, v] = {
    match m$17700 {
        case DelayMap.DMap(t$17706) =>
            DelayMap.DMap(RedBlackTree.remove(k$17696, t$17706))
    }
}

def DelayMap.singleton(k$14243: k, v$14265: v): DelayMap[k, v] = {
    DelayMap.insert(k$14243, v$14265, DelayMap.empty(()))
}

def DelayMap.size(m$14338: DelayMap[k, v]): Int32 = {
    match m$14338 {case DelayMap.DMap(t$14350) => RedBlackTree.size(t$14350)}
}

def DelayMap.sumKeys(m$22152: DelayMap[Int32, v]): Int32 = {
    DelayMap.sumWith(k$22167 -> _$22171 -> k$22167, m$22152)
}

def DelayMap.sumValues(m$22203: DelayMap[k, Int32]): Int32 = {
    DelayMap.sumWith(_$22216 -> v$22218 -> v$22218, m$22203)
}

def DelayMap.sumWith(
    f$22230: k -> v -> Int32 \ ef,
    m$22236: DelayMap[k, v]
): Int32 \ ef = {
    match m$22236 {
        case DelayMap.DMap(t$22244) =>
            letrec sw$22249: (Unit -> Int32) = _unit$22251 ->
                match DelayMap.parallelForce(m$22236) {
                    case _ =>
                        RedBlackTree.sumWith(
                            k$22257 ->
                                v$22260 ->
                                    f$22230(k$22257)(force v$22260),
                            t$22244
                        )
                };
            match purityOf2(f$22230) {
                case Purity2.Pure(g$22272) =>
                    if (DelayMap.useParallelEvaluation(m$22236)) {
                        let h$22274: (k -> Lazy[v] -> Int32) = k$22276 ->
                            v$22280 ->
                                g$22272(k$22276)(force v$22280);
                        RedBlackTree.parSumWith(
                            <[unknown exp]>(DelayMap.threads(()), 1i32),
                            h$22274,
                            t$22244
                        )
                    } else {
                        sw$22249(())
                    }
                case Purity2.Impure(_) =>
                    sw$22249(())
            }
    }
}

def DelayMap.threads(_unit$13616: Unit): Int32 = {
    let multiplier$13664: Int32 = 4i32;
    <[unknown exp]>(multiplier$13664, Environment.getVirtualProcessors(()))
}

def DelayMap.toDelayList(m$21920: DelayMap[k, v]): DelayList[(k, v)] = {
    DelayMap.foldRightWithKey(
        k$21926 ->
            v$21928 ->
                acc$21930 ->
                    DelayList.ECons((k$21926, v$21928), acc$21930),
        DelayList.ENil,
        m$21920
    )
}

def DelayMap.toList(m$21825: DelayMap[k, v]): List[(k, v)] = {
    DelayMap.foldRightWithKey(
        k$21832 ->
            v$21834 ->
                acc$21848 ->
                    List.Cons((k$21832, v$21834), acc$21848),
        List.Nil,
        m$21825
    )
}

def DelayMap.toMap(m$21855: DelayMap[k, v]): Map[k, v] = {
    match DelayMap.parallelForce(m$21855) {
        case _ =>
            match m$21855 {
                case DelayMap.DMap(t$21865) =>
                    Map.Map(
                        RedBlackTree.mapWithKey(
                            _$21869 ->
                                v$21871 ->
                                    force v$21871,
                            t$21865
                        )
                    )
            }
    }
}

def DelayMap.toMutDeque(
    rc$21986: Region[r],
    m$21995: DelayMap[k, v]
): MutDeque[(k, v), r] \ r = {
    let m1$22004: Map[k, v] = DelayMap.toMap(m$21995);
    Map.toMutDeque(rc$21986, m1$22004)
}

def DelayMap.toMutMap(
    rc$21884: Region[r],
    m$21892: DelayMap[k, v]
): MutMap[k, v, r] \ r = {
    MutMap.MutMap(rc$21884, (ref DelayMap.toMap(m$21892)) @ rc$21884)
}

def DelayMap.toSet(m$21899: DelayMap[k, v]): Set[(k, v)] = {
    DelayMap.foldLeftWithKey(
        acc$21902 ->
            k$21904 ->
                v$21906 ->
                    Set.insert((k$21904, v$21906), acc$21902),
        Set.empty(()),
        m$21899
    )
}

def DelayMap.toString(m$13399: DelayMap[k, v]): String = {
    region rc$13403 {
        let sb$13407: StringBuilder[rc] = StringBuilder.empty(rc$13403);
        match DelayMap.parallelForce(m$13399) {
            case _ =>
                StringBuilder.appendString!("""DelayMap#{""", sb$13407);
                DelayMap.forEachWithIndex(
                    i$13420 ->
                        k$13427 ->
                            v$13432 ->
                                if (<[unknown exp]>(i$13420, 1i32)) {
                                    StringBuilder.appendString!(
                                        (
                                            (
                                                """""" + <[unknown exp]>(
                                                    k$13427
                                                )
                                            ) + """ => """
                                        ) + <[unknown exp]>(v$13432),
                                        sb$13407
                                    )
                                } else {
                                    StringBuilder.appendString!(
                                        (
                                            (
                                                (
                                                    """""" + """, """
                                                ) + <[unknown exp]>(k$13427)
                                            ) + """ => """
                                        ) + <[unknown exp]>(v$13432),
                                        sb$13407
                                    )
                                },
                    m$13399
                );
                StringBuilder.appendString!("""}""", sb$13407);
                StringBuilder.toString(sb$13407)
        }
    }
}

def DelayMap.union(
    m1$20774: DelayMap[k, v],
    m2$20780: DelayMap[k, v]
): DelayMap[k, v] = {
    DelayMap.unionWithKey(
        _$20787 ->
            v1$20791 ->
                _$20793 ->
                    v1$20791,
        m1$20774,
        m2$20780
    )
}

def DelayMap.unionWith(
    f$20811: v -> v -> v \ ef,
    m1$20819: DelayMap[k, v],
    m2$20823: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    DelayMap.unionWithKey(
        _$20843 ->
            v1$20846 ->
                v2$20848 ->
                    f$20811(v1$20846)(v2$20848),
        m1$20819,
        m2$20823
    )
}

def DelayMap.unionWithKey(
    f$20870: k -> v -> (v -> v \ ef),
    m1$20876: DelayMap[k, v],
    m2$20880: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    match purityOf3(f$20870) {
        case Purity3.Pure(g$20890) =>
            DelayMap.unionWithKeyL(g$20890, m1$20876, m2$20880)
        case Purity3.Impure(g$20897) =>
            DelayMap.unionWithKeyE(g$20897, m1$20876, m2$20880)
    }
}

def DelayMap.unionWithKeyE(
    f$20999: k -> v -> (v -> v \ ef),
    m1$21002: DelayMap[k, v],
    m2$21004: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    <[unknown exp]>
}

def DelayMap.unionWithKeyL(
    f$20914: k -> v -> (v -> v),
    m1$20917: DelayMap[k, v],
    m2$20921: DelayMap[k, v]
): DelayMap[k, v] = {
    <[unknown exp]>
}

def DelayMap.update(
    f$21662: v -> Option[v],
    k$21667: k,
    m$21669: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    DelayMap.updateWithKey(
        _$21676 ->
            v1$21678 ->
                f$21662(v1$21678),
        k$21667,
        m$21669
    )
}

def DelayMap.updateWithKey(
    f$21692: k -> v -> Option[v] \ ef,
    k$21697: k,
    m$21699: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    match purityOf2(f$21692) {
        case Purity2.Pure(g$21703) =>
            DelayMap.updateWithKeyL(g$21703, k$21697, m$21699)
        case Purity2.Impure(g$21706) =>
            DelayMap.updateWithKeyE(g$21706, k$21697, m$21699)
    }
}

def DelayMap.updateWithKeyE(
    f$21779: k -> v -> Option[v] \ ef,
    k$21781: k,
    m$21785: DelayMap[k, v]
): DelayMap[k, v] \ ef = {
    match m$21785 {
        case DelayMap.DMap(t$21797) =>
            let f1$21799: (k -> Lazy[v] -> Option[Lazy[v]] \ ef) = k1$21801 ->
                v1$21803 ->
                    {
                        let res$21805: Option[v] = f$21779(
                            k1$21801
                        )(force v1$21803);
                        match res$21805 {
                            case Option.Some(v2$21809) =>
                                Option.Some(lazy v2$21809)
                            case Option.None =>
                                Option.None
                        }
                    };
            DelayMap.DMap(RedBlackTree.updateWith(f1$21799, k$21781, t$21797))
    }
}

def DelayMap.updateWithKeyL(
    f$21732: k -> v -> Option[v],
    k$21739: k,
    m$21743: DelayMap[k, v]
): DelayMap[k, v] = {
    match m$21743 {
        case DelayMap.DMap(t$21751) =>
            let f1$21754: (k -> Lazy[v] -> Option[Lazy[v]]) = k1$21758 ->
                v1$21760 ->
                    {
                        let res$21762: Lazy[v] = lazy match f$21732(
                            k1$21758
                        )(force v1$21760) {
                            case Option.Some(v2$21765) =>
                                v2$21765
                            case Option.None =>
                                force v1$21760
                        };
                        Option.Some(res$21762)
                    };
            DelayMap.DMap(RedBlackTree.updateWith(f1$21754, k$21739, t$21751))
    }
}

def DelayMap.useParallelEvaluation(m$14167: DelayMap[k, v]): Bool = {
    match m$14167 {
        case DelayMap.DMap(t$14189) =>
            let minSize$14191: Int32 = Int32.pow(
                2i32,
                RedBlackTree.blackHeight(t$14189)
            );
            <[unknown exp]>(minSize$14191, 1024i32)
    }
}

def DelayMap.valuesOf(m$17666: DelayMap[k, v]): List[v] = {
    DelayMap.foldRight(
        v$17675 ->
            acc$17681 ->
                List.Cons(v$17675, acc$17681),
        List.Nil,
        m$17666
    )
}

enum Down[a] {case Down(a)}

def Eff.Random.BiasedCoin.ioHandler(f$44233: Unit -> a): a \ ef + IO = {
    let r$44235: Random = Random.fresh(());
    try {
        f$44233(())
    } with Eff.Random.BiasedCoin {
        def Eff.Random.BiasedCoin.flip(p$44237: Float64, k$44239: Bool -> a) =
        {
            if (<[unknown exp]>(Random.nextFloat64(r$44235), p$44237)) {
                k$44239(true)
            } else {
                k$44239(false)
            }
        }
    }
}

def Eff.Random.RandomCoin.ioHandler(f$42528: Unit -> a): a \ ef + IO = {
    let r$42534: Random = Random.fresh(());
    try {
        f$42528(())
    } with Eff.Random.RandomCoin {
        def Eff.Random.RandomCoin.flip(_unit$42938: Unit, k$42940: Bool -> a) =
        {
            k$42940(Random.nextBool(r$42534))
        }
    }
}

def Environment.getArgs(_unit$28553: Unit): List[String] = {
    region rc$28555 {
        let getArgs$28562: (Unit -> Array[String, rc]) = _$28564 ->
            <[unknown exp]>;
        match rc$28555 {case _ => Array.toList(getArgs$28562(()))}
    }
}

def Environment.getCurrentWorkingDirectory(
    _unit$28871: Unit
): Option[String] = {
    Environment.getProp("""user.dir""")
}

def Environment.getEnv(_unit$28598: Unit): Map[String, String] = {
    region rc$28607 {
        let getenv$28610: (Unit -> java.util.Map) = _$28612 ->
            <[unknown exp]>;
        let entrySet$28614: (java.util.Map -> java.util.Set) = obj$$28616 ->
            <[unknown exp]>;
        let iterator$28619: (
            java.util.Set -> java.util.Iterator
        ) = obj$$28621 ->
            <[unknown exp]>;
        match rc$28607 {
            case _ =>
                try {
                    let iter$28623: java.util.Iterator = |>(
                        |>(getenv$28610(()), entrySet$28614),
                        iterator$28619
                    );
                    Environment.getEnvHelper(iter$28623, Map.empty(()))
                } catch {case _$28686: ##java.lang.Exception => Map.empty(())}
        }
    }
}

def Environment.getEnvHelper(
    iter$28962: java.util.Iterator,
    m$28964: Map[String, String]
): Map[String, String] = {
    let hasNext$28966: (java.util.Iterator -> Bool) = obj$$28969 ->
        <[unknown exp]>;
    let next$28990: (java.util.Iterator -> java.lang.Object) = obj$$28992 ->
        <[unknown exp]>;
    let getKey$28995: (java.util.Map$Entry -> java.lang.Object) = obj$$28997 ->
        <[unknown exp]>;
    let getValue$29004: (
        java.util.Map$Entry -> java.lang.Object
    ) = obj$$29006 ->
        <[unknown exp]>;
    if (hasNext$28966(iter$28962)) {
        let e$29008: java.util.Map$Entry = <[unknown exp]>;
        let k$29010: String = <[unknown exp]>;
        let v$29016: String = <[unknown exp]>;
        Environment.getEnvHelper(
            iter$28962,
            Map.insert(k$29010, v$29016, m$28964)
        )
    } else {
        m$28964
    }
}

def Environment.getFileSeparator(_unit$28818: Unit): String = {
    let sep$28823: (Unit -> String) = _$28825 -> <[unknown exp]>; sep$28823(())
}

def Environment.getLineSeparator(_unit$28859: Unit): String = {
    let lineSeparator$28864: (Unit -> String) = _$28866 ->
        <[unknown exp]>;
    lineSeparator$28864(())
}

def Environment.getOsArch(_unit$28798: Unit): Option[String] = {
    Environment.getProp("""os.arch""")
}

def Environment.getOsName(_unit$28778: Unit): Option[String] = {
    Environment.getProp("""os.name""")
}

def Environment.getOsVersion(_unit$28802: Unit): Option[String] = {
    Environment.getProp("""os.version""")
}

def Environment.getPathSeparator(_unit$28836: Unit): String = {
    let pathSep$28838: (Unit -> String) = _$28840 ->
        <[unknown exp]>;
    pathSep$28838(())
}

def Environment.getProp(name$28746: String): Option[String] = {
    let getProperty$28748: (String -> String) = a0$$28750 ->
        <[unknown exp]>;
    try {
        let result$28752: String = getProperty$28748(name$28746);
        Object.toOption(result$28752)
    } catch {case _$28757: ##java.lang.Exception => Option.None}
}

def Environment.getTemporaryDirectory(_unit$28902: Unit): Option[String] = {
    Environment.getProp("""java.io.tmpdir""")
}

def Environment.getUserHomeDirectory(_unit$28925: Unit): Option[String] = {
    Environment.getProp("""user.home""")
}

def Environment.getUserName(_unit$28912: Unit): Option[String] = {
    Environment.getProp("""user.name""")
}

def Environment.getVar(name$28706: String): Option[String] = {
    let getenv$28715: (String -> String) = a0$$28717 ->
        <[unknown exp]>;
    try {
        let result$28738: String = getenv$28715(name$28706);
        Object.toOption(result$28738)
    } catch {case _$28740: ##java.lang.Exception => Option.None}
}

def Environment.getVirtualProcessors(_unit$28936: Unit): Int32 = {
    let getRuntime$28938: (Unit -> java.lang.Runtime) = _$28940 ->
        <[unknown exp]>;
    let availableProcessors$28947: (java.lang.Runtime -> Int32) = obj$$28949 ->
        <[unknown exp]>;
    |>(getRuntime$28938(()), availableProcessors$28947)
}

enum File {case File(java.io.RandomAccessFile)}

def File.close!(f$18549: File): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$18560 ->
            {
                let close$18564: (
                    java.io.RandomAccessFile -> Unit
                ) = obj$$18566 ->
                    obj$$18566..close();
                match f$18549 {
                    case File.File(f1$18575) =>
                        close$18564(f1$18575)
                }
            }
    )
}

def File.length(f$18581: File): Result[IOError, Int64] \ IO = {
    IOError.tryCatch(
        _$18590 ->
            {
                let length$18592: (
                    java.io.RandomAccessFile -> Int64
                ) = obj$$18594 ->
                    obj$$18594..length();
                match f$18581 {
                    case File.File(f1$18596) =>
                        length$18592(f1$18596)
                }
            }
    )
}

def File.modeString(m$17584: Mode): String = {
    match m$17584 {
        case File.Mode.ReadOnly =>
            """r"""
        case File.Mode.ReadWrite =>
            """rw"""
        case File.Mode.ReadWriteS =>
            """rws"""
        case File.Mode.ReadWriteD =>
            """rwd"""
    }
}

def File.open(
    path$17635: String,
    mode$17637: Mode
): Result[IOError, File] \ IO = {
    IOError.tryCatch(
        _$17655 ->
            {
                let newRandomAccessFile$18309: (
                    String -> String -> java.io.RandomAccessFile \ IO
                ) = a0$18313 ->
                    a1$18498 ->
                        ##java.io.RandomAccessFile(a0$18313, a1$18498);
                let mode1$18513: String = File.modeString(mode$17637);
                File.File(newRandomAccessFile$18309(path$17635)(mode1$18513))
            }
    )
}

def File.read!(
    buf$18750: Array[Int8, r],
    f$18760: File
): Result[IOError, Int32] \ IO + r = {
    IOError.tryCatch(
        _$18766 ->
            {
                let read$18769: (
                    java.io.RandomAccessFile -> Array[Int8, r] -> Int32 \ IO + r
                ) = obj$$18775 ->
                    a0$$18784 ->
                        <[unknown exp]>;
                match f$18760 {
                    case File.File(f1$18788) =>
                        read$18769(f1$18788)(buf$18750)
                }
            }
    )
}

def File.readBool!(f$19011: File): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$19017 ->
            {
                let readBoolean$19019: (
                    java.io.RandomAccessFile -> Bool
                ) = obj$$19021 ->
                    obj$$19021..readBoolean();
                match f$19011 {
                    case File.File(f1$19027) =>
                        readBoolean$19019(f1$19027)
                }
            }
    )
}

def File.readByte!(f$18990: File): Result[IOError, Int32] \ IO = {
    IOError.tryCatch(
        _$18999 ->
            {
                let read$19001: (
                    java.io.RandomAccessFile -> Int32
                ) = obj$$19003 ->
                    obj$$19003..read();
                match f$18990 {case File.File(f1$19007) => read$19001(f1$19007)}
            }
    )
}

def File.readChar!(f$19041: File): Result[IOError, Char] \ IO = {
    IOError.tryCatch(
        _$19051 ->
            {
                let readChar$19053: (
                    java.io.RandomAccessFile -> Char
                ) = obj$$19055 ->
                    obj$$19055..readChar();
                match f$19041 {
                    case File.File(f1$19063) =>
                        readChar$19053(f1$19063)
                }
            }
    )
}

def File.readFloat32!(f$19206: File): Result[IOError, Float32] \ IO = {
    IOError.tryCatch(
        _$19213 ->
            {
                let readFloat$19217: (
                    java.io.RandomAccessFile -> Float32
                ) = obj$$19219 ->
                    obj$$19219..readFloat();
                match f$19206 {
                    case File.File(f1$19228) =>
                        readFloat$19217(f1$19228)
                }
            }
    )
}

def File.readFloat64!(f$19239: File): Result[IOError, Float64] \ IO = {
    IOError.tryCatch(
        _$19247 ->
            {
                let readDouble$19253: (
                    java.io.RandomAccessFile -> Float64
                ) = obj$$19257 ->
                    obj$$19257..readDouble();
                match f$19239 {
                    case File.File(f1$19264) =>
                        readDouble$19253(f1$19264)
                }
            }
    )
}

def File.readFully!(
    buf$18884: Array[Int8, r],
    f$18897: File
): Result[IOError, Unit] \ IO + r = {
    IOError.tryCatch(
        _$18901 ->
            {
                let readFully$18903: (
                    java.io.RandomAccessFile -> Array[Int8, r] -> Unit \ IO + r
                ) = obj$$18905 ->
                    a0$$18907 ->
                        <[unknown exp]>;
                match f$18897 {
                    case File.File(f1$18925) =>
                        readFully$18903(f1$18925)(buf$18884)
                }
            }
    )
}

def File.readFullyWith!(
    destOffset$18939: { destOffset = Int32 },
    length$18943: { length = Int32 },
    buf$18948: Array[Int8, r],
    f$18950: File
): Result[IOError, Unit] \ IO + r = {
    IOError.tryCatch(
        _$18958 ->
            {
                let readFully$18960: (
                    java.io.RandomAccessFile ->
                        Array[Int8, r] -> (Int32 -> (Int32 -> Unit \ IO + r))
                ) = obj$$18962 ->
                    a0$$18966 ->
                        a1$$18971 ->
                            a2$$18973 ->
                                <[unknown exp]>;
                match f$18950 {
                    case File.File(f1$18977) =>
                        readFully$18960(
                            f1$18977
                        )(
                            buf$18948
                        )(destOffset$18939.destOffset)(length$18943.length)
                }
            }
    )
}

def File.readInt16!(f$19099: File): Result[IOError, Int16] \ IO = {
    IOError.tryCatch(
        _$19102 ->
            {
                let readShort$19104: (
                    java.io.RandomAccessFile -> Int16
                ) = obj$$19109 ->
                    obj$$19109..readShort();
                match f$19099 {
                    case File.File(f1$19114) =>
                        readShort$19104(f1$19114)
                }
            }
    )
}

def File.readInt32!(f$19124: File): Result[IOError, Int32] \ IO = {
    IOError.tryCatch(
        _$19132 ->
            {
                let readInt$19135: (
                    java.io.RandomAccessFile -> Int32
                ) = obj$$19137 ->
                    obj$$19137..readInt();
                match f$19124 {
                    case File.File(f1$19144) =>
                        readInt$19135(f1$19144)
                }
            }
    )
}

def File.readInt64!(f$19170: File): Result[IOError, Int64] \ IO = {
    IOError.tryCatch(
        _$19187 ->
            {
                let readLong$19189: (
                    java.io.RandomAccessFile -> Int64
                ) = obj$$19192 ->
                    obj$$19192..readLong();
                match f$19170 {
                    case File.File(f1$19194) =>
                        readLong$19189(f1$19194)
                }
            }
    )
}

def File.readInt8!(f$19076: File): Result[IOError, Int8] \ IO = {
    IOError.tryCatch(
        _$19085 ->
            {
                let readByte$19087: (
                    java.io.RandomAccessFile -> Int8
                ) = obj$$19089 ->
                    obj$$19089..readByte();
                match f$19076 {
                    case File.File(f1$19091) =>
                        readByte$19087(f1$19091)
                }
            }
    )
}

def File.readLine!(f$19353: File): Result[IOError, String] \ IO = {
    IOError.tryCatch(
        _$19360 ->
            {
                let readLine$19362: (
                    java.io.RandomAccessFile -> String
                ) = obj$$19364 ->
                    obj$$19364..readLine();
                match f$19353 {
                    case File.File(f1$19366) =>
                        readLine$19362(f1$19366)
                }
            }
    )
}

def File.readModifiedUTF!(f$19376: File): Result[IOError, String] \ IO = {
    IOError.tryCatch(
        _$19388 ->
            {
                let readUTF$19393: (
                    java.io.RandomAccessFile -> String
                ) = obj$$19397 ->
                    obj$$19397..readUTF();
                match f$19376 {
                    case File.File(f1$19402) =>
                        readUTF$19393(f1$19402)
                }
            }
    )
}

def File.readUnsignedByte!(f$19275: File): Result[IOError, Int32] \ IO = {
    IOError.tryCatch(
        _$19282 ->
            {
                let readUnsignedByte$19285: (
                    java.io.RandomAccessFile -> Int32
                ) = obj$$19289 ->
                    obj$$19289..readUnsignedByte();
                match f$19275 {
                    case File.File(f1$19303) =>
                        readUnsignedByte$19285(f1$19303)
                }
            }
    )
}

def File.readUnsignedShort!(f$19320: File): Result[IOError, Int32] \ IO = {
    IOError.tryCatch(
        _$19328 ->
            {
                let readUnsignedShort$19330: (
                    java.io.RandomAccessFile -> Int32
                ) = obj$$19332 ->
                    obj$$19332..readUnsignedShort();
                match f$19320 {
                    case File.File(f1$19338) =>
                        readUnsignedShort$19330(f1$19338)
                }
            }
    )
}

def File.readWith!(
    destOffset$18803: { destOffset = Int32 },
    length$18819: { length = Int32 },
    buf$18823: Array[Int8, r],
    f$18829: File
): Result[IOError, Int32] \ IO + r = {
    IOError.tryCatch(
        _$18837 ->
            {
                let read$18841: (
                    java.io.RandomAccessFile ->
                        Array[Int8, r] -> (Int32 -> (Int32 -> Int32 \ IO + r))
                ) = obj$$18843 ->
                    a0$$18849 ->
                        a1$$18863 ->
                            a2$$18866 ->
                                <[unknown exp]>;
                match f$18829 {
                    case File.File(f1$18876) =>
                        read$18841(
                            f1$18876
                        )(
                            buf$18823
                        )(destOffset$18803.destOffset)(length$18819.length)
                }
            }
    )
}

def File.seek!(pos$18599: Int64, f$18612: File): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$18616 ->
            {
                let seek$18618: (
                    java.io.RandomAccessFile -> Int64 -> Unit \ IO
                ) = obj$$18620 ->
                    a0$$18622 ->
                        obj$$18620..seek(a0$$18622);
                match f$18612 {
                    case File.File(f1$18633) =>
                        seek$18618(f1$18633)(pos$18599)
                }
            }
    )
}

def File.setLength!(
    len$18705: Int64,
    f$18707: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$18709 ->
            {
                let setLength$18713: (
                    java.io.RandomAccessFile -> Int64 -> Unit \ IO
                ) = obj$$18715 ->
                    a0$$18718 ->
                        obj$$18715..setLength(a0$$18718);
                match f$18707 {
                    case File.File(f1$18726) =>
                        setLength$18713(f1$18726)(len$18705)
                }
            }
    )
}

def File.skipBytes!(
    n$18649: Int32,
    f$18651: File
): Result[IOError, Int32] \ IO = {
    IOError.tryCatch(
        _$18657 ->
            {
                let skipBytes$18659: (
                    java.io.RandomAccessFile -> Int32 -> Int32 \ IO
                ) = obj$$18661 ->
                    a0$$18667 ->
                        obj$$18661..skipBytes(a0$$18667);
                match f$18651 {
                    case File.File(f1$18678) =>
                        skipBytes$18659(f1$18678)(n$18649)
                }
            }
    )
}

def File.write!(
    buf$19414: Array[Int8, r],
    f$19416: File
): Result[IOError, Unit] \ IO + r = {
    IOError.tryCatch(
        _$19418 ->
            {
                let write$19421: (
                    java.io.RandomAccessFile -> Array[Int8, r] -> Unit \ IO + r
                ) = obj$$19423 ->
                    a0$$19426 ->
                        <[unknown exp]>;
                match f$19416 {
                    case File.File(f1$19435) =>
                        write$19421(f1$19435)(buf$19414)
                }
            }
    )
}

def File.writeAsByte!(
    i$20035: Int32,
    f$20041: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$20044 ->
            {
                let writeByte$20048: (
                    java.io.RandomAccessFile -> Int32 -> Unit \ IO
                ) = obj$$20050 ->
                    a0$$20052 ->
                        obj$$20050..writeByte(a0$$20052);
                match f$20041 {
                    case File.File(f1$20062) =>
                        writeByte$20048(f1$20062)(i$20035)
                }
            }
    )
}

def File.writeAsChar!(
    c$19991: Int32,
    f$19994: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$20005 ->
            {
                let writeChar$20009: (
                    java.io.RandomAccessFile -> Int32 -> Unit \ IO
                ) = obj$$20011 ->
                    a0$$20013 ->
                        obj$$20011..writeChar(a0$$20013);
                match f$19994 {
                    case File.File(f1$20025) =>
                        writeChar$20009(f1$20025)(c$19991)
                }
            }
    )
}

def File.writeAsShort!(
    i$20069: Int32,
    f$20072: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$20074 ->
            {
                let writeShort$20076: (
                    java.io.RandomAccessFile -> Int32 -> Unit \ IO
                ) = obj$$20080 ->
                    a0$$20082 ->
                        obj$$20080..writeShort(a0$$20082);
                match f$20072 {
                    case File.File(f1$20091) =>
                        writeShort$20076(f1$20091)(i$20069)
                }
            }
    )
}

def File.writeBool!(
    b$19926: Bool,
    f$19931: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$19937 ->
            {
                let writeBoolean$19942: (
                    java.io.RandomAccessFile -> Bool -> Unit \ IO
                ) = obj$$19948 ->
                    a0$$19954 ->
                        obj$$19948..writeBoolean(a0$$19954);
                match f$19931 {
                    case File.File(f1$19967) =>
                        writeBoolean$19942(f1$19967)(b$19926)
                }
            }
    )
}

def File.writeFloat32!(
    d$20174: Float32,
    f$20180: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$20184 ->
            {
                let writeFloat$20186: (
                    java.io.RandomAccessFile -> Float32 -> Unit \ IO
                ) = obj$$20188 ->
                    a0$$20190 ->
                        obj$$20188..writeFloat(a0$$20190);
                match f$20180 {
                    case File.File(f1$20196) =>
                        writeFloat$20186(f1$20196)(d$20174)
                }
            }
    )
}

def File.writeFloat64!(
    d$20222: Float64,
    f$20229: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$20238 ->
            {
                let writeDouble$20240: (
                    java.io.RandomAccessFile -> Float64 -> Unit \ IO
                ) = obj$$20242 ->
                    a0$$20244 ->
                        obj$$20242..writeDouble(a0$$20244);
                match f$20229 {
                    case File.File(f1$20250) =>
                        writeDouble$20240(f1$20250)(d$20222)
                }
            }
    )
}

def File.writeInt32!(
    i$20106: Int32,
    f$20108: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$20118 ->
            {
                let writeInt$20122: (
                    java.io.RandomAccessFile -> Int32 -> Unit \ IO
                ) = obj$$20125 ->
                    a0$$20128 ->
                        obj$$20125..writeInt(a0$$20128);
                match f$20108 {
                    case File.File(f1$20134) =>
                        writeInt$20122(f1$20134)(i$20106)
                }
            }
    )
}

def File.writeInt64!(
    i$20138: Int64,
    f$20142: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$20152 ->
            {
                let writeLong$20154: (
                    java.io.RandomAccessFile -> Int64 -> Unit \ IO
                ) = obj$$20156 ->
                    a0$$20158 ->
                        obj$$20156..writeLong(a0$$20158);
                match f$20142 {
                    case File.File(f1$20171) =>
                        writeLong$20154(f1$20171)(i$20138)
                }
            }
    )
}

def File.writeModifiedUTF!(
    s$20269: String,
    f$20273: File
): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$20275 ->
            {
                let writeUTF$20277: (
                    java.io.RandomAccessFile -> String -> Unit \ IO
                ) = obj$$20279 ->
                    a0$$20281 ->
                        obj$$20279..writeUTF(a0$$20281);
                match f$20273 {
                    case File.File(f1$20287) =>
                        writeUTF$20277(f1$20287)(s$20269)
                }
            }
    )
}

def File.writeWith!(
    sourceOffset$19458: { sourceOffset = Int32 },
    length$19462: { length = Int32 },
    buf$19468: Array[Int8, r],
    f$19472: File
): Result[IOError, Unit] \ IO + r = {
    IOError.tryCatch(
        _$19484 ->
            {
                let write$19486: (
                    java.io.RandomAccessFile ->
                        Array[Int8, r] -> (Int32 -> (Int32 -> Unit \ IO + r))
                ) = obj$$19714 ->
                    a0$$19723 ->
                        a1$$19736 ->
                            a2$$19747 ->
                                <[unknown exp]>;
                match f$19472 {
                    case File.File(f1$19773) =>
                        write$19486(
                            f1$19773
                        )(
                            buf$19468
                        )(sourceOffset$19458.sourceOffset)(length$19462.length)
                }
            }
    )
}

enum File.Mode {
    case ReadOnly(Unit)
    case ReadWrite(Unit)
    case ReadWriteS(Unit)
    case ReadWriteD(Unit)
}

def Files.accessTime(f$4335: String): Result[IOError, Int64] \ IO = {
    try {
        let lastAccessTime$4338: (
            java.nio.file.attribute.BasicFileAttributes ->
                java.nio.file.attribute.FileTime
        ) = obj$$4340 ->
            obj$$4340..lastAccessTime();
        let toMillis$4342: (
            java.nio.file.attribute.FileTime -> Int64
        ) = obj$$4344 ->
            obj$$4344..toMillis();
        <[unknown exp]>(
            pat$13$4350 ->
                match pat$13$4350 {
                    case fileAttributes$4353 =>
                        <[unknown exp]>(
                            |>(
                                |>(fileAttributes$4353, lastAccessTime$4338),
                                toMillis$4342
                            )
                        )
                },
            Files.getAttributes(f$4335)
        )
    } catch {
        case ex$4367: ##java.io.IOException =>
            let getMessage$4369: (java.lang.Throwable -> String) = obj$$4373 ->
                obj$$4373..getMessage();
            Result.Err(IOError.Generic(getMessage$4369(<[unknown exp]>)))
    }
}

def Files.append(f$8184: String, data$8188: t): Result[IOError, Bool] \ IO = {
    try {
        let newFile$8201: (String -> java.io.File) = a0$8203 ->
            ##java.io.File(a0$8203);
        let newFileWriter$8211: (
            java.io.File -> Bool -> java.io.FileWriter \ IO
        ) = a0$8213 ->
            a1$8215 ->
                ##java.io.FileWriter(a0$8213, a1$8215);
        let newPrintWriter$8230: (
            java.io.Writer -> java.io.PrintWriter
        ) = a0$8235 ->
            ##java.io.PrintWriter(a0$8235);
        let println$8241: (
            java.io.PrintWriter -> String -> Unit \ IO
        ) = obj$$8247 ->
            a0$$8249 ->
                obj$$8247..println(a0$$8249);
        let close$8252: (java.io.PrintWriter -> Unit) = obj$$8254 ->
            obj$$8254..close();
        let checkError$8257: (java.io.PrintWriter -> Bool) = obj$$8265 ->
            obj$$8265..checkError();
        let alreadyExists$8279: Result[IOError, Bool] = Files.exists(f$8184);
        let javaFile$8281: java.io.File = newFile$8201(f$8184);
        let fileWriter$8283: java.io.FileWriter = newFileWriter$8211(
            javaFile$8281
        )(true);
        let printWriter$8295: java.io.PrintWriter = newPrintWriter$8230(
            <[unknown exp]>
        );
        println$8241(printWriter$8295)("""""" + <[unknown exp]>(data$8188));
        close$8252(printWriter$8295);
        if (checkError$8257(printWriter$8295)) {
            Result.Err(
                IOError.Generic(
                    (
                        (
                            """""" + """An error occurred when appending to the file: '"""
                        ) + <[unknown exp]>(f$8184)
                    ) + """'."""
                )
            )
        } else {
            Result.flatMap(
                exists$8301 ->
                    Result.Ok(!exists$8301),
                alreadyExists$8279
            )
        }
    } catch {
        case ex$8376: ##java.io.IOException =>
            let getMessage$8378: (java.lang.Throwable -> String) = obj$$8381 ->
                obj$$8381..getMessage();
            Result.Err(IOError.Generic(getMessage$8378(<[unknown exp]>)))
    }
}

def Files.appendBytes(
    f$9449: String,
    data$9453: f[Int8]
): Result[IOError, Bool] \ IO = {
    region rc$9463 {
        try {
            let newFile$9472: (String -> java.io.File) = a0$9475 ->
                ##java.io.File(a0$9475);
            let newFileStream$9484: (
                java.io.File -> Bool -> java.io.FileOutputStream \ IO
            ) = a0$9487 ->
                a1$9489 ->
                    ##java.io.FileOutputStream(a0$9487, a1$9489);
            let newPrintWriter$9496: (
                java.io.OutputStream -> java.io.PrintWriter
            ) = a0$9500 ->
                ##java.io.PrintWriter(a0$9500);
            let write$9508: (
                java.io.FileOutputStream -> Array[Int8, rc] -> Unit \ IO
            ) = obj$$9510 ->
                a0$$9515 ->
                    obj$$9510..write(a0$$9515);
            let close$9522: (java.io.PrintWriter -> Unit) = obj$$9524 ->
                obj$$9524..close();
            let checkError$9537: (java.io.PrintWriter -> Bool) = obj$$9543 ->
                obj$$9543..checkError();
            let alreadyExists$9546: Result[IOError, Bool] = Files.exists(
                f$9449
            );
            let javaFile$9550: java.io.File = newFile$9472(f$9449);
            let fileStream$9552: java.io.FileOutputStream = newFileStream$9484(
                javaFile$9550
            )(true);
            let printWriter$9557: java.io.PrintWriter = newPrintWriter$9496(
                <[unknown exp]>
            );
            let dataAsArray$9570: Array[Int8, rc] = <[unknown exp]>(
                rc$9463,
                data$9453
            );
            write$9508(fileStream$9552)(dataAsArray$9570);
            close$9522(printWriter$9557);
            if (checkError$9537(printWriter$9557)) {
                Result.Err(
                    IOError.Generic(
                        (
                            (
                                """""" + """An error occurred when appending to the file: '"""
                            ) + <[unknown exp]>(f$9449)
                        ) + """'."""
                    )
                )
            } else {
                Result.flatMap(
                    exists$9582 ->
                        Result.Ok(!exists$9582),
                    alreadyExists$9546
                )
            }
        } catch {
            case ex$9597: ##java.io.IOException =>
                let getMessage$9599: (
                    java.lang.Throwable -> String
                ) = obj$$9601 ->
                    obj$$9601..getMessage();
                Result.Err(IOError.Generic(getMessage$9599(<[unknown exp]>)))
        }
    }
}

def Files.appendLines(
    f$8772: String,
    data$8774: f[String]
): Result[IOError, Bool] \ IO = {
    try {
        let newFile$8789: (String -> java.io.File) = a0$8795 ->
            ##java.io.File(a0$8795);
        let newFileWriter$8802: (
            java.io.File -> Bool -> java.io.FileWriter \ IO
        ) = a0$8804 ->
            a1$8806 ->
                ##java.io.FileWriter(a0$8804, a1$8806);
        let newPrintWriter$8814: (
            java.io.Writer -> java.io.PrintWriter
        ) = a0$8822 ->
            ##java.io.PrintWriter(a0$8822);
        let println$8833: (
            java.io.PrintWriter -> String -> Unit \ IO
        ) = obj$$8836 ->
            a0$$8841 ->
                obj$$8836..println(a0$$8841);
        let close$8966: (java.io.PrintWriter -> Unit) = obj$$8974 ->
            obj$$8974..close();
        let checkError$8995: (java.io.PrintWriter -> Bool) = obj$$9001 ->
            obj$$9001..checkError();
        let alreadyExists$9108: Result[IOError, Bool] = Files.exists(f$8772);
        let javaFile$9110: java.io.File = newFile$8789(f$8772);
        let fileWriter$9115: java.io.FileWriter = newFileWriter$8802(
            javaFile$9110
        )(true);
        let printWriter$9117: java.io.PrintWriter = newPrintWriter$8814(
            <[unknown exp]>
        );
        <[unknown exp]>(
            line$9143 ->
                println$8833(printWriter$9117)(line$9143),
            data$8774
        );
        close$8966(printWriter$9117);
        if (checkError$8995(printWriter$9117)) {
            Result.Err(
                IOError.Generic(
                    (
                        (
                            """""" + """An error occurred when appending lines to the file: '"""
                        ) + <[unknown exp]>(f$8772)
                    ) + """'."""
                )
            )
        } else {
            Result.flatMap(
                exists$9171 ->
                    Result.Ok(!exists$9171),
                alreadyExists$9108
            )
        }
    } catch {
        case ex$9194: ##java.io.IOException =>
            let getMessage$9200: (java.lang.Throwable -> String) = obj$$9202 ->
                obj$$9202..getMessage();
            Result.Err(IOError.Generic(getMessage$9200(<[unknown exp]>)))
    }
}

def Files.copy(
    src$14939: { src = String },
    dst$14947: String
): Result[IOError, Unit] \ IO = {
    region rc$14966 {
        IOError.tryCatch(
            _$14969 ->
                {
                    let newFile$14971: (String -> java.io.File) = a0$14975 ->
                        ##java.io.File(a0$14975);
                    let toPath$14979: (
                        java.io.File -> java.nio.file.Path
                    ) = obj$$14981 ->
                        obj$$14981..toPath();
                    let copy$14996: (
                        java.nio.file.Path ->
                            java.nio.file.Path -> (Array[java.nio.file.CopyOption, rc] -> java.nio.file.Path \ IO)
                    ) = a0$$14999 ->
                        a1$$15001 ->
                            a2$$15004 ->
                                ##java.nio.file.Files.copy(
                                    a0$$14999,
                                    a1$$15001,
                                    a2$$15004
                                );
                    let srcFile$15037: java.io.File = newFile$14971(
                        src$14939.src
                    );
                    let srcPath$15043: java.nio.file.Path = toPath$14979(
                        srcFile$15037
                    );
                    let dstFile$15048: java.io.File = newFile$14971(dst$14947);
                    let dstPath$15053: java.nio.file.Path = toPath$14979(
                        dstFile$15048
                    );
                    discard copy$14996(
                        srcPath$15043
                    )(dstPath$15053)([] @ rc$14966)
                }
        )
    }
}

def Files.copyInto(
    src$15070: { src = String },
    dst$15074: String
): Result[IOError, Unit] \ IO = {
    try {
        match Files.isDirectory(dst$15074) {
            case Result.Ok(true) =>
                let newFile$15078: (String -> java.io.File) = a0$15080 ->
                    ##java.io.File(a0$15080);
                let toPath$15084: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$15086 ->
                    obj$$15086..toPath();
                let getFileName$15093: (
                    java.nio.file.Path -> java.nio.file.Path
                ) = obj$$15096 ->
                    obj$$15096..getFileName();
                let pathToString$15111: (
                    java.nio.file.Path -> String
                ) = obj$$15113 ->
                    obj$$15113..toString();
                let javaFile$15121: java.io.File = newFile$15078(src$15070.src);
                let javaPath$15127: java.nio.file.Path = toPath$15084(
                    javaFile$15121
                );
                let name$15131: String = pathToString$15111(
                    getFileName$15093(javaPath$15127)
                );
                let newDst$15133: String = <[unknown exp]>(
                    dst$15074,
                    name$15131
                );
                Files.copy({+src = src$15070.src | {}}, newDst$15133)
            case Result.Ok(false) =>
                Result.Err(IOError.Generic("""dst is not a directory."""))
            case Result.Err(msg$15155) =>
                Result.Err(msg$15155)
        }
    } catch {
        case ex$15159: ##java.io.IOException =>
            let getMessage$15161: (
                java.lang.Throwable -> String
            ) = obj$$15163 ->
                obj$$15163..getMessage();
            Result.Err(IOError.Generic(getMessage$15161(<[unknown exp]>)))
    }
}

def Files.copyOver(
    src$15199: { src = String },
    dst$15206: String
): Result[IOError, Unit] \ IO = {
    region rc$15208 {
        IOError.tryCatch(
            _$15211 ->
                {
                    let newFile$15213: (String -> java.io.File) = a0$15217 ->
                        ##java.io.File(a0$15217);
                    let toPath$15221: (
                        java.io.File -> java.nio.file.Path
                    ) = obj$$15223 ->
                        obj$$15223..toPath();
                    let copy$15228: (
                        java.nio.file.Path ->
                            java.nio.file.Path -> (Array[java.nio.file.CopyOption, rc] -> java.nio.file.Path \ IO)
                    ) = a0$$15232 ->
                        a1$$15234 ->
                            a2$$15236 ->
                                ##java.nio.file.Files.copy(
                                    a0$$15232,
                                    a1$$15234,
                                    a2$$15236
                                );
                    let getOverwrite$15250: (
                        Unit -> java.nio.file.StandardCopyOption
                    ) = _$15252 ->
                        ##java.nio.file.StandardCopyOption.REPLACE_EXISTING;
                    let dstFile$15254: java.io.File = newFile$15213(dst$15206);
                    let dstPath$15256: java.nio.file.Path = toPath$15221(
                        dstFile$15254
                    );
                    let srcFile$15262: java.io.File = newFile$15213(
                        src$15199.src
                    );
                    let srcPath$15264: java.nio.file.Path = toPath$15221(
                        srcFile$15262
                    );
                    discard copy$15228(
                        srcPath$15264
                    )(dstPath$15256)([<[unknown exp]>] @ rc$15208)
                }
        )
    }
}

def Files.creationTime(f$4379: String): Result[IOError, Int64] \ IO = {
    try {
        let creationTime$4386: (
            java.nio.file.attribute.BasicFileAttributes ->
                java.nio.file.attribute.FileTime
        ) = obj$$4388 ->
            obj$$4388..creationTime();
        let toMillis$4390: (
            java.nio.file.attribute.FileTime -> Int64
        ) = obj$$4392 ->
            obj$$4392..toMillis();
        <[unknown exp]>(
            pat$14$4405 ->
                match pat$14$4405 {
                    case fileAttributes$4409 =>
                        <[unknown exp]>(
                            |>(
                                |>(fileAttributes$4409, creationTime$4386),
                                toMillis$4390
                            )
                        )
                },
            Files.getAttributes(f$4379)
        )
    } catch {
        case ex$4412: ##java.io.IOException =>
            let getMessage$4414: (java.lang.Throwable -> String) = obj$$4416 ->
                obj$$4416..getMessage();
            Result.Err(IOError.Generic(getMessage$4414(<[unknown exp]>)))
    }
}

def Files.delete(f$15290: String): Result[IOError, Unit] \ IO = {
    IOError.tryCatch(
        _$15332 ->
            {
                let newFile$15338: (String -> java.io.File) = a0$15340 ->
                    ##java.io.File(a0$15340);
                let toPath$15349: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$15351 ->
                    obj$$15351..toPath();
                let delete$15369: (java.nio.file.Path -> Unit) = a0$$15373 ->
                    ##java.nio.file.Files.delete(a0$$15373);
                let javaFile$15389: java.io.File = newFile$15338(f$15290);
                let javaPath$15398: java.nio.file.Path = toPath$15349(
                    javaFile$15389
                );
                delete$15369(javaPath$15398)
            }
    )
}

def Files.deleteIfExists(f$17279: String): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$17305 ->
            {
                let newFile$17307: (String -> java.io.File) = a0$17309 ->
                    ##java.io.File(a0$17309);
                let toPath$17324: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$17326 ->
                    obj$$17326..toPath();
                let deleteIfExists$17389: (
                    java.nio.file.Path -> Bool
                ) = a0$$17391 ->
                    ##java.nio.file.Files.deleteIfExists(a0$$17391);
                let javaFile$17408: java.io.File = newFile$17307(f$17279);
                let javaPath$17414: java.nio.file.Path = toPath$17324(
                    javaFile$17408
                );
                deleteIfExists$17389(javaPath$17414)
            }
    )
}

def Files.exists(f$4715: String): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$4721 ->
            {
                let newFile$4726: (String -> java.io.File) = a0$4728 ->
                    ##java.io.File(a0$4728);
                let exists$4730: (java.io.File -> Bool) = obj$$4737 ->
                    obj$$4737..exists();
                exists$4730(newFile$4726(f$4715))
            }
    )
}

def Files.fileType(f$4614: String): Result[IOError, FileType] \ IO = {
    <[unknown exp]>(
        pat$19$4625 ->
            match pat$19$4625 {
                case isFile$4627 =>
                    <[unknown exp]>(
                        pat$18$4629 ->
                            match pat$18$4629 {
                                case isDirec$4631 =>
                                    <[unknown exp]>(
                                        pat$17$4633 ->
                                            match pat$17$4633 {
                                                case isSymLink$4637 =>
                                                    <[unknown exp]>(
                                                        if (isFile$4627) {
                                                            Files.FileType.File
                                                        } else {
                                                            if (isDirec$4631) {
                                                                Files.FileType.Directory
                                                            } else {
                                                                if (
                                                                    isSymLink$4637
                                                                ) {
                                                                    Files.FileType.SymLink
                                                                } else {
                                                                    Files.FileType.Other
                                                                }
                                                            }
                                                        }
                                                    )
                                            },
                                        Files.isSymbolicLink(f$4614)
                                    )
                            },
                        Files.isDirectory(f$4614)
                    )
            },
        Files.isRegularFile(f$4614)
    )
}

def Files.fromJavaIter(
    rc$14318: Region[r],
    iter$14322: java.util.Iterator
): Iterator[a, r, r] = {
    let hasNext$14324: (java.util.Iterator -> Bool) = obj$$14328 ->
        <[unknown exp]>;
    let getNext$14342: (java.util.Iterator -> a) = obj$$14352 ->
        <[unknown exp]>;
    let next$14359: (Unit -> Option[a]) = _unit$14361 ->
        if (hasNext$14324(iter$14322)) {
            |>(getNext$14342(iter$14322), x$$46608 -> Option.Some(x$$46608))
        } else {
            Option.None
        };
    Iterator.iterate(rc$14318, next$14359)
}

def Files.getAttributes(
    f$4503: String
): Result[IOError, java.nio.file.attribute.BasicFileAttributes] \ IO = {
    region rc$4505 {
        IOError.tryCatch(
            _$4510 ->
                {
                    let newFile$4513: (String -> java.io.File) = a0$4517 ->
                        ##java.io.File(a0$4517);
                    let toPath$4527: (
                        java.io.File -> java.nio.file.Path
                    ) = obj$$4531 ->
                        obj$$4531..toPath();
                    let readAttributes$4543: (
                        java.nio.file.Path ->
                            java.lang.Class -> (Array[java.nio.file.LinkOption, rc] -> java.nio.file.attribute.BasicFileAttributes \ IO)
                    ) = a0$$4547 ->
                        a1$$4553 ->
                            a2$$4556 ->
                                ##java.nio.file.Files.readAttributes(
                                    a0$$4547,
                                    a1$$4553,
                                    a2$$4556
                                );
                    let forName$4574: (String -> java.lang.Class) = a0$$4576 ->
                        ##java.lang.Class.forName(a0$$4576);
                    let javaFile$4586: java.io.File = newFile$4513(f$4503);
                    let javaPath$4590: java.nio.file.Path = toPath$4527(
                        javaFile$4586
                    );
                    let classOfAttributes$4596: java.lang.Class = forName$4574(
                        """java.nio.file.attribute.BasicFileAttributes"""
                    );
                    readAttributes$4543(
                        javaPath$4590
                    )(classOfAttributes$4596)([] @ rc$4505)
                }
        )
    }
}

def Files.isDirectory(f$4775: String): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$4804 ->
            {
                let newFile$4808: (String -> java.io.File) = a0$4810 ->
                    ##java.io.File(a0$4810);
                let isDirectory$4835: (java.io.File -> Bool) = obj$$4837 ->
                    obj$$4837..isDirectory();
                isDirectory$4835(newFile$4808(f$4775))
            }
    )
}

def Files.isExecutable(f$5121: String): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$5137 ->
            {
                let newFile$5139: (String -> java.io.File) = a0$5143 ->
                    ##java.io.File(a0$5143);
                let canExecute$5147: (java.io.File -> Bool) = obj$$5149 ->
                    obj$$5149..canExecute();
                canExecute$5147(newFile$5139(f$5121))
            }
    )
}

def Files.isReadable(f$4963: String): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$4968 ->
            {
                let newFile$4972: (String -> java.io.File) = a0$4976 ->
                    ##java.io.File(a0$4976);
                let canRead$4995: (java.io.File -> Bool) = obj$$4999 ->
                    obj$$4999..canRead();
                canRead$4995(newFile$4972(f$4963))
            }
    )
}

def Files.isRegularFile(f$4887: String): Result[IOError, Bool] \ IO = {
    region rc$4897 {
        IOError.tryCatch(
            _$4904 ->
                {
                    let newFile$4908: (String -> java.io.File) = a0$4910 ->
                        ##java.io.File(a0$4910);
                    let toPath$4915: (
                        java.io.File -> java.nio.file.Path
                    ) = obj$$4917 ->
                        obj$$4917..toPath();
                    let isRegularFile$4919: (
                        java.nio.file.Path ->
                            Array[java.nio.file.LinkOption, rc] -> Bool \ IO
                    ) = a0$$4921 ->
                        a1$$4924 ->
                            ##java.nio.file.Files.isRegularFile(
                                a0$$4921,
                                a1$$4924
                            );
                    let javaFile$4928: java.io.File = newFile$4908(f$4887);
                    let javaPath$4934: java.nio.file.Path = toPath$4915(
                        javaFile$4928
                    );
                    isRegularFile$4919(javaPath$4934)([] @ rc$4897)
                }
        )
    }
}

def Files.isSymbolicLink(f$5025: String): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$5036 ->
            {
                let newFile$5038: (String -> java.io.File) = a0$5042 ->
                    ##java.io.File(a0$5042);
                let toPath$5046: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$5048 ->
                    obj$$5048..toPath();
                let isSymbolicLink$5050: (
                    java.nio.file.Path -> Bool
                ) = a0$$5052 ->
                    ##java.nio.file.Files.isSymbolicLink(a0$$5052);
                let javaFile$5061: java.io.File = newFile$5038(f$5025);
                let javaPath$5067: java.nio.file.Path = toPath$5046(
                    javaFile$5061
                );
                isSymbolicLink$5050(javaPath$5067)
            }
    )
}

def Files.isWritable(f$5084: String): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$5087 ->
            {
                let newFile$5089: (String -> java.io.File) = a0$5091 ->
                    ##java.io.File(a0$5091);
                let canWrite$5098: (java.io.File -> Bool) = obj$$5100 ->
                    obj$$5100..canWrite();
                canWrite$5098(newFile$5089(f$5084))
            }
    )
}

def Files.list(f$10123: String): Result[IOError, List[String]] \ IO = {
    region rc$10143 {
        try {
            let newFile$10155: (String -> java.io.File) = a0$10164 ->
                ##java.io.File(a0$10164);
            let listFiles$10174: (
                java.io.File -> Array[java.io.File, rc]
            ) = obj$$10177 ->
                <[unknown exp]>;
            let toPath$12778: (
                java.io.File -> java.nio.file.Path
            ) = obj$$12795 ->
                obj$$12795..toPath();
            let pathToString$13071: (
                java.nio.file.Path -> String
            ) = obj$$13073 ->
                obj$$13073..toString();
            let javaList$13099: Array[java.io.File, rc] = |>(
                |>(f$10123, newFile$10155),
                listFiles$10174
            );
            if (!Object.isNull(javaList$13099)) {
                let paths$13115: Array[String, rc] = |>(
                    javaList$13099,
                    (
                        $0$46067 ->
                            $1$46069 ->
                                $2$46071 ->
                                    Array.map($0$46067, $1$46069, $2$46071)
                    )(rc$10143)(>>(toPath$12778, pathToString$13071))
                );
                Result.Ok(Array.toList(paths$13115))
            } else {
                Result.Err(
                    IOError.Generic(
                        (
                            (
                                """""" + """An error occurred when trying to list the file: '"""
                            ) + <[unknown exp]>(f$10123)
                        ) + """'."""
                    )
                )
            }
        } catch {
            case ex$13216: ##java.io.IOException =>
                let getMessage$13220: (
                    java.lang.Throwable -> String
                ) = obj$$13222 ->
                    obj$$13222..getMessage();
                Result.Err(IOError.Generic(getMessage$13220(<[unknown exp]>)))
        }
    }
}

def Files.listWithIter(
    rc$13276: Region[r],
    f$13278: String
): Result[IOError, Iterator[String, r, r]] \ IO = {
    IOError.tryCatch(
        _$13288 ->
            {
                let newFile$13291: (String -> java.io.File) = a0$13293 ->
                    ##java.io.File(a0$13293);
                let toPath$13352: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$13360 ->
                    obj$$13360..toPath();
                let newDirectoryStream$13374: (
                    java.nio.file.Path -> java.nio.file.DirectoryStream
                ) = a0$$13393 ->
                    ##java.nio.file.Files.newDirectoryStream(a0$$13393);
                let iterator$13488: (
                    java.nio.file.DirectoryStream -> java.util.Iterator
                ) = obj$$13491 ->
                    obj$$13491..iterator();
                let pathToString$13506: (
                    java.nio.file.Path -> String
                ) = obj$$13508 ->
                    <[unknown exp]>;
                let javaFile$13535: java.io.File = newFile$13291(f$13278);
                let javaPath$13543: java.nio.file.Path = toPath$13352(
                    javaFile$13535
                );
                let javaStream$13545: java.nio.file.DirectoryStream = newDirectoryStream$13374(
                    javaPath$13543
                );
                let javaIter$13547: java.util.Iterator = iterator$13488(
                    javaStream$13545
                );
                let iter$13549: Iterator[java.nio.file.Path, r, r] = Files.fromJavaIter(
                    rc$13276,
                    javaIter$13547
                );
                Iterator.map(pathToString$13506, iter$13549)
            }
    )
}

def Files.mkdir(d$9854: String): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$9921 ->
            {
                let newFile$9926: (String -> java.io.File) = a0$9929 ->
                    ##java.io.File(a0$9929);
                let mkdir$9937: (java.io.File -> Bool) = obj$$9939 ->
                    obj$$9939..mkdir();
                let javaFile$9949: java.io.File = newFile$9926(d$9854);
                mkdir$9937(javaFile$9949)
            }
    )
}

def Files.mkdirs(d$9973: String): Result[IOError, Bool] \ IO = {
    IOError.tryCatch(
        _$9986 ->
            {
                let newFile$10067: (String -> java.io.File) = a0$10069 ->
                    ##java.io.File(a0$10069);
                let mkdirs$10073: (java.io.File -> Bool) = obj$$10075 ->
                    obj$$10075..mkdirs();
                let javaFile$10090: java.io.File = newFile$10067(d$9973);
                mkdirs$10073(javaFile$10090)
            }
    )
}

def Files.modificationTime(f$4423: String): Result[IOError, Int64] \ IO = {
    try {
        let lastModifiedTime$4426: (
            java.nio.file.attribute.BasicFileAttributes ->
                java.nio.file.attribute.FileTime
        ) = obj$$4430 ->
            obj$$4430..lastModifiedTime();
        let toMillis$4435: (
            java.nio.file.attribute.FileTime -> Int64
        ) = obj$$4439 ->
            obj$$4439..toMillis();
        <[unknown exp]>(
            pat$15$4447 ->
                match pat$15$4447 {
                    case fileAttributes$4449 =>
                        <[unknown exp]>(
                            |>(
                                |>(fileAttributes$4449, lastModifiedTime$4426),
                                toMillis$4435
                            )
                        )
                },
            Files.getAttributes(f$4423)
        )
    } catch {
        case ex$4452: ##java.io.IOException =>
            let getMessage$4454: (java.lang.Throwable -> String) = obj$$4456 ->
                obj$$4456..getMessage();
            Result.Err(IOError.Generic(getMessage$4454(<[unknown exp]>)))
    }
}

def Files.move(
    src$14409: { src = String },
    dst$14422: String
): Result[IOError, Unit] \ IO = {
    region rc$14434 {
        IOError.tryCatch(
            _$14437 ->
                {
                    let newFile$14441: (String -> java.io.File) = a0$14445 ->
                        ##java.io.File(a0$14445);
                    let toPath$14470: (
                        java.io.File -> java.nio.file.Path
                    ) = obj$$14472 ->
                        obj$$14472..toPath();
                    let move$14522: (
                        java.nio.file.Path ->
                            java.nio.file.Path -> (Array[java.nio.file.CopyOption, rc] -> java.nio.file.Path \ IO)
                    ) = a0$$14524 ->
                        a1$$14538 ->
                            a2$$14540 ->
                                ##java.nio.file.Files.move(
                                    a0$$14524,
                                    a1$$14538,
                                    a2$$14540
                                );
                    let srcFile$14577: java.io.File = newFile$14441(
                        src$14409.src
                    );
                    let srcPath$14579: java.nio.file.Path = toPath$14470(
                        srcFile$14577
                    );
                    let dstFile$14581: java.io.File = newFile$14441(dst$14422);
                    let dstPath$14583: java.nio.file.Path = toPath$14470(
                        dstFile$14581
                    );
                    discard move$14522(
                        srcPath$14579
                    )(dstPath$14583)([] @ rc$14434)
                }
        )
    }
}

def Files.moveInto(
    src$14671: { src = String },
    dst$14675: String
): Result[IOError, Unit] \ IO = {
    try {
        match Files.isDirectory(dst$14675) {
            case Result.Ok(true) =>
                let newFile$14682: (String -> java.io.File) = a0$14684 ->
                    ##java.io.File(a0$14684);
                let toPath$14696: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$14699 ->
                    obj$$14699..toPath();
                let getFileName$14704: (
                    java.nio.file.Path -> java.nio.file.Path
                ) = obj$$14708 ->
                    obj$$14708..getFileName();
                let pathToString$14710: (
                    java.nio.file.Path -> String
                ) = obj$$14712 ->
                    obj$$14712..toString();
                let javaFile$14716: java.io.File = newFile$14682(src$14671.src);
                let javaPath$14718: java.nio.file.Path = toPath$14696(
                    javaFile$14716
                );
                let name$14720: String = pathToString$14710(
                    getFileName$14704(javaPath$14718)
                );
                let newDst$14722: String = <[unknown exp]>(
                    dst$14675,
                    name$14720
                );
                Files.move({+src = src$14671.src | {}}, newDst$14722)
            case Result.Ok(false) =>
                Result.Err(IOError.Generic("""dst is not a directory."""))
            case Result.Err(msg$14729) =>
                Result.Err(msg$14729)
        }
    } catch {
        case ex$14737: ##java.io.IOException =>
            let getMessage$14741: (
                java.lang.Throwable -> String
            ) = obj$$14743 ->
                obj$$14743..getMessage();
            Result.Err(IOError.Generic(getMessage$14741(<[unknown exp]>)))
    }
}

def Files.moveOver(
    src$14763: { src = String },
    dst$14769: String
): Result[IOError, Unit] \ IO = {
    region rc$14779 {
        IOError.tryCatch(
            _$14782 ->
                {
                    let newFile$14812: (String -> java.io.File) = a0$14816 ->
                        ##java.io.File(a0$14816);
                    let toPath$14824: (
                        java.io.File -> java.nio.file.Path
                    ) = obj$$14826 ->
                        obj$$14826..toPath();
                    let move$14836: (
                        java.nio.file.Path ->
                            java.nio.file.Path -> (Array[java.nio.file.CopyOption, rc] -> java.nio.file.Path \ IO)
                    ) = a0$$14846 ->
                        a1$$14851 ->
                            a2$$14855 ->
                                ##java.nio.file.Files.move(
                                    a0$$14846,
                                    a1$$14851,
                                    a2$$14855
                                );
                    let getOverwrite$14873: (
                        Unit -> java.nio.file.StandardCopyOption
                    ) = _$14875 ->
                        ##java.nio.file.StandardCopyOption.REPLACE_EXISTING;
                    let dstFile$14877: java.io.File = newFile$14812(dst$14769);
                    let dstPath$14879: java.nio.file.Path = toPath$14824(
                        dstFile$14877
                    );
                    let srcFile$14881: java.io.File = newFile$14812(
                        src$14763.src
                    );
                    let srcPath$14883: java.nio.file.Path = toPath$14824(
                        srcFile$14881
                    );
                    discard move$14836(
                        srcPath$14883
                    )(dstPath$14879)([<[unknown exp]>] @ rc$14779)
                }
        )
    }
}

def Files.read(f$5182: String): Result[IOError, String] \ IO = {
    IOError.tryCatch(
        _$5197 ->
            {
                let newFile$5199: (String -> java.io.File) = a0$5201 ->
                    ##java.io.File(a0$5201);
                let toPath$5210: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$5213 ->
                    obj$$5213..toPath();
                let readString$5219: (
                    java.nio.file.Path -> String
                ) = a0$$5223 ->
                    ##java.nio.file.Files.readString(a0$$5223);
                let javaFile$5228: java.io.File = newFile$5199(f$5182);
                let javaPath$5230: java.nio.file.Path = toPath$5210(
                    javaFile$5228
                );
                let result$5239: String = readString$5219(javaPath$5230);
                result$5239
            }
    )
}

def Files.readAll(r$5717: java.io.BufferedReader): List[String] \ IO = {
    let readLine$5725: (java.io.BufferedReader -> String) = obj$$5729 ->
        obj$$5729..readLine();
    letrec loop$5736: (List[String] -> List[String] -> List[String]) = k$5739 ->
        {
            let l$5746: String = readLine$5725(r$5717);
            if (Object.isNull(l$5746)) {
                k$5739(List.Nil)
            } else {
                loop$5736(ks$5760 -> k$5739(List.Cons(l$5746, ks$5760)))
            }
        };
    loop$5736($0$45658 -> identity($0$45658))
}

def Files.readBytes(
    _rc$6183: Region[r],
    f$6195: String
): Result[IOError, Array[Int8, r]] \ r + IO = {
    IOError.tryCatch(
        _$6212 ->
            {
                let newFile$6216: (String -> java.io.File) = a0$6218 ->
                    ##java.io.File(a0$6218);
                let toPath$6222: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$6224 ->
                    obj$$6224..toPath();
                let readAllBytes$6228: (
                    java.nio.file.Path -> Array[Int8, r]
                ) = a0$$6230 ->
                    <[unknown exp]>;
                let javaFile$6241: java.io.File = newFile$6216(f$6195);
                let javaPath$6244: java.nio.file.Path = toPath$6222(
                    javaFile$6241
                );
                let bytes$6248: Array[Int8, r] = readAllBytes$6228(
                    javaPath$6244
                );
                bytes$6248
            }
    )
}

def Files.readBytesWith(
    rc$6257: Region[r],
    opts$6265: { count = Int32, offset = Int64 },
    f$6273: String
): Result[IOError, Array[Int8, r]] \ r + IO = {
    if (<[unknown exp]>(0i32, opts$6265.count)) {
        try {
            let newFile$6285: (String -> java.io.File) = a0$6289 ->
                ##java.io.File(a0$6289);
            let newInputStream$6295: (
                java.io.File -> java.io.FileInputStream
            ) = a0$6298 ->
                ##java.io.FileInputStream(a0$6298);
            let read$6301: (
                java.io.FileInputStream ->
                    Array[Int8, r] -> (Int32 -> (Int32 -> Int32 \ IO))
            ) = obj$$6303 ->
                a0$$6305 ->
                    a1$$6308 ->
                        a2$$6313 ->
                            obj$$6303..read(a0$$6305, a1$$6308, a2$$6313);
            let javaFile$6331: java.io.File = newFile$6285(f$6273);
            let stream$6335: java.io.FileInputStream = newInputStream$6295(
                javaFile$6331
            );
            match Files.skip(
                <[unknown exp]>(opts$6265.offset, 10000i64),
                opts$6265.offset,
                stream$6335,
                f$6273
            ) {
                case Result.Ok(_) =>
                    let bytes$6359: Array[Int8, r] = Array.empty(
                        rc$6257,
                        opts$6265.count
                    );
                    let numberRead$6364: Int32 = read$6301(
                        stream$6335
                    )(bytes$6359)(0i32)(opts$6265.count);
                    let res$6366: Array[Int8, r] = Files.readBytesWithHelper(
                        rc$6257,
                        bytes$6359,
                        numberRead$6364,
                        opts$6265.count
                    );
                    Result.Ok(res$6366)
                case Result.Err(msg$6369) =>
                    Result.Err(msg$6369)
            }
        } catch {
            case ex$6378: ##java.io.IOException =>
                let getMessage$6381: (
                    java.lang.Throwable -> String
                ) = obj$$6383 ->
                    obj$$6383..getMessage();
                Result.Err(IOError.Generic(getMessage$6381(<[unknown exp]>)))
        }
    } else {
        if (<[unknown exp]>(opts$6265.count, 0i32)) {
            Result.Ok([] @ rc$6257)
        } else {
            Result.Err(
                IOError.Generic(
                    """The argument `count` has to be a non negative number when calling `File.readBytesWith`."""
                )
            )
        }
    }
}

def Files.readBytesWithHelper(
    rc$6429: Region[r],
    bytes$6435: Array[Int8, r],
    numberRead$6441: Int32,
    count$6443: Int32
): Array[Int8, r] \ r = {
    let nothingRead$6450: Bool = <[unknown exp]>(numberRead$6441, -1i32);
    if (nothingRead$6450) {
        [] @ rc$6429
    } else {
        let countBiggest$6452: Bool = <[unknown exp]>(
            numberRead$6441,
            count$6443
        );
        if (countBiggest$6452) {
            Array.slice(
                rc$6429,
                {+start = 0i32 | {}},
                {+end = numberRead$6441 | {}},
                bytes$6435
            )
        } else {
            bytes$6435
        }
    }
}

def Files.readChunks(
    rc$6527: Region[r],
    chunkSize$6536: Int32,
    f$6540: String
): Iterator[Result[IOError, Array[Int8, r]], IO + r, r] \ IO + r = {
    if (<[unknown exp]>(0i32, chunkSize$6536)) {
        try {
            let newFile$6600: (String -> java.io.File) = a0$6602 ->
                ##java.io.File(a0$6602);
            let newInputStream$6617: (
                java.io.File -> java.io.FileInputStream
            ) = a0$6621 ->
                ##java.io.FileInputStream(a0$6621);
            let read$6629: (
                java.io.FileInputStream -> Array[Int8, r] -> Int32 \ IO + r
            ) = obj$$6631 ->
                a0$$6634 ->
                    <[unknown exp]>;
            let javaFile$6671: java.io.File = newFile$6600(f$6540);
            let stream$6675: java.io.FileInputStream = newInputStream$6617(
                javaFile$6671
            );
            let bytes$6677: Ref[Array[Int8, r], r] = (
                ref Array.empty(rc$6527, chunkSize$6536)
            ) @ rc$6527;
            let numberRead$6698: Ref[Int32, r] = (
                ref read$6629(stream$6675)(deref bytes$6677)
            ) @ rc$6527;
            let next$6725: (
                Unit -> Option[Result[IOError, Array[Int8, r]]]
            ) = _unit$6728 ->
                <[unknown exp]>;
            Iterator.iterate(rc$6527, next$6725)
        } catch {
            case ex$6863: ##java.io.IOException =>
                let getMessage$6866: (
                    java.lang.Throwable -> String
                ) = obj$$6869 ->
                    <[unknown exp]>;
                Iterator.iterate(
                    rc$6527,
                    constant(
                        Option.Some(
                            Result.Err(
                                IOError.Generic(
                                    getMessage$6866(<[unknown exp]>)
                                )
                            )
                        )
                    )
                )
        }
    } else {
        Iterator.iterate(
            rc$6527,
            constant(
                Option.Some(
                    Result.Err(
                        IOError.Generic(
                            """The argument `chunkSize` has to be a non negative number when calling `File.readChunks`."""
                        )
                    )
                )
            )
        )
    }
}

def Files.readLines(f$5621: String): Result[IOError, List[String]] \ IO = {
    IOError.tryCatch(
        _$5635 ->
            {
                let newFile$5641: (String -> java.io.File) = a0$5645 ->
                    ##java.io.File(a0$5645);
                let toPath$5663: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$5671 ->
                    obj$$5671..toPath();
                let newBufferedReader$5695: (
                    java.nio.file.Path -> java.io.BufferedReader
                ) = a0$$5697 ->
                    ##java.nio.file.Files.newBufferedReader(a0$$5697);
                let javaFile$5703: java.io.File = newFile$5641(f$5621);
                let javaPath$5705: java.nio.file.Path = toPath$5663(
                    javaFile$5703
                );
                let reader$5709: java.io.BufferedReader = newBufferedReader$5695(
                    javaPath$5705
                );
                Files.readAll(reader$5709)
            }
    )
}

def Files.readLinesIter(
    rc$5867: Region[r],
    f$5869: String
): Iterator[Result[IOError, String], IO + r, r] \ r + IO = {
    try {
        let newFile$5879: (String -> java.io.File) = a0$5882 ->
            ##java.io.File(a0$5882);
        let toPath$5893: (java.io.File -> java.nio.file.Path) = obj$$5895 ->
            obj$$5895..toPath();
        let newBufferedReader$5899: (
            java.nio.file.Path -> java.io.BufferedReader
        ) = a0$$5901 ->
            ##java.nio.file.Files.newBufferedReader(a0$$5901);
        let readLine$5903: (java.io.BufferedReader -> String) = obj$$5905 ->
            obj$$5905..readLine();
        let javaFile$5920: java.io.File = newFile$5879(f$5869);
        let javaPath$5924: java.nio.file.Path = toPath$5893(javaFile$5920);
        let reader$5926: java.io.BufferedReader = newBufferedReader$5899(
            javaPath$5924
        );
        let line$5932: Ref[String, r] = (
            ref readLine$5903(reader$5926)
        ) @ rc$5867;
        let next$5936: (Unit -> Option[Result[IOError, String]]) = _unit$5939 ->
            <[unknown exp]>;
        Iterator.iterate(rc$5867, next$5936)
    } catch {
        case ex$5974: ##java.io.IOException =>
            let getMessage$5976: (java.lang.Throwable -> String) = obj$$5978 ->
                <[unknown exp]>;
            Iterator.iterate(
                rc$5867,
                constant(
                    Option.Some(
                        Result.Err(
                            IOError.Generic(getMessage$5976(<[unknown exp]>))
                        )
                    )
                )
            )
    }
}

def Files.readLinesIterWith(
    rc$6009: Region[r],
    opts$6011: { charSet = String },
    f$6019: String
): Iterator[Result[IOError, String], IO + r, r] \ r + IO = {
    try {
        let newFile$6026: (String -> java.io.File) = a0$6028 ->
            ##java.io.File(a0$6028);
        let toPath$6046: (java.io.File -> java.nio.file.Path) = obj$$6048 ->
            obj$$6048..toPath();
        let newBufferedReader$6053: (
            java.nio.file.Path ->
                java.nio.charset.Charset -> java.io.BufferedReader \ IO
        ) = a0$$6055 ->
            a1$$6059 ->
                ##java.nio.file.Files.newBufferedReader(a0$$6055, a1$$6059);
        let forName$6075: (String -> java.nio.charset.Charset) = a0$$6077 ->
            ##java.nio.charset.Charset.forName(a0$$6077);
        let readLine$6079: (java.io.BufferedReader -> String) = obj$$6081 ->
            obj$$6081..readLine();
        let javaFile$6089: java.io.File = newFile$6026(f$6019);
        let javaPath$6097: java.nio.file.Path = toPath$6046(javaFile$6089);
        let reader$6102: java.io.BufferedReader = newBufferedReader$6053(
            javaPath$6097
        )(forName$6075(opts$6011.charSet));
        let line$6108: Ref[String, r] = (
            ref readLine$6079(reader$6102)
        ) @ rc$6009;
        let next$6110: (Unit -> Option[Result[IOError, String]]) = _unit$6112 ->
            <[unknown exp]>;
        Iterator.iterate(rc$6009, next$6110)
    } catch {
        case ex$6159: ##java.io.IOException =>
            let getMessage$6163: (java.lang.Throwable -> String) = obj$$6167 ->
                <[unknown exp]>;
            Iterator.iterate(
                rc$6009,
                constant(
                    Option.Some(
                        Result.Err(
                            IOError.Generic(getMessage$6163(<[unknown exp]>))
                        )
                    )
                )
            )
    }
}

def Files.readLinesWith(
    opts$5782: { charSet = String },
    f$5784: String
): Result[IOError, List[String]] \ IO = {
    IOError.tryCatch(
        _$5789 ->
            {
                let newFile$5791: (String -> java.io.File) = a0$5793 ->
                    ##java.io.File(a0$5793);
                let toPath$5800: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$5804 ->
                    obj$$5804..toPath();
                let newBufferedReader$5810: (
                    java.nio.file.Path ->
                        java.nio.charset.Charset -> java.io.BufferedReader \ IO
                ) = a0$$5812 ->
                    a1$$5814 ->
                        ##java.nio.file.Files.newBufferedReader(
                            a0$$5812,
                            a1$$5814
                        );
                let forName$5822: (
                    String -> java.nio.charset.Charset
                ) = a0$$5824 ->
                    ##java.nio.charset.Charset.forName(a0$$5824);
                let javaFile$5836: java.io.File = newFile$5791(f$5784);
                let javaPath$5844: java.nio.file.Path = toPath$5800(
                    javaFile$5836
                );
                let reader$5846: java.io.BufferedReader = newBufferedReader$5810(
                    javaPath$5844
                )(forName$5822(opts$5782.charSet));
                Files.readAll(reader$5846)
            }
    )
}

def Files.readWith(
    opts$5257: { charSet = String, count = Int32, offset = Int64 },
    f$5273: String
): Result[IOError, String] \ IO = {
    region rc$5283 {
        if (<[unknown exp]>(0i32, opts$5257.count)) {
            try {
                let newFile$5292: (String -> java.io.File) = a0$5294 ->
                    ##java.io.File(a0$5294);
                let newInputStream$5297: (
                    java.io.File -> java.io.FileInputStream
                ) = a0$5301 ->
                    ##java.io.FileInputStream(a0$5301);
                let read$5306: (
                    java.io.FileInputStream ->
                        Array[Int8, rc] -> (Int32 -> (Int32 -> Int32 \ IO))
                ) = obj$$5310 ->
                    a0$$5319 ->
                        a1$$5324 ->
                            a2$$5326 ->
                                obj$$5310..read(a0$$5319, a1$$5324, a2$$5326);
                let forName$5331: (
                    String -> java.nio.charset.Charset
                ) = a0$$5333 ->
                    ##java.nio.charset.Charset.forName(a0$$5333);
                let newString$5337: (
                    Array[Int8, rc] -> java.nio.charset.Charset -> String \ IO
                ) = a0$5339 ->
                    a1$5342 ->
                        ##java.lang.String(a0$5339, a1$5342);
                let javaFile$5365: java.io.File = newFile$5292(f$5273);
                let stream$5367: java.io.FileInputStream = newInputStream$5297(
                    javaFile$5365
                );
                match Files.skip(
                    <[unknown exp]>(opts$5257.offset, 10000i64),
                    opts$5257.offset,
                    stream$5367,
                    f$5273
                ) {
                    case Result.Ok(_) =>
                        let bytes$5376: Array[Int8, rc] = Array.empty(
                            rc$5283,
                            opts$5257.count
                        );
                        discard read$5306(
                            stream$5367
                        )(bytes$5376)(0i32)(opts$5257.count);
                        let charSet$5432: java.nio.charset.Charset = forName$5331(
                            opts$5257.charSet
                        );
                        let returnString$5437: String = newString$5337(
                            bytes$5376
                        )(charSet$5432);
                        Result.Ok(returnString$5437)
                    case Result.Err(msg$5462) =>
                        Result.Err(msg$5462)
                }
            } catch {
                case ex$5512: ##java.io.IOException =>
                    let getMessage$5520: (
                        java.lang.Throwable -> String
                    ) = obj$$5524 ->
                        obj$$5524..getMessage();
                    Result.Err(
                        IOError.Generic(getMessage$5520(<[unknown exp]>))
                    )
            }
        } else {
            if (<[unknown exp]>(opts$5257.count, 0i32)) {
                Result.Ok("""""")
            } else {
                Result.Err(
                    IOError.Generic(
                        """The argument `count` has to be a non negative number when calling `File.readWith`."""
                    )
                )
            }
        }
    }
}

def Files.size(f$4470: String): Result[IOError, Int64] \ IO = {
    try {
        let size$4477: (
            java.nio.file.attribute.BasicFileAttributes -> Int64
        ) = obj$$4479 ->
            obj$$4479..size();
        <[unknown exp]>(
            pat$16$4483 ->
                match pat$16$4483 {
                    case fileAttributes$4485 =>
                        <[unknown exp]>(size$4477(fileAttributes$4485))
                },
            Files.getAttributes(f$4470)
        )
    } catch {
        case ex$4490: ##java.io.IOException =>
            let getMessage$4494: (java.lang.Throwable -> String) = obj$$4496 ->
                obj$$4496..getMessage();
            Result.Err(IOError.Generic(getMessage$4494(<[unknown exp]>)))
    }
}

def Files.skip(
    i$5548: Int64,
    bytesToSkip$5553: Int64,
    stream$5559: java.io.FileInputStream,
    f$5565: String
): Result[IOError, Unit] \ IO = {
    try {
        if (<[unknown exp]>(0i64, i$5548)) {
            let javaSkip$5572: (
                java.io.FileInputStream -> Int64 -> Int64 \ IO
            ) = obj$$5574 ->
                a0$$5576 ->
                    obj$$5574..skip(a0$$5576);
            let skipped$5580: Int64 = javaSkip$5572(
                stream$5559
            )(bytesToSkip$5553);
            if (<[unknown exp]>(skipped$5580, bytesToSkip$5553)) {
                Files.skip(
                    <[unknown exp]>(i$5548, 1i64),
                    <[unknown exp]>(bytesToSkip$5553, skipped$5580),
                    stream$5559,
                    f$5565
                )
            } else {
                Result.Ok
            }
        } else {
            Result.Err(
                IOError.Generic(
                    (
                        (
                            """""" + """An error occurred when reading the file: '"""
                        ) + <[unknown exp]>(f$5565)
                    ) + """'."""
                )
            )
        }
    } catch {
        case ex$5592: ##java.io.IOException =>
            let getMessage$5594: (java.lang.Throwable -> String) = obj$$5596 ->
                obj$$5596..getMessage();
            Result.Err(IOError.Generic(getMessage$5594(<[unknown exp]>)))
    }
}

def Files.stat(f$4666: String): Result[IOError, StatInfo] \ IO = {
    <[unknown exp]>(
        pat$24$4676 ->
            match pat$24$4676 {
                case fileAccessTime$4678 =>
                    <[unknown exp]>(
                        pat$23$4680 ->
                            match pat$23$4680 {
                                case fileCreationTime$4684 =>
                                    <[unknown exp]>(
                                        pat$22$4687 ->
                                            match pat$22$4687 {
                                                case fileModificationTime$4693 =>
                                                    <[unknown exp]>(
                                                        pat$21$4695 ->
                                                            match pat$21$4695 {
                                                                case fileSize$4697 =>
                                                                    <[unknown exp]>(
                                                                        pat$20$4700 ->
                                                                            match pat$20$4700 {
                                                                                case typeOfFile$4702 =>
                                                                                    <[unknown exp]>(
                                                                                        {
                                                                                            +accessTime = fileAccessTime$4678,
                                                                                            +creationTime = fileCreationTime$4684,
                                                                                            +modificationTime = fileModificationTime$4693,
                                                                                            +size = fileSize$4697,
                                                                                            +fileType = typeOfFile$4702 |
                                                                                            {}
                                                                                        }
                                                                                    )
                                                                            },
                                                                        Files.fileType(
                                                                            f$4666
                                                                        )
                                                                    )
                                                            },
                                                        Files.size(f$4666)
                                                    )
                                            },
                                        Files.modificationTime(f$4666)
                                    )
                            },
                        Files.creationTime(f$4666)
                    )
            },
        Files.accessTime(f$4666)
    )
}

def Files.truncate(f$9641: String): Result[IOError, Bool] \ IO = {
    try {
        let newFile$9647: (String -> java.io.File) = a0$9652 ->
            ##java.io.File(a0$9652);
        let newPrintWriter$9658: (
            java.io.File -> java.io.PrintWriter
        ) = a0$9660 ->
            ##java.io.PrintWriter(a0$9660);
        let close$9666: (java.io.PrintWriter -> Unit) = obj$$9668 ->
            obj$$9668..close();
        let checkError$9702: (java.io.PrintWriter -> Bool) = obj$$9709 ->
            obj$$9709..checkError();
        let alreadyExists$9724: Result[IOError, Bool] = Files.exists(f$9641);
        let javaFile$9734: java.io.File = newFile$9647(f$9641);
        let printWriter$9736: java.io.PrintWriter = newPrintWriter$9658(
            javaFile$9734
        );
        close$9666(printWriter$9736);
        if (checkError$9702(printWriter$9736)) {
            Result.Err(
                IOError.Generic(
                    (
                        (
                            """""" + """An error occurred when truncating to the file: '"""
                        ) + <[unknown exp]>(f$9641)
                    ) + """'."""
                )
            )
        } else {
            Result.flatMap(
                exists$9777 ->
                    Result.Ok(!exists$9777),
                alreadyExists$9724
            )
        }
    } catch {
        case ex$9794: ##java.io.IOException =>
            let getMessage$9796: (java.lang.Throwable -> String) = obj$$9800 ->
                obj$$9800..getMessage();
            Result.Err(IOError.Generic(getMessage$9796(<[unknown exp]>)))
    }
}

def Files.walk(
    rc$13757: Region[r],
    f$13799: String
): Result[IOError, Iterator[String, r, r]] \ IO + r = {
    IOError.tryCatch(
        _$13882 ->
            {
                let newFile$13893: (String -> java.io.File) = a0$13895 ->
                    ##java.io.File(a0$13895);
                let toPath$13975: (
                    java.io.File -> java.nio.file.Path
                ) = obj$$13977 ->
                    obj$$13977..toPath();
                let walk$14149: (
                    java.nio.file.Path ->
                        Array[java.nio.file.FileVisitOption, r] -> java.util.stream.Stream \ IO
                ) = a0$$14153 ->
                    a1$$14157 ->
                        ##java.nio.file.Files.walk(a0$$14153, a1$$14157);
                let iterator$14159: (
                    java.util.stream.BaseStream -> java.util.Iterator
                ) = obj$$14161 ->
                    obj$$14161..iterator();
                let pathToString$14165: (
                    java.nio.file.Path -> String
                ) = obj$$14169 ->
                    <[unknown exp]>;
                let javaFile$14171: java.io.File = newFile$13893(f$13799);
                let javaPath$14173: java.nio.file.Path = toPath$13975(
                    javaFile$14171
                );
                let javaStream$14175: java.util.stream.Stream = walk$14149(
                    javaPath$14173
                )([] @ rc$13757);
                let javaIter$14286: java.util.Iterator = iterator$14159(
                    <[unknown exp]>
                );
                let iter$14296: Iterator[java.nio.file.Path, r, r] = Files.fromJavaIter(
                    rc$13757,
                    javaIter$14286
                );
                Iterator.map(pathToString$14165, iter$14296)
            }
    )
}

def Files.write(f$6946: String, data$6950: t): Result[IOError, Bool] \ IO = {
    try {
        let newFile$6961: (String -> java.io.File) = a0$6963 ->
            ##java.io.File(a0$6963);
        let newPrintWriter$6966: (
            java.io.File -> java.io.PrintWriter
        ) = a0$6971 ->
            ##java.io.PrintWriter(a0$6971);
        let print$6979: (
            java.io.PrintWriter -> String -> Unit \ IO
        ) = obj$$6981 ->
            a0$$6985 ->
                obj$$6981..print(a0$$6985);
        let close$6993: (java.io.PrintWriter -> Unit) = obj$$6995 ->
            obj$$6995..close();
        let checkError$7001: (java.io.PrintWriter -> Bool) = obj$$7003 ->
            obj$$7003..checkError();
        let alreadyExists$7006: Result[IOError, Bool] = Files.exists(f$6946);
        let javaFile$7008: java.io.File = newFile$6961(f$6946);
        let w$7012: java.io.PrintWriter = newPrintWriter$6966(javaFile$7008);
        print$6979(w$7012)("""""" + <[unknown exp]>(data$6950));
        close$6993(w$7012);
        if (checkError$7001(w$7012)) {
            Result.Err(
                IOError.Generic(
                    (
                        (
                            """""" + """An error occurred when writing to the file: '"""
                        ) + <[unknown exp]>(f$6946)
                    ) + """'."""
                )
            )
        } else {
            Result.flatMap(
                exists$7028 ->
                    Result.Ok(!exists$7028),
                alreadyExists$7006
            )
        }
    } catch {
        case ex$7069: ##java.io.IOException =>
            let getMessage$7071: (java.lang.Throwable -> String) = obj$$7091 ->
                obj$$7091..getMessage();
            Result.Err(IOError.Generic(getMessage$7071(<[unknown exp]>)))
    }
}

def Files.writeBytes(
    f$9237: String,
    data$9241: f[Int8]
): Result[IOError, Bool] \ IO = {
    region rc$9263 {
        try {
            let newFile$9268: (String -> java.io.File) = a0$9270 ->
                ##java.io.File(a0$9270);
            let newFileStream$9290: (
                java.io.File -> java.io.FileOutputStream
            ) = a0$9292 ->
                ##java.io.FileOutputStream(a0$9292);
            let newPrintWriter$9302: (
                java.io.OutputStream -> java.io.PrintWriter
            ) = a0$9308 ->
                ##java.io.PrintWriter(a0$9308);
            let write$9314: (
                java.io.FileOutputStream -> Array[Int8, rc] -> Unit \ IO
            ) = obj$$9316 ->
                a0$$9318 ->
                    obj$$9316..write(a0$$9318);
            let close$9336: (java.io.PrintWriter -> Unit) = obj$$9341 ->
                obj$$9341..close();
            let checkError$9343: (java.io.PrintWriter -> Bool) = obj$$9345 ->
                obj$$9345..checkError();
            let alreadyExists$9356: Result[IOError, Bool] = Files.exists(
                f$9237
            );
            let javaFile$9359: java.io.File = newFile$9268(f$9237);
            let fileStream$9363: java.io.FileOutputStream = newFileStream$9290(
                javaFile$9359
            );
            let printWriter$9365: java.io.PrintWriter = newPrintWriter$9302(
                <[unknown exp]>
            );
            let dataAsArray$9370: Array[Int8, rc] = <[unknown exp]>(
                rc$9263,
                data$9241
            );
            write$9314(fileStream$9363)(dataAsArray$9370);
            close$9336(printWriter$9365);
            if (checkError$9343(printWriter$9365)) {
                Result.Err(
                    IOError.Generic(
                        (
                            (
                                """""" + """An error occurred when writing to the file: '"""
                            ) + <[unknown exp]>(f$9237)
                        ) + """'."""
                    )
                )
            } else {
                Result.flatMap(
                    exists$9392 ->
                        Result.Ok(!exists$9392),
                    alreadyExists$9356
                )
            }
        } catch {
            case ex$9420: ##java.io.IOException =>
                let getMessage$9422: (
                    java.lang.Throwable -> String
                ) = obj$$9424 ->
                    obj$$9424..getMessage();
                Result.Err(IOError.Generic(getMessage$9422(<[unknown exp]>)))
        }
    }
}

def Files.writeLines(
    f$7162: String,
    data$7164: f[String]
): Result[IOError, Bool] \ IO = {
    try {
        let newFile$7170: (String -> java.io.File) = a0$7173 ->
            ##java.io.File(a0$7173);
        let newPrintWriter$7175: (
            java.io.File -> java.io.PrintWriter
        ) = a0$7177 ->
            ##java.io.PrintWriter(a0$7177);
        let println$7182: (
            java.io.PrintWriter -> String -> Unit \ IO
        ) = obj$$7184 ->
            a0$$7186 ->
                obj$$7184..println(a0$$7186);
        let close$7248: (java.io.PrintWriter -> Unit) = obj$$7250 ->
            obj$$7250..close();
        let checkError$7283: (java.io.PrintWriter -> Bool) = obj$$7285 ->
            obj$$7285..checkError();
        let alreadyExists$8082: Result[IOError, Bool] = Files.exists(f$7162);
        let javaFile$8084: java.io.File = newFile$7170(f$7162);
        let w$8122: java.io.PrintWriter = newPrintWriter$7175(javaFile$8084);
        <[unknown exp]>(
            line$8134 ->
                println$7182(w$8122)(line$8134),
            data$7164
        );
        close$7248(w$8122);
        if (checkError$7283(w$8122)) {
            Result.Err(
                IOError.Generic(
                    (
                        (
                            """""" + """An error occurred when writing lines to the file: '"""
                        ) + <[unknown exp]>(f$7162)
                    ) + """'."""
                )
            )
        } else {
            Result.flatMap(
                exists$8150 ->
                    Result.Ok(!exists$8150),
                alreadyExists$8082
            )
        }
    } catch {
        case ex$8154: ##java.io.IOException =>
            let getMessage$8156: (java.lang.Throwable -> String) = obj$$8158 ->
                obj$$8158..getMessage();
            Result.Err(IOError.Generic(getMessage$8156(<[unknown exp]>)))
    }
}

enum Files.FileType {
    case File(Unit)
    case Directory(Unit)
    case SymLink(Unit)
    case Other(Unit)
}

enum Fixpoint.Ast.Datalog.BodyPredicate[v] {
    case Guard2(v -> (v -> Bool), VarSym, VarSym)
    case Guard3(v -> (v -> (v -> Bool)), VarSym, VarSym, VarSym)
    case BodyAtom(PredSym, Denotation[v], Polarity, Fixity, Vector[BodyTerm[v]])
    case Functional(
        Vector[VarSym],
        Vector[v] -> Vector[Vector[v]],
        Vector[VarSym]
    )
    case Guard0(Unit -> Bool)
    case Guard4(v -> (v -> (v -> (v -> Bool))), VarSym, VarSym, VarSym, VarSym)
    case Guard1(v -> Bool, VarSym)
    case Guard5(
        v -> (v -> (v -> (v -> (v -> Bool)))),
        VarSym,
        VarSym,
        VarSym,
        VarSym,
        VarSym
    )
}

enum Fixpoint.Ast.Datalog.BodyTerm[v] {
    case Wild(Unit)
    case Var(VarSym)
    case Lit(v)
}

enum Fixpoint.Ast.Datalog.Constraint[v] {
    case Constraint(HeadPredicate[v], Vector[BodyPredicate[v]])
}

enum Fixpoint.Ast.Datalog.Datalog[v] {
    case Datalog(Vector[Constraint[v]], Vector[Constraint[v]])
    case Model(Map[RamSym[v], Map[Vector[v], v]])
    case Join(Datalog[v], Datalog[v])
}

enum Fixpoint.Ast.Datalog.Fixity {case Loose(Unit) case Fixed(Unit)}

enum Fixpoint.Ast.Datalog.HeadPredicate[v] {
    case HeadAtom(PredSym, Denotation[v], Vector[HeadTerm[v]])
}

enum Fixpoint.Ast.Datalog.HeadTerm[v] {
    case App5(
        v -> (v -> (v -> (v -> (v -> v)))),
        VarSym,
        VarSym,
        VarSym,
        VarSym,
        VarSym
    )
    case App1(v -> v, VarSym)
    case Var(VarSym)
    case App0(Unit -> v)
    case App3(v -> (v -> (v -> v)), VarSym, VarSym, VarSym)
    case Lit(v)
    case App4(v -> (v -> (v -> (v -> v))), VarSym, VarSym, VarSym, VarSym)
    case App2(v -> (v -> v), VarSym, VarSym)
}

enum Fixpoint.Ast.Datalog.Polarity {case Positive(Unit) case Negative(Unit)}

enum Fixpoint.Ast.Datalog.VarSym {case VarSym(String)}

enum Fixpoint.Ast.PrecedenceEdge {
    case StrongEdge(PredSym, PredSym)
    case WeakEdge(PredSym, PredSym)
}

enum Fixpoint.Ast.PrecedenceGraph {case PrecedenceGraph(Set[PrecedenceEdge])}

def Fixpoint.Ast.Ram.arityOf(ramSym$20040: RamSym[v]): Int32 = {
    match ramSym$20040 {
        case Fixpoint.Ast.Ram.RamSym.Full(_, arity$20046, _) =>
            arity$20046
        case Fixpoint.Ast.Ram.RamSym.Delta(_, arity$20054, _) =>
            arity$20054
        case Fixpoint.Ast.Ram.RamSym.New(_, arity$20057, _) =>
            arity$20057
    }
}

def Fixpoint.Ast.Ram.toDenotation(ramSym$20068: RamSym[v]): Denotation[v] = {
    match ramSym$20068 {
        case Fixpoint.Ast.Ram.RamSym.Full(_, _, den$20077) =>
            den$20077
        case Fixpoint.Ast.Ram.RamSym.Delta(_, _, den$20084) =>
            den$20084
        case Fixpoint.Ast.Ram.RamSym.New(_, _, den$20087) =>
            den$20087
    }
}

enum Fixpoint.Ast.Ram.BoolExp[v] {
    case Leq(v -> (v -> Bool), RamTerm[v], RamTerm[v])
    case Guard2(v -> (v -> Bool), RamTerm[v], RamTerm[v])
    case Guard4(
        v -> (v -> (v -> (v -> Bool))),
        RamTerm[v],
        RamTerm[v],
        RamTerm[v],
        RamTerm[v]
    )
    case Eq(RamTerm[v], RamTerm[v])
    case Guard3(v -> (v -> (v -> Bool)), RamTerm[v], RamTerm[v], RamTerm[v])
    case NotMemberOf(Vector[RamTerm[v]], RamSym[v])
    case Guard5(
        v -> (v -> (v -> (v -> (v -> Bool)))),
        RamTerm[v],
        RamTerm[v],
        RamTerm[v],
        RamTerm[v],
        RamTerm[v]
    )
    case Guard0(Unit -> Bool)
    case Guard1(v -> Bool, RamTerm[v])
    case Empty(RamSym[v])
}

enum Fixpoint.Ast.Ram.RamStmt[v] {
    case Until(Vector[BoolExp[v]], RamStmt[v])
    case Seq(Vector[RamStmt[v]])
    case Insert(RelOp[v])
    case Comment(String)
    case Purge(RamSym[v])
    case Assign(RamSym[v], RamSym[v])
    case Merge(RamSym[v], RamSym[v])
}

enum Fixpoint.Ast.Ram.RamSym[v] {
    case Full(PredSym, Int32, Denotation[v])
    case Delta(PredSym, Int32, Denotation[v])
    case New(PredSym, Int32, Denotation[v])
}

enum Fixpoint.Ast.Ram.RamTerm[v] {
    case App3(v -> (v -> (v -> v)), RamTerm[v], RamTerm[v], RamTerm[v])
    case RowLoad(RowVar, Int32)
    case Lit(v)
    case App1(v -> v, RamTerm[v])
    case App0(Unit -> v)
    case App2(v -> (v -> v), RamTerm[v], RamTerm[v])
    case LoadLatVar(RowVar)
    case App4(
        v -> (v -> (v -> (v -> v))),
        RamTerm[v],
        RamTerm[v],
        RamTerm[v],
        RamTerm[v]
    )
    case App5(
        v -> (v -> (v -> (v -> (v -> v)))),
        RamTerm[v],
        RamTerm[v],
        RamTerm[v],
        RamTerm[v],
        RamTerm[v]
    )
    case Meet(v -> (v -> v), RamTerm[v], RamTerm[v])
}

enum Fixpoint.Ast.Ram.RelOp[v] {
    case Query(RowVar, RamSym[v], Vector[(Int32, RamTerm[v])], RelOp[v])
    case Project(Vector[RamTerm[v]], RamSym[v])
    case If(Vector[BoolExp[v]], RelOp[v])
    case Functional(
        RowVar,
        Vector[v] -> Vector[Vector[v]],
        Vector[RamTerm[v]],
        RelOp[v]
    )
    case Search(RowVar, RamSym[v], RelOp[v])
}

enum Fixpoint.Ast.Ram.RowVar {case Named(String) case Index(Int32)}

def Fixpoint.Ast.Shared.box(d$6549: Denotation[t]): Denotation[Boxed] = {
    match d$6549 {
        case Fixpoint.Ast.Shared.Denotation.Relational =>
            Fixpoint.Ast.Shared.Denotation.Relational
        case Fixpoint.Ast.Shared.Denotation.Latticenal(
            bot$6558,
            leq$6560,
            lub$6562,
            glb$6564
        ) =>
            Fixpoint.Ast.Shared.Denotation.Latticenal(
                Boxable.box(bot$6558),
                Boxable.lift2b(leq$6560),
                Boxable.lift2(lub$6562),
                Boxable.lift2(glb$6564)
            )
    }
}

def Fixpoint.Ast.Shared.isRelational(den$6501: Denotation[v]): Bool = {
    match den$6501 {
        case Fixpoint.Ast.Shared.Denotation.Relational =>
            true
        case _ =>
            false
    }
}

def Fixpoint.Ast.Shared.lattice(_unit$6508: Unit): Denotation[t] = {
    Fixpoint.Ast.Shared.Denotation.Latticenal(
        <[unknown exp]>(()),
        x$6520 ->
            y$6522 ->
                <[unknown exp]>(x$6520, y$6522),
        x$6529 ->
            y$6533 ->
                <[unknown exp]>(x$6529, y$6533),
        x$6538 ->
            y$6542 ->
                <[unknown exp]>(x$6538, y$6542)
    )
}

enum Fixpoint.Ast.Shared.Denotation[v] {
    case Relational(Unit)
    case Latticenal(v, v -> (v -> Bool), v -> (v -> v), v -> (v -> v))
}

enum Fixpoint.Ast.Shared.PredSym {case PredSym(String, Int64)}

def Fixpoint.Debugging.notifyPostSolve(d$20582: Datalog[v]): Unit \ IO = {
    if (Fixpoint.Options.enableDebugging(())) {
        println(String.repeat(80i32, """*"""));
        println("""** Minimal Model""");
        println(String.repeat(80i32, """*"""));
        println("""""");
        println(String.indent(4i32, """""" + <[unknown exp]>(d$20582)));
        println("""""")
    } else {
        ()
    }
}

def Fixpoint.Debugging.notifyPreInterpret(s$20606: RamStmt[v]): Unit \ IO = {
    if (Fixpoint.Options.enableDebugging(())) {
        println(String.repeat(80i32, """*"""));
        println("""** Relation Algebra Machine AST""");
        println(String.repeat(80i32, """*"""));
        println("""""");
        println(String.indent(4i32, """""" + <[unknown exp]>(s$20606)));
        println("""""")
    } else {
        ()
    }
}

def Fixpoint.Debugging.notifyPreSolve(
    d$20568: Datalog[v],
    _stf$20570: Map[PredSym, Int32]
): Unit \ IO = {
    if (Fixpoint.Options.enableDebugging(())) {
        println(String.repeat(80i32, """*"""));
        println("""** Datalog Input""");
        println(String.repeat(80i32, """*"""));
        println("""""");
        println(String.indent(4i32, """""" + <[unknown exp]>(d$20568)));
        println("""""")
    } else {
        ()
    }
}

def Fixpoint.Interpreter.allocEnv(
    rc$983: Region[r],
    depth$985: Int32,
    relOp$987: RelOp[v]
): SearchEnv[v, r] \ r = {
    match relOp$987 {
        case Fixpoint.Ast.Ram.RelOp.Search(_, _, body$989) =>
            Fixpoint.Interpreter.allocEnv(
                rc$983,
                <[unknown exp]>(depth$985, 1i32),
                body$989
            )
        case Fixpoint.Ast.Ram.RelOp.Query(_, _, _, body$996) =>
            Fixpoint.Interpreter.allocEnv(
                rc$983,
                <[unknown exp]>(depth$985, 1i32),
                body$996
            )
        case Fixpoint.Ast.Ram.RelOp.Functional(_, _, _, body$998) =>
            Fixpoint.Interpreter.allocEnv(
                rc$983,
                <[unknown exp]>(depth$985, 1i32),
                body$998
            )
        case Fixpoint.Ast.Ram.RelOp.Project(_) =>
            (
                Array.repeat(rc$983, depth$985, Vector.empty(())),
                Array.empty(rc$983, depth$985)
            )
        case Fixpoint.Ast.Ram.RelOp.If(_, then$1004) =>
            Fixpoint.Interpreter.allocEnv(rc$983, depth$985, then$1004)
    }
}

def Fixpoint.Interpreter.evalBoolExp(
    rc1$1336: Region[r1],
    db$1338: Database[v, r1],
    env$1342: SearchEnv[v, r2],
    es$1346: Vector[BoolExp[v]]
): Bool \ r1 + r2 = {
    Vector.forAll(
        exp$1352 ->
            match exp$1352 {
                case Fixpoint.Ast.Ram.BoolExp.Empty(ramSym$1356) =>
                    MutMap.isEmpty(
                        MutMap.getWithDefault(
                            ramSym$1356,
                            MutMap.empty(rc1$1336),
                            db$1338
                        )
                    )
                case Fixpoint.Ast.Ram.BoolExp.NotMemberOf(
                    terms$1362,
                    ramSym$1364
                ) =>
                    let rel$1368: MutMap[Vector[v], v, r1] = MutMap.getWithDefault(
                        ramSym$1364,
                        MutMap.empty(rc1$1336),
                        db$1338
                    );
                    match Fixpoint.Ast.Ram.toDenotation(ramSym$1364) {
                        case Fixpoint.Ast.Shared.Denotation.Relational =>
                            let tuple$1376: Vector[v] = Vector.map(
                                (
                                    $0$45334 ->
                                        $1$45336 ->
                                            Fixpoint.Interpreter.evalTerm(
                                                $0$45334,
                                                $1$45336
                                            )
                                )(env$1342),
                                terms$1362
                            );
                            !MutMap.memberOf(tuple$1376, rel$1368)
                        case Fixpoint.Ast.Shared.Denotation.Latticenal(
                            bot$1378,
                            leq$1380,
                            _,
                            _
                        ) =>
                            let len$1382: Int32 = Vector.length(terms$1362);
                            let evalTerms$1384: Vector[v] = Vector.map(
                                (
                                    $0$45342 ->
                                        $1$45344 ->
                                            Fixpoint.Interpreter.evalTerm(
                                                $0$45342,
                                                $1$45344
                                            )
                                )(env$1342),
                                terms$1362
                            );
                            let key$1386: Vector[v] = Vector.take(
                                <[unknown exp]>(len$1382, 1i32),
                                evalTerms$1384
                            );
                            let latTerms$1393: Vector[v] = Vector.drop(
                                <[unknown exp]>(len$1382, 1i32),
                                evalTerms$1384
                            );
                            let latTerm$1395: v = match Vector.head(
                                latTerms$1393
                            ) {
                                case Option.None =>
                                    bug!("""Found predicate without terms""")
                                case Option.Some(hd$1399) =>
                                    hd$1399
                            };
                            !leq$1380(
                                latTerm$1395
                            )(
                                MutMap.getWithDefault(
                                    key$1386,
                                    bot$1378,
                                    rel$1368
                                )
                            )
                    }
                case Fixpoint.Ast.Ram.BoolExp.Eq(lhs$1405, rhs$1407) =>
                    <[unknown exp]>(
                        Fixpoint.Interpreter.evalTerm(env$1342, lhs$1405),
                        Fixpoint.Interpreter.evalTerm(env$1342, rhs$1407)
                    )
                case Fixpoint.Ast.Ram.BoolExp.Leq(
                    leq$1409,
                    lhs$1411,
                    rhs$1413
                ) =>
                    leq$1409(
                        Fixpoint.Interpreter.evalTerm(env$1342, lhs$1411)
                    )(Fixpoint.Interpreter.evalTerm(env$1342, rhs$1413))
                case Fixpoint.Ast.Ram.BoolExp.Guard0(f$1421) =>
                    f$1421(())
                case Fixpoint.Ast.Ram.BoolExp.Guard1(f$1423, t$1425) =>
                    let v$1427: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t$1425
                    );
                    f$1423(v$1427)
                case Fixpoint.Ast.Ram.BoolExp.Guard2(
                    f$1435,
                    t1$1437,
                    t2$1439
                ) =>
                    let v1$1445: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t1$1437
                    );
                    let v2$1447: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t2$1439
                    );
                    f$1435(v1$1445)(v2$1447)
                case Fixpoint.Ast.Ram.BoolExp.Guard3(
                    f$1453,
                    t1$1456,
                    t2$1459,
                    t3$1461
                ) =>
                    let v1$1463: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t1$1456
                    );
                    let v2$1465: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t2$1459
                    );
                    let v3$1467: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t3$1461
                    );
                    f$1453(v1$1463)(v2$1465)(v3$1467)
                case Fixpoint.Ast.Ram.BoolExp.Guard4(
                    f$1472,
                    t1$1477,
                    t2$1479,
                    t3$1481,
                    t4$1483
                ) =>
                    let v1$1487: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t1$1477
                    );
                    let v2$1491: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t2$1479
                    );
                    let v3$1493: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t3$1481
                    );
                    let v4$1495: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t4$1483
                    );
                    f$1472(v1$1487)(v2$1491)(v3$1493)(v4$1495)
                case Fixpoint.Ast.Ram.BoolExp.Guard5(
                    f$1501,
                    t1$1503,
                    t2$1505,
                    t3$1507,
                    t4$1510,
                    t5$1513
                ) =>
                    let v1$1515: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t1$1503
                    );
                    let v2$1517: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t2$1505
                    );
                    let v3$1519: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t3$1507
                    );
                    let v4$1521: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t4$1510
                    );
                    let v5$1525: v = Fixpoint.Interpreter.evalTerm(
                        env$1342,
                        t5$1513
                    );
                    f$1501(v1$1515)(v2$1517)(v3$1519)(v4$1521)(v5$1525)
            },
        es$1346
    )
}

def Fixpoint.Interpreter.evalOp(
    rc1$1030: Region[r1],
    db$1038: Database[v, r1],
    env$1042: SearchEnv[v, r2],
    op$1046: RelOp[v]
): Unit \ r1 + r2 = {
    match op$1046 {
        case Fixpoint.Ast.Ram.RelOp.Search(
            Fixpoint.Ast.Ram.RowVar.Index(i$1052),
            ramSym$1058,
            body$1060
        ) =>
            match env$1042 {
                case (tupleEnv$1062, latEnv$1064) =>
                    MutMap.forEach(
                        t$1066 ->
                            l$1068 ->
                                {
                                    Array.put(t$1066, i$1052, tupleEnv$1062);
                                    Array.put(l$1068, i$1052, latEnv$1064);
                                    Fixpoint.Interpreter.evalOp(
                                        rc1$1030,
                                        db$1038,
                                        env$1042,
                                        body$1060
                                    )
                                },
                        MutMap.getWithDefault(
                            ramSym$1058,
                            MutMap.empty(rc1$1030),
                            db$1038
                        )
                    )
            }
        case Fixpoint.Ast.Ram.RelOp.Query(
            Fixpoint.Ast.Ram.RowVar.Index(i$1096),
            ramSym$1098,
            qry$1100,
            body$1102
        ) =>
            match env$1042 {
                case (tupleEnv$1105, latEnv$1108) =>
                    MutMap.rangeQueryWith(
                        (
                            $0$45302 ->
                                $1$45304 ->
                                    $2$45306 ->
                                        Fixpoint.Interpreter.evalQuery(
                                            $0$45302,
                                            $1$45304,
                                            $2$45306
                                        )
                        )(env$1042)(Vector.toList(qry$1100)),
                        t$1114 ->
                            l$1120 ->
                                {
                                    Array.put(t$1114, i$1096, tupleEnv$1105);
                                    Array.put(l$1120, i$1096, latEnv$1108);
                                    Fixpoint.Interpreter.evalOp(
                                        rc1$1030,
                                        db$1038,
                                        env$1042,
                                        body$1102
                                    )
                                },
                        MutMap.getWithDefault(
                            ramSym$1098,
                            MutMap.empty(rc1$1030),
                            db$1038
                        )
                    )
            }
        case Fixpoint.Ast.Ram.RelOp.Functional(
            Fixpoint.Ast.Ram.RowVar.Index(i$1138),
            f$1140,
            terms$1142,
            body$1144
        ) =>
            let args$1146: Vector[v] = |>(
                terms$1142,
                (
                    $0$45308 ->
                        $1$45310 ->
                            Vector.map($0$45308, $1$45310)
                )(
                    (
                        $0$45312 ->
                            $1$45314 ->
                                Fixpoint.Interpreter.evalTerm(
                                    $0$45312,
                                    $1$45314
                                )
                    )(env$1042)
                )
            );
            let result$1150: Vector[Vector[v]] = f$1140(args$1146);
            match env$1042 {
                case (tupleEnv$1160, _latEnv$1166) =>
                    region reg$1$1172 {
                        Iterator.forEach(
                            pat$10$1177 ->
                                match pat$10$1177 {
                                    case t$1181 =>
                                        Array.put(
                                            t$1181,
                                            i$1138,
                                            tupleEnv$1160
                                        );
                                        Fixpoint.Interpreter.evalOp(
                                            rc1$1030,
                                            db$1038,
                                            env$1042,
                                            body$1144
                                        )
                                },
                            <[unknown exp]>(reg$1$1172, result$1150)
                        )
                    }
            }
        case Fixpoint.Ast.Ram.RelOp.Project(terms$1197, ramSym$1199) =>
            let rel$1201: MutMap[Vector[v], v, r1] = MutMap.getOrElsePut!(
                ramSym$1199,
                MutMap.empty(rc1$1030),
                db$1038
            );
            match Fixpoint.Ast.Ram.toDenotation(ramSym$1199) {
                case Fixpoint.Ast.Shared.Denotation.Relational =>
                    let tuple$1209: Vector[v] = Vector.map(
                        (
                            $0$45316 ->
                                $1$45318 ->
                                    Fixpoint.Interpreter.evalTerm(
                                        $0$45316,
                                        $1$45318
                                    )
                        )(env$1042),
                        terms$1197
                    );
                    MutMap.put!(tuple$1209, Reflect.default(()), rel$1201)
                case Fixpoint.Ast.Shared.Denotation.Latticenal(
                    bot$1215,
                    leq$1218,
                    lub$1221,
                    _
                ) =>
                    let len$1223: Int32 = Vector.length(terms$1197);
                    let keyList$1225: Vector[v] = |>(
                        terms$1197,
                        (
                            $0$45322 ->
                                $1$45325 ->
                                    Vector.map($0$45322, $1$45325)
                        )(
                            (
                                $0$45330 ->
                                    $1$45332 ->
                                        Fixpoint.Interpreter.evalTerm(
                                            $0$45330,
                                            $1$45332
                                        )
                            )(env$1042)
                        )
                    );
                    match Vector.splitAt(
                        <[unknown exp]>(len$1223, 1i32),
                        keyList$1225
                    ) {
                        case (key$1238, latValList$1240) =>
                            let latVal$1242: v = match Vector.head(
                                latValList$1240
                            ) {
                                case Option.None =>
                                    bug!("""Found predicate without terms""")
                                case Option.Some(k$1244) =>
                                    k$1244
                            };
                            if (leq$1218(latVal$1242)(bot$1215)) {
                                ()
                            } else {
                                MutMap.putWith!(
                                    lub$1221,
                                    key$1238,
                                    latVal$1242,
                                    rel$1201
                                )
                            }
                    }
            }
        case Fixpoint.Ast.Ram.RelOp.If(test$1260, then$1264) =>
            if (
                Fixpoint.Interpreter.evalBoolExp(
                    rc1$1030,
                    db$1038,
                    env$1042,
                    test$1260
                )
            ) {
                Fixpoint.Interpreter.evalOp(
                    rc1$1030,
                    db$1038,
                    env$1042,
                    then$1264
                )
            } else {
                ()
            }
        case _ =>
            ()
    }
}

def Fixpoint.Interpreter.evalQuery(
    env$1284: SearchEnv[v, r],
    qry$1288: List[(Int32, RamTerm[v])],
    tuple$1292: Vector[v]
): Comparison \ r = {
    match qry$1288 {
        case List.Nil =>
            Comparison.EqualTo
        case List.Cons((j$1303, t$1305), tl$1307) =>
            match <[unknown exp]>(
                Vector.get(j$1303, tuple$1292),
                Fixpoint.Interpreter.evalTerm(env$1284, t$1305)
            ) {
                case Comparison.EqualTo =>
                    Fixpoint.Interpreter.evalQuery(
                        env$1284,
                        tl$1307,
                        tuple$1292
                    )
                case cmp$1311 =>
                    cmp$1311
            }
    }
}

def Fixpoint.Interpreter.evalStmt(
    rc$269: Region[r],
    db$271: Database[v, r],
    stmt$273: RamStmt[v]
): Unit \ r = {
    match stmt$273 {
        case Fixpoint.Ast.Ram.RamStmt.Insert(relOp$275) =>
            Fixpoint.Interpreter.evalOp(
                rc$269,
                db$271,
                Fixpoint.Interpreter.allocEnv(rc$269, 0i32, relOp$275),
                relOp$275
            )
        case Fixpoint.Ast.Ram.RamStmt.Merge(srcSym$307, dstSym$309) =>
            let dst$311: MutMap[Vector[v], v, r] = MutMap.getOrElsePut!(
                dstSym$309,
                MutMap.empty(rc$269),
                db$271
            );
            match Fixpoint.Ast.Ram.toDenotation(srcSym$307) {
                case Fixpoint.Ast.Shared.Denotation.Relational =>
                    MutMap.merge!(
                        MutMap.getWithDefault(
                            srcSym$307,
                            MutMap.empty(rc$269),
                            db$271
                        ),
                        dst$311
                    )
                case Fixpoint.Ast.Shared.Denotation.Latticenal(
                    _,
                    _,
                    lub$467,
                    _
                ) =>
                    MutMap.mergeWith!(
                        lub$467,
                        MutMap.getWithDefault(
                            srcSym$307,
                            MutMap.empty(rc$269),
                            db$271
                        ),
                        dst$311
                    )
            }
        case Fixpoint.Ast.Ram.RamStmt.Assign(lhs$469, rhs$471) =>
            MutMap.put!(
                lhs$469,
                MutMap.getWithDefault(rhs$471, MutMap.empty(rc$269), db$271),
                db$271
            )
        case Fixpoint.Ast.Ram.RamStmt.Purge(ramSym$473) =>
            MutMap.remove!(ramSym$473, db$271)
        case Fixpoint.Ast.Ram.RamStmt.Seq(stmts$475) =>
            Vector.forEach(
                (
                    $0$45296 ->
                        $1$45298 ->
                            $2$45300 ->
                                Fixpoint.Interpreter.evalStmt(
                                    $0$45296,
                                    $1$45298,
                                    $2$45300
                                )
                )(rc$269)(db$271),
                stmts$475
            )
        case Fixpoint.Ast.Ram.RamStmt.Until(test$477, body$479) =>
            if (
                Fixpoint.Interpreter.evalBoolExp(
                    rc$269,
                    db$271,
                    ([] @ rc$269, [] @ rc$269),
                    test$477
                )
            ) {
                ()
            } else {
                Fixpoint.Interpreter.evalStmt(rc$269, db$271, body$479);
                Fixpoint.Interpreter.evalStmt(rc$269, db$271, stmt$273)
            }
        case Fixpoint.Ast.Ram.RamStmt.Comment(_) =>
            ()
    }
}

def Fixpoint.Interpreter.evalTerm(
    env$1541: SearchEnv[v, r],
    term$1543: RamTerm[v]
): v \ r = {
    match term$1543 {
        case Fixpoint.Ast.Ram.RamTerm.Lit(v$1547) =>
            v$1547
        case Fixpoint.Ast.Ram.RamTerm.RowLoad(
            Fixpoint.Ast.Ram.RowVar.Index(i$1549),
            index$1551
        ) =>
            match env$1541 {
                case (tupleEnv$1553, _) =>
                    Vector.get(index$1551, Array.get(i$1549, tupleEnv$1553))
            }
        case Fixpoint.Ast.Ram.RamTerm.LoadLatVar(
            Fixpoint.Ast.Ram.RowVar.Index(i$1555)
        ) =>
            match env$1541 {
                case (_, latEnv$1557) =>
                    Array.get(i$1555, latEnv$1557)
            }
        case Fixpoint.Ast.Ram.RamTerm.Meet(cap$1559, lhs$1561, rhs$1563) =>
            cap$1559(
                Fixpoint.Interpreter.evalTerm(env$1541, lhs$1561)
            )(Fixpoint.Interpreter.evalTerm(env$1541, rhs$1563))
        case Fixpoint.Ast.Ram.RamTerm.App0(f$1571) =>
            f$1571(())
        case Fixpoint.Ast.Ram.RamTerm.App1(f$1574, t$1577) =>
            let v$1581: v = Fixpoint.Interpreter.evalTerm(env$1541, t$1577);
            f$1574(v$1581)
        case Fixpoint.Ast.Ram.RamTerm.App2(f$1583, t1$1585, t2$1587) =>
            let v1$1589: v = Fixpoint.Interpreter.evalTerm(env$1541, t1$1585);
            let v2$1591: v = Fixpoint.Interpreter.evalTerm(env$1541, t2$1587);
            f$1583(v1$1589)(v2$1591)
        case Fixpoint.Ast.Ram.RamTerm.App3(f$1597, t1$1599, t2$1601, t3$1603) =>
            let v1$1605: v = Fixpoint.Interpreter.evalTerm(env$1541, t1$1599);
            let v2$1608: v = Fixpoint.Interpreter.evalTerm(env$1541, t2$1601);
            let v3$1611: v = Fixpoint.Interpreter.evalTerm(env$1541, t3$1603);
            f$1597(v1$1605)(v2$1608)(v3$1611)
        case Fixpoint.Ast.Ram.RamTerm.App4(
            f$1613,
            t1$1619,
            t2$1621,
            t3$1623,
            t4$1627
        ) =>
            let v1$1629: v = Fixpoint.Interpreter.evalTerm(env$1541, t1$1619);
            let v2$1632: v = Fixpoint.Interpreter.evalTerm(env$1541, t2$1621);
            let v3$1637: v = Fixpoint.Interpreter.evalTerm(env$1541, t3$1623);
            let v4$1639: v = Fixpoint.Interpreter.evalTerm(env$1541, t4$1627);
            f$1613(v1$1629)(v2$1632)(v3$1637)(v4$1639)
        case Fixpoint.Ast.Ram.RamTerm.App5(
            f$1649,
            t1$1651,
            t2$1653,
            t3$1656,
            t4$1659,
            t5$1661
        ) =>
            let v1$1665: v = Fixpoint.Interpreter.evalTerm(env$1541, t1$1651);
            let v2$1669: v = Fixpoint.Interpreter.evalTerm(env$1541, t2$1653);
            let v3$1673: v = Fixpoint.Interpreter.evalTerm(env$1541, t3$1656);
            let v4$1677: v = Fixpoint.Interpreter.evalTerm(env$1541, t4$1659);
            let v5$1681: v = Fixpoint.Interpreter.evalTerm(env$1541, t5$1661);
            f$1649(v1$1665)(v2$1669)(v3$1673)(v4$1677)(v5$1681)
        case Fixpoint.Ast.Ram.RamTerm.RowLoad(rowVar$1683, index$1685) =>
            bug!(
                (
                    (
                        (
                            """""" + """Illegal RowLoad with """
                        ) + <[unknown exp]>(rowVar$1683)
                    ) + """ """
                ) + <[unknown exp]>(index$1685)
            )
        case _ =>
            bug!(("""""" + """Illegal term """) + <[unknown exp]>(term$1543))
    }
}

def Fixpoint.Interpreter.interpret(
    rc$177: Region[r],
    stmt$181: RamStmt[v]
): Database[v, r] \ r = {
    Fixpoint.Interpreter.interpretWithDatabase(
        rc$177,
        MutMap.empty(rc$177),
        stmt$181
    )
}

def Fixpoint.Interpreter.interpretWithDatabase(
    rc$222: Region[r],
    db$225: Database[v, r],
    stmt$228: RamStmt[v]
): Database[v, r] \ r = {
    <[unknown exp]>;
    Fixpoint.Interpreter.evalStmt(rc$222, db$225, stmt$228);
    db$225
}

def Fixpoint.Options.enableDebugging(_unit$19075: Unit): Bool = {false}

def Fixpoint.Phase.Compiler.augmentBody(
    body$11354: Vector[BodyPredicate[v]]
): Vector[(BodyPredicate[v], RowVar)] = {
    Vector.mapWithIndex(
        i$11374 ->
            atom$11376 ->
                match atom$11376 {
                    case Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                        predSym$11378,
                        _,
                        Fixpoint.Ast.Datalog.Polarity.Positive,
                        _,
                        _
                    ) =>
                        (
                            atom$11376,
                            Fixpoint.Ast.Ram.RowVar.Named(
                                (
                                    (
                                        """""" + <[unknown exp]>(predSym$11378)
                                    ) + """$"""
                                ) + <[unknown exp]>(i$11374)
                            )
                        )
                    case Fixpoint.Ast.Datalog.BodyPredicate.Functional(
                        _,
                        _,
                        _
                    ) =>
                        (
                            atom$11376,
                            Fixpoint.Ast.Ram.RowVar.Named(
                                ("""""" + """l$""") + <[unknown exp]>(i$11374)
                            )
                        )
                    case _ =>
                        (
                            atom$11376,
                            Fixpoint.Ast.Ram.RowVar.Named(
                                """IfYouSeeThisYouFoundABug"""
                            )
                        )
                },
        body$11354
    )
}

def Fixpoint.Phase.Compiler.compile(
    d$10456: Datalog[v],
    strat$10469: Map[PredSym, Int32]
): RamStmt[v] = {
    match d$10456 {
        case Fixpoint.Ast.Datalog.Datalog.Datalog(facts$10475, rules$10478) =>
            region rc$10480 {
                let stmts$10483: MutList[RamStmt[v], rc] = MutList.empty(
                    rc$10480
                );
                Vector.forEach(
                    (
                        $0$45616 ->
                            $1$45618 ->
                                Fixpoint.Phase.Compiler.compileRule(
                                    $0$45616,
                                    $1$45618
                                )
                    )(stmts$10483),
                    facts$10475
                );
                |>(
                    Vector.foldRight(
                        rule$10493 ->
                            match rule$10493 {
                                case Fixpoint.Ast.Datalog.Constraint.Constraint(
                                    Fixpoint.Ast.Datalog.HeadPredicate.HeadAtom(
                                        p$10502,
                                        _,
                                        _
                                    ),
                                    _
                                ) =>
                                    let ruleStratum$10507: Int32 = Map.getWithDefault(
                                        p$10502,
                                        0i32,
                                        strat$10469
                                    );
                                    (
                                        $0$45620 ->
                                            $1$45622 ->
                                                $2$45624 ->
                                                    $3$45626 ->
                                                        Map.insertWith(
                                                            $0$45620,
                                                            $1$45622,
                                                            $2$45624,
                                                            $3$45626
                                                        )
                                    )(
                                        $0$45628 ->
                                            $1$45630 ->
                                                List.append($0$45628, $1$45630)
                                    )(
                                        ruleStratum$10507
                                    )(List.Cons(rule$10493, List.Nil))
                            },
                        Map.empty(()),
                        rules$10478
                    ),
                    (
                        $0$45632 ->
                            $1$45634 ->
                                Map.forEach($0$45632, $1$45634)
                    )(
                        _$10526 ->
                            s$10530 ->
                                Fixpoint.Phase.Compiler.compileStratum(
                                    stmts$10483,
                                    s$10530
                                )
                    )
                );
                Fixpoint.Ast.Ram.RamStmt.Seq(MutList.toVector(stmts$10483))
            }
        case _ =>
            bug!("""Datalog normalization bug""")
    }
}

def Fixpoint.Phase.Compiler.compileBody(
    env$11612: Map[VarSym, RamTerm[v]],
    body$11614: Vector[(BodyPredicate[v], RowVar)]
): Vector[BoolExp[v]] = {
    Vector.flatMap(
        pat$75$11625 ->
            match pat$75$11625 {
                case (atom$11627, rowVar$11629) =>
                    let compileBodyTerm$11633: (
                        Int32 -> BodyTerm[v] -> RamTerm[v]
                    ) = j$11637 ->
                        term$11639 ->
                            match term$11639 {
                                case Fixpoint.Ast.Datalog.BodyTerm.Wild =>
                                    Fixpoint.Ast.Ram.RamTerm.RowLoad(
                                        rowVar$11629,
                                        j$11637
                                    )
                                case Fixpoint.Ast.Datalog.BodyTerm.Var(
                                    var$11643
                                ) =>
                                    Fixpoint.Phase.Compiler.unwrap(
                                        Map.get(var$11643, env$11612)
                                    )
                                case Fixpoint.Ast.Datalog.BodyTerm.Lit(
                                    v$11655
                                ) =>
                                    Fixpoint.Ast.Ram.RamTerm.Lit(v$11655)
                            };
                    match atom$11627 {
                        case Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                            _,
                            denotation$11657,
                            Fixpoint.Ast.Datalog.Polarity.Positive,
                            _,
                            terms$11659
                        ) =>
                            |>(
                                Vector.mapWithIndex(
                                    compileBodyTerm$11633,
                                    terms$11659
                                ),
                                (
                                    $0$45800 ->
                                        $1$45802 ->
                                            Vector.mapWithIndex(
                                                $0$45800,
                                                $1$45802
                                            )
                                )(
                                    i$11663 ->
                                        t$11668 ->
                                            match denotation$11657 {
                                                case Fixpoint.Ast.Shared.Denotation.Relational =>
                                                    Fixpoint.Ast.Ram.BoolExp.Eq(
                                                        Fixpoint.Ast.Ram.RamTerm.RowLoad(
                                                            rowVar$11629,
                                                            i$11663
                                                        ),
                                                        t$11668
                                                    )
                                                case Fixpoint.Ast.Shared.Denotation.Latticenal(
                                                    _,
                                                    leq$11683,
                                                    _,
                                                    _
                                                ) =>
                                                    if (
                                                        <[unknown exp]>(
                                                            i$11663,
                                                            <[unknown exp]>(
                                                                Vector.length(
                                                                    terms$11659
                                                                ),
                                                                1i32
                                                            )
                                                        )
                                                    ) {
                                                        Fixpoint.Ast.Ram.BoolExp.Eq(
                                                            Fixpoint.Ast.Ram.RamTerm.RowLoad(
                                                                rowVar$11629,
                                                                i$11663
                                                            ),
                                                            t$11668
                                                        )
                                                    } else {
                                                        Fixpoint.Ast.Ram.BoolExp.Leq(
                                                            leq$11683,
                                                            t$11668,
                                                            Fixpoint.Ast.Ram.RamTerm.LoadLatVar(
                                                                rowVar$11629
                                                            )
                                                        )
                                                    }
                                            }
                                )
                            )
                        case Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                            bodySym$11705,
                            denotation$11707,
                            Fixpoint.Ast.Datalog.Polarity.Negative,
                            _,
                            terms$11709
                        ) =>
                            let ramTerms$11711: Vector[RamTerm[v]] = Vector.mapWithIndex(
                                compileBodyTerm$11633,
                                terms$11709
                            );
                            let arity$11713: Int32 = Vector.length(
                                ramTerms$11711
                            );
                            [|
                                Fixpoint.Ast.Ram.BoolExp.NotMemberOf(
                                    ramTerms$11711,
                                    Fixpoint.Ast.Ram.RamSym.Full(
                                        bodySym$11705,
                                        arity$11713,
                                        denotation$11707
                                    )
                                )
                            |]
                        case Fixpoint.Ast.Datalog.BodyPredicate.Functional(
                            _,
                            _,
                            _
                        ) =>
                            Vector.empty(())
                        case Fixpoint.Ast.Datalog.BodyPredicate.Guard0(
                            f$11739
                        ) =>
                            [|Fixpoint.Ast.Ram.BoolExp.Guard0(f$11739)|]
                        case Fixpoint.Ast.Datalog.BodyPredicate.Guard1(
                            f$11743,
                            v$11745
                        ) =>
                            let t$11747: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v$11745, env$11612)
                            );
                            [|
                                Fixpoint.Ast.Ram.BoolExp.Guard1(
                                    f$11743,
                                    t$11747
                                )
                            |]
                        case Fixpoint.Ast.Datalog.BodyPredicate.Guard2(
                            f$11755,
                            v1$11758,
                            v2$11765
                        ) =>
                            let t1$11771: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v1$11758, env$11612)
                            );
                            let t2$11777: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v2$11765, env$11612)
                            );
                            [|
                                Fixpoint.Ast.Ram.BoolExp.Guard2(
                                    f$11755,
                                    t1$11771,
                                    t2$11777
                                )
                            |]
                        case Fixpoint.Ast.Datalog.BodyPredicate.Guard3(
                            f$11781,
                            v1$11784,
                            v2$11786,
                            v3$11788
                        ) =>
                            let t1$11790: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v1$11784, env$11612)
                            );
                            let t2$11792: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v2$11786, env$11612)
                            );
                            let t3$11794: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v3$11788, env$11612)
                            );
                            [|
                                Fixpoint.Ast.Ram.BoolExp.Guard3(
                                    f$11781,
                                    t1$11790,
                                    t2$11792,
                                    t3$11794
                                )
                            |]
                        case Fixpoint.Ast.Datalog.BodyPredicate.Guard4(
                            f$11800,
                            v1$11803,
                            v2$11807,
                            v3$11810,
                            v4$11813
                        ) =>
                            let t1$11818: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v1$11803, env$11612)
                            );
                            let t2$11831: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v2$11807, env$11612)
                            );
                            let t3$11835: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v3$11810, env$11612)
                            );
                            let t4$11839: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v4$11813, env$11612)
                            );
                            [|
                                Fixpoint.Ast.Ram.BoolExp.Guard4(
                                    f$11800,
                                    t1$11818,
                                    t2$11831,
                                    t3$11835,
                                    t4$11839
                                )
                            |]
                        case Fixpoint.Ast.Datalog.BodyPredicate.Guard5(
                            f$11843,
                            v1$11845,
                            v2$11847,
                            v3$11849,
                            v4$11851,
                            v5$11853
                        ) =>
                            let t1$11855: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v1$11845, env$11612)
                            );
                            let t2$11857: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v2$11847, env$11612)
                            );
                            let t3$11869: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v3$11849, env$11612)
                            );
                            let t4$11877: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v4$11851, env$11612)
                            );
                            let t5$11881: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                                Map.get(v5$11853, env$11612)
                            );
                            [|
                                Fixpoint.Ast.Ram.BoolExp.Guard5(
                                    f$11843,
                                    t1$11855,
                                    t2$11857,
                                    t3$11869,
                                    t4$11877,
                                    t5$11881
                                )
                            |]
                    }
            },
        body$11614
    )
}

def Fixpoint.Phase.Compiler.compileHeadTerm(
    env$11166: Map[VarSym, RamTerm[v]],
    term$11170: HeadTerm[v]
): RamTerm[v] = {
    match term$11170 {
        case Fixpoint.Ast.Datalog.HeadTerm.Var(var$11172) =>
            Fixpoint.Phase.Compiler.unwrap(Map.get(var$11172, env$11166))
        case Fixpoint.Ast.Datalog.HeadTerm.Lit(v$11182) =>
            Fixpoint.Ast.Ram.RamTerm.Lit(v$11182)
        case Fixpoint.Ast.Datalog.HeadTerm.App0(f$11184) =>
            Fixpoint.Ast.Ram.RamTerm.App0(f$11184)
        case Fixpoint.Ast.Datalog.HeadTerm.App1(f$11188, v$11193) =>
            let t$11199: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v$11193, env$11166)
            );
            Fixpoint.Ast.Ram.RamTerm.App1(f$11188, t$11199)
        case Fixpoint.Ast.Datalog.HeadTerm.App2(f$11217, v1$11219, v2$11221) =>
            let t1$11223: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v1$11219, env$11166)
            );
            let t2$11229: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v2$11221, env$11166)
            );
            Fixpoint.Ast.Ram.RamTerm.App2(f$11217, t1$11223, t2$11229)
        case Fixpoint.Ast.Datalog.HeadTerm.App3(
            f$11231,
            v1$11233,
            v2$11235,
            v3$11237
        ) =>
            let t1$11239: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v1$11233, env$11166)
            );
            let t2$11242: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v2$11235, env$11166)
            );
            let t3$11248: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v3$11237, env$11166)
            );
            Fixpoint.Ast.Ram.RamTerm.App3(f$11231, t1$11239, t2$11242, t3$11248)
        case Fixpoint.Ast.Datalog.HeadTerm.App4(
            f$11251,
            v1$11253,
            v2$11257,
            v3$11261,
            v4$11263
        ) =>
            let t1$11265: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v1$11253, env$11166)
            );
            let t2$11267: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v2$11257, env$11166)
            );
            let t3$11269: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v3$11261, env$11166)
            );
            let t4$11275: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v4$11263, env$11166)
            );
            Fixpoint.Ast.Ram.RamTerm.App4(
                f$11251,
                t1$11265,
                t2$11267,
                t3$11269,
                t4$11275
            )
        case Fixpoint.Ast.Datalog.HeadTerm.App5(
            f$11285,
            v1$11288,
            v2$11291,
            v3$11297,
            v4$11299,
            v5$11301
        ) =>
            let t1$11305: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v1$11288, env$11166)
            );
            let t2$11309: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v2$11291, env$11166)
            );
            let t3$11311: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v3$11297, env$11166)
            );
            let t4$11324: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v4$11299, env$11166)
            );
            let t5$11332: RamTerm[v] = Fixpoint.Phase.Compiler.unwrap(
                Map.get(v5$11301, env$11166)
            );
            Fixpoint.Ast.Ram.RamTerm.App5(
                f$11285,
                t1$11305,
                t2$11309,
                t3$11311,
                t4$11324,
                t5$11332
            )
    }
}

def Fixpoint.Phase.Compiler.compileRule(
    stmts$10801: MutList[RamStmt[v], r],
    rule$10803: Constraint[v]
): Unit \ r = {
    match rule$10803 {
        case Fixpoint.Ast.Datalog.Constraint.Constraint(
            Fixpoint.Ast.Datalog.HeadPredicate.HeadAtom(
                headSym$10806,
                headDen$10808,
                headTerms$10810
            ),
            body$10812
        ) =>
            let augBody$10814: Vector[(BodyPredicate[v], RowVar)] = Fixpoint.Phase.Compiler.augmentBody(
                body$10812
            );
            let env$10816: Map[VarSym, RamTerm[v]] = Fixpoint.Phase.Compiler.unifyVars(
                augBody$10814
            );
            let ramTerms$10823: Vector[RamTerm[v]] = Vector.map(
                (
                    $0$45660 ->
                        $1$45662 ->
                            Fixpoint.Phase.Compiler.compileHeadTerm(
                                $0$45660,
                                $1$45662
                            )
                )(env$10816),
                headTerms$10810
            );
            let arity$10825: Int32 = Vector.length(ramTerms$10823);
            let projection$10829: RelOp[v] = Fixpoint.Ast.Ram.RelOp.Project(
                ramTerms$10823,
                Fixpoint.Ast.Ram.RamSym.Full(
                    headSym$10806,
                    arity$10825,
                    headDen$10808
                )
            );
            let join$10837: Vector[BoolExp[v]] = Fixpoint.Phase.Compiler.compileBody(
                env$10816,
                augBody$10814
            );
            let loopBody$10839: RelOp[v] = Fixpoint.Ast.Ram.RelOp.If(
                join$10837,
                projection$10829
            );
            let insert$10841: RamStmt[v] = |>(
                Vector.foldRight(
                    pat$66$10843 ->
                        match pat$66$10843 {
                            case (atom$10845, rowVar$10848) =>
                                acc$10851 ->
                                    match atom$10845 {
                                        case Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                                            bodySym$10855,
                                            den$10857,
                                            Fixpoint.Ast.Datalog.Polarity.Positive,
                                            _,
                                            terms$10859
                                        ) =>
                                            let arity1$10862: Int32 = Vector.length(
                                                terms$10859
                                            );
                                            Fixpoint.Ast.Ram.RelOp.Search(
                                                rowVar$10848,
                                                Fixpoint.Ast.Ram.RamSym.Full(
                                                    bodySym$10855,
                                                    arity1$10862,
                                                    den$10857
                                                ),
                                                acc$10851
                                            )
                                        case Fixpoint.Ast.Datalog.BodyPredicate.Functional(
                                            _,
                                            f$10872,
                                            freeVars$10874
                                        ) =>
                                            let terms$10876: Vector[RamTerm[v]] = Vector.map(
                                                v$10880 ->
                                                    Fixpoint.Phase.Compiler.unwrap(
                                                        Map.get(
                                                            v$10880,
                                                            env$10816
                                                        )
                                                    ),
                                                freeVars$10874
                                            );
                                            Fixpoint.Ast.Ram.RelOp.Functional(
                                                rowVar$10848,
                                                f$10872,
                                                terms$10876,
                                                acc$10851
                                            )
                                        case _ =>
                                            acc$10851
                                    }
                        },
                    loopBody$10839,
                    augBody$10814
                ),
                x$$45668 ->
                    Fixpoint.Ast.Ram.RamStmt.Insert(x$$45668)
            );
            if (Fixpoint.Options.enableDebugging(())) {
                let comment$10898: RamStmt[v] = Fixpoint.Ast.Ram.RamStmt.Comment(
                    <[unknown exp]>(rule$10803)
                );
                MutList.push!(comment$10898, stmts$10801);
                MutList.push!(insert$10841, stmts$10801)
            } else {
                MutList.push!(insert$10841, stmts$10801)
            }
    }
}

def Fixpoint.Phase.Compiler.compileRuleIncr(
    stmts$10939: MutList[RamStmt[v], r],
    rule$10941: Constraint[v]
): Unit \ r = {
    match rule$10941 {
        case Fixpoint.Ast.Datalog.Constraint.Constraint(
            Fixpoint.Ast.Datalog.HeadPredicate.HeadAtom(
                headSym$10949,
                headDen$10951,
                headTerms$10953
            ),
            body$10955
        ) =>
            let augBody$10961: Vector[(BodyPredicate[v], RowVar)] = Fixpoint.Phase.Compiler.augmentBody(
                body$10955
            );
            let env$10965: Map[VarSym, RamTerm[v]] = Fixpoint.Phase.Compiler.unifyVars(
                augBody$10961
            );
            let ramTerms$10967: Vector[RamTerm[v]] = Vector.map(
                (
                    $0$45672 ->
                        $1$45674 ->
                            Fixpoint.Phase.Compiler.compileHeadTerm(
                                $0$45672,
                                $1$45674
                            )
                )(env$10965),
                headTerms$10953
            );
            let arity$10973: Int32 = Vector.length(ramTerms$10967);
            let projection$10979: RelOp[v] = Fixpoint.Ast.Ram.RelOp.Project(
                ramTerms$10967,
                Fixpoint.Ast.Ram.RamSym.New(
                    headSym$10949,
                    arity$10973,
                    headDen$10951
                )
            );
            let join$10983: Vector[BoolExp[v]] = Fixpoint.Phase.Compiler.compileBody(
                env$10965,
                augBody$10961
            );
            let loopBody$10985: RelOp[v] = Fixpoint.Ast.Ram.RelOp.If(
                Vector.append(
                    [|
                        Fixpoint.Ast.Ram.BoolExp.NotMemberOf(
                            ramTerms$10967,
                            Fixpoint.Ast.Ram.RamSym.Full(
                                headSym$10949,
                                arity$10973,
                                headDen$10951
                            )
                        )
                    |],
                    join$10983
                ),
                projection$10979
            );
            let compile$10997: (RowVar -> Unit) = delta$11000 ->
                {
                    let insert$11005: RamStmt[v] = |>(
                        Vector.foldRight(
                            pat$67$11009 ->
                                match pat$67$11009 {
                                    case (atom$11011, rowVar$11013) =>
                                        acc$11016 ->
                                            match atom$11011 {
                                                case Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                                                    bodySym$11025,
                                                    den$11030,
                                                    Fixpoint.Ast.Datalog.Polarity.Positive,
                                                    _,
                                                    terms$11034
                                                ) =>
                                                    let arity1$11036: Int32 = Vector.length(
                                                        terms$11034
                                                    );
                                                    let ramSym$11038: RamSym[v] = if (
                                                        <[unknown exp]>(
                                                            rowVar$11013,
                                                            delta$11000
                                                        ) and Fixpoint.Ast.Shared.isRelational(
                                                            den$11030
                                                        )
                                                    ) {
                                                        Fixpoint.Ast.Ram.RamSym.Delta(
                                                            bodySym$11025,
                                                            arity1$11036,
                                                            den$11030
                                                        )
                                                    } else {
                                                        Fixpoint.Ast.Ram.RamSym.Full(
                                                            bodySym$11025,
                                                            arity1$11036,
                                                            den$11030
                                                        )
                                                    };
                                                    Fixpoint.Ast.Ram.RelOp.Search(
                                                        rowVar$11013,
                                                        ramSym$11038,
                                                        acc$11016
                                                    )
                                                case Fixpoint.Ast.Datalog.BodyPredicate.Functional(
                                                    _,
                                                    f$11066,
                                                    freeVars$11073
                                                ) =>
                                                    let terms$11075: Vector[RamTerm[v]] = Vector.map(
                                                        v$11077 ->
                                                            Fixpoint.Phase.Compiler.unwrap(
                                                                Map.get(
                                                                    v$11077,
                                                                    env$10965
                                                                )
                                                            ),
                                                        freeVars$11073
                                                    );
                                                    Fixpoint.Ast.Ram.RelOp.Functional(
                                                        rowVar$11013,
                                                        f$11066,
                                                        terms$11075,
                                                        acc$11016
                                                    )
                                                case _ =>
                                                    acc$11016
                                            }
                                },
                            loopBody$10985,
                            augBody$10961
                        ),
                        x$$45686 ->
                            Fixpoint.Ast.Ram.RamStmt.Insert(x$$45686)
                    );
                    MutList.push!(insert$11005, stmts$10939)
                };
            let positiveAtoms$11084: Vector[(BodyPredicate[v], RowVar)] = Vector.filter(
                pat$68$11087 ->
                    match pat$68$11087 {
                        case (atom$11091, _) =>
                            match atom$11091 {
                                case Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                                    _,
                                    _,
                                    Fixpoint.Ast.Datalog.Polarity.Positive,
                                    _,
                                    _
                                ) =>
                                    true
                                case _ =>
                                    false
                            }
                    },
                augBody$10961
            );
            if (Fixpoint.Options.enableDebugging(())) {
                let comment$11108: RamStmt[v] = Fixpoint.Ast.Ram.RamStmt.Comment(
                    <[unknown exp]>(rule$10941)
                );
                MutList.push!(comment$11108, stmts$10939);
                Vector.forEach(
                    pat$69$11129 ->
                        match pat$69$11129 {
                            case (_, rowVar$11137) =>
                                compile$10997(rowVar$11137)
                        },
                    positiveAtoms$11084
                )
            } else {
                Vector.forEach(
                    pat$70$11141 ->
                        match pat$70$11141 {
                            case (_, rowVar$11143) =>
                                compile$10997(rowVar$11143)
                        },
                    positiveAtoms$11084
                )
            }
    }
}

def Fixpoint.Phase.Compiler.compileStratum(
    stmts$10548: MutList[RamStmt[v], r],
    stratum$10554: List[Constraint[v]]
): Unit \ r = {
    region rc$10556 {
        let idb$10560: Map[PredSym, (Int32, Denotation[v])] = List.foldRight(
            pat$60$10562 ->
                match pat$60$10562 {
                    case Fixpoint.Ast.Datalog.Constraint.Constraint(
                        Fixpoint.Ast.Datalog.HeadPredicate.HeadAtom(
                            pred$10569,
                            den$10573,
                            terms$10575
                        ),
                        _
                    ) =>
                        let arity$10580: Int32 = Vector.length(terms$10575);
                        (
                            $0$45640 ->
                                $1$45642 ->
                                    $2$45644 ->
                                        Map.insert($0$45640, $1$45642, $2$45644)
                        )(pred$10569)((arity$10580, den$10573))
                },
            Map.empty(()),
            stratum$10554
        );
        let loopBody$10599: MutList[RamStmt[v], rc] = MutList.empty(rc$10556);
        List.forEach(
            (
                $0$45646 ->
                    $1$45648 ->
                        Fixpoint.Phase.Compiler.compileRule($0$45646, $1$45648)
            )(stmts$10548),
            stratum$10554
        );
        Map.forEach(
            predSym$10607 ->
                pat$61$10611 ->
                    match pat$61$10611 {
                        case (arity$10614, den$10616) =>
                            let full$10620: RamSym[v] = Fixpoint.Ast.Ram.RamSym.Full(
                                predSym$10607,
                                arity$10614,
                                den$10616
                            );
                            let delta$10626: RamSym[v] = Fixpoint.Ast.Ram.RamSym.Delta(
                                predSym$10607,
                                arity$10614,
                                den$10616
                            );
                            let mergeDelta$10630: RamStmt[v] = Fixpoint.Ast.Ram.RamStmt.Merge(
                                full$10620,
                                delta$10626
                            );
                            MutList.push!(mergeDelta$10630, stmts$10548)
                    },
            idb$10560
        );
        Map.forEach(
            predSym$10639 ->
                pat$62$10645 ->
                    match pat$62$10645 {
                        case (arity$10649, den$10651) =>
                            let purge$10653: RamStmt[v] = Fixpoint.Ast.Ram.RamStmt.Purge(
                                Fixpoint.Ast.Ram.RamSym.New(
                                    predSym$10639,
                                    arity$10649,
                                    den$10651
                                )
                            );
                            MutList.push!(purge$10653, loopBody$10599)
                    },
            idb$10560
        );
        List.forEach(
            (
                $0$45650 ->
                    $1$45652 ->
                        Fixpoint.Phase.Compiler.compileRuleIncr(
                            $0$45650,
                            $1$45652
                        )
            )(loopBody$10599),
            stratum$10554
        );
        Map.forEach(
            predSym$10658 ->
                pat$63$10660 ->
                    match pat$63$10660 {
                        case (arity$10667, den$10671) =>
                            let newr$10673: RamSym[v] = Fixpoint.Ast.Ram.RamSym.New(
                                predSym$10658,
                                arity$10667,
                                den$10671
                            );
                            let full$10680: RamSym[v] = Fixpoint.Ast.Ram.RamSym.Full(
                                predSym$10658,
                                arity$10667,
                                den$10671
                            );
                            let mergeNew$10686: RamStmt[v] = Fixpoint.Ast.Ram.RamStmt.Merge(
                                newr$10673,
                                full$10680
                            );
                            MutList.push!(mergeNew$10686, loopBody$10599)
                    },
            idb$10560
        );
        Map.forEach(
            predSym$10703 ->
                pat$64$10705 ->
                    match pat$64$10705 {
                        case (arity$10715, den$10725) =>
                            let delta$10729: RamSym[v] = Fixpoint.Ast.Ram.RamSym.Delta(
                                predSym$10703,
                                arity$10715,
                                den$10725
                            );
                            let newr$10733: RamSym[v] = Fixpoint.Ast.Ram.RamSym.New(
                                predSym$10703,
                                arity$10715,
                                den$10725
                            );
                            let assign$10739: RamStmt[v] = Fixpoint.Ast.Ram.RamStmt.Assign(
                                delta$10729,
                                newr$10733
                            );
                            MutList.push!(assign$10739, loopBody$10599)
                    },
            idb$10560
        );
        let loopTest$10744: Vector[BoolExp[v]] = |>(
            |>(
                Map.mapWithKey(
                    predSym$10746 ->
                        pat$65$10748 ->
                            match pat$65$10748 {
                                case (arity$10750, den$10752) =>
                                    Fixpoint.Ast.Ram.BoolExp.Empty(
                                        Fixpoint.Ast.Ram.RamSym.Delta(
                                            predSym$10746,
                                            arity$10750,
                                            den$10752
                                        )
                                    )
                            },
                    idb$10560
                ),
                $0$45654 ->
                    Map.valuesOf($0$45654)
            ),
            $0$45656 ->
                List.toVector($0$45656)
        );
        let untilBody$10762: RamStmt[v] = Fixpoint.Ast.Ram.RamStmt.Seq(
            MutList.toVector(loopBody$10599)
        );
        let fixpoint$10773: RamStmt[v] = Fixpoint.Ast.Ram.RamStmt.Until(
            loopTest$10744,
            untilBody$10762
        );
        MutList.push!(fixpoint$10773, stmts$10548)
    }
}

def Fixpoint.Phase.Compiler.unifyVars(
    body$11418: Vector[(BodyPredicate[v], RowVar)]
): Map[VarSym, RamTerm[v]] = {
    Vector.foldLeft(
        acc$11430 ->
            pat$73$11435 ->
                match pat$73$11435 {
                    case (atom$11445, rowVar$11447) =>
                        match atom$11445 {
                            case Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                                _,
                                denotation$11449,
                                Fixpoint.Ast.Datalog.Polarity.Positive,
                                _,
                                terms$11451
                            ) =>
                                |>(
                                    Vector.mapWithIndex(
                                        i$11453 ->
                                            term$11455 ->
                                                (term$11455, i$11453),
                                        terms$11451
                                    ),
                                    (
                                        $0$45706 ->
                                            $1$45708 ->
                                                $2$45710 ->
                                                    Vector.foldRight(
                                                        $0$45706,
                                                        $1$45708,
                                                        $2$45710
                                                    )
                                    )(
                                        pat$71$11458 ->
                                            match pat$71$11458 {
                                                case (term$11463, i$11467) =>
                                                    match term$11463 {
                                                        case Fixpoint.Ast.Datalog.BodyTerm.Var(
                                                            var$11474
                                                        ) =>
                                                            match denotation$11449 {
                                                                case Fixpoint.Ast.Shared.Denotation.Relational =>
                                                                    (
                                                                        $0$45712 ->
                                                                            $1$45714 ->
                                                                                $2$45716 ->
                                                                                    $3$45718 ->
                                                                                        Map.insertWith(
                                                                                            $0$45712,
                                                                                            $1$45714,
                                                                                            $2$45716,
                                                                                            $3$45718
                                                                                        )
                                                                    )(
                                                                        _$11478 ->
                                                                            t$11481 ->
                                                                                t$11481
                                                                    )(
                                                                        var$11474
                                                                    )(
                                                                        Fixpoint.Ast.Ram.RamTerm.RowLoad(
                                                                            rowVar$11447,
                                                                            i$11467
                                                                        )
                                                                    )
                                                                case Fixpoint.Ast.Shared.Denotation.Latticenal(
                                                                    _,
                                                                    _,
                                                                    _,
                                                                    glb$11483
                                                                ) =>
                                                                    if (
                                                                        <[unknown exp]>(
                                                                            i$11467,
                                                                            <[unknown exp]>(
                                                                                Vector.length(
                                                                                    terms$11451
                                                                                ),
                                                                                1i32
                                                                            )
                                                                        )
                                                                    ) {
                                                                        (
                                                                            $0$45720 ->
                                                                                $1$45722 ->
                                                                                    $2$45724 ->
                                                                                        $3$45726 ->
                                                                                            Map.insertWith(
                                                                                                $0$45720,
                                                                                                $1$45722,
                                                                                                $2$45724,
                                                                                                $3$45726
                                                                                            )
                                                                        )(
                                                                            _$11485 ->
                                                                                t$11487 ->
                                                                                    t$11487
                                                                        )(
                                                                            var$11474
                                                                        )(
                                                                            Fixpoint.Ast.Ram.RamTerm.RowLoad(
                                                                                rowVar$11447,
                                                                                i$11467
                                                                            )
                                                                        )
                                                                    } else {
                                                                        let f$11494: (
                                                                            RamTerm[v] ->
                                                                                RamTerm[v] -> RamTerm[v]
                                                                        ) = t1$11496 ->
                                                                            t2$11498 ->
                                                                                Fixpoint.Ast.Ram.RamTerm.Meet(
                                                                                    glb$11483,
                                                                                    t1$11496,
                                                                                    t2$11498
                                                                                );
                                                                        (
                                                                            $0$45756 ->
                                                                                $1$45758 ->
                                                                                    $2$45760 ->
                                                                                        $3$45762 ->
                                                                                            Map.insertWith(
                                                                                                $0$45756,
                                                                                                $1$45758,
                                                                                                $2$45760,
                                                                                                $3$45762
                                                                                            )
                                                                        )(
                                                                            f$11494
                                                                        )(
                                                                            var$11474
                                                                        )(
                                                                            Fixpoint.Ast.Ram.RamTerm.LoadLatVar(
                                                                                rowVar$11447
                                                                            )
                                                                        )
                                                                    }
                                                            }
                                                        case _ =>
                                                            x$11519 ->
                                                                x$11519
                                                    }
                                            }
                                    )(acc$11430)
                                )
                            case Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                                _,
                                _,
                                Fixpoint.Ast.Datalog.Polarity.Negative,
                                _,
                                _
                            ) =>
                                acc$11430
                            case Fixpoint.Ast.Datalog.BodyPredicate.Functional(
                                boundVars$11533,
                                _,
                                _
                            ) =>
                                |>(
                                    Vector.mapWithIndex(
                                        i$11535 ->
                                            var$11537 ->
                                                (var$11537, i$11535),
                                        boundVars$11533
                                    ),
                                    (
                                        $0$45768 ->
                                            $1$45770 ->
                                                $2$45772 ->
                                                    Vector.foldRight(
                                                        $0$45768,
                                                        $1$45770,
                                                        $2$45772
                                                    )
                                    )(
                                        pat$72$11539 ->
                                            match pat$72$11539 {
                                                case (var$11545, i$11550) =>
                                                    (
                                                        $0$45774 ->
                                                            $1$45776 ->
                                                                $2$45778 ->
                                                                    $3$45780 ->
                                                                        Map.insertWith(
                                                                            $0$45774,
                                                                            $1$45776,
                                                                            $2$45778,
                                                                            $3$45780
                                                                        )
                                                    )(
                                                        _$11556 ->
                                                            t$11563 ->
                                                                t$11563
                                                    )(
                                                        var$11545
                                                    )(
                                                        Fixpoint.Ast.Ram.RamTerm.RowLoad(
                                                            rowVar$11447,
                                                            i$11550
                                                        )
                                                    )
                                            }
                                    )(acc$11430)
                                )
                            case Fixpoint.Ast.Datalog.BodyPredicate.Guard0(_) =>
                                acc$11430
                            case Fixpoint.Ast.Datalog.BodyPredicate.Guard1(
                                _,
                                _
                            ) =>
                                acc$11430
                            case Fixpoint.Ast.Datalog.BodyPredicate.Guard2(
                                _,
                                _,
                                _
                            ) =>
                                acc$11430
                            case Fixpoint.Ast.Datalog.BodyPredicate.Guard3(
                                _,
                                _,
                                _,
                                _
                            ) =>
                                acc$11430
                            case Fixpoint.Ast.Datalog.BodyPredicate.Guard4(
                                _,
                                _,
                                _,
                                _,
                                _
                            ) =>
                                acc$11430
                            case Fixpoint.Ast.Datalog.BodyPredicate.Guard5(
                                _,
                                _,
                                _,
                                _,
                                _,
                                _
                            ) =>
                                acc$11430
                        }
                },
        Map.empty(()),
        body$11418
    )
}

def Fixpoint.Phase.Compiler.unwrap(o$11927: Option[a]): a = {
    match o$11927 {
        case Option.Some(a$11941) =>
            a$11941
        case Option.None =>
            bug!("""Unexpected None""")
    }
}

def Fixpoint.Phase.IndexSelection.isExpGround(
    freeVars$26742: Set[RowVar],
    exp$26748: BoolExp[v]
): Bool = {
    match exp$26748 {
        case Fixpoint.Ast.Ram.BoolExp.Empty(_) =>
            true
        case Fixpoint.Ast.Ram.BoolExp.NotMemberOf(terms$26759, _) =>
            Vector.forAll(
                (
                    $0$46484 ->
                        $1$46486 ->
                            Fixpoint.Phase.IndexSelection.isTermGround(
                                $0$46484,
                                $1$46486
                            )
                )(freeVars$26742),
                terms$26759
            )
        case Fixpoint.Ast.Ram.BoolExp.Eq(lhs$26761, rhs$26763) =>
            Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26742,
                lhs$26761
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26742,
                rhs$26763
            )
        case Fixpoint.Ast.Ram.BoolExp.Leq(_, lhs$26765, rhs$26767) =>
            Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26742,
                lhs$26765
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26742,
                rhs$26767
            )
        case Fixpoint.Ast.Ram.BoolExp.Guard0(_) =>
            true
        case Fixpoint.Ast.Ram.BoolExp.Guard1(_, t$26769) =>
            Fixpoint.Phase.IndexSelection.isTermGround(freeVars$26742, t$26769)
        case Fixpoint.Ast.Ram.BoolExp.Guard2(_, t1$26773, t2$26775) =>
            Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26742,
                t1$26773
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26742,
                t2$26775
            )
        case Fixpoint.Ast.Ram.BoolExp.Guard3(_, t1$26782, t2$26788, t3$26790) =>
            (
                Fixpoint.Phase.IndexSelection.isTermGround(
                    freeVars$26742,
                    t1$26782
                ) and Fixpoint.Phase.IndexSelection.isTermGround(
                    freeVars$26742,
                    t2$26788
                )
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26742,
                t3$26790
            )
        case Fixpoint.Ast.Ram.BoolExp.Guard4(
            _,
            t1$26802,
            t2$26804,
            t3$26808,
            t4$26812
        ) =>
            (
                (
                    Fixpoint.Phase.IndexSelection.isTermGround(
                        freeVars$26742,
                        t1$26802
                    ) and Fixpoint.Phase.IndexSelection.isTermGround(
                        freeVars$26742,
                        t2$26804
                    )
                ) and Fixpoint.Phase.IndexSelection.isTermGround(
                    freeVars$26742,
                    t3$26808
                )
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26742,
                t4$26812
            )
        case Fixpoint.Ast.Ram.BoolExp.Guard5(
            _,
            t1$26818,
            t2$26820,
            t3$26822,
            t4$26825,
            t5$26827
        ) =>
            (
                (
                    (
                        Fixpoint.Phase.IndexSelection.isTermGround(
                            freeVars$26742,
                            t1$26818
                        ) and Fixpoint.Phase.IndexSelection.isTermGround(
                            freeVars$26742,
                            t2$26820
                        )
                    ) and Fixpoint.Phase.IndexSelection.isTermGround(
                        freeVars$26742,
                        t3$26822
                    )
                ) and Fixpoint.Phase.IndexSelection.isTermGround(
                    freeVars$26742,
                    t4$26825
                )
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26742,
                t5$26827
            )
    }
}

def Fixpoint.Phase.IndexSelection.isTermGround(
    freeVars$26851: Set[RowVar],
    term$26857: RamTerm[v]
): Bool = {
    match term$26857 {
        case Fixpoint.Ast.Ram.RamTerm.Lit(_) =>
            true
        case Fixpoint.Ast.Ram.RamTerm.RowLoad(var$26887, _) =>
            Set.memberOf(var$26887, freeVars$26851)
        case Fixpoint.Ast.Ram.RamTerm.LoadLatVar(var$26889) =>
            Set.memberOf(var$26889, freeVars$26851)
        case Fixpoint.Ast.Ram.RamTerm.Meet(_, t1$26891, t2$26893) =>
            Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26851,
                t1$26891
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26851,
                t2$26893
            )
        case Fixpoint.Ast.Ram.RamTerm.App0(_) =>
            true
        case Fixpoint.Ast.Ram.RamTerm.App1(_, t$26895) =>
            Fixpoint.Phase.IndexSelection.isTermGround(freeVars$26851, t$26895)
        case Fixpoint.Ast.Ram.RamTerm.App2(_, t1$26899, t2$26901) =>
            Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26851,
                t1$26899
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26851,
                t2$26901
            )
        case Fixpoint.Ast.Ram.RamTerm.App3(_, t1$26907, t2$26909, t3$26911) =>
            (
                Fixpoint.Phase.IndexSelection.isTermGround(
                    freeVars$26851,
                    t1$26907
                ) and Fixpoint.Phase.IndexSelection.isTermGround(
                    freeVars$26851,
                    t2$26909
                )
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26851,
                t3$26911
            )
        case Fixpoint.Ast.Ram.RamTerm.App4(
            _,
            t1$26913,
            t2$26915,
            t3$26917,
            t4$26919
        ) =>
            (
                (
                    Fixpoint.Phase.IndexSelection.isTermGround(
                        freeVars$26851,
                        t1$26913
                    ) and Fixpoint.Phase.IndexSelection.isTermGround(
                        freeVars$26851,
                        t2$26915
                    )
                ) and Fixpoint.Phase.IndexSelection.isTermGround(
                    freeVars$26851,
                    t3$26917
                )
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26851,
                t4$26919
            )
        case Fixpoint.Ast.Ram.RamTerm.App5(
            _,
            t1$26922,
            t2$26924,
            t3$26926,
            t4$26928,
            t5$26930
        ) =>
            (
                (
                    (
                        Fixpoint.Phase.IndexSelection.isTermGround(
                            freeVars$26851,
                            t1$26922
                        ) and Fixpoint.Phase.IndexSelection.isTermGround(
                            freeVars$26851,
                            t2$26924
                        )
                    ) and Fixpoint.Phase.IndexSelection.isTermGround(
                        freeVars$26851,
                        t3$26926
                    )
                ) and Fixpoint.Phase.IndexSelection.isTermGround(
                    freeVars$26851,
                    t4$26928
                )
            ) and Fixpoint.Phase.IndexSelection.isTermGround(
                freeVars$26851,
                t5$26930
            )
    }
}

def Fixpoint.Phase.IndexSelection.longestPrefixQuery(
    varQuery$26630: Vector[BoolExp[v]]
): (Vector[BoolExp[v]], Vector[BoolExp[v]]) = {
    <[unknown exp]>
}

def Fixpoint.Phase.IndexSelection.queryOp(
    op$26450: RelOp[v],
    freeVars$26458: Set[RowVar]
): (RelOp[v], Vector[BoolExp[v]]) = {
    match op$26450 {
        case Fixpoint.Ast.Ram.RelOp.Search(
            var$26473,
            ramSym$26475,
            body$26479
        ) =>
            <[unknown exp]>
        case Fixpoint.Ast.Ram.RelOp.Query(_) =>
            (op$26450, Vector.empty(()))
        case Fixpoint.Ast.Ram.RelOp.Functional(_) =>
            (op$26450, Vector.empty(()))
        case Fixpoint.Ast.Ram.RelOp.Project(_) =>
            (op$26450, Vector.empty(()))
        case Fixpoint.Ast.Ram.RelOp.If(test$26598, then$26602) =>
            match Fixpoint.Phase.IndexSelection.queryOp(
                then$26602,
                freeVars$26458
            ) {
                case (innerOp$26605, innerGround$26607) =>
                    (
                        innerOp$26605,
                        Vector.append(test$26598, innerGround$26607)
                    )
            }
    }
}

def Fixpoint.Phase.IndexSelection.queryStmt(
    stmt$26330: RamStmt[v]
): RamStmt[v] = {
    match stmt$26330 {
        case Fixpoint.Ast.Ram.RamStmt.Insert(op$26341) =>
            match Fixpoint.Phase.IndexSelection.queryOp(
                op$26341,
                Set.empty(())
            ) {
                case (innerOp$26353, ground$26355) =>
                    if (Vector.isEmpty(ground$26355)) {
                        Fixpoint.Ast.Ram.RamStmt.Insert(innerOp$26353)
                    } else {
                        Fixpoint.Ast.Ram.RamStmt.Insert(
                            Fixpoint.Ast.Ram.RelOp.If(
                                ground$26355,
                                innerOp$26353
                            )
                        )
                    }
            }
        case Fixpoint.Ast.Ram.RamStmt.Merge(_, _) =>
            stmt$26330
        case Fixpoint.Ast.Ram.RamStmt.Assign(_, _) =>
            stmt$26330
        case Fixpoint.Ast.Ram.RamStmt.Purge(_) =>
            stmt$26330
        case Fixpoint.Ast.Ram.RamStmt.Seq(xs$26397) =>
            Fixpoint.Ast.Ram.RamStmt.Seq(
                Vector.map(
                    $0$46386 ->
                        Fixpoint.Phase.IndexSelection.queryStmt($0$46386),
                    xs$26397
                )
            )
        case Fixpoint.Ast.Ram.RamStmt.Until(test$26405, body$26411) =>
            Fixpoint.Ast.Ram.RamStmt.Until(
                test$26405,
                Fixpoint.Phase.IndexSelection.queryStmt(body$26411)
            )
        case Fixpoint.Ast.Ram.RamStmt.Comment(_) =>
            stmt$26330
    }
}

def Fixpoint.Phase.Simplifier.ramTermVars(
    term$40760: RamTerm[v]
): Set[RowVar] = {
    match term$40760 {
        case Fixpoint.Ast.Ram.RamTerm.Lit(_) =>
            Set.empty(())
        case Fixpoint.Ast.Ram.RamTerm.RowLoad(var$40776, _) =>
            Set.insert(var$40776, Set.empty(()))
        case Fixpoint.Ast.Ram.RamTerm.LoadLatVar(var$40782) =>
            Set.insert(var$40782, Set.empty(()))
        case Fixpoint.Ast.Ram.RamTerm.Meet(_, lhs$40784, rhs$40786) =>
            Set.union(
                Fixpoint.Phase.Simplifier.ramTermVars(lhs$40784),
                Fixpoint.Phase.Simplifier.ramTermVars(rhs$40786)
            )
        case Fixpoint.Ast.Ram.RamTerm.App0(_) =>
            Set.empty(())
        case Fixpoint.Ast.Ram.RamTerm.App1(_, t$40795) =>
            Fixpoint.Phase.Simplifier.ramTermVars(t$40795)
        case Fixpoint.Ast.Ram.RamTerm.App2(_, t1$40801, t2$40803) =>
            Set.union(
                Fixpoint.Phase.Simplifier.ramTermVars(t1$40801),
                Fixpoint.Phase.Simplifier.ramTermVars(t2$40803)
            )
        case Fixpoint.Ast.Ram.RamTerm.App3(_, t1$40811, t2$40813, t3$40815) =>
            let v1$40817: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t1$40811
            );
            let v2$40819: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t2$40813
            );
            let v3$40823: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t3$40815
            );
            Set.union(v1$40817, Set.union(v2$40819, v3$40823))
        case Fixpoint.Ast.Ram.RamTerm.App4(
            _,
            t1$40826,
            t2$40829,
            t3$40831,
            t4$40833
        ) =>
            let v1$40835: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t1$40826
            );
            let v2$40837: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t2$40829
            );
            let v3$40839: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t3$40831
            );
            let v4$40841: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t4$40833
            );
            Set.union(
                v1$40835,
                Set.union(v2$40837, Set.union(v3$40839, v4$40841))
            )
        case Fixpoint.Ast.Ram.RamTerm.App5(
            _,
            t1$40843,
            t2$40845,
            t3$40847,
            t4$40849,
            t5$40851
        ) =>
            let v1$40853: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t1$40843
            );
            let v2$40855: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t2$40845
            );
            let v3$40857: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t3$40847
            );
            let v4$40859: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t4$40849
            );
            let v5$40861: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                t5$40851
            );
            Set.union(
                v1$40853,
                Set.union(
                    v2$40855,
                    Set.union(v3$40857, Set.union(v4$40859, v5$40861))
                )
            )
    }
}

def Fixpoint.Phase.Simplifier.simplifyHelper(
    stratum$40473: Set[RamSym[v]],
    stmt$40477: RamStmt[v]
): Option[RamStmt[v]] = {
    match stmt$40477 {
        case Fixpoint.Ast.Ram.RamStmt.Insert(op$40492) =>
            <[unknown exp]>(
                pat$129$40494 ->
                    match pat$129$40494 {
                        case newOp$40502 =>
                            <[unknown exp]>(
                                match newOp$40502 {
                                    case _ =>
                                        Fixpoint.Ast.Ram.RamStmt.Insert(
                                            newOp$40502
                                        )
                                }
                            )
                    },
                Fixpoint.Phase.Simplifier.simplifyOp(stratum$40473, op$40492)
            )
        case Fixpoint.Ast.Ram.RamStmt.Merge(_, _) =>
            Option.Some(stmt$40477)
        case Fixpoint.Ast.Ram.RamStmt.Assign(_, _) =>
            Option.Some(stmt$40477)
        case Fixpoint.Ast.Ram.RamStmt.Purge(_) =>
            Option.Some(stmt$40477)
        case Fixpoint.Ast.Ram.RamStmt.Seq(xs$40527) =>
            Option.Some(
                Fixpoint.Ast.Ram.RamStmt.Seq(
                    Vector.filterMap(
                        (
                            $0$46902 ->
                                $1$46904 ->
                                    Fixpoint.Phase.Simplifier.simplifyHelper(
                                        $0$46902,
                                        $1$46904
                                    )
                        )(stratum$40473),
                        xs$40527
                    )
                )
            )
        case Fixpoint.Ast.Ram.RamStmt.Until(test$40534, body$40536) =>
            let newStratum$40538: Set[RamSym[v]] = Vector.foldLeft(
                acc$40540 ->
                    e$40542 ->
                        match e$40542 {
                            case Fixpoint.Ast.Ram.BoolExp.Empty(ramSym$40544) =>
                                Set.insert(ramSym$40544, acc$40540)
                            case _ =>
                                acc$40540
                        },
                Set.empty(()),
                test$40534
            );
            |>(
                Fixpoint.Phase.Simplifier.simplifyHelper(
                    newStratum$40538,
                    body$40536
                ),
                (
                    $0$46906 ->
                        $1$46908 ->
                            Option.map($0$46906, $1$46908)
                )(
                    newBody$40548 ->
                        Fixpoint.Ast.Ram.RamStmt.Until(
                            test$40534,
                            newBody$40548
                        )
                )
            )
        case Fixpoint.Ast.Ram.RamStmt.Comment(_) =>
            Option.Some(stmt$40477)
    }
}

def Fixpoint.Phase.Simplifier.simplifyOp(
    stratum$40596: Set[RamSym[v]],
    op$40598: RelOp[v]
): Option[RelOp[v]] = {
    match op$40598 {
        case Fixpoint.Ast.Ram.RelOp.If(test$40600, then$40602) =>
            match |>(
                Vector.filter(
                    e$40604 ->
                        match e$40604 {
                            case Fixpoint.Ast.Ram.BoolExp.Eq(
                                Fixpoint.Ast.Ram.RamTerm.RowLoad(lhs$40606),
                                Fixpoint.Ast.Ram.RamTerm.RowLoad(rhs$40608)
                            ) =>
                                <[unknown exp]>(lhs$40606, rhs$40608)
                            case Fixpoint.Ast.Ram.BoolExp.Leq(
                                _,
                                lhs$40611,
                                Fixpoint.Ast.Ram.RamTerm.LoadLatVar(
                                    rhsVar$40613
                                )
                            ) =>
                                let lhsVars$40615: Set[RowVar] = Fixpoint.Phase.Simplifier.ramTermVars(
                                    lhs$40611
                                );
                                !Set.memberOf(rhsVar$40613, lhsVars$40615)
                            case _ =>
                                true
                        },
                    test$40600
                ),
                (
                    $0$46912 ->
                        $1$46914 ->
                            Vector.partition($0$46912, $1$46914)
                )(
                    e$40623 ->
                        match e$40623 {
                            case Fixpoint.Ast.Ram.BoolExp.NotMemberOf(_) =>
                                true
                            case _ =>
                                false
                        }
                )
            ) {
                case (memberOf$40635, rest$40637) =>
                    let newTest$40639: Vector[BoolExp[v]] = Vector.append(
                        rest$40637,
                        memberOf$40635
                    );
                    if (Vector.isEmpty(newTest$40639)) {
                        Option.Some(then$40602)
                    } else {
                        Option.Some(
                            Fixpoint.Ast.Ram.RelOp.If(newTest$40639, then$40602)
                        )
                    }
            }
        case Fixpoint.Ast.Ram.RelOp.Search(
            rowVar$40647,
            ramSym$40650,
            body$40653
        ) =>
            let f$40657: (RelOp[v] -> Option[RelOp[v]]) = nb$40662 ->
                match ramSym$40650 {
                    case Fixpoint.Ast.Ram.RamSym.Delta(_) =>
                        if (Set.memberOf(ramSym$40650, stratum$40596)) {
                            Option.Some(
                                Fixpoint.Ast.Ram.RelOp.Search(
                                    rowVar$40647,
                                    ramSym$40650,
                                    nb$40662
                                )
                            )
                        } else {
                            Option.None
                        }
                    case _ =>
                        Option.Some(
                            Fixpoint.Ast.Ram.RelOp.Search(
                                rowVar$40647,
                                ramSym$40650,
                                nb$40662
                            )
                        )
                };
            <[unknown exp]>(
                pat$131$40667 ->
                    match pat$131$40667 {
                        case newBody$40669 =>
                            <[unknown exp]>(
                                pat$130$40671 ->
                                    match pat$130$40671 {
                                        case res$40673 =>
                                            <[unknown exp]>(res$40673)
                                    },
                                f$40657(newBody$40669)
                            )
                    },
                Fixpoint.Phase.Simplifier.simplifyOp(stratum$40596, body$40653)
            )
        case Fixpoint.Ast.Ram.RelOp.Query(
            rowVar$40675,
            ramSym$40678,
            qry$40680,
            body$40682
        ) =>
            let f$40684: (RelOp[v] -> Option[RelOp[v]]) = nb$40686 ->
                match ramSym$40678 {
                    case Fixpoint.Ast.Ram.RamSym.Delta(_) =>
                        if (Set.memberOf(ramSym$40678, stratum$40596)) {
                            Option.Some(
                                Fixpoint.Ast.Ram.RelOp.Query(
                                    rowVar$40675,
                                    ramSym$40678,
                                    qry$40680,
                                    nb$40686
                                )
                            )
                        } else {
                            Option.None
                        }
                    case _ =>
                        Option.Some(
                            Fixpoint.Ast.Ram.RelOp.Query(
                                rowVar$40675,
                                ramSym$40678,
                                qry$40680,
                                nb$40686
                            )
                        )
                };
            <[unknown exp]>(
                pat$133$40701 ->
                    match pat$133$40701 {
                        case newBody$40705 =>
                            <[unknown exp]>(
                                pat$132$40707 ->
                                    match pat$132$40707 {
                                        case res$40709 =>
                                            <[unknown exp]>(res$40709)
                                    },
                                f$40684(newBody$40705)
                            )
                    },
                Fixpoint.Phase.Simplifier.simplifyOp(stratum$40596, body$40682)
            )
        case Fixpoint.Ast.Ram.RelOp.Functional(
            rowVar$40729,
            f$40731,
            terms$40733,
            body$40735
        ) =>
            <[unknown exp]>(
                pat$134$40737 ->
                    match pat$134$40737 {
                        case newBody$40739 =>
                            <[unknown exp]>(
                                Fixpoint.Ast.Ram.RelOp.Functional(
                                    rowVar$40729,
                                    f$40731,
                                    terms$40733,
                                    newBody$40739
                                )
                            )
                    },
                Fixpoint.Phase.Simplifier.simplifyOp(stratum$40596, body$40735)
            )
        case Fixpoint.Ast.Ram.RelOp.Project(_) =>
            Option.Some(op$40598)
    }
}

def Fixpoint.Phase.Simplifier.simplifyStmt(
    stmt$40310: RamStmt[v]
): RamStmt[v] = {
    Option.getWithDefault(
        Fixpoint.Ast.Ram.RamStmt.Seq([||]),
        Fixpoint.Phase.Simplifier.simplifyHelper(Set.empty(()), stmt$40310)
    )
}

def Fixpoint.Phase.Stratifier.mkDepEdge(
    dst$21534: HeadPredicate[v],
    src$21540: BodyPredicate[v]
): PrecedenceGraph = {
    match (dst$21534, src$21540) {
        case (
            Fixpoint.Ast.Datalog.HeadPredicate.HeadAtom(headSym$21554, _, _),
            Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                bodySym$21558,
                _,
                Fixpoint.Ast.Datalog.Polarity.Positive,
                Fixpoint.Ast.Datalog.Fixity.Loose,
                _
            )
        ) =>
            Fixpoint.Ast.PrecedenceGraph.PrecedenceGraph(
                Set.insert(
                    Fixpoint.Ast.PrecedenceEdge.WeakEdge(
                        bodySym$21558,
                        headSym$21554
                    ),
                    Set.empty(())
                )
            )
        case (
            Fixpoint.Ast.Datalog.HeadPredicate.HeadAtom(headSym$21570, _, _),
            Fixpoint.Ast.Datalog.BodyPredicate.BodyAtom(
                bodySym$21572,
                _,
                _,
                _,
                _
            )
        ) =>
            Fixpoint.Ast.PrecedenceGraph.PrecedenceGraph(
                Set.insert(
                    Fixpoint.Ast.PrecedenceEdge.StrongEdge(
                        bodySym$21572,
                        headSym$21570
                    ),
                    Set.empty(())
                )
            )
        case _ =>
            Fixpoint.Ast.PrecedenceGraph.PrecedenceGraph(Set.empty(()))
    }
}

def Fixpoint.Phase.Stratifier.mkDepGraph(
    d$21506: Datalog[v]
): PrecedenceGraph = {
    match d$21506 {
        case Fixpoint.Ast.Datalog.Datalog.Datalog(_, rules$21508) =>
            Vector.fold(
                Vector.map(
                    $0$46220 ->
                        Fixpoint.Phase.Stratifier.precedenceHelper($0$46220),
                    rules$21508
                )
            )
        case Fixpoint.Ast.Datalog.Datalog.Model(_) =>
            <[unknown exp]>(())
        case Fixpoint.Ast.Datalog.Datalog.Join(d1$21510, d2$21512) =>
            <[unknown exp]>(
                Fixpoint.Phase.Stratifier.mkDepGraph(d1$21510),
                Fixpoint.Phase.Stratifier.mkDepGraph(d2$21512)
            )
    }
}

def Fixpoint.Phase.Stratifier.precedenceHelper(
    cnst$21518: Constraint[v]
): PrecedenceGraph = {
    match cnst$21518 {
        case Fixpoint.Ast.Datalog.Constraint.Constraint(
            head$21522,
            body$21524
        ) =>
            Vector.fold(
                Vector.map(
                    (
                        $0$46222 ->
                            $1$46224 ->
                                Fixpoint.Phase.Stratifier.mkDepEdge(
                                    $0$46222,
                                    $1$46224
                                )
                    )(head$21522),
                    body$21524
                )
            )
    }
}

def Fixpoint.Phase.Stratifier.stratify(
    d$21403: Datalog[v]
): Map[PredSym, Int32] = {
    match d$21403 {
        case Fixpoint.Ast.Datalog.Datalog.Datalog(_, rules$21408) =>
            |>(
                Vector.foldRight(
                    pat$81$21415 ->
                        match pat$81$21415 {
                            case Fixpoint.Ast.Datalog.Constraint.Constraint(
                                Fixpoint.Ast.Datalog.HeadPredicate.HeadAtom(
                                    p$21425,
                                    _,
                                    _
                                ),
                                _
                            ) =>
                                (
                                    $0$46174 ->
                                        $1$46176 ->
                                            $2$46178 ->
                                                Map.insert(
                                                    $0$46174,
                                                    $1$46176,
                                                    $2$46178
                                                )
                                )(p$21425)(0i32)
                        },
                    Map.empty(()),
                    rules$21408
                ),
                (
                    $0$46180 ->
                        $1$46182 ->
                            Fixpoint.Phase.Stratifier.stratifyHelper(
                                $0$46180,
                                $1$46182
                            )
                )(Fixpoint.Phase.Stratifier.mkDepGraph(d$21403))
            )
        case Fixpoint.Ast.Datalog.Datalog.Model(_) =>
            Map.empty(())
        case Fixpoint.Ast.Datalog.Datalog.Join(d1$21432, d2$21437) =>
            Map.unionWith(
                $0$46216 ->
                    $1$46218 ->
                        Int32.max($0$46216, $1$46218),
                Fixpoint.Phase.Stratifier.stratify(d1$21432),
                Fixpoint.Phase.Stratifier.stratify(d2$21437)
            )
    }
}

def Fixpoint.Phase.Stratifier.stratifyHelper(
    g$21443: PrecedenceGraph,
    stf$21445: Map[PredSym, Int32]
): Map[PredSym, Int32] = {
    match g$21443 {
        case Fixpoint.Ast.PrecedenceGraph.PrecedenceGraph(xs$21448) =>
            let maxStratum$21452: Int32 = Set.size(xs$21448);
            match Set.foldLeft(
                pat$82$21458 ->
                    match pat$82$21458 {
                        case (acc$21462, changed$21464) =>
                            edge$21467 ->
                                match edge$21467 {
                                    case Fixpoint.Ast.PrecedenceEdge.WeakEdge(
                                        bodySym$21470,
                                        headSym$21472
                                    ) =>
                                        let bodyStratum$21474: Int32 = Map.getWithDefault(
                                            bodySym$21470,
                                            0i32,
                                            acc$21462
                                        );
                                        let headStratum$21476: Int32 = Map.getWithDefault(
                                            headSym$21472,
                                            0i32,
                                            acc$21462
                                        );
                                        if (
                                            <[unknown exp]>(
                                                bodyStratum$21474,
                                                headStratum$21476
                                            )
                                        ) {
                                            (
                                                Map.insert(
                                                    headSym$21472,
                                                    bodyStratum$21474,
                                                    acc$21462
                                                ),
                                                true
                                            )
                                        } else {
                                            (acc$21462, changed$21464)
                                        }
                                    case Fixpoint.Ast.PrecedenceEdge.StrongEdge(
                                        bodySym$21486,
                                        headSym$21488
                                    ) =>
                                        let bodyStratum$21490: Int32 = Map.getWithDefault(
                                            bodySym$21486,
                                            0i32,
                                            acc$21462
                                        );
                                        let headStratum$21492: Int32 = Map.getWithDefault(
                                            headSym$21488,
                                            0i32,
                                            acc$21462
                                        );
                                        if (
                                            <[unknown exp]>(
                                                bodyStratum$21490,
                                                headStratum$21492
                                            )
                                        ) {
                                            let newHeadStratum$21494: Int32 = <[unknown exp]>(
                                                bodyStratum$21490,
                                                1i32
                                            );
                                            if (
                                                <[unknown exp]>(
                                                    newHeadStratum$21494,
                                                    maxStratum$21452
                                                )
                                            ) {
                                                bug!(
                                                    """Stratification error (strong cycle)"""
                                                )
                                            } else {
                                                (
                                                    Map.insert(
                                                        headSym$21488,
                                                        newHeadStratum$21494,
                                                        acc$21462
                                                    ),
                                                    true
                                                )
                                            }
                                        } else {
                                            (acc$21462, changed$21464)
                                        }
                                }
                    },
                (stf$21445, false),
                xs$21448
            ) {
                case (newStf$21496, changed$21498) =>
                    if (changed$21498) {
                        Fixpoint.Phase.Stratifier.stratifyHelper(
                            g$21443,
                            newStf$21496
                        )
                    } else {
                        stf$21445
                    }
            }
    }
}

def Fixpoint.Phase.VarsToIndices.lowerExp(
    rowVars$22092: Map[RowVar, RowVar],
    exp$22095: BoolExp[v]
): BoolExp[v] = {
    match exp$22095 {
        case Fixpoint.Ast.Ram.BoolExp.Empty(_) =>
            exp$22095
        case Fixpoint.Ast.Ram.BoolExp.NotMemberOf(terms$22108, ramSym$22111) =>
            Fixpoint.Ast.Ram.BoolExp.NotMemberOf(
                Vector.map(
                    (
                        $0$46202 ->
                            $1$46204 ->
                                Fixpoint.Phase.VarsToIndices.lowerTerm(
                                    $0$46202,
                                    $1$46204
                                )
                    )(rowVars$22092),
                    terms$22108
                ),
                ramSym$22111
            )
        case Fixpoint.Ast.Ram.BoolExp.Eq(lhs$22120, rhs$22122) =>
            Fixpoint.Ast.Ram.BoolExp.Eq(
                Fixpoint.Phase.VarsToIndices.lowerTerm(
                    rowVars$22092,
                    lhs$22120
                ),
                Fixpoint.Phase.VarsToIndices.lowerTerm(rowVars$22092, rhs$22122)
            )
        case Fixpoint.Ast.Ram.BoolExp.Leq(f$22124, lhs$22127, rhs$22129) =>
            Fixpoint.Ast.Ram.BoolExp.Leq(
                f$22124,
                Fixpoint.Phase.VarsToIndices.lowerTerm(
                    rowVars$22092,
                    lhs$22127
                ),
                Fixpoint.Phase.VarsToIndices.lowerTerm(rowVars$22092, rhs$22129)
            )
        case Fixpoint.Ast.Ram.BoolExp.Guard0(_) =>
            exp$22095
        case Fixpoint.Ast.Ram.BoolExp.Guard1(f$22131, v$22133) =>
            let t$22135: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v$22133
            );
            Fixpoint.Ast.Ram.BoolExp.Guard1(f$22131, t$22135)
        case Fixpoint.Ast.Ram.BoolExp.Guard2(f$22137, v1$22139, v2$22141) =>
            let t1$22143: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v1$22139
            );
            let t2$22145: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v2$22141
            );
            Fixpoint.Ast.Ram.BoolExp.Guard2(f$22137, t1$22143, t2$22145)
        case Fixpoint.Ast.Ram.BoolExp.Guard3(
            f$22148,
            v1$22150,
            v2$22154,
            v3$22156
        ) =>
            let t1$22158: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v1$22150
            );
            let t2$22161: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v2$22154
            );
            let t3$22163: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v3$22156
            );
            Fixpoint.Ast.Ram.BoolExp.Guard3(
                f$22148,
                t1$22158,
                t2$22161,
                t3$22163
            )
        case Fixpoint.Ast.Ram.BoolExp.Guard4(
            f$22169,
            v1$22173,
            v2$22175,
            v3$22177,
            v4$22179
        ) =>
            let t1$22181: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v1$22173
            );
            let t2$22183: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v2$22175
            );
            let t3$22185: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v3$22177
            );
            let t4$22187: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v4$22179
            );
            Fixpoint.Ast.Ram.BoolExp.Guard4(
                f$22169,
                t1$22181,
                t2$22183,
                t3$22185,
                t4$22187
            )
        case Fixpoint.Ast.Ram.BoolExp.Guard5(
            f$22190,
            v1$22192,
            v2$22194,
            v3$22196,
            v4$22199,
            v5$22201
        ) =>
            let t1$22205: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v1$22192
            );
            let t2$22208: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v2$22194
            );
            let t3$22210: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v3$22196
            );
            let t4$22212: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v4$22199
            );
            let t5$22214: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22092,
                v5$22201
            );
            Fixpoint.Ast.Ram.BoolExp.Guard5(
                f$22190,
                t1$22205,
                t2$22208,
                t3$22210,
                t4$22212,
                t5$22214
            )
    }
}

def Fixpoint.Phase.VarsToIndices.lowerOp(
    op$21991: RelOp[v],
    rowVars$21994: Map[RowVar, RowVar],
    depth$21999: Int32
): RelOp[v] = {
    match op$21991 {
        case Fixpoint.Ast.Ram.RelOp.Search(
            var$22008,
            ramSym$22012,
            body$22014
        ) =>
            let newVar$22016: RowVar = Fixpoint.Ast.Ram.RowVar.Index(
                depth$21999
            );
            let newVars$22019: Map[RowVar, RowVar] = Map.insert(
                var$22008,
                newVar$22016,
                rowVars$21994
            );
            Fixpoint.Ast.Ram.RelOp.Search(
                newVar$22016,
                ramSym$22012,
                Fixpoint.Phase.VarsToIndices.lowerOp(
                    body$22014,
                    newVars$22019,
                    <[unknown exp]>(depth$21999, 1i32)
                )
            )
        case Fixpoint.Ast.Ram.RelOp.Query(
            var$22022,
            ramSym$22024,
            prefixQuery$22026,
            body$22028
        ) =>
            let newVar$22030: RowVar = Fixpoint.Ast.Ram.RowVar.Index(
                depth$21999
            );
            let newVars$22032: Map[RowVar, RowVar] = Map.insert(
                var$22022,
                newVar$22030,
                rowVars$21994
            );
            let newQuery$22034: Vector[(Int32, RamTerm[v])] = Vector.map(
                pat$83$22036 ->
                    match pat$83$22036 {
                        case (j$22038, t$22040) =>
                            (
                                j$22038,
                                Fixpoint.Phase.VarsToIndices.lowerTerm(
                                    rowVars$21994,
                                    t$22040
                                )
                            )
                    },
                prefixQuery$22026
            );
            Fixpoint.Ast.Ram.RelOp.Query(
                newVar$22030,
                ramSym$22024,
                newQuery$22034,
                Fixpoint.Phase.VarsToIndices.lowerOp(
                    body$22028,
                    newVars$22032,
                    <[unknown exp]>(depth$21999, 1i32)
                )
            )
        case Fixpoint.Ast.Ram.RelOp.Functional(
            rowVar$22052,
            f$22054,
            terms$22057,
            body$22059
        ) =>
            let newVar$22062: RowVar = Fixpoint.Ast.Ram.RowVar.Index(
                depth$21999
            );
            let newVars$22065: Map[RowVar, RowVar] = Map.insert(
                rowVar$22052,
                newVar$22062,
                rowVars$21994
            );
            let newTerms$22071: Vector[RamTerm[v]] = |>(
                terms$22057,
                (
                    $0$46186 ->
                        $1$46188 ->
                            Vector.map($0$46186, $1$46188)
                )(
                    (
                        $0$46190 ->
                            $1$46192 ->
                                Fixpoint.Phase.VarsToIndices.lowerTerm(
                                    $0$46190,
                                    $1$46192
                                )
                    )(rowVars$21994)
                )
            );
            let newBody$22075: RelOp[v] = Fixpoint.Phase.VarsToIndices.lowerOp(
                body$22059,
                newVars$22065,
                <[unknown exp]>(depth$21999, 1i32)
            );
            Fixpoint.Ast.Ram.RelOp.Functional(
                newVar$22062,
                f$22054,
                newTerms$22071,
                newBody$22075
            )
        case Fixpoint.Ast.Ram.RelOp.Project(terms$22078, ramSym$22080) =>
            Fixpoint.Ast.Ram.RelOp.Project(
                Vector.map(
                    (
                        $0$46194 ->
                            $1$46196 ->
                                Fixpoint.Phase.VarsToIndices.lowerTerm(
                                    $0$46194,
                                    $1$46196
                                )
                    )(rowVars$21994),
                    terms$22078
                ),
                ramSym$22080
            )
        case Fixpoint.Ast.Ram.RelOp.If(test$22082, then$22084) =>
            Fixpoint.Ast.Ram.RelOp.If(
                Vector.map(
                    (
                        $0$46198 ->
                            $1$46200 ->
                                Fixpoint.Phase.VarsToIndices.lowerExp(
                                    $0$46198,
                                    $1$46200
                                )
                    )(rowVars$21994),
                    test$22082
                ),
                Fixpoint.Phase.VarsToIndices.lowerOp(
                    then$22084,
                    rowVars$21994,
                    depth$21999
                )
            )
    }
}

def Fixpoint.Phase.VarsToIndices.lowerStmt(
    stmt$21949: RamStmt[v]
): RamStmt[v] = {
    match stmt$21949 {
        case Fixpoint.Ast.Ram.RamStmt.Insert(op$21958) =>
            Fixpoint.Ast.Ram.RamStmt.Insert(
                Fixpoint.Phase.VarsToIndices.lowerOp(
                    op$21958,
                    Map.empty(()),
                    0i32
                )
            )
        case Fixpoint.Ast.Ram.RamStmt.Merge(_, _) =>
            stmt$21949
        case Fixpoint.Ast.Ram.RamStmt.Assign(_, _) =>
            stmt$21949
        case Fixpoint.Ast.Ram.RamStmt.Purge(_) =>
            stmt$21949
        case Fixpoint.Ast.Ram.RamStmt.Seq(xs$21970) =>
            Fixpoint.Ast.Ram.RamStmt.Seq(
                Vector.map(
                    $0$46184 ->
                        Fixpoint.Phase.VarsToIndices.lowerStmt($0$46184),
                    xs$21970
                )
            )
        case Fixpoint.Ast.Ram.RamStmt.Until(test$21974, body$21976) =>
            Fixpoint.Ast.Ram.RamStmt.Until(
                test$21974,
                Fixpoint.Phase.VarsToIndices.lowerStmt(body$21976)
            )
        case Fixpoint.Ast.Ram.RamStmt.Comment(_) =>
            stmt$21949
    }
}

def Fixpoint.Phase.VarsToIndices.lowerTerm(
    rowVars$22228: Map[RowVar, RowVar],
    term$22234: RamTerm[v]
): RamTerm[v] = {
    match term$22234 {
        case Fixpoint.Ast.Ram.RamTerm.Lit(_) =>
            term$22234
        case Fixpoint.Ast.Ram.RamTerm.RowLoad(rowVar$22241, index$22247) =>
            Fixpoint.Ast.Ram.RamTerm.RowLoad(
                Map.getWithDefault(rowVar$22241, rowVar$22241, rowVars$22228),
                index$22247
            )
        case Fixpoint.Ast.Ram.RamTerm.LoadLatVar(rowVar$22253) =>
            Fixpoint.Ast.Ram.RamTerm.LoadLatVar(
                Map.getWithDefault(rowVar$22253, rowVar$22253, rowVars$22228)
            )
        case Fixpoint.Ast.Ram.RamTerm.Meet(f$22262, v1$22264, v2$22266) =>
            let t1$22268: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v1$22264
            );
            let t2$22270: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v2$22266
            );
            Fixpoint.Ast.Ram.RamTerm.Meet(f$22262, t1$22268, t2$22270)
        case Fixpoint.Ast.Ram.RamTerm.App0(_) =>
            term$22234
        case Fixpoint.Ast.Ram.RamTerm.App1(f$22284, v$22286) =>
            let t$22288: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v$22286
            );
            Fixpoint.Ast.Ram.RamTerm.App1(f$22284, t$22288)
        case Fixpoint.Ast.Ram.RamTerm.App2(f$22290, v1$22292, v2$22294) =>
            let t1$22296: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v1$22292
            );
            let t2$22298: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v2$22294
            );
            Fixpoint.Ast.Ram.RamTerm.App2(f$22290, t1$22296, t2$22298)
        case Fixpoint.Ast.Ram.RamTerm.App3(
            f$22306,
            v1$22311,
            v2$22313,
            v3$22316
        ) =>
            let t1$22319: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v1$22311
            );
            let t2$22321: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v2$22313
            );
            let t3$22323: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v3$22316
            );
            Fixpoint.Ast.Ram.RamTerm.App3(f$22306, t1$22319, t2$22321, t3$22323)
        case Fixpoint.Ast.Ram.RamTerm.App4(
            f$22325,
            v1$22327,
            v2$22330,
            v3$22334,
            v4$22336
        ) =>
            let t1$22340: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v1$22327
            );
            let t2$22343: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v2$22330
            );
            let t3$22347: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v3$22334
            );
            let t4$22351: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v4$22336
            );
            Fixpoint.Ast.Ram.RamTerm.App4(
                f$22325,
                t1$22340,
                t2$22343,
                t3$22347,
                t4$22351
            )
        case Fixpoint.Ast.Ram.RamTerm.App5(
            f$22356,
            v1$22358,
            v2$22361,
            v3$22364,
            v4$22366,
            v5$22368
        ) =>
            let t1$22370: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v1$22358
            );
            let t2$22372: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v2$22361
            );
            let t3$22374: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v3$22364
            );
            let t4$22376: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v4$22366
            );
            let t5$22378: RamTerm[v] = Fixpoint.Phase.VarsToIndices.lowerTerm(
                rowVars$22228,
                v5$22368
            );
            Fixpoint.Ast.Ram.RamTerm.App5(
                f$22356,
                t1$22370,
                t2$22372,
                t3$22374,
                t4$22376,
                t5$22378
            )
    }
}

def Fixpoint.Solver.facts0(
    p$33650: PredSym,
    d$33652: Datalog[Boxed]
): Vector[v] = {
    Fixpoint.Solver.factsOf(_$33660 -> <[unknown exp]>, p$33650, d$33652)
}

def Fixpoint.Solver.facts1(
    p$33674: PredSym,
    d$33677: Datalog[Boxed]
): Vector[v] = {
    let f$33688: (List[Boxed] -> v) = terms$33690 ->
        match terms$33690 {
            case List.Cons(hd$33692, _) =>
                Boxable.unbox(hd$33692)
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$33688, p$33674, d$33677)
}

def Fixpoint.Solver.facts10(
    p$34743: PredSym,
    d$34745: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)] = {
    let f$34784: (
        List[Boxed] -> (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)
    ) = terms$34786 ->
        match terms$34786 {
            case List.Cons(
                v0$34792,
                List.Cons(
                    v1$34796,
                    List.Cons(
                        v2$34798,
                        List.Cons(
                            v3$34800,
                            List.Cons(
                                v4$34802,
                                List.Cons(
                                    v5$34804,
                                    List.Cons(
                                        v6$34806,
                                        List.Cons(
                                            v7$34808,
                                            List.Cons(
                                                v8$34810,
                                                List.Cons(v9$34812, _)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$34792),
                    Boxable.unbox(v1$34796),
                    Boxable.unbox(v2$34798),
                    Boxable.unbox(v3$34800),
                    Boxable.unbox(v4$34802),
                    Boxable.unbox(v5$34804),
                    Boxable.unbox(v6$34806),
                    Boxable.unbox(v7$34808),
                    Boxable.unbox(v8$34810),
                    Boxable.unbox(v9$34812)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$34784, p$34743, d$34745)
}

def Fixpoint.Solver.facts11(
    p$35505: PredSym,
    d$35509: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11)] = {
    let f$35559: (
        List[Boxed] -> (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11)
    ) = terms$35561 ->
        match terms$35561 {
            case List.Cons(
                v0$35607,
                List.Cons(
                    v1$35609,
                    List.Cons(
                        v2$35611,
                        List.Cons(
                            v3$35613,
                            List.Cons(
                                v4$35615,
                                List.Cons(
                                    v5$35618,
                                    List.Cons(
                                        v6$35623,
                                        List.Cons(
                                            v7$35625,
                                            List.Cons(
                                                v8$35628,
                                                List.Cons(
                                                    v9$35631,
                                                    List.Cons(v10$35633, _)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$35607),
                    Boxable.unbox(v1$35609),
                    Boxable.unbox(v2$35611),
                    Boxable.unbox(v3$35613),
                    Boxable.unbox(v4$35615),
                    Boxable.unbox(v5$35618),
                    Boxable.unbox(v6$35623),
                    Boxable.unbox(v7$35625),
                    Boxable.unbox(v8$35628),
                    Boxable.unbox(v9$35631),
                    Boxable.unbox(v10$35633)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$35559, p$35505, d$35509)
}

def Fixpoint.Solver.facts12(
    p$35756: PredSym,
    d$35762: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)] = {
    let f$35787: (
        List[Boxed] -> (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)
    ) = terms$35793 ->
        match terms$35793 {
            case List.Cons(
                v0$35795,
                List.Cons(
                    v1$35797,
                    List.Cons(
                        v2$35799,
                        List.Cons(
                            v3$35801,
                            List.Cons(
                                v4$35803,
                                List.Cons(
                                    v5$35805,
                                    List.Cons(
                                        v6$35807,
                                        List.Cons(
                                            v7$35809,
                                            List.Cons(
                                                v8$35811,
                                                List.Cons(
                                                    v9$35813,
                                                    List.Cons(
                                                        v10$35815,
                                                        List.Cons(v11$35817, _)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$35795),
                    Boxable.unbox(v1$35797),
                    Boxable.unbox(v2$35799),
                    Boxable.unbox(v3$35801),
                    Boxable.unbox(v4$35803),
                    Boxable.unbox(v5$35805),
                    Boxable.unbox(v6$35807),
                    Boxable.unbox(v7$35809),
                    Boxable.unbox(v8$35811),
                    Boxable.unbox(v9$35813),
                    Boxable.unbox(v10$35815),
                    Boxable.unbox(v11$35817)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$35787, p$35756, d$35762)
}

def Fixpoint.Solver.facts13(
    p$35929: PredSym,
    d$35934: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)] = {
    let f$35966: (
        List[Boxed] -> (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)
    ) = terms$35968 ->
        match terms$35968 {
            case List.Cons(
                v0$35970,
                List.Cons(
                    v1$35973,
                    List.Cons(
                        v2$35977,
                        List.Cons(
                            v3$35979,
                            List.Cons(
                                v4$35983,
                                List.Cons(
                                    v5$35987,
                                    List.Cons(
                                        v6$35991,
                                        List.Cons(
                                            v7$35993,
                                            List.Cons(
                                                v8$35996,
                                                List.Cons(
                                                    v9$35999,
                                                    List.Cons(
                                                        v10$36001,
                                                        List.Cons(
                                                            v11$36003,
                                                            List.Cons(
                                                                v12$36007,
                                                                _
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$35970),
                    Boxable.unbox(v1$35973),
                    Boxable.unbox(v2$35977),
                    Boxable.unbox(v3$35979),
                    Boxable.unbox(v4$35983),
                    Boxable.unbox(v5$35987),
                    Boxable.unbox(v6$35991),
                    Boxable.unbox(v7$35993),
                    Boxable.unbox(v8$35996),
                    Boxable.unbox(v9$35999),
                    Boxable.unbox(v10$36001),
                    Boxable.unbox(v11$36003),
                    Boxable.unbox(v12$36007)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$35966, p$35929, d$35934)
}

def Fixpoint.Solver.facts14(
    p$36094: PredSym,
    d$36096: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14)] = {
    let f$36138: (
        List[Boxed] ->
            (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14)
    ) = terms$36140 ->
        match terms$36140 {
            case List.Cons(
                v0$36142,
                List.Cons(
                    v1$36144,
                    List.Cons(
                        v2$36146,
                        List.Cons(
                            v3$36148,
                            List.Cons(
                                v4$36150,
                                List.Cons(
                                    v5$36152,
                                    List.Cons(
                                        v6$36154,
                                        List.Cons(
                                            v7$36156,
                                            List.Cons(
                                                v8$36158,
                                                List.Cons(
                                                    v9$36160,
                                                    List.Cons(
                                                        v10$36162,
                                                        List.Cons(
                                                            v11$36164,
                                                            List.Cons(
                                                                v12$36166,
                                                                List.Cons(
                                                                    v13$36170,
                                                                    _
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$36142),
                    Boxable.unbox(v1$36144),
                    Boxable.unbox(v2$36146),
                    Boxable.unbox(v3$36148),
                    Boxable.unbox(v4$36150),
                    Boxable.unbox(v5$36152),
                    Boxable.unbox(v6$36154),
                    Boxable.unbox(v7$36156),
                    Boxable.unbox(v8$36158),
                    Boxable.unbox(v9$36160),
                    Boxable.unbox(v10$36162),
                    Boxable.unbox(v11$36164),
                    Boxable.unbox(v12$36166),
                    Boxable.unbox(v13$36170)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$36138, p$36094, d$36096)
}

def Fixpoint.Solver.facts15(
    p$36244: PredSym,
    d$36246: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15)] =
{
    let f$36560: (
        List[Boxed] ->
            (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15)
    ) = terms$36562 ->
        match terms$36562 {
            case List.Cons(
                v0$36566,
                List.Cons(
                    v1$36568,
                    List.Cons(
                        v2$36570,
                        List.Cons(
                            v3$36572,
                            List.Cons(
                                v4$36574,
                                List.Cons(
                                    v5$36576,
                                    List.Cons(
                                        v6$36578,
                                        List.Cons(
                                            v7$36580,
                                            List.Cons(
                                                v8$36583,
                                                List.Cons(
                                                    v9$36587,
                                                    List.Cons(
                                                        v10$36589,
                                                        List.Cons(
                                                            v11$36591,
                                                            List.Cons(
                                                                v12$36593,
                                                                List.Cons(
                                                                    v13$36600,
                                                                    List.Cons(
                                                                        v14$36603,
                                                                        _
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$36566),
                    Boxable.unbox(v1$36568),
                    Boxable.unbox(v2$36570),
                    Boxable.unbox(v3$36572),
                    Boxable.unbox(v4$36574),
                    Boxable.unbox(v5$36576),
                    Boxable.unbox(v6$36578),
                    Boxable.unbox(v7$36580),
                    Boxable.unbox(v8$36583),
                    Boxable.unbox(v9$36587),
                    Boxable.unbox(v10$36589),
                    Boxable.unbox(v11$36591),
                    Boxable.unbox(v12$36593),
                    Boxable.unbox(v13$36600),
                    Boxable.unbox(v14$36603)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$36560, p$36244, d$36246)
}

def Fixpoint.Solver.facts2(
    p$33735: PredSym,
    d$33738: Datalog[Boxed]
): Vector[(t1, t2)] = {
    let f$33743: (List[Boxed] -> (t1, t2)) = terms$33745 ->
        match terms$33745 {
            case List.Cons(v0$33747, List.Cons(v1$33749, _)) =>
                (Boxable.unbox(v0$33747), Boxable.unbox(v1$33749))
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$33743, p$33735, d$33738)
}

def Fixpoint.Solver.facts3(
    p$33793: PredSym,
    d$33796: Datalog[Boxed]
): Vector[(t1, t2, t3)] = {
    let f$33804: (List[Boxed] -> (t1, t2, t3)) = terms$33806 ->
        match terms$33806 {
            case List.Cons(
                v0$33808,
                List.Cons(v1$33862, List.Cons(v2$33864, _))
            ) =>
                (
                    Boxable.unbox(v0$33808),
                    Boxable.unbox(v1$33862),
                    Boxable.unbox(v2$33864)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$33804, p$33793, d$33796)
}

def Fixpoint.Solver.facts4(
    p$33903: PredSym,
    d$33905: Datalog[Boxed]
): Vector[(t1, t2, t3, t4)] = {
    let f$34119: (List[Boxed] -> (t1, t2, t3, t4)) = terms$34121 ->
        match terms$34121 {
            case List.Cons(
                v0$34127,
                List.Cons(v1$34135, List.Cons(v2$34140, List.Cons(v3$34143, _)))
            ) =>
                (
                    Boxable.unbox(v0$34127),
                    Boxable.unbox(v1$34135),
                    Boxable.unbox(v2$34140),
                    Boxable.unbox(v3$34143)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$34119, p$33903, d$33905)
}

def Fixpoint.Solver.facts5(
    p$34194: PredSym,
    d$34196: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5)] = {
    let f$34208: (List[Boxed] -> (t1, t2, t3, t4, t5)) = terms$34210 ->
        match terms$34210 {
            case List.Cons(
                v0$34214,
                List.Cons(
                    v1$34216,
                    List.Cons(
                        v2$34218,
                        List.Cons(v3$34220, List.Cons(v4$34222, _))
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$34214),
                    Boxable.unbox(v1$34216),
                    Boxable.unbox(v2$34218),
                    Boxable.unbox(v3$34220),
                    Boxable.unbox(v4$34222)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$34208, p$34194, d$34196)
}

def Fixpoint.Solver.facts6(
    p$34243: PredSym,
    d$34246: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6)] = {
    let f$34258: (List[Boxed] -> (t1, t2, t3, t4, t5, t6)) = terms$34260 ->
        match terms$34260 {
            case List.Cons(
                v0$34262,
                List.Cons(
                    v1$34264,
                    List.Cons(
                        v2$34266,
                        List.Cons(
                            v3$34268,
                            List.Cons(v4$34274, List.Cons(v5$34277, _))
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$34262),
                    Boxable.unbox(v1$34264),
                    Boxable.unbox(v2$34266),
                    Boxable.unbox(v3$34268),
                    Boxable.unbox(v4$34274),
                    Boxable.unbox(v5$34277)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$34258, p$34243, d$34246)
}

def Fixpoint.Solver.facts7(
    p$34325: PredSym,
    d$34327: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6, t7)] = {
    let f$34357: (List[Boxed] -> (t1, t2, t3, t4, t5, t6, t7)) = terms$34359 ->
        match terms$34359 {
            case List.Cons(
                v0$34366,
                List.Cons(
                    v1$34370,
                    List.Cons(
                        v2$34374,
                        List.Cons(
                            v3$34385,
                            List.Cons(
                                v4$34387,
                                List.Cons(v5$34389, List.Cons(v6$34391, _))
                            )
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$34366),
                    Boxable.unbox(v1$34370),
                    Boxable.unbox(v2$34374),
                    Boxable.unbox(v3$34385),
                    Boxable.unbox(v4$34387),
                    Boxable.unbox(v5$34389),
                    Boxable.unbox(v6$34391)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$34357, p$34325, d$34327)
}

def Fixpoint.Solver.facts8(
    p$34456: PredSym,
    d$34462: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6, t7, t8)] = {
    let f$34494: (
        List[Boxed] -> (t1, t2, t3, t4, t5, t6, t7, t8)
    ) = terms$34496 ->
        match terms$34496 {
            case List.Cons(
                v0$34500,
                List.Cons(
                    v1$34502,
                    List.Cons(
                        v2$34504,
                        List.Cons(
                            v3$34506,
                            List.Cons(
                                v4$34508,
                                List.Cons(
                                    v5$34510,
                                    List.Cons(v6$34512, List.Cons(v7$34514, _))
                                )
                            )
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$34500),
                    Boxable.unbox(v1$34502),
                    Boxable.unbox(v2$34504),
                    Boxable.unbox(v3$34506),
                    Boxable.unbox(v4$34508),
                    Boxable.unbox(v5$34510),
                    Boxable.unbox(v6$34512),
                    Boxable.unbox(v7$34514)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$34494, p$34456, d$34462)
}

def Fixpoint.Solver.facts9(
    p$34585: PredSym,
    d$34592: Datalog[Boxed]
): Vector[(t1, t2, t3, t4, t5, t6, t7, t8, t9)] = {
    let f$34631: (
        List[Boxed] -> (t1, t2, t3, t4, t5, t6, t7, t8, t9)
    ) = terms$34634 ->
        match terms$34634 {
            case List.Cons(
                v0$34643,
                List.Cons(
                    v1$34645,
                    List.Cons(
                        v2$34647,
                        List.Cons(
                            v3$34649,
                            List.Cons(
                                v4$34654,
                                List.Cons(
                                    v5$34657,
                                    List.Cons(
                                        v6$34662,
                                        List.Cons(
                                            v7$34665,
                                            List.Cons(v8$34667, _)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) =>
                (
                    Boxable.unbox(v0$34643),
                    Boxable.unbox(v1$34645),
                    Boxable.unbox(v2$34647),
                    Boxable.unbox(v3$34649),
                    Boxable.unbox(v4$34654),
                    Boxable.unbox(v5$34657),
                    Boxable.unbox(v6$34662),
                    Boxable.unbox(v7$34665),
                    Boxable.unbox(v8$34667)
                )
            case _ =>
                unreachable!(())
        };
    Fixpoint.Solver.factsOf(f$34631, p$34585, d$34592)
}

def Fixpoint.Solver.factsOf(
    f$36685: List[v] -> t,
    p$36746: PredSym,
    d$36750: Datalog[v]
): Vector[t] \ ef = {
    match d$36750 {
        case Fixpoint.Ast.Datalog.Datalog.Datalog(_, cs$36762) =>
            region rc$36764 {
                let pFacts$36767: MutList[t, rc] = MutList.empty(rc$36764);
                Vector.forEach(
                    c$36769 ->
                        match c$36769 {
                            case Fixpoint.Ast.Datalog.Constraint.Constraint(
                                Fixpoint.Ast.Datalog.HeadPredicate.HeadAtom(
                                    headPred$36775,
                                    _,
                                    terms$36777
                                ),
                                body$36779
                            ) =>
                                if (
                                    <[unknown exp]>(
                                        headPred$36775,
                                        p$36746
                                    ) and Vector.isEmpty(body$36779)
                                ) {
                                    let vs$36781: Vector[v] = Vector.map(
                                        $0$46676 ->
                                            Fixpoint.Solver.headTermValue(
                                                $0$46676
                                            ),
                                        terms$36777
                                    );
                                    MutList.push!(
                                        f$36685(Vector.toList(vs$36781)),
                                        pFacts$36767
                                    )
                                } else {
                                    ()
                                }
                            case _ =>
                                ()
                        },
                    cs$36762
                );
                |>(pFacts$36767, $0$46684 -> MutList.toVector($0$46684))
            }
        case Fixpoint.Ast.Datalog.Datalog.Model(db$36796) =>
            region rc$36800 {<[unknown exp]>}
        case Fixpoint.Ast.Datalog.Datalog.Join(d1$36906, d2$36908) =>
            Vector.append(
                Fixpoint.Solver.factsOf(f$36685, p$36746, d1$36906),
                Fixpoint.Solver.factsOf(f$36685, p$36746, d2$36908)
            )
    }
}

def Fixpoint.Solver.headTermValue(t$36954: HeadTerm[v]): v = {
    match t$36954 {
        case Fixpoint.Ast.Datalog.HeadTerm.Lit(v$36976) =>
            v$36976
        case _ =>
            bug!("""Unexpected non-value term.""")
    }
}

def Fixpoint.Solver.injectInto1(
    p$31876: PredSym,
    ts$31878: f[t1]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$104$31882 ->
            match pat$104$31882 {
                case v1$31889 =>
                    List.Cons(Boxable.box(v1$31889), List.Nil)
            },
        p$31876,
        ts$31878
    )
}

def Fixpoint.Solver.injectInto10(
    p$33038: PredSym,
    ts$33040: f[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$113$33049 ->
            match pat$113$33049 {
                case (
                    v1$33056,
                    v2$33059,
                    v3$33062,
                    v4$33064,
                    v5$33066,
                    v6$33068,
                    v7$33070,
                    v8$33072,
                    v9$33074,
                    v10$33076
                ) =>
                    List.Cons(
                        Boxable.box(v1$33056),
                        List.Cons(
                            Boxable.box(v2$33059),
                            List.Cons(
                                Boxable.box(v3$33062),
                                List.Cons(
                                    Boxable.box(v4$33064),
                                    List.Cons(
                                        Boxable.box(v5$33066),
                                        List.Cons(
                                            Boxable.box(v6$33068),
                                            List.Cons(
                                                Boxable.box(v7$33070),
                                                List.Cons(
                                                    Boxable.box(v8$33072),
                                                    List.Cons(
                                                        Boxable.box(v9$33074),
                                                        List.Cons(
                                                            Boxable.box(
                                                                v10$33076
                                                            ),
                                                            List.Nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$33038,
        ts$33040
    )
}

def Fixpoint.Solver.injectInto11(
    p$33115: PredSym,
    ts$33119: f[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$114$33143 ->
            match pat$114$33143 {
                case (
                    v1$33145,
                    v2$33147,
                    v3$33149,
                    v4$33151,
                    v5$33153,
                    v6$33155,
                    v7$33157,
                    v8$33159,
                    v9$33161,
                    v10$33163,
                    v11$33165
                ) =>
                    List.Cons(
                        Boxable.box(v1$33145),
                        List.Cons(
                            Boxable.box(v2$33147),
                            List.Cons(
                                Boxable.box(v3$33149),
                                List.Cons(
                                    Boxable.box(v4$33151),
                                    List.Cons(
                                        Boxable.box(v5$33153),
                                        List.Cons(
                                            Boxable.box(v6$33155),
                                            List.Cons(
                                                Boxable.box(v7$33157),
                                                List.Cons(
                                                    Boxable.box(v8$33159),
                                                    List.Cons(
                                                        Boxable.box(v9$33161),
                                                        List.Cons(
                                                            Boxable.box(
                                                                v10$33163
                                                            ),
                                                            List.Cons(
                                                                Boxable.box(
                                                                    v11$33165
                                                                ),
                                                                List.Nil
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$33115,
        ts$33119
    )
}

def Fixpoint.Solver.injectInto12(
    p$33228: PredSym,
    ts$33230: f[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$115$33246 ->
            match pat$115$33246 {
                case (
                    v1$33255,
                    v2$33259,
                    v3$33261,
                    v4$33263,
                    v5$33265,
                    v6$33267,
                    v7$33269,
                    v8$33271,
                    v9$33273,
                    v10$33275,
                    v11$33277,
                    v12$33279
                ) =>
                    List.Cons(
                        Boxable.box(v1$33255),
                        List.Cons(
                            Boxable.box(v2$33259),
                            List.Cons(
                                Boxable.box(v3$33261),
                                List.Cons(
                                    Boxable.box(v4$33263),
                                    List.Cons(
                                        Boxable.box(v5$33265),
                                        List.Cons(
                                            Boxable.box(v6$33267),
                                            List.Cons(
                                                Boxable.box(v7$33269),
                                                List.Cons(
                                                    Boxable.box(v8$33271),
                                                    List.Cons(
                                                        Boxable.box(v9$33273),
                                                        List.Cons(
                                                            Boxable.box(
                                                                v10$33275
                                                            ),
                                                            List.Cons(
                                                                Boxable.box(
                                                                    v11$33277
                                                                ),
                                                                List.Cons(
                                                                    Boxable.box(
                                                                        v12$33279
                                                                    ),
                                                                    List.Nil
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$33228,
        ts$33230
    )
}

def Fixpoint.Solver.injectInto13(
    p$33337: PredSym,
    ts$33339: f[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$116$33347 ->
            match pat$116$33347 {
                case (
                    v1$33349,
                    v2$33351,
                    v3$33353,
                    v4$33355,
                    v5$33357,
                    v6$33359,
                    v7$33361,
                    v8$33363,
                    v9$33365,
                    v10$33367,
                    v11$33369,
                    v12$33371,
                    v13$33373
                ) =>
                    List.Cons(
                        Boxable.box(v1$33349),
                        List.Cons(
                            Boxable.box(v2$33351),
                            List.Cons(
                                Boxable.box(v3$33353),
                                List.Cons(
                                    Boxable.box(v4$33355),
                                    List.Cons(
                                        Boxable.box(v5$33357),
                                        List.Cons(
                                            Boxable.box(v6$33359),
                                            List.Cons(
                                                Boxable.box(v7$33361),
                                                List.Cons(
                                                    Boxable.box(v8$33363),
                                                    List.Cons(
                                                        Boxable.box(v9$33365),
                                                        List.Cons(
                                                            Boxable.box(
                                                                v10$33367
                                                            ),
                                                            List.Cons(
                                                                Boxable.box(
                                                                    v11$33369
                                                                ),
                                                                List.Cons(
                                                                    Boxable.box(
                                                                        v12$33371
                                                                    ),
                                                                    List.Cons(
                                                                        Boxable.box(
                                                                            v13$33373
                                                                        ),
                                                                        List.Nil
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$33337,
        ts$33339
    )
}

def Fixpoint.Solver.injectInto14(
    p$33433: PredSym,
    ts$33439: f[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$117$33445 ->
            match pat$117$33445 {
                case (
                    v1$33449,
                    v2$33451,
                    v3$33454,
                    v4$33457,
                    v5$33461,
                    v6$33463,
                    v7$33465,
                    v8$33467,
                    v9$33471,
                    v10$33473,
                    v11$33475,
                    v12$33477,
                    v13$33479,
                    v14$33481
                ) =>
                    List.Cons(
                        Boxable.box(v1$33449),
                        List.Cons(
                            Boxable.box(v2$33451),
                            List.Cons(
                                Boxable.box(v3$33454),
                                List.Cons(
                                    Boxable.box(v4$33457),
                                    List.Cons(
                                        Boxable.box(v5$33461),
                                        List.Cons(
                                            Boxable.box(v6$33463),
                                            List.Cons(
                                                Boxable.box(v7$33465),
                                                List.Cons(
                                                    Boxable.box(v8$33467),
                                                    List.Cons(
                                                        Boxable.box(v9$33471),
                                                        List.Cons(
                                                            Boxable.box(
                                                                v10$33473
                                                            ),
                                                            List.Cons(
                                                                Boxable.box(
                                                                    v11$33475
                                                                ),
                                                                List.Cons(
                                                                    Boxable.box(
                                                                        v12$33477
                                                                    ),
                                                                    List.Cons(
                                                                        Boxable.box(
                                                                            v13$33479
                                                                        ),
                                                                        List.Cons(
                                                                            Boxable.box(
                                                                                v14$33481
                                                                            ),
                                                                            List.Nil
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$33433,
        ts$33439
    )
}

def Fixpoint.Solver.injectInto15(
    p$33517: PredSym,
    ts$33521: f[(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$118$33532 ->
            match pat$118$33532 {
                case (
                    v1$33534,
                    v2$33536,
                    v3$33538,
                    v4$33540,
                    v5$33542,
                    v6$33544,
                    v7$33546,
                    v8$33549,
                    v9$33551,
                    v10$33553,
                    v11$33555,
                    v12$33557,
                    v13$33559,
                    v14$33561,
                    v15$33563
                ) =>
                    List.Cons(
                        Boxable.box(v1$33534),
                        List.Cons(
                            Boxable.box(v2$33536),
                            List.Cons(
                                Boxable.box(v3$33538),
                                List.Cons(
                                    Boxable.box(v4$33540),
                                    List.Cons(
                                        Boxable.box(v5$33542),
                                        List.Cons(
                                            Boxable.box(v6$33544),
                                            List.Cons(
                                                Boxable.box(v7$33546),
                                                List.Cons(
                                                    Boxable.box(v8$33549),
                                                    List.Cons(
                                                        Boxable.box(v9$33551),
                                                        List.Cons(
                                                            Boxable.box(
                                                                v10$33553
                                                            ),
                                                            List.Cons(
                                                                Boxable.box(
                                                                    v11$33555
                                                                ),
                                                                List.Cons(
                                                                    Boxable.box(
                                                                        v12$33557
                                                                    ),
                                                                    List.Cons(
                                                                        Boxable.box(
                                                                            v13$33559
                                                                        ),
                                                                        List.Cons(
                                                                            Boxable.box(
                                                                                v14$33561
                                                                            ),
                                                                            List.Cons(
                                                                                Boxable.box(
                                                                                    v15$33563
                                                                                ),
                                                                                List.Nil
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$33517,
        ts$33521
    )
}

def Fixpoint.Solver.injectInto2(
    p$31912: PredSym,
    ts$31914: f[(t1, t2)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$105$32379 ->
            match pat$105$32379 {
                case (v1$32383, v2$32385) =>
                    List.Cons(
                        Boxable.box(v1$32383),
                        List.Cons(Boxable.box(v2$32385), List.Nil)
                    )
            },
        p$31912,
        ts$31914
    )
}

def Fixpoint.Solver.injectInto3(
    p$32415: PredSym,
    ts$32417: f[(t1, t2, t3)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$106$32424 ->
            match pat$106$32424 {
                case (v1$32426, v2$32428, v3$32430) =>
                    List.Cons(
                        Boxable.box(v1$32426),
                        List.Cons(
                            Boxable.box(v2$32428),
                            List.Cons(Boxable.box(v3$32430), List.Nil)
                        )
                    )
            },
        p$32415,
        ts$32417
    )
}

def Fixpoint.Solver.injectInto4(
    p$32501: PredSym,
    ts$32504: f[(t1, t2, t3, t4)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$107$32665 ->
            match pat$107$32665 {
                case (v1$32667, v2$32669, v3$32671, v4$32673) =>
                    List.Cons(
                        Boxable.box(v1$32667),
                        List.Cons(
                            Boxable.box(v2$32669),
                            List.Cons(
                                Boxable.box(v3$32671),
                                List.Cons(Boxable.box(v4$32673), List.Nil)
                            )
                        )
                    )
            },
        p$32501,
        ts$32504
    )
}

def Fixpoint.Solver.injectInto5(
    p$32698: PredSym,
    ts$32700: f[(t1, t2, t3, t4, t5)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$108$32712 ->
            match pat$108$32712 {
                case (v1$32714, v2$32716, v3$32718, v4$32720, v5$32722) =>
                    List.Cons(
                        Boxable.box(v1$32714),
                        List.Cons(
                            Boxable.box(v2$32716),
                            List.Cons(
                                Boxable.box(v3$32718),
                                List.Cons(
                                    Boxable.box(v4$32720),
                                    List.Cons(Boxable.box(v5$32722), List.Nil)
                                )
                            )
                        )
                    )
            },
        p$32698,
        ts$32700
    )
}

def Fixpoint.Solver.injectInto6(
    p$32747: PredSym,
    ts$32751: f[(t1, t2, t3, t4, t5, t6)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$109$32774 ->
            match pat$109$32774 {
                case (
                    v1$32776,
                    v2$32778,
                    v3$32780,
                    v4$32782,
                    v5$32784,
                    v6$32786
                ) =>
                    List.Cons(
                        Boxable.box(v1$32776),
                        List.Cons(
                            Boxable.box(v2$32778),
                            List.Cons(
                                Boxable.box(v3$32780),
                                List.Cons(
                                    Boxable.box(v4$32782),
                                    List.Cons(
                                        Boxable.box(v5$32784),
                                        List.Cons(
                                            Boxable.box(v6$32786),
                                            List.Nil
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$32747,
        ts$32751
    )
}

def Fixpoint.Solver.injectInto7(
    p$32822: PredSym,
    ts$32824: f[(t1, t2, t3, t4, t5, t6, t7)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$110$32826 ->
            match pat$110$32826 {
                case (
                    v1$32828,
                    v2$32832,
                    v3$32834,
                    v4$32836,
                    v5$32838,
                    v6$32840,
                    v7$32844
                ) =>
                    List.Cons(
                        Boxable.box(v1$32828),
                        List.Cons(
                            Boxable.box(v2$32832),
                            List.Cons(
                                Boxable.box(v3$32834),
                                List.Cons(
                                    Boxable.box(v4$32836),
                                    List.Cons(
                                        Boxable.box(v5$32838),
                                        List.Cons(
                                            Boxable.box(v6$32840),
                                            List.Cons(
                                                Boxable.box(v7$32844),
                                                List.Nil
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$32822,
        ts$32824
    )
}

def Fixpoint.Solver.injectInto8(
    p$32880: PredSym,
    ts$32884: f[(t1, t2, t3, t4, t5, t6, t7, t8)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$111$32897 ->
            match pat$111$32897 {
                case (
                    v1$32901,
                    v2$32903,
                    v3$32905,
                    v4$32907,
                    v5$32909,
                    v6$32911,
                    v7$32913,
                    v8$32915
                ) =>
                    List.Cons(
                        Boxable.box(v1$32901),
                        List.Cons(
                            Boxable.box(v2$32903),
                            List.Cons(
                                Boxable.box(v3$32905),
                                List.Cons(
                                    Boxable.box(v4$32907),
                                    List.Cons(
                                        Boxable.box(v5$32909),
                                        List.Cons(
                                            Boxable.box(v6$32911),
                                            List.Cons(
                                                Boxable.box(v7$32913),
                                                List.Cons(
                                                    Boxable.box(v8$32915),
                                                    List.Nil
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$32880,
        ts$32884
    )
}

def Fixpoint.Solver.injectInto9(
    p$32947: PredSym,
    ts$32949: f[(t1, t2, t3, t4, t5, t6, t7, t8, t9)]
): Datalog[Boxed] = {
    Fixpoint.Solver.injectIntoX(
        pat$112$32961 ->
            match pat$112$32961 {
                case (
                    v1$32967,
                    v2$32969,
                    v3$32971,
                    v4$32973,
                    v5$32975,
                    v6$32979,
                    v7$32981,
                    v8$32983,
                    v9$32987
                ) =>
                    List.Cons(
                        Boxable.box(v1$32967),
                        List.Cons(
                            Boxable.box(v2$32969),
                            List.Cons(
                                Boxable.box(v3$32971),
                                List.Cons(
                                    Boxable.box(v4$32973),
                                    List.Cons(
                                        Boxable.box(v5$32975),
                                        List.Cons(
                                            Boxable.box(v6$32979),
                                            List.Cons(
                                                Boxable.box(v7$32981),
                                                List.Cons(
                                                    Boxable.box(v8$32983),
                                                    List.Cons(
                                                        Boxable.box(v9$32987),
                                                        List.Nil
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            },
        p$32947,
        ts$32949
    )
}

def Fixpoint.Solver.injectIntoX(
    f$33591: t -> List[Boxed],
    p$33601: PredSym,
    ts$33603: f[t]
): Datalog[Boxed] \ ef = {
    region rc$33613 {
        let db$33618: Database[Boxed, rc] = MutMap.empty(rc$33613);
        <[unknown exp]>(
            _unit$33620 ->
                t$33622 ->
                    {
                        let vs$33624: List[Boxed] = f$33591(t$33622);
                        let arity$33626: Int32 = List.length(vs$33624);
                        let ramSym$33628: RamSym[Boxed] = Fixpoint.Ast.Ram.RamSym.Full(
                            p$33601,
                            arity$33626,
                            Fixpoint.Ast.Shared.Denotation.Relational
                        );
                        let rel$33630: MutMap[Vector[Boxed], Boxed, rc] = MutMap.getOrElsePut!(
                            ramSym$33628,
                            MutMap.empty(rc$33613),
                            db$33618
                        );
                        MutMap.put!(
                            List.toVector(vs$33624),
                            Reflect.default(()),
                            rel$33630
                        )
                    },
            (),
            ts$33603
        );
        Fixpoint.Solver.toModel(db$33618)
    }
}

def Fixpoint.Solver.projectSym(
    p$31744: PredSym,
    d$31751: Datalog[v]
): Datalog[v] = {
    match d$31751 {
        case Fixpoint.Ast.Datalog.Datalog.Datalog(facts$31759, _) =>
            let pFacts$31761: Vector[Constraint[v]] = Vector.filter(
                pat$103$31763 ->
                    match pat$103$31763 {
                        case Fixpoint.Ast.Datalog.Constraint.Constraint(
                            Fixpoint.Ast.Datalog.HeadPredicate.HeadAtom(
                                head$31765,
                                _,
                                _
                            ),
                            _
                        ) =>
                            <[unknown exp]>(head$31765, p$31744)
                    },
                facts$31759
            );
            Fixpoint.Ast.Datalog.Datalog.Datalog(pFacts$31761, Vector.empty(()))
        case Fixpoint.Ast.Datalog.Datalog.Model(db$31780) =>
            |>(
                |>(
                    Map.rangeQuery(
                        ramSym$31782 ->
                            match ramSym$31782 {
                                case Fixpoint.Ast.Ram.RamSym.Full(
                                    predSym$31784,
                                    _,
                                    _
                                ) =>
                                    match <[unknown exp]>(
                                        predSym$31784,
                                        p$31744
                                    ) {
                                        case Comparison.EqualTo =>
                                            Comparison.EqualTo
                                        case cmp$31790 =>
                                            cmp$31790
                                    }
                                case _ =>
                                    Comparison.LessThan
                            },
                        db$31780
                    ),
                    $0$46570 ->
                        List.toMap($0$46570)
                ),
                x$$46572 ->
                    Fixpoint.Ast.Datalog.Datalog.Model(x$$46572)
            )
        case Fixpoint.Ast.Datalog.Datalog.Join(d1$31792, d2$31794) =>
            Fixpoint.Solver.union(
                Fixpoint.Solver.projectSym(p$31744, d1$31792),
                Fixpoint.Solver.projectSym(p$31744, d2$31794)
            )
    }
}

def Fixpoint.Solver.rename(
    preds$31822: List[PredSym],
    d$31824: Datalog[v]
): Datalog[v] = {
    <[unknown exp]>
}

def Fixpoint.Solver.run(d$31562: Datalog[v]): Datalog[v] = {
    |>(
        Fixpoint.Phase.Stratifier.stratify(d$31562),
        (
            $0$46520 ->
                $1$46522 ->
                    Fixpoint.Solver.runWithStratification($0$46520, $1$46522)
        )(d$31562)
    )
}

def Fixpoint.Solver.runWithStratification(
    d$31581: Datalog[v],
    stf$31583: Map[PredSym, Int32]
): Datalog[v] = {
    <[unknown exp]>;
    let compiler$31596: (Datalog[v] -> RamStmt[v]) = cs$31598 ->
        |>(
            |>(
                |>(
                    Fixpoint.Phase.Compiler.compile(cs$31598, stf$31583),
                    $0$46526 ->
                        Fixpoint.Phase.Simplifier.simplifyStmt($0$46526)
                ),
                $0$46528 ->
                    Fixpoint.Phase.IndexSelection.queryStmt($0$46528)
            ),
            $0$46530 ->
                Fixpoint.Phase.VarsToIndices.lowerStmt($0$46530)
        );
    let model$31600: Datalog[v] = match d$31581 {
        case Fixpoint.Ast.Datalog.Datalog.Datalog(_) =>
            region rc$31602 {
                |>(
                    |>(
                        compiler$31596(d$31581),
                        (
                            $0$46534 ->
                                $1$46536 ->
                                    Fixpoint.Interpreter.interpret(
                                        $0$46534,
                                        $1$46536
                                    )
                        )(rc$31602)
                    ),
                    $0$46538 ->
                        Fixpoint.Solver.toModel($0$46538)
                )
            }
        case Fixpoint.Ast.Datalog.Datalog.Model(_) =>
            d$31581
        case Fixpoint.Ast.Datalog.Datalog.Join(
            Fixpoint.Ast.Datalog.Datalog.Model(m$31611),
            cs$31613
        ) =>
            region rc$31615 {
                let db$31618: MutMap[RamSym[v], MutMap[Vector[v], v, rc], rc] = |>(
                    Map.map(
                        (
                            $0$46540 ->
                                $1$46542 ->
                                    Map.toMutMap($0$46540, $1$46542)
                        )(rc$31615),
                        m$31611
                    ),
                    (
                        $0$46544 ->
                            $1$46546 ->
                                Map.toMutMap($0$46544, $1$46546)
                    )(rc$31615)
                );
                |>(
                    |>(
                        compiler$31596(cs$31613),
                        (
                            $0$46548 ->
                                $1$46550 ->
                                    $2$46552 ->
                                        Fixpoint.Interpreter.interpretWithDatabase(
                                            $0$46548,
                                            $1$46550,
                                            $2$46552
                                        )
                        )(rc$31615)(db$31618)
                    ),
                    $0$46554 ->
                        Fixpoint.Solver.toModel($0$46554)
                )
            }
        case _ =>
            bug!("""Datalog normalization bug""")
    };
    <[unknown exp]>;
    model$31600
}

def Fixpoint.Solver.toModel(db$37004: Database[v, r]): Datalog[v] \ r = {
    |>(
        |>(
            MutMap.toMap(db$37004),
            (
                $0$46703 ->
                    $1$46705 ->
                        Map.map($0$46703, $1$46705)
            )($0$46707 -> MutMap.toMap($0$46707))
        ),
        x$$46709 ->
            Fixpoint.Ast.Datalog.Datalog.Model(x$$46709)
    )
}

def Fixpoint.Solver.union(
    d1$31640: Datalog[v],
    d2$31647: Datalog[v]
): Datalog[v] = {
    match (d1$31640, d2$31647) {
        case (
            Fixpoint.Ast.Datalog.Datalog.Datalog(edb1$31671, idb1$31673),
            Fixpoint.Ast.Datalog.Datalog.Datalog(edb2$31675, idb2$31677)
        ) =>
            Fixpoint.Ast.Datalog.Datalog.Datalog(
                Vector.append(edb1$31671, edb2$31675),
                Vector.append(idb1$31673, idb2$31677)
            )
        case (
            Fixpoint.Ast.Datalog.Datalog.Model(db1$31688),
            Fixpoint.Ast.Datalog.Datalog.Model(db2$31690)
        ) =>
            <[unknown exp]>
        case (
            Fixpoint.Ast.Datalog.Datalog.Model(_),
            Fixpoint.Ast.Datalog.Datalog.Datalog(_, _)
        ) =>
            Fixpoint.Ast.Datalog.Datalog.Join(d1$31640, d2$31647)
        case (
            Fixpoint.Ast.Datalog.Datalog.Datalog(_, _),
            Fixpoint.Ast.Datalog.Datalog.Model(_)
        ) =>
            Fixpoint.Ast.Datalog.Datalog.Join(d2$31647, d1$31640)
        case (
            Fixpoint.Ast.Datalog.Datalog.Join(model$31698, datalog$31700),
            Fixpoint.Ast.Datalog.Datalog.Datalog(_, _)
        ) =>
            Fixpoint.Ast.Datalog.Datalog.Join(
                model$31698,
                Fixpoint.Solver.union(datalog$31700, d2$31647)
            )
        case (
            Fixpoint.Ast.Datalog.Datalog.Datalog(_, _),
            Fixpoint.Ast.Datalog.Datalog.Join(model$31704, datalog$31708)
        ) =>
            Fixpoint.Ast.Datalog.Datalog.Join(
                model$31704,
                Fixpoint.Solver.union(datalog$31708, d1$31640)
            )
        case (
            Fixpoint.Ast.Datalog.Datalog.Join(model$31720, datalog$31723),
            Fixpoint.Ast.Datalog.Datalog.Model(_)
        ) =>
            Fixpoint.Ast.Datalog.Datalog.Join(
                Fixpoint.Solver.union(model$31720, d2$31647),
                datalog$31723
            )
        case (
            Fixpoint.Ast.Datalog.Datalog.Model(_),
            Fixpoint.Ast.Datalog.Datalog.Join(model$31726, datalog$31728)
        ) =>
            Fixpoint.Ast.Datalog.Datalog.Join(
                Fixpoint.Solver.union(model$31726, d1$31640),
                datalog$31728
            )
        case (
            Fixpoint.Ast.Datalog.Datalog.Join(x$31730, y$31732),
            Fixpoint.Ast.Datalog.Datalog.Join(z$31734, w$31736)
        ) =>
            Fixpoint.Ast.Datalog.Datalog.Join(
                Fixpoint.Solver.union(x$31730, z$31734),
                Fixpoint.Solver.union(y$31732, w$31736)
            )
    }
}

def Float32.abs(x$21214: Float32): Float32 = {
    let abs$21220: (Float32 -> Float32) = a0$$21224 ->
        <[unknown exp]>;
    abs$21220(x$21214)
}

def Float32.ceil(x$21230: Float32): Float32 = {
    let valueOfF32$21239: (Float32 -> java.lang.Float) = a0$$21243 ->
        <[unknown exp]>;
    let valueOfF64$21246: (Float64 -> java.lang.Double) = a0$$21248 ->
        <[unknown exp]>;
    let ceil$21250: (Float64 -> Float64) = a0$$21252 ->
        <[unknown exp]>;
    let floatValue$21254: (java.lang.Double -> Float32) = obj$$21256 ->
        <[unknown exp]>;
    let doubleValue$21258: (java.lang.Float -> Float64) = obj$$21260 ->
        <[unknown exp]>;
    let x1$21266: Float64 = ceil$21250(
        doubleValue$21258(valueOfF32$21239(x$21230))
    );
    floatValue$21254(valueOfF64$21246(x1$21266))
}

def Float32.clamp(
    x$21026: Float32,
    minimum$21030: Float32,
    maximum$21038: Float32
): Float32 = {
    if (<[unknown exp]>(x$21026, minimum$21030)) {
        minimum$21030
    } else {
        if (<[unknown exp]>(x$21026, maximum$21038)) {
            maximum$21038
        } else {
            x$21026
        }
    }
}

def Float32.clampToInt16(
    x$21092: Float32,
    minimum$21095: Int16,
    maximum$21101: Int16,
    nanValue$21105: Int16
): Int16 = {
    let valueOf$21109: (Float32 -> java.lang.Float) = a0$$21111 ->
        <[unknown exp]>;
    let shortValue$21115: (java.lang.Float -> Int16) = obj$$21117 ->
        <[unknown exp]>;
    let minf32$21119: Float32 = Int16.toFloat32(minimum$21095);
    let maxf32$21121: Float32 = Int16.toFloat32(maximum$21101);
    if (Float32.isNan(x$21092)) {
        nanValue$21105
    } else {
        |>(
            valueOf$21109(Float32.clamp(x$21092, minf32$21119, maxf32$21121)),
            shortValue$21115
        )
    }
}

def Float32.clampToInt32(
    x$21133: Float32,
    minimum$21136: Int32,
    maximum$21140: Int32,
    nanValue$21142: Int32
): Int32 = {
    let valueOf$21144: (Float32 -> java.lang.Float) = a0$$21146 ->
        <[unknown exp]>;
    let intValue$21162: (java.lang.Float -> Int32) = obj$$21166 ->
        <[unknown exp]>;
    let minf32$21174: Float32 = Int32.toFloat32(minimum$21136);
    let maxf32$21176: Float32 = Int32.toFloat32(maximum$21140);
    if (Float32.isNan(x$21133)) {
        nanValue$21142
    } else {
        |>(
            valueOf$21144(Float32.clamp(x$21133, minf32$21174, maxf32$21176)),
            intValue$21162
        )
    }
}

def Float32.clampToInt64(
    x$21184: Float32,
    minimum$21186: Int64,
    maximum$21188: Int64,
    nanValue$21190: Int64
): Int64 = {
    let valueOf$21196: (Float32 -> java.lang.Float) = a0$$21198 ->
        <[unknown exp]>;
    let longValue$21202: (java.lang.Float -> Int64) = obj$$21205 ->
        <[unknown exp]>;
    let minf32$21210: Float32 = Int64.toFloat32(minimum$21186);
    let maxf32$21212: Float32 = Int64.toFloat32(maximum$21188);
    if (Float32.isNan(x$21184)) {
        nanValue$21190
    } else {
        |>(
            valueOf$21196(Float32.clamp(x$21184, minf32$21210, maxf32$21212)),
            longValue$21202
        )
    }
}

def Float32.clampToInt8(
    x$21060: Float32,
    minimum$21062: Int8,
    maximum$21064: Int8,
    nanValue$21066: Int8
): Int8 = {
    let valueOf$21068: (Float32 -> java.lang.Float) = a0$$21070 ->
        <[unknown exp]>;
    let byteValue$21072: (java.lang.Float -> Int8) = obj$$21074 ->
        <[unknown exp]>;
    let minf32$21076: Float32 = Int8.toFloat32(minimum$21062);
    let maxf32$21081: Float32 = Int8.toFloat32(maximum$21064);
    if (Float32.isNan(x$21060)) {
        nanValue$21066
    } else {
        |>(
            valueOf$21068(Float32.clamp(x$21060, minf32$21076, maxf32$21081)),
            byteValue$21072
        )
    }
}

def Float32.floatValue(d$21367: java.lang.Float): Float32 = {
    let floatValue$21371: (java.lang.Float -> Float32) = obj$$21375 ->
        <[unknown exp]>;
    floatValue$21371(d$21367)
}

def Float32.floor(x$21274: Float32): Float32 = {
    let valueOfF32$21283: (Float32 -> java.lang.Float) = a0$$21286 ->
        <[unknown exp]>;
    let valueOfF64$21288: (Float64 -> java.lang.Double) = a0$$21290 ->
        <[unknown exp]>;
    let floor$21292: (Float64 -> Float64) = a0$$21294 ->
        <[unknown exp]>;
    let floatValue$21296: (java.lang.Double -> Float32) = obj$$21298 ->
        <[unknown exp]>;
    let doubleValue$21310: (java.lang.Float -> Float64) = obj$$21312 ->
        <[unknown exp]>;
    let x1$21322: Float64 = floor$21292(
        doubleValue$21310(valueOfF32$21283(x$21274))
    );
    floatValue$21296(valueOfF64$21288(x1$21322))
}

def Float32.fromString(s$20783: String): Option[Float32] = {
    try {
        let strip$20785: (String -> String) = obj$$20789 ->
            <[unknown exp]>;
        let parseFloat$20795: (String -> Float32) = a0$$20799 ->
            <[unknown exp]>;
        Option.Some(|>(|>(s$20783, strip$20785), parseFloat$20795))
    } catch {case _$20805: ##java.lang.NumberFormatException => Option.None}
}

def Float32.isFinite(x$20711: Float32): Bool = {
    <[unknown exp]>(
        x$20711,
        Float32.minValue(())
    ) and <[unknown exp]>(x$20711, Float32.maxValue(()))
}

def Float32.isInfinite(x$20731: Float32): Bool = {
    <[unknown exp]>(
        x$20731,
        Float32.positiveInfinity(())
    ) or <[unknown exp]>(x$20731, Float32.negativeInfinity(()))
}

def Float32.isNan(x$20741: Float32): Bool = {<[unknown exp]>(x$20741, x$20741)}

def Float32.max(x$20764: Float32, y$20767: Float32): Float32 = {
    if (<[unknown exp]>(x$20764, y$20767)) {x$20764} else {y$20767}
}

def Float32.maxExponent(_unit$20640: Unit): Int32 = {127i32}

def Float32.maxValue(_unit$20649: Unit): Float32 = {
    <[unknown exp]>(
        <[unknown exp]>(2.0f32, Float32.pow(2.0f32, -23.0f32)),
        Float32.pow(2.0f32, 127.0f32)
    )
}

def Float32.min(x$20751: Float32, y$20753: Float32): Float32 = {
    if (<[unknown exp]>(x$20751, y$20753)) {x$20751} else {y$20753}
}

def Float32.minExponent(_unit$20643: Unit): Int32 = {-126i32}

def Float32.minPositiveValue(_unit$20666: Unit): Float32 = {
    Float32.pow(2.0f32, -149.0f32)
}

def Float32.minValue(_unit$20658: Unit): Float32 = {
    <[unknown exp]>(Float32.maxValue(()))
}

def Float32.nan(_unit$20674: Unit): Float32 = {<[unknown exp]>(0.0f32, 0.0f32)}

def Float32.negativeInfinity(_unit$20693: Unit): Float32 = {
    <[unknown exp]>(-1.0f32, 0.0f32)
}

def Float32.positiveInfinity(_unit$20685: Unit): Float32 = {
    <[unknown exp]>(1.0f32, 0.0f32)
}

def Float32.pow(b$21363: Float32, n$21365: Float32): Float32 = {
    b$21363 ** n$21365
}

def Float32.round(x$21332: Float32): Float32 = {
    let valueOfF32$21334: (Float32 -> java.lang.Float) = a0$$21336 ->
        <[unknown exp]>;
    let valueOfF64$21343: (Float64 -> java.lang.Double) = a0$$21345 ->
        <[unknown exp]>;
    let rint$21347: (Float64 -> Float64) = a0$$21349 ->
        <[unknown exp]>;
    let floatValue$21351: (java.lang.Double -> Float32) = obj$$21353 ->
        <[unknown exp]>;
    let doubleValue$21355: (java.lang.Float -> Float64) = obj$$21357 ->
        <[unknown exp]>;
    let x1$21359: Float64 = rint$21347(
        doubleValue$21355(valueOfF32$21334(x$21332))
    );
    floatValue$21351(valueOfF64$21343(x1$21359))
}

def Float32.size(_unit$20632: Unit): Int32 = {32i32}

def Float32.toFloat64(x$20983: Float32): Float64 = {
    let valueOf$20985: (Float32 -> java.lang.Float) = a0$$20987 ->
        <[unknown exp]>;
    let doubleValue$20989: (java.lang.Float -> Float64) = obj$$20992 ->
        <[unknown exp]>;
    |>(valueOf$20985(x$20983), doubleValue$20989)
}

def Float32.toString(x$20770: Float32): String = {<[unknown exp]>(x$20770)}

def Float32.tryToBigDecimal(x$21006: Float32): Option[BigDecimal] = {
    |>(
        Float32.toFloat64(x$21006),
        $0$46162 ->
            Float64.tryToBigDecimal($0$46162)
    )
}

def Float32.tryToBigInt(x$20965: Float32): Option[BigInt] = {
    Float64.tryToBigInt(Float32.toFloat64(x$20965))
}

def Float32.tryToInt16(x$20850: Float32): Option[Int16] = {
    let valueOf$20855: (Float32 -> java.lang.Float) = a0$$20858 ->
        <[unknown exp]>;
    let shortValue$20860: (java.lang.Float -> Int16) = obj$$20862 ->
        <[unknown exp]>;
    if (
        (
            (
                <[unknown exp]>(
                    x$20850,
                    Int16.toFloat32(Int16.minValue(()))
                ) or <[unknown exp]>(
                    x$20850,
                    Int16.toFloat32(Int16.maxValue(()))
                )
            ) or Float32.isNan(x$20850)
        ) or Float32.isInfinite(x$20850)
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$20855(x$20850), shortValue$20860))
    }
}

def Float32.tryToInt32(x$20884: Float32): Option[Int32] = {
    let valueOf$20888: (Float32 -> java.lang.Float) = a0$$20891 ->
        <[unknown exp]>;
    let intValue$20900: (java.lang.Float -> Int32) = obj$$20902 ->
        <[unknown exp]>;
    if (
        (
            (
                <[unknown exp]>(
                    x$20884,
                    Int32.toFloat32(Int32.minValue(()))
                ) or <[unknown exp]>(
                    x$20884,
                    Int32.toFloat32(Int32.maxValue(()))
                )
            ) or Float32.isNan(x$20884)
        ) or Float32.isInfinite(x$20884)
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$20888(x$20884), intValue$20900))
    }
}

def Float32.tryToInt64(x$20919: Float32): Option[Int64] = {
    let valueOf$20923: (Float32 -> java.lang.Float) = a0$$20925 ->
        <[unknown exp]>;
    let longValue$20931: (java.lang.Float -> Int64) = obj$$20933 ->
        <[unknown exp]>;
    if (
        (
            (
                <[unknown exp]>(
                    x$20919,
                    Int64.toFloat32(Int64.minValue(()))
                ) or <[unknown exp]>(
                    x$20919,
                    Int64.toFloat32(Int64.maxValue(()))
                )
            ) or Float32.isNan(x$20919)
        ) or Float32.isInfinite(x$20919)
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$20923(x$20919), longValue$20931))
    }
}

def Float32.tryToInt8(x$20821: Float32): Option[Int8] = {
    let valueOf$20827: (Float32 -> java.lang.Float) = a0$$20829 ->
        <[unknown exp]>;
    let byteValue$20837: (java.lang.Float -> Int8) = obj$$20839 ->
        <[unknown exp]>;
    if (
        (
            (
                <[unknown exp]>(
                    x$20821,
                    Int8.toFloat32(Int8.minValue(()))
                ) or <[unknown exp]>(x$20821, Int8.toFloat32(Int8.maxValue(())))
            ) or Float32.isNan(x$20821)
        ) or Float32.isInfinite(x$20821)
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$20827(x$20821), byteValue$20837))
    }
}

def Float32.valueOf(d$21383: Float32): java.lang.Float = {
    let valueOf$21385: (Float32 -> java.lang.Float) = a0$$21387 ->
        <[unknown exp]>;
    valueOf$21385(d$21383)
}

def Float64.abs(x$4193: Float64): Float64 = {
    let abs$4197: (Float64 -> Float64) = a0$$4201 ->
        <[unknown exp]>;
    abs$4197(x$4193)
}

def Float64.ceil(x$4219: Float64): Float64 = {
    let ceil$4227: (Float64 -> Float64) = a0$$4229 ->
        <[unknown exp]>;
    ceil$4227(x$4219)
}

def Float64.clamp(
    x$3967: Float64,
    minimum$3969: Float64,
    maximum$3971: Float64
): Float64 = {
    if (<[unknown exp]>(x$3967, minimum$3969)) {
        minimum$3969
    } else {
        if (<[unknown exp]>(x$3967, maximum$3971)) {maximum$3971} else {x$3967}
    }
}

def Float64.clampToFloat32(
    x$4155: Float64,
    minimum$4159: Float32,
    maximum$4161: Float32
): Float32 = {
    let valueOf$4163: (Float64 -> java.lang.Double) = a0$$4165 ->
        <[unknown exp]>;
    let floatValue$4173: (java.lang.Double -> Float32) = obj$$4177 ->
        <[unknown exp]>;
    let minf64$4184: Float64 = Float32.toFloat64(minimum$4159);
    let maxf64$4186: Float64 = Float32.toFloat64(maximum$4161);
    if (Float64.isNan(x$4155)) {
        Float32.nan(())
    } else {
        |>(
            valueOf$4163(Float64.clamp(x$4155, minf64$4184, maxf64$4186)),
            floatValue$4173
        )
    }
}

def Float64.clampToInt16(
    x$4027: Float64,
    minimum$4029: Int16,
    maximum$4031: Int16,
    nanValue$4033: Int16
): Int16 = {
    let valueOf$4035: (Float64 -> java.lang.Double) = a0$$4037 ->
        <[unknown exp]>;
    let shortValue$4043: (java.lang.Double -> Int16) = obj$$4045 ->
        <[unknown exp]>;
    let minf64$4053: Float64 = Int16.toFloat64(minimum$4029);
    let maxf64$4057: Float64 = Int16.toFloat64(maximum$4031);
    if (Float64.isNan(x$4027)) {
        nanValue$4033
    } else {
        |>(
            valueOf$4035(Float64.clamp(x$4027, minf64$4053, maxf64$4057)),
            shortValue$4043
        )
    }
}

def Float64.clampToInt32(
    x$4075: Float64,
    minimum$4077: Int32,
    maximum$4079: Int32,
    nanValue$4081: Int32
): Int32 = {
    let valueOf$4085: (Float64 -> java.lang.Double) = a0$$4089 ->
        <[unknown exp]>;
    let intValue$4101: (java.lang.Double -> Int32) = obj$$4103 ->
        <[unknown exp]>;
    let minf64$4106: Float64 = Int32.toFloat64(minimum$4077);
    let maxf64$4108: Float64 = Int32.toFloat64(maximum$4079);
    if (Float64.isNan(x$4075)) {
        nanValue$4081
    } else {
        |>(
            valueOf$4085(Float64.clamp(x$4075, minf64$4106, maxf64$4108)),
            intValue$4101
        )
    }
}

def Float64.clampToInt64(
    x$4117: Float64,
    minimum$4119: Int64,
    maximum$4121: Int64,
    nanValue$4125: Int64
): Int64 = {
    let valueOf$4127: (Float64 -> java.lang.Double) = a0$$4131 ->
        <[unknown exp]>;
    let longValue$4137: (java.lang.Double -> Int64) = obj$$4139 ->
        <[unknown exp]>;
    let minf64$4144: Float64 = Int64.toFloat64(minimum$4119);
    let maxf64$4146: Float64 = Int64.toFloat64(maximum$4121);
    if (Float64.isNan(x$4117)) {
        nanValue$4125
    } else {
        |>(
            valueOf$4127(Float64.clamp(x$4117, minf64$4144, maxf64$4146)),
            longValue$4137
        )
    }
}

def Float64.clampToInt8(
    x$3990: Float64,
    minimum$3992: Int8,
    maximum$3999: Int8,
    nanValue$4001: Int8
): Int8 = {
    let valueOf$4003: (Float64 -> java.lang.Double) = a0$$4005 ->
        <[unknown exp]>;
    let byteValue$4007: (java.lang.Double -> Int8) = obj$$4009 ->
        <[unknown exp]>;
    let minf64$4018: Float64 = Int8.toFloat64(minimum$3992);
    let maxf64$4022: Float64 = Int8.toFloat64(maximum$3999);
    if (Float64.isNan(x$3990)) {
        nanValue$4001
    } else {
        |>(
            valueOf$4003(Float64.clamp(x$3990, minf64$4018, maxf64$4022)),
            byteValue$4007
        )
    }
}

def Float64.doubleValue(i$4293: java.lang.Double): Float64 = {
    let doubleValue$4295: (java.lang.Double -> Float64) = obj$$4297 ->
        <[unknown exp]>;
    doubleValue$4295(i$4293)
}

def Float64.exp(x$4275: Float64): Float64 = {
    let exp$4283: (Float64 -> Float64) = a0$$4285 ->
        <[unknown exp]>;
    exp$4283(x$4275)
}

def Float64.floor(x$4234: Float64): Float64 = {
    let floor$4236: (Float64 -> Float64) = a0$$4239 ->
        <[unknown exp]>;
    floor$4236(x$4234)
}

def Float64.fromString(s$3414: String): Option[Float64] = {
    try {
        let strip$3416: (String -> String) = obj$$3418 ->
            <[unknown exp]>;
        let parseDouble$3428: (String -> Float64) = a0$$3430 ->
            <[unknown exp]>;
        Option.Some(|>(|>(s$3414, strip$3416), parseDouble$3428))
    } catch {case _$3703: ##java.lang.NumberFormatException => Option.None}
}

def Float64.isFinite(x$3330: Float64): Bool = {
    <[unknown exp]>(
        x$3330,
        Float64.minValue(())
    ) and <[unknown exp]>(x$3330, Float64.maxValue(()))
}

def Float64.isInfinite(x$3350: Float64): Bool = {
    <[unknown exp]>(
        x$3350,
        Float64.positiveInfinity(())
    ) or <[unknown exp]>(x$3350, Float64.negativeInfinity(()))
}

def Float64.isNan(x$3360: Float64): Bool = {<[unknown exp]>(x$3360, x$3360)}

def Float64.max(x$3386: Float64, y$3388: Float64): Float64 = {
    if (<[unknown exp]>(x$3386, y$3388)) {x$3386} else {y$3388}
}

def Float64.maxExponent(_unit$3247: Unit): Int32 = {1023i32}

def Float64.maxValue(_unit$3262: Unit): Float64 = {
    <[unknown exp]>(
        <[unknown exp]>(2.0f64, Float64.pow(2.0f64, -52.0f64)),
        Float64.pow(2.0f64, 1023.0f64)
    )
}

def Float64.min(x$3367: Float64, y$3369: Float64): Float64 = {
    if (<[unknown exp]>(x$3367, y$3369)) {x$3367} else {y$3369}
}

def Float64.minExponent(_unit$3257: Unit): Int32 = {-1022i32}

def Float64.minPositiveValue(_unit$3294: Unit): Float64 = {
    Float64.pow(2.0f64, -1074.0f64)
}

def Float64.minValue(_unit$3277: Unit): Float64 = {
    <[unknown exp]>(Float64.maxValue(()))
}

def Float64.nan(_unit$3300: Unit): Float64 = {<[unknown exp]>(0.0f64, 0.0f64)}

def Float64.negativeInfinity(_unit$3323: Unit): Float64 = {
    <[unknown exp]>(-1.0f64, 0.0f64)
}

def Float64.positiveInfinity(_unit$3307: Unit): Float64 = {
    <[unknown exp]>(1.0f64, 0.0f64)
}

def Float64.pow(x$4267: Float64, n$4269: Float64): Float64 = {x$4267 ** n$4269}

def Float64.round(x$4254: Float64): Float64 = {
    let rint$4258: (Float64 -> Float64) = a0$$4260 ->
        <[unknown exp]>;
    rint$4258(x$4254)
}

def Float64.size(_unit$3233: Unit): Int32 = {64i32}

def Float64.toString(x$3403: Float64): String = {<[unknown exp]>(x$3403)}

def Float64.tryToBigDecimal(x$3949: Float64): Option[BigDecimal] = {
    let fromFloat64$3951: (Float64 -> BigDecimal) = a0$3953 ->
        <[unknown exp]>;
    try {
        Option.Some(fromFloat64$3951(x$3949))
    } catch {case _$3965: ##java.lang.NumberFormatException => Option.None}
}

def Float64.tryToBigInt(x$3884: Float64): Option[BigInt] = {
    let valueOf$3887: (Float64 -> BigDecimal) = a0$$3889 ->
        <[unknown exp]>;
    let toBigInteger$3893: (BigDecimal -> BigInt) = obj$$3895 ->
        <[unknown exp]>;
    try {
        Option.Some(|>(|>(x$3884, valueOf$3887), toBigInteger$3893))
    } catch {case _$3903: ##java.lang.NumberFormatException => Option.None}
}

def Float64.tryToFloat32(x$3916: Float64): Option[Float32] = {
    let valueOf$3921: (Float64 -> java.lang.Double) = a0$$3924 ->
        <[unknown exp]>;
    let floatValue$3931: (java.lang.Double -> Float32) = obj$$3933 ->
        <[unknown exp]>;
    if (
        <[unknown exp]>(
            x$3916,
            Float32.toFloat64(Float32.minValue(()))
        ) or <[unknown exp]>(x$3916, Float32.toFloat64(Float32.maxValue(())))
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$3921(x$3916), floatValue$3931))
    }
}

def Float64.tryToInt16(x$3755: Float64): Option[Int16] = {
    let valueOf$3759: (Float64 -> java.lang.Double) = a0$$3761 ->
        <[unknown exp]>;
    let shortValue$3767: (java.lang.Double -> Int16) = obj$$3769 ->
        <[unknown exp]>;
    if (
        (
            (
                <[unknown exp]>(
                    x$3755,
                    Int16.toFloat64(Int16.minValue(()))
                ) or <[unknown exp]>(
                    x$3755,
                    Int16.toFloat64(Int16.maxValue(()))
                )
            ) or Float64.isNan(x$3755)
        ) or Float64.isInfinite(x$3755)
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$3759(x$3755), shortValue$3767))
    }
}

def Float64.tryToInt32(x$3796: Float64): Option[Int32] = {
    let valueOf$3800: (Float64 -> java.lang.Double) = a0$$3805 ->
        <[unknown exp]>;
    let intValue$3812: (java.lang.Double -> Int32) = obj$$3816 ->
        <[unknown exp]>;
    if (
        (
            (
                <[unknown exp]>(
                    x$3796,
                    Int32.toFloat64(Int32.minValue(()))
                ) or <[unknown exp]>(
                    x$3796,
                    Int32.toFloat64(Int32.maxValue(()))
                )
            ) or Float64.isNan(x$3796)
        ) or Float64.isInfinite(x$3796)
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$3800(x$3796), intValue$3812))
    }
}

def Float64.tryToInt64(x$3838: Float64): Option[Int64] = {
    let valueOf$3840: (Float64 -> java.lang.Double) = a0$$3842 ->
        <[unknown exp]>;
    let longValue$3850: (java.lang.Double -> Int64) = obj$$3854 ->
        <[unknown exp]>;
    if (
        (
            (
                <[unknown exp]>(
                    x$3838,
                    Int64.toFloat64(Int64.minValue(()))
                ) or <[unknown exp]>(
                    x$3838,
                    Int64.toFloat64(Int64.maxValue(()))
                )
            ) or Float64.isNan(x$3838)
        ) or Float64.isInfinite(x$3838)
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$3840(x$3838), longValue$3850))
    }
}

def Float64.tryToInt8(x$3705: Float64): Option[Int8] = {
    let valueOf$3709: (Float64 -> java.lang.Double) = a0$$3711 ->
        <[unknown exp]>;
    let byteValue$3720: (java.lang.Double -> Int8) = obj$$3722 ->
        <[unknown exp]>;
    if (
        (
            (
                <[unknown exp]>(
                    x$3705,
                    Int8.toFloat64(Int8.minValue(()))
                ) or <[unknown exp]>(x$3705, Int8.toFloat64(Int8.maxValue(())))
            ) or Float64.isNan(x$3705)
        ) or Float64.isInfinite(x$3705)
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$3709(x$3705), byteValue$3720))
    }
}

def Float64.valueOf(i$4310: Float64): java.lang.Double = {
    let valueOf$4313: (Float64 -> java.lang.Double) = a0$$4315 ->
        <[unknown exp]>;
    valueOf$4313(i$4310)
}

def Foldable.fold(t$23812: t[a]): a = {
    <[unknown exp]>(
        acc$23818 ->
            x$23821 ->
                <[unknown exp]>(acc$23818, x$23821),
        <[unknown exp]>(()),
        t$23812
    )
}

def Functor.$>(ma$41422: f[a], x$41424: b): f[b] = {
    Functor.replace(ma$41422, x$41424)
}

def Functor.<$(x$41199: a, ma$41206: f[b]): f[a] = {
    Functor.replace(ma$41206, x$41199)
}

def Functor.<$$>(x$41180: m[a], f$41184: a -> b): m[b] \ ef = {
    <[unknown exp]>(f$41184, x$41180)
}

def Functor.<$>(f$41157: a -> b, x$41162: m[a]): m[b] \ ef = {
    <[unknown exp]>(f$41157, x$41162)
}

def Functor.ignore(s$41145: m[a]): m[Unit] = {Functor.replace(s$41145, ())}

def Functor.replace(s$41117: m[a], x$41119: b): m[b] = {
    <[unknown exp]>(_$41128 -> x$41119, s$41117)
}

def GetOpt.decodeArg(
    x$14964: Option[a],
    optStr$14973: String
): OptionKind[a] = {
    match x$14964 {
        case Option.Some(x1$14983) =>
            GetOpt.OptionKind.Opt(x1$14983)
        case Option.None =>
            GetOpt.errDecode(optStr$14973)
    }
}

def GetOpt.deconsLeft(s$14651: String): Option[(Char, String)] = {
    if (<[unknown exp]>(String.length(s$14651), 0i32)) {
        Option.Some(
            String.charAt(0i32, s$14651),
            String.dropLeft(1i32, s$14651)
        )
    } else {
        Option.None
    }
}

def GetOpt.errAmbig(
    ods$15170: Nel[OptionDescr[a]],
    optStr$15172: String
): OptionKind[a] = {
    let header$15174: String = (
        ("""""" + """option '""") + <[unknown exp]>(optStr$15172)
    ) + """' is ambiguous; could be one of:""";
    GetOpt.OptionKind.OptErr(
        GetOpt.usageInfo(header$15174, Nel.toList(ods$15170))
    )
}

def GetOpt.errDecode(optStr$15635: String): OptionKind[a] = {
    GetOpt.OptionKind.OptErr(
        (
            ("""""" + """option '""") + <[unknown exp]>(optStr$15635)
        ) + """' could not decode its argument
"""
    )
}

def GetOpt.errNoArgReq(optStr$15366: String): OptionKind[a] = {
    GetOpt.OptionKind.OptErr(
        (
            ("""""" + """option '""") + <[unknown exp]>(optStr$15366)
        ) + """' doesn't allow an argument
"""
    )
}

def GetOpt.errReq(d$15192: String, optStr$15204: String): OptionKind[a] = {
    GetOpt.OptionKind.OptErr(
        (
            (
                (
                    ("""""" + """option '""") + <[unknown exp]>(optStr$15204)
                ) + """' requires an argument """
            ) + <[unknown exp]>(d$15192)
        ) + """
"""
    )
}

def GetOpt.errUnrec(optStr$15268: String): String = {
    (
        ("""""" + """unrecognized option '""") + <[unknown exp]>(optStr$15268)
    ) + """'
"""
}

def GetOpt.findOptionById(
    xc$15102: Char,
    optDescrs$15109: List[OptionDescr[a]]
): Result[GetOptionFailure[a], OptionDescr[a]] = {
    let options$15119: List[OptionDescr[a]] = List.filterMap(
        o$15123 ->
            {
                let ss$15125: List[Char] = o$15123.optionIds;
                if (
                    List.exists(
                        s$15129 ->
                            <[unknown exp]>(s$15129, xc$15102),
                        ss$15125
                    )
                ) {
                    Option.Some(o$15123)
                } else {
                    Option.None
                }
            },
        optDescrs$15109
    );
    match options$15119 {
        case List.Cons(optd$15135, List.Nil) =>
            Result.Ok(optd$15135)
        case List.Cons(x$15143, xs$15145) =>
            Result.Err(
                GetOpt.GetOptionFailure.Ambiguous(Nel.Nel(x$15143, xs$15145))
            )
        case List.Nil =>
            Result.Err(GetOpt.GetOptionFailure.NotFound)
    }
}

def GetOpt.findOptionByName(
    optname$15014: String,
    optDescrs$15018: List[OptionDescr[a]]
): Result[GetOptionFailure[a], OptionDescr[a]] = {
    let getWith$15027: (
        String -> (String -> Bool) ->
            List[{ argDescriptor = ArgDescr[a], explanation = String, optionIds = List[Char], optionNames = List[String] }]
    ) = p$15029 ->
        List.filterMap(
            o$15033 ->
                {
                    let xs$15035: List[String] = o$15033.optionNames;
                    if (List.exists(p$15029(optname$15014), xs$15035)) {
                        Option.Some(o$15033)
                    } else {
                        Option.None
                    }
                },
            optDescrs$15018
        );
    let exact$15041: List[OptionDescr[a]] = getWith$15027(
        x$15045 ->
            y$15051 ->
                <[unknown exp]>(x$15045, y$15051)
    );
    let options$15055: List[OptionDescr[a]] = if (List.isEmpty(exact$15041)) {
        getWith$15027(
            sub$15057 ->
                s1$15059 ->
                    String.startsWith({+prefix = sub$15057 | {}}, s1$15059)
        )
    } else {
        exact$15041
    };
    match options$15055 {
        case List.Cons(optd$15061, List.Nil) =>
            Result.Ok(optd$15061)
        case List.Cons(x$15063, xs$15065) =>
            Result.Err(
                GetOpt.GetOptionFailure.Ambiguous(Nel.Nel(x$15063, xs$15065))
            )
        case List.Nil =>
            Result.Err(GetOpt.GetOptionFailure.NotFound)
    }
}

def GetOpt.formatLong(
    argDescr$12287: ArgDescr[a],
    long$12291: String
): String = {
    match argDescr$12287 {
        case GetOpt.ArgDescr.NoArg(_) =>
            ("""""" + """--""") + <[unknown exp]>(long$12291)
        case GetOpt.ArgDescr.ReqArg(_, descr$12299) =>
            (
                (("""""" + """--""") + <[unknown exp]>(long$12291)) + """="""
            ) + <[unknown exp]>(descr$12299)
        case GetOpt.ArgDescr.OptArg(_, descr$12305) =>
            (
                (
                    (
                        ("""""" + """--""") + <[unknown exp]>(long$12291)
                    ) + """[="""
                ) + <[unknown exp]>(descr$12305)
            ) + """]"""
    }
}

def GetOpt.formatOpt(
    opts$12130: OptionDescr[a]
): List[(String, String, String)] = {
    let shorts$12140: String = |>(
        List.map(
            (
                $0$45688 ->
                    $1$45690 ->
                        GetOpt.formatShort($0$45688, $1$45690)
            )(opts$12130.argDescriptor),
            opts$12130.optionIds
        ),
        ($0$45692 -> $1$45694 -> GetOpt.sepBy($0$45692, $1$45694))(''',''')
    );
    let longs$12145: String = |>(
        List.map(
            (
                $0$45696 ->
                    $1$45698 ->
                        GetOpt.formatLong($0$45696, $1$45698)
            )(opts$12130.argDescriptor),
            opts$12130.optionNames
        ),
        ($0$45700 -> $1$45702 -> GetOpt.sepBy($0$45700, $1$45702))(''',''')
    );
    match String.lines(opts$12130.explanation) {
        case List.Nil =>
            List.Cons((shorts$12140, longs$12145, """"""), List.Nil)
        case List.Cons(d$12168, ds$12174) =>
            List.Cons(
                (shorts$12140, longs$12145, d$12168),
                List.map(x$12178 -> ("""""", """""", x$12178), ds$12174)
            )
    }
}

def GetOpt.formatShort(
    argDescr$12231: ArgDescr[a],
    short$12236: Char
): String = {
    match argDescr$12231 {
        case GetOpt.ArgDescr.NoArg(_) =>
            ("""""" + """-""") + <[unknown exp]>(short$12236)
        case GetOpt.ArgDescr.ReqArg(_, descr$12254) =>
            (
                (("""""" + """-""") + <[unknown exp]>(short$12236)) + """ """
            ) + <[unknown exp]>(descr$12254)
        case GetOpt.ArgDescr.OptArg(_, descr$12258) =>
            (
                (
                    (
                        ("""""" + """-""") + <[unknown exp]>(short$12236)
                    ) + """["""
                ) + <[unknown exp]>(descr$12258)
            ) + """]"""
    }
}

def GetOpt.getNext(
    arg$12605: String,
    optDescrs$12607: List[OptionDescr[a]],
    tokens$12610: List[String]
): (OptionKind[a], List[String]) = {
    match arg$12605 {
        case """--""" =>
            (GetOpt.OptionKind.EndOfOpts, tokens$12610)
        case s$12618 if String.startsWith({+prefix = """--""" | {}}, s$12618) =>
            GetOpt.longOpt(
                String.dropLeft(2i32, s$12618),
                optDescrs$12607,
                tokens$12610
            )
        case s$12623 if String.startsWith(
            {+prefix = """-""" | {}},
            s$12623
        ) and <[unknown exp]>(String.length(s$12623), 2i32) =>
            GetOpt.shortOpt(
                String.charAt(1i32, s$12623),
                String.dropLeft(2i32, s$12623),
                optDescrs$12607,
                tokens$12610
            )
        case s$12625 =>
            (GetOpt.OptionKind.NonOpt(s$12625), tokens$12610)
    }
}

def GetOpt.getOpt(
    ordering$12345: ArgOrder[a],
    optDescriptors$12358: List[OptionDescr[a]],
    sourceArgs$12370: List[String]
): Validation[String, { nonOptions = List[String], options = List[a] }] = {
    let answers$12376: { errors = List[String], nonOptions = List[String], options = List[a], unknowns = List[String] } = GetOpt.getOpt1(
        ordering$12345,
        optDescriptors$12358,
        sourceArgs$12370
    );
    match List.append(
        answers$12376.errors,
        List.map($0$45704 -> GetOpt.errUnrec($0$45704), answers$12376.unknowns)
    ) {
        case List.Nil =>
            Validation.Success(
                {
                    +options = answers$12376.options,
                    +nonOptions = answers$12376.nonOptions |
                    {}
                }
            )
        case List.Cons(e$12390, es$12394) =>
            match List.toNec(es$12394) {
                case Option.None =>
                    Validation.Failure(Nec.singleton(e$12390))
                case Option.Some(c$12402) =>
                    Validation.Failure(Nec.cons(e$12390, c$12402))
            }
    }
}

def GetOpt.getOpt1(
    ordering$12413: ArgOrder[a],
    optDescriptors$12415: List[OptionDescr[a]],
    sourceArgs$12418: List[String]
): { errors = List[String], nonOptions = List[String], options = List[a], unknowns = List[String] } =
{
    match GetOpt.getOpt1Helper(
        ordering$12413,
        optDescriptors$12415,
        sourceArgs$12418
    ) {
        case (os$12442, xs$12444, us$12447, es$12450) =>
            {
                +options = os$12442,
                +nonOptions = xs$12444,
                +unknowns = us$12447,
                +errors = es$12450 |
                {}
            }
    }
}

def GetOpt.getOpt1Helper(
    ordering$12464: ArgOrder[a],
    optDescrs$12477: List[OptionDescr[a]],
    sourceArgs$12487: List[String]
): (List[a], List[String], List[String], List[String]) = {
    match sourceArgs$12487 {
        case List.Nil =>
            (List.Nil, List.Nil, List.Nil, List.Nil)
        case List.Cons(arg$12498, args$12504) =>
            match GetOpt.getNext(arg$12498, optDescrs$12477, args$12504) {
                case (opt$12521, rest$12525) =>
                    match GetOpt.getOpt1Helper(
                        ordering$12464,
                        optDescrs$12477,
                        rest$12525
                    ) {
                        case (os$12535, xs$12538, us$12541, es$12543) =>
                            match (opt$12521, ordering$12464) {
                                case (GetOpt.OptionKind.Opt(o$12545), _) =>
                                    (
                                        List.Cons(o$12545, os$12535),
                                        xs$12538,
                                        us$12541,
                                        es$12543
                                    )
                                case (GetOpt.OptionKind.UnreqOpt(u$12553), _) =>
                                    (
                                        os$12535,
                                        xs$12538,
                                        List.Cons(u$12553, us$12541),
                                        es$12543
                                    )
                                case (
                                    GetOpt.OptionKind.NonOpt(x$12555),
                                    GetOpt.ArgOrder.RequireOrder
                                ) =>
                                    (
                                        List.Nil,
                                        List.Cons(x$12555, rest$12525),
                                        List.Nil,
                                        List.Nil
                                    )
                                case (
                                    GetOpt.OptionKind.NonOpt(x$12557),
                                    GetOpt.ArgOrder.Permute
                                ) =>
                                    (
                                        os$12535,
                                        List.Cons(x$12557, xs$12538),
                                        us$12541,
                                        es$12543
                                    )
                                case (
                                    GetOpt.OptionKind.NonOpt(x$12559),
                                    GetOpt.ArgOrder.ReturnInOrder(f$12562)
                                ) =>
                                    (
                                        List.Cons(f$12562(x$12559), os$12535),
                                        xs$12538,
                                        us$12541,
                                        es$12543
                                    )
                                case (
                                    GetOpt.OptionKind.EndOfOpts,
                                    GetOpt.ArgOrder.RequireOrder
                                ) =>
                                    (List.Nil, rest$12525, List.Nil, List.Nil)
                                case (
                                    GetOpt.OptionKind.EndOfOpts,
                                    GetOpt.ArgOrder.Permute
                                ) =>
                                    (List.Nil, rest$12525, List.Nil, List.Nil)
                                case (
                                    GetOpt.OptionKind.EndOfOpts,
                                    GetOpt.ArgOrder.ReturnInOrder(f$12577)
                                ) =>
                                    (
                                        List.map(f$12577, rest$12525),
                                        List.Nil,
                                        List.Nil,
                                        List.Nil
                                    )
                                case (GetOpt.OptionKind.OptErr(e$12583), _) =>
                                    (
                                        os$12535,
                                        xs$12538,
                                        us$12541,
                                        List.Cons(e$12583, es$12543)
                                    )
                            }
                    }
            }
    }
}

def GetOpt.groupWhenQuoted(
    quoteOpen$16826: String,
    quoteClose$16833: String,
    args$16838: List[String]
): List[String] = {
    GetOpt.groupWhenQuotedHelper(
        quoteOpen$16826,
        quoteClose$16833,
        args$16838,
        ks$16848 ->
            ks$16848
    )
}

def GetOpt.groupWhenQuotedHelper(
    quoteOpen$16873: String,
    quoteClose$16875: String,
    tokens$16879: List[String],
    k$16889: List[String] -> List[String]
): List[String] \ ef = {
    match tokens$16879 {
        case List.Nil =>
            k$16889(List.Nil)
        case List.Cons(
            x$16909,
            rest$16911
        ) if String.contains(
            {+substr = quoteOpen$16873 | {}},
            x$16909
        ) and String.endsWith({+suffix = quoteClose$16875 | {}}, x$16909) =>
            GetOpt.groupWhenQuotedHelper(
                quoteOpen$16873,
                quoteClose$16875,
                rest$16911,
                ks$16915 ->
                    k$16889(List.Cons(x$16909, ks$16915))
            )
        case List.Cons(
            x$16917,
            rest$16919
        ) if String.contains({+substr = quoteOpen$16873 | {}}, x$16917) =>
            GetOpt.groupWhenQuotedHelperInner(
                quoteOpen$16873,
                quoteClose$16875,
                rest$16919,
                x$16917,
                ks$16927 ->
                    k$16889(ks$16927)
            )
        case List.Cons(x$16937, rest$16939) =>
            GetOpt.groupWhenQuotedHelper(
                quoteOpen$16873,
                quoteClose$16875,
                rest$16939,
                ks$16949 ->
                    k$16889(List.Cons(x$16937, ks$16949))
            )
    }
}

def GetOpt.groupWhenQuotedHelperInner(
    quoteOpen$16980: String,
    quoteClose$16983: String,
    tokens$16986: List[String],
    acc$16991: String,
    k$16993: List[String] -> List[String]
): List[String] \ ef = {
    match tokens$16986 {
        case List.Nil =>
            k$16993(List.Cons(acc$16991, List.Nil))
        case List.Cons(
            x$17012,
            rest$17014
        ) if String.contains({+substr = quoteClose$16983 | {}}, x$17012) =>
            GetOpt.groupWhenQuotedHelper(
                quoteOpen$16980,
                quoteClose$16983,
                rest$17014,
                ks$17016 ->
                    k$16993(
                        List.Cons(
                            <[unknown exp]>(
                                <[unknown exp]>(acc$16991, """ """),
                                x$17012
                            ),
                            ks$17016
                        )
                    )
            )
        case List.Cons(x$17022, rest$17027) =>
            GetOpt.groupWhenQuotedHelperInner(
                quoteOpen$16980,
                quoteClose$16983,
                rest$17027,
                <[unknown exp]>(<[unknown exp]>(acc$16991, """ """), x$17022),
                k$16993
            )
    }
}

def GetOpt.longOpt(
    xstr$12642: String,
    optDescrs$12645: List[OptionDescr[a]],
    tokens$12650: List[String]
): (OptionKind[a], List[String]) = {
    match String.breakOnLeft({+substr = """=""" | {}}, xstr$12642) {
        case (optname$12653, arg$12655) =>
            let optStr$12657: String = (
                """""" + """--"""
            ) + <[unknown exp]>(optname$12653);
            match GetOpt.findOptionByName(optname$12653, optDescrs$12645) {
                case Result.Ok(opt$12659) =>
                    match (
                        opt$12659.argDescriptor,
                        GetOpt.deconsLeft(arg$12655),
                        tokens$12650
                    ) {
                        case (
                            GetOpt.ArgDescr.NoArg(a$12668),
                            Option.None,
                            rest$12672
                        ) =>
                            (GetOpt.OptionKind.Opt(a$12668), rest$12672)
                        case (
                            GetOpt.ArgDescr.NoArg(_),
                            Option.Some('''=''', _),
                            rest$12677
                        ) =>
                            (GetOpt.errNoArgReq(optStr$12657), rest$12677)
                        case (
                            GetOpt.ArgDescr.ReqArg(_, d$12679),
                            Option.None,
                            List.Nil
                        ) =>
                            (GetOpt.errReq(d$12679, optStr$12657), List.Nil)
                        case (
                            GetOpt.ArgDescr.ReqArg(f$12681, _),
                            Option.None,
                            List.Cons(r$12686, rest$12688)
                        ) =>
                            (
                                GetOpt.decodeArg(
                                    f$12681(r$12686),
                                    optStr$12657
                                ),
                                rest$12688
                            )
                        case (
                            GetOpt.ArgDescr.ReqArg(f$12690, _),
                            Option.Some('''=''', ss$12695),
                            rest$12697
                        ) =>
                            (
                                GetOpt.decodeArg(
                                    f$12690(ss$12695),
                                    optStr$12657
                                ),
                                rest$12697
                            )
                        case (
                            GetOpt.ArgDescr.OptArg(f$12699, _),
                            Option.None,
                            rest$12702
                        ) =>
                            (
                                GetOpt.decodeArg(
                                    f$12699(Option.None),
                                    optStr$12657
                                ),
                                rest$12702
                            )
                        case (
                            GetOpt.ArgDescr.OptArg(f$14607, _),
                            Option.Some('''=''', ss$14614),
                            rest$14617
                        ) =>
                            (
                                GetOpt.decodeArg(
                                    f$14607(Option.Some(ss$14614)),
                                    optStr$12657
                                ),
                                rest$14617
                            )
                        case (_, _, rest$14619) =>
                            (
                                GetOpt.OptionKind.UnreqOpt(
                                    (
                                        """""" + """--"""
                                    ) + <[unknown exp]>(xstr$12642)
                                ),
                                rest$14619
                            )
                    }
                case Result.Err(
                    GetOpt.GetOptionFailure.Ambiguous(options$14627)
                ) =>
                    (GetOpt.errAmbig(options$14627, optStr$12657), tokens$12650)
                case Result.Err(GetOpt.GetOptionFailure.NotFound) =>
                    (
                        GetOpt.OptionKind.UnreqOpt(
                            ("""""" + """--""") + <[unknown exp]>(xstr$12642)
                        ),
                        tokens$12650
                    )
            }
    }
}

def GetOpt.preprocess(
    options$16788: { quoteClose = String, quoteOpen = String, stripQuoteMarks = Bool },
    args$16796: List[String]
): List[String] = {
    let args1$16808: List[String] = GetOpt.groupWhenQuoted(
        options$16788.quoteOpen,
        options$16788.quoteClose,
        args$16796
    );
    if (options$16788.stripQuoteMarks) {
        GetOpt.removeQuoteMarks(
            options$16788.quoteOpen,
            options$16788.quoteClose,
            args1$16808
        )
    } else {
        args1$16808
    }
}

def GetOpt.removeQuoteMarks(
    quoteOpen$17049: String,
    quoteClose$17051: String,
    args$17057: List[String]
): List[String] = {
    |>(
        args$17057,
        (
            $0$45897 ->
                $1$45901 ->
                    List.map($0$45897, $1$45901)
        )(
            >>(
                (
                    $0$45905 ->
                        $1$45907 ->
                            $2$45909 ->
                                String.replace($0$45905, $1$45907, $2$45909)
                )({+src = quoteOpen$17049 | {}})({+dst = """""" | {}}),
                (
                    $0$45911 ->
                        $1$45913 ->
                            $2$45915 ->
                                String.replace($0$45911, $1$45913, $2$45915)
                )({+src = quoteClose$17051 | {}})({+dst = """""" | {}})
            )
        )
    )
}

def GetOpt.sameLen(xs$12084: List[String]): List[String] = {
    let width$12098: Int32 = List.foldLeft(
        ac$12100 ->
            x$12102 ->
                Int32.max(ac$12100, String.length(x$12102)),
        0i32,
        xs$12084
    );
    List.map(
        (
            $0$45680 ->
                $1$45682 ->
                    $2$45684 ->
                        String.padRight($0$45680, $1$45682, $2$45684)
        )(width$12098)(''' '''),
        xs$12084
    )
}

def GetOpt.sepBy(ch$12224: Char, ss$12226: List[String]): String = {
    String.intercalate(("""""" + <[unknown exp]>(ch$12224)) + """ """, ss$12226)
}

def GetOpt.shortOpt(
    xc$14680: Char,
    xstr$14686: String,
    optDescrs$14690: List[OptionDescr[a]],
    tokens$14698: List[String]
): (OptionKind[a], List[String]) = {
    let optStr$14726: String = ("""""" + """-""") + <[unknown exp]>(xc$14680);
    match GetOpt.findOptionById(xc$14680, optDescrs$14690) {
        case Result.Ok(opt$14728) =>
            match (opt$14728.argDescriptor, xstr$14686, tokens$14698) {
                case (GetOpt.ArgDescr.NoArg(a$14761), """""", rest$14765) =>
                    (GetOpt.OptionKind.Opt(a$14761), rest$14765)
                case (GetOpt.ArgDescr.NoArg(a$14794), str$14800, rest$14802) =>
                    (
                        GetOpt.OptionKind.Opt(a$14794),
                        List.Cons(
                            ("""""" + """-""") + <[unknown exp]>(str$14800),
                            rest$14802
                        )
                    )
                case (GetOpt.ArgDescr.ReqArg(_, d$14814), """""", List.Nil) =>
                    (GetOpt.errReq(d$14814, optStr$14726), List.Nil)
                case (
                    GetOpt.ArgDescr.ReqArg(f$14861, _),
                    """""",
                    List.Cons(r$14863, rest$14869)
                ) =>
                    (
                        GetOpt.decodeArg(f$14861(r$14863), optStr$14726),
                        rest$14869
                    )
                case (
                    GetOpt.ArgDescr.ReqArg(f$14902, _),
                    str$14904,
                    rest$14906
                ) =>
                    (
                        GetOpt.decodeArg(f$14902(str$14904), optStr$14726),
                        rest$14906
                    )
                case (GetOpt.ArgDescr.OptArg(f$14908, _), """""", rest$14910) =>
                    (
                        GetOpt.decodeArg(f$14908(Option.None), optStr$14726),
                        rest$14910
                    )
                case (
                    GetOpt.ArgDescr.OptArg(f$14916, _),
                    str$14920,
                    rest$14924
                ) =>
                    (
                        GetOpt.decodeArg(
                            f$14916(Option.Some(str$14920)),
                            optStr$14726
                        ),
                        rest$14924
                    )
            }
        case Result.Err(GetOpt.GetOptionFailure.Ambiguous(options$14930)) =>
            (GetOpt.errAmbig(options$14930, optStr$14726), tokens$14698)
        case Result.Err(
            GetOpt.GetOptionFailure.NotFound
        ) if <[unknown exp]>(xstr$14686, """""") =>
            (GetOpt.OptionKind.UnreqOpt(optStr$14726), tokens$14698)
        case Result.Err(GetOpt.GetOptionFailure.NotFound) =>
            (
                GetOpt.OptionKind.UnreqOpt(optStr$14726),
                List.Cons(
                    ("""""" + """-""") + <[unknown exp]>(xstr$14686),
                    tokens$14698
                )
            )
    }
}

def GetOpt.usageInfo(
    header$12034: String,
    optionDescriptors$12044: List[OptionDescr[a]]
): String = {
    let paste$12056: (String -> String -> (String -> String)) = x$12058 ->
        y$12060 ->
            z$12062 ->
                (
                    (
                        (
                            (
                                ("""""" + """  """) + <[unknown exp]>(x$12058)
                            ) + """  """
                        ) + <[unknown exp]>(y$12060)
                    ) + """  """
                ) + <[unknown exp]>(z$12062);
    match |>(
        List.flatMap(
            $0$45676 ->
                GetOpt.formatOpt($0$45676),
            optionDescriptors$12044
        ),
        $0$45678 ->
            List.unzip3($0$45678)
    ) {
        case (shorts$12067, longs$12069, ds$12071) =>
            let table$12073: List[String] = List.zipWith3(
                paste$12056,
                GetOpt.sameLen(shorts$12067),
                GetOpt.sameLen(longs$12069),
                ds$12071
            );
            String.unlines(List.Cons(header$12034, table$12073))
    }
}

enum GetOpt.ArgDescr[a] {
    case NoArg(a)
    case ReqArg(String -> Option[a], String)
    case OptArg(Option[String] -> Option[a], String)
}

enum GetOpt.ArgOrder[a] {
    case RequireOrder(Unit)
    case Permute(Unit)
    case ReturnInOrder(String -> a)
}

enum GetOpt.GetOptionFailure[a] {
    case Ambiguous(Nel[OptionDescr[a]])
    case NotFound(Unit)
}

enum GetOpt.OptionKind[a] {
    case OptErr(String)
    case EndOfOpts(Unit)
    case NonOpt(String)
    case UnreqOpt(String)
    case Opt(a)
}

def Graph.boundedDistances(g$44583: m[(t, Int32, t)]): Map[(t, t), Int32] = {
    let edges$44585: #{ Dist(t, t; Down[Int32]), Edge(t, Int32, t), Mapping((t, t), Int32) | s121498 } = <[unknown exp]>;
    let dists$44587: #{ Dist(t, t; Down[Int32]), Edge(t, Int32, t), Mapping((t, t), Int32) | s121498 } = <[unknown exp]>;
    let mapping$44631: #{ Dist(t, t; Down[Int32]), Edge(t, Int32, t), Mapping((t, t), Int32) | s121498 } = <[unknown exp]>;
    let res$44645: Vector[((t, t), Int32)] = <[unknown exp]>;
    |>(res$44645, $0$47125 -> Vector.toMap($0$47125))
}

def Graph.closure(g$29135: m[(t, t)]): Set[(t, t)] = {
    let edges$29139: #{ Edge(t, t), Node(t), Reachable(t, t) | s121622 } = <[unknown exp]>;
    let res$40282: Vector[(t, t)] = <[unknown exp]>;
    Vector.toSet(res$40282)
}

def Graph.cutPoints(g$45034: m[(t, t)]): Set[(t, t, t)] = {
    let edges$45036: #{ Circumvent(t, t, t), CutPoint(t, t, t), CutPointSet(t, t; Set[t]), Edge(t, t), Node(t), Reachable(t, t) | s109619 } = <[unknown exp]>;
    letrec unpack$45038: (Option[t] -> t) = opt$45040 ->
        match opt$45040 {
            case Option.Some(v$45042) =>
                v$45042
            case Option.None =>
                unreachable!(())
        };
    let cuts$45044: #{ Circumvent(t, t, t), CutPoint(t, t, t), CutPointSet(t, t; Set[t]), Edge(t, t), Node(t), Reachable(t, t) | s109619 } = <[unknown exp]>;
    let res$45108: Vector[(t, t, t)] = <[unknown exp]>;
    Vector.toSet(res$45108)
}

def Graph.degrees(g$44916: m[(t, t)]): Map[t, Int32] = {<[unknown exp]>}

def Graph.destructDown(d$45290: Down[a]): a = {
    match d$45290 {case Down.Down(a$45292) => a$45292}
}

def Graph.distance(
    src$44695: { src = t },
    dst$44697: { dst = t },
    g$44699: m[(t, Int32, t)]
): Option[Int32] = {
    |>(
        Graph.distancesFrom(src$44695.src, g$44699),
        ($0$47129 -> $1$47131 -> Map.get($0$47129, $1$47131))(dst$44697.dst)
    )
}

def Graph.distances(g$44425: m[(t, Int32, t)]): Option[Map[(t, t), Int32]] = {
    letrec rank$44427: (t -> Set[t] -> Int32) = v$44429 ->
        s$44431 ->
            |>(
                |>(
                    |>(
                        s$44431,
                        (
                            $0$47117 ->
                                $1$47119 ->
                                    Set.partition($0$47117, $1$47119)
                        )(v0$44433 -> <[unknown exp]>(v0$44433, v$44429))
                    ),
                    $0$47121 ->
                        fst($0$47121)
                ),
                $0$47123 ->
                    Set.size($0$47123)
            );
    let edges$44435: #{ Dist(t, t, Int32; Down[Int32]), Edge(t, Int32, t), Mapping((t, t), Int32), NegCycle(), Node(t), NodeCount(Int32), NodeRank(t, Int32), Nodes(; Set[t]) | s110068 } = <[unknown exp]>;
    let negCycle$44437: #{ Dist(t, t, Int32; Down[Int32]), Edge(t, Int32, t), Mapping((t, t), Int32), NegCycle(), Node(t), NodeCount(Int32), NodeRank(t, Int32), Nodes(; Set[t]) | s110068 } = <[unknown exp]>;
    let mapping$44545: #{ Dist(t, t, Int32; Down[Int32]), Edge(t, Int32, t), Mapping((t, t), Int32), NegCycle(), Node(t), NodeCount(Int32), NodeRank(t, Int32), Nodes(; Set[t]) | s110068 } = <[unknown exp]>;
    let sol$44565: #{ Dist(t, t, Int32; Down[Int32]), Edge(t, Int32, t), Mapping((t, t), Int32), NegCycle(), Node(t), NodeCount(Int32), NodeRank(t, Int32), Nodes(; Set[t]) | s110068 } = {
        let tmp$137$44567: #{ Dist(t, t, Int32; Down[Int32]), Edge(t, Int32, t), Mapping((t, t), Int32), NegCycle(), Node(t), NodeCount(Int32), NodeRank(t, Int32), Nodes(; Set[t]) | s110068 } = <[unknown exp]>;
        tmp$137$44567
    };
    let cycle$44569: Vector[Unit] = <[unknown exp]>;
    if (Vector.isEmpty(cycle$44569)) {
        let res$44571: Vector[((t, t), Int32)] = <[unknown exp]>;
        Option.Some(Vector.toMap(res$44571))
    } else {
        Option.None
    }
}

def Graph.distancesFrom(
    src$44657: t,
    g$44659: m[(t, Int32, t)]
): Map[t, Int32] = {
    let edges$44661: #{ Dist(t; Down[Int32]), Edge(t, Int32, t) | s116253 } = <[unknown exp]>;
    let dists$44663: #{ Dist(t; Down[Int32]), Edge(t, Int32, t) | s116253 } = <[unknown exp]>;
    let res$44683: Vector[(t, Out[Down[Int32]])] = <[unknown exp]>;
    |>(res$44683, $0$47127 -> Vector.toMap($0$47127))
}

def Graph.flipEdges(g$44329: m[(t, t)]): Set[(t, t)] = {
    let edges$44331: #{ Edge(t, t), RevEdge(t, t) | s127394 } = <[unknown exp]>;
    let rev$44333: #{ Edge(t, t), RevEdge(t, t) | s127394 } = <[unknown exp]>;
    let res$44343: Vector[(t, t)] = <[unknown exp]>;
    Vector.toSet(res$44343)
}

def Graph.frontiersFrom(
    src$44962: t,
    g$44964: m[(t, t)]
): Map[Int32, Set[t]] = {
    let edges$44966: #{ Dist(t; Down[Int32]), Edge(t, t), Frontier(Int32; Option[Set[t]]), Frontiers(; Set[Int32]), MaxFrontier(Int32) | s115488 } = <[unknown exp]>;
    let frontiers$44968: #{ Dist(t; Down[Int32]), Edge(t, t), Frontier(Int32; Option[Set[t]]), Frontiers(; Set[Int32]), MaxFrontier(Int32) | s115488 } = <[unknown exp]>;
    let res$45012: Vector[(Int32, Option[Set[t]])] = <[unknown exp]>;
    let unwrapOption$45022: (
        (Int32, Option[Set[t]]) -> Option[(Int32, Set[t])]
    ) = pat$142$45024 ->
        match pat$142$45024 {
            case (n$45026, s$45028) =>
                match s$45028 {
                    case Option.Some(v$45030) =>
                        Option.Some(n$45026, v$45030)
                    case Option.None =>
                        Option.None
                }
        };
    |>(
        |>(
            res$45012,
            (
                $0$47167 ->
                    $1$47169 ->
                        Vector.filterMap($0$47167, $1$47169)
            )(unwrapOption$45022)
        ),
        $0$47171 ->
            Vector.toMap($0$47171)
    )
}

def Graph.graphvizId(id$45239: t): String = {
    (
        (
            """""" + """""""
        ) + <[unknown exp]>(
            String.replace(
                {+src = """"""" | {}},
                {+dst = """\"""" | {}},
                """""" + <[unknown exp]>(id$45239)
            )
        )
    ) + """""""
}

def Graph.inDegrees(g$45124: m[(t, t)]): Map[t, Int32] = {<[unknown exp]>}

def Graph.invert(g$44355: m[(t, t)]): Set[(t, t)] = {
    let edges$44357: #{ Edge(t, t), InvEdge(t, t), Node(t) | s108794 } = <[unknown exp]>;
    let inverse$44359: #{ Edge(t, t), InvEdge(t, t), Node(t) | s108794 } = <[unknown exp]>;
    let res$44373: Vector[(t, t)] = <[unknown exp]>;
    Vector.toSet(res$44373)
}

def Graph.isCyclic(g$44385: m[(t, t)]): Bool = {
    let edges$44387: #{ Edge(t, t), Reachable(t, t) | s129099 } = <[unknown exp]>;
    let reachability$44389: #{ Edge(t, t), Reachable(t, t) | s129099 } = <[unknown exp]>;
    let res$44413: Vector[Unit] = <[unknown exp]>;
    <[unknown exp]>(Vector.length(res$44413), 0i32)
}

def Graph.nodes(_unit$45265: Unit): #{ Edge(t, t), Node(t) | r } = {
    <[unknown exp]>
}

def Graph.outDegrees(g$45162: m[(t, t)]): Map[t, Int32] = {<[unknown exp]>}

def Graph.reachability(
    _unit$45243: Unit
): #{ Edge(t, t), Node(t), Reachable(t, t) | r } = {
    <[unknown exp]>
}

def Graph.reachabilityFromSrc(
    src$45277: t
): #{ Edge(t, t), Reachable(t) | r } = {
    <[unknown exp]>
}

def Graph.reachable(
    src$44283: { src = t },
    dst$44285: { dst = t },
    g$44287: m[(t, t)]
): Bool = {
    |>(
        Graph.reachableFrom(src$44283.src, g$44287),
        (
            $0$47113 ->
                $1$47115 ->
                    Set.exists($0$47113, $1$47115)
        )(x$44289 -> <[unknown exp]>(dst$44285.dst, x$44289))
    )
}

def Graph.reachableFrom(src$44247: t, g$44249: m[(t, t)]): Set[t] = {
    let edges$44251: #{ Edge(t, t), Reachable(t) | s123571 } = <[unknown exp]>;
    let res$44253: Vector[t] = <[unknown exp]>;
    Vector.toSet(res$44253)
}

def Graph.stronglyConnectedComponents(g$44293: m[(t, t)]): Set[Set[t]] = {
    let edges$44295: #{ Components(Set[t]), Connected(t; Set[t]), Edge(t, t), Node(t), Reachable(t, t) | s125108 } = <[unknown exp]>;
    let connected$44297: #{ Components(Set[t]), Connected(t; Set[t]), Edge(t, t), Node(t), Reachable(t, t) | s125108 } = <[unknown exp]>;
    let components$44311: #{ Components(Set[t]), Connected(t; Set[t]), Edge(t, t), Node(t), Reachable(t, t) | s125108 } = <[unknown exp]>;
    let res$44321: Vector[Set[t]] = <[unknown exp]>;
    Vector.toSet(res$44321)
}

def Graph.toGraphviz(g$45200: m[(t, t)]): String = {
    region rc$45202 {
        let sb$45205: StringBuilder[rc] = StringBuilder.empty(rc$45202);
        letrec output$45207: (String -> Unit) = s$45209 ->
            StringBuilder.appendLine!(s$45209, sb$45205);
        output$45207("""digraph {""");
        <[unknown exp]>(
            pat$143$45211 ->
                match pat$143$45211 {
                    case (x$45213, y$45215) =>
                        output$45207(
                            (
                                (
                                    (
                                        """""" + """  """
                                    ) + <[unknown exp]>(
                                        Graph.graphvizId(x$45213)
                                    )
                                ) + """ -> """
                            ) + <[unknown exp]>(Graph.graphvizId(y$45215))
                        )
                },
            g$45200
        );
        output$45207("""}""");
        StringBuilder.toString(sb$45205)
    }
}

def Graph.toGraphvizWeighted(g$45219: m[(t, Int32, t)]): String = {
    region rc$45221 {
        let sb$45224: StringBuilder[rc] = StringBuilder.empty(rc$45221);
        letrec output$45226: (String -> Unit) = s$45228 ->
            StringBuilder.appendLine!(s$45228, sb$45224);
        output$45226("""digraph {""");
        <[unknown exp]>(
            pat$144$45230 ->
                match pat$144$45230 {
                    case (x$45232, w$45234, y$45236) =>
                        output$45226(
                            (
                                (
                                    (
                                        (
                                            (
                                                (
                                                    """""" + """  """
                                                ) + <[unknown exp]>(
                                                    Graph.graphvizId(x$45232)
                                                )
                                            ) + """ -> """
                                        ) + <[unknown exp]>(
                                            Graph.graphvizId(y$45236)
                                        )
                                    ) + """ [label = """
                                ) + <[unknown exp]>(w$45234)
                            ) + """]"""
                        )
                },
            g$45219
        );
        output$45226("""}""");
        StringBuilder.toString(sb$45224)
    }
}

def Graph.toUndirected(g$44703: m[(t, t)]): Set[(t, t)] = {
    |>(
        |>(g$44703, $0$47133 -> <[unknown exp]>($0$47133)),
        (
            $0$47135 ->
                $1$47137 ->
                    Set.flatMap($0$47135, $1$47137)
        )(
            pat$138$44705 ->
                match pat$138$44705 {
                    case (a$44707, b$44709) =>
                        Set.insert(
                            (b$44709, a$44707),
                            Set.insert((a$44707, b$44709), Set.empty(()))
                        )
                }
        )
    )
}

def Graph.toUndirectedWeighted(
    g$44713: m[(t, Int32, t)]
): Set[(t, Int32, t)] = {
    |>(
        |>(g$44713, $0$47139 -> <[unknown exp]>($0$47139)),
        (
            $0$47141 ->
                $1$47143 ->
                    Set.flatMap($0$47141, $1$47143)
        )(
            pat$139$44715 ->
                match pat$139$44715 {
                    case (a$44717, w$44719, b$44721) =>
                        Set.insert(
                            (b$44721, w$44719, a$44717),
                            Set.insert(
                                (a$44717, w$44719, b$44721),
                                Set.empty(())
                            )
                        )
                }
        )
    )
}

def Graph.topologicalSort(g$44801: m[(t, t)]): List[t] = {
    region rc$44803 {
        let edges$44806: #{ After(t, t), Before(t, t), Edge(t, t), EdgeFirst(t), EdgeSecond(t), Index(t; Int32), Node(t) | s114681 } = <[unknown exp]>;
        let topSort$44808: #{ After(t, t), Before(t, t), Edge(t, t), EdgeFirst(t), EdgeSecond(t), Index(t; Int32), Node(t) | s114681 } = <[unknown exp]>;
        let res$44892: Vector[(t, Int32)] = <[unknown exp]>;
        let ml$44902: MutList[t, rc] = MutList.empty(rc$44803);
        |>(
            |>(
                res$44892,
                (
                    $0$47145 ->
                        $1$47147 ->
                            Vector.sortBy($0$47145, $1$47147)
                )(
                    pat$140$44904 ->
                        match pat$140$44904 {
                            case (x$44906, i$44908) =>
                                (i$44908, x$44906)
                        }
                )
            ),
            (
                $0$47149 ->
                    $1$47151 ->
                        Vector.forEach($0$47149, $1$47151)
            )(
                pat$141$44910 ->
                    match pat$141$44910 {
                        case (x$44912, _) =>
                            MutList.push!(x$44912, ml$44902)
                    }
            )
        );
        MutList.toList(ml$44902)
    }
}

def Graph.unreachableFrom(src$44261: t, g$44263: m[(t, t)]): Set[t] = {
    let edges$44265: #{ Edge(t, t), Node(t), Reachable(t), UnReachable(t) | s131371 } = <[unknown exp]>;
    let unreachablility$44267: #{ Edge(t, t), Node(t), Reachable(t), UnReachable(t) | s131371 } = <[unknown exp]>;
    let res$44275: Vector[t] = <[unknown exp]>;
    Vector.toSet(res$44275)
}

def Graph.withinDistanceOf(
    src$44725: t,
    limit$44727: Int32,
    g$44729: m[(t, Int32, t)]
): Set[t] = {
    let edges$44731: #{ Dist(t; Down[Int32]), Edge(t, Int32, t), Node(t) | s108783 } = <[unknown exp]>;
    let nodes$44733: #{ Dist(t; Down[Int32]), Edge(t, Int32, t), Node(t) | s108783 } = <[unknown exp]>;
    let res$44757: Vector[t] = <[unknown exp]>;
    Vector.toSet(res$44757)
}

def Graph.withinEdgesOf(
    src$44765: t,
    limit$44767: Int32,
    g$44769: m[(t, t)]
): Set[t] = {
    let edges$44771: #{ Dist(t; Down[Int32]), Edge(t, t), Node(t) | s127529 } = <[unknown exp]>;
    let nodes$44773: #{ Dist(t; Down[Int32]), Edge(t, t), Node(t) | s127529 } = <[unknown exp]>;
    let res$44793: Vector[t] = <[unknown exp]>;
    Vector.toSet(res$44793)
}

def Hash.combine(h1$27691: Int32, h2$27695: Int32): Int32 = {
    <[unknown exp]>(<[unknown exp]>(h1$27691, Hash.magic(())), h2$27695)
}

def Hash.magic(_unit$27721: Unit): Int32 = {-1640531535i32}

enum IOError {case Generic(String)}

def IOError.tryCatch(f$33391: Unit -> a): Result[IOError, a] \ ef = {
    try {
        Result.Ok(f$33391(()))
    } catch {
        case e$33416: ##java.lang.Exception =>
            let getMessage$33421: (
                java.lang.Throwable -> String
            ) = obj$$33426 ->
                <[unknown exp]>;
            Result.Err(IOError.Generic(getMessage$33421(<[unknown exp]>)))
    }
}

enum Identity[a] {case Identity(a)}

def Int16.abs(x$23999: Int16): Int16 = {
    if (<[unknown exp]>(x$23999, 0i16)) {
        x$23999
    } else {
        if (<[unknown exp]>(x$23999, Int16.minValue(()))) {
            -1i16
        } else {
            <[unknown exp]>(x$23999)
        }
    }
}

def Int16.bitCount(x$24179: Int16): Int32 = {
    if (<[unknown exp]>(x$24179, 0i16)) {
        0i32
    } else {
        if (<[unknown exp]>(Int16.remainder(x$24179, 2i16), 0i16)) {
            <[unknown exp]>(
                Int16.bitCount(
                    Int16.logicalRightShift({+dist = 1i32 | {}}, x$24179)
                ),
                1i32
            )
        } else {
            Int16.bitCount(
                Int16.logicalRightShift({+dist = 1i32 | {}}, x$24179)
            )
        }
    }
}

def Int16.bitPositionToInt16(position$24439: Int32): Int16 = {
    if (
        <[unknown exp]>(
            position$24439,
            0i32
        ) or <[unknown exp]>(
            position$24439,
            <[unknown exp]>(Int16.size(()), 1i32)
        )
    ) {
        0i16
    } else {
        Int16.leftShift(1i16, position$24439)
    }
}

def Int16.bitwiseAnd(x$31992: Int16, y$31994: Int16): Int16 = {
    x$31992 and y$31994
}

def Int16.bitwiseNot(x$32002: Int16): Int16 = {!x$32002}

def Int16.bitwiseOr(x$32020: Int16, y$32022: Int16): Int16 = {
    x$32020 or y$32022
}

def Int16.bitwiseXor(x$32037: Int16, y$32041: Int16): Int16 = {
    x$32037 xor y$32041
}

def Int16.clamp(
    min$34345: { min = Int16 },
    max$34347: { max = Int16 },
    x$34349: Int16
): Int16 = {
    if (<[unknown exp]>(x$34349, min$34345.min)) {
        min$34345.min
    } else {
        if (<[unknown exp]>(x$34349, max$34347.max)) {
            max$34347.max
        } else {
            x$34349
        }
    }
}

def Int16.clampToInt8(
    min$34424: { min = Int8 },
    max$34426: { max = Int8 },
    x$34432: Int16
): Int8 = {
    let valueOf$34440: (Int16 -> java.lang.Short) = a0$$34442 ->
        <[unknown exp]>;
    let byteValue$34474: (java.lang.Short -> Int8) = obj$$34476 ->
        <[unknown exp]>;
    let mini16$34488: Int16 = Int8.toInt16(min$34424.min);
    let maxi16$34498: Int16 = Int8.toInt16(max$34426.max);
    |>(
        valueOf$34440(
            Int16.clamp(
                {+min = mini16$34488 | {}},
                {+max = maxi16$34498 | {}},
                x$34432
            )
        ),
        byteValue$34474
    )
}

def Int16.clearBit(pos$24569: { pos = Int32 }, x$24575: Int16): Int16 = {
    Int16.bitwiseAnd(
        x$24575,
        Int16.bitwiseNot(Int16.leftShift(1i16, pos$24569.pos))
    )
}

def Int16.compare(x$24083: Int16, y$24085: Int16): Int32 = {
    if (<[unknown exp]>(x$24083, y$24085)) {
        0i32
    } else {
        if (<[unknown exp]>(x$24083, y$24085)) {-1i32} else {1i32}
    }
}

def Int16.dist(x$24065: Int16, y$24067: Int16): Int16 = {
    if (<[unknown exp]>(x$24065, 0i16) and <[unknown exp]>(y$24067, 0i16)) {
        Int16.abs(<[unknown exp]>(x$24065, y$24067))
    } else {
        if (<[unknown exp]>(x$24065, 0i16) and <[unknown exp]>(y$24067, 0i16)) {
            Int16.abs(<[unknown exp]>(x$24065, y$24067))
        } else {
            if (
                <[unknown exp]>(
                    x$24065,
                    Int16.minValue(())
                ) or <[unknown exp]>(y$24067, Int16.minValue(()))
            ) {
                -1i16
            } else {
                if (
                    <[unknown exp]>(
                        <[unknown exp]>(
                            <[unknown exp]>(
                                Int16.minValue(()),
                                Int16.abs(x$24065)
                            ),
                            Int16.abs(y$24067)
                        ),
                        0i16
                    )
                ) {
                    -1i16
                } else {
                    Int16.abs(<[unknown exp]>(x$24065, y$24067))
                }
            }
        }
    }
}

def Int16.factorial(x$32087: Int16): Int32 = {
    |>(Int16.toInt32(x$32087), $0$46262 -> Int32.factorial($0$46262))
}

def Int16.flipBit(pos$24595: { pos = Int32 }, x$24597: Int16): Int16 = {
    Int16.bitwiseXor(x$24597, Int16.leftShift(1i16, pos$24595.pos))
}

def Int16.fromString(s$32124: String): Option[Int16] = {
    try {
        let strip$32128: (String -> String) = obj$$32130 ->
            <[unknown exp]>;
        let parseShort$32136: (String -> Int16) = a0$$32138 ->
            <[unknown exp]>;
        Option.Some(|>(|>(s$32124, strip$32128), parseShort$32136))
    } catch {case _$32153: ##java.lang.NumberFormatException => Option.None}
}

def Int16.getBit(pos$24511: { pos = Int32 }, x$24519: Int16): Int32 = {
    if (
        <[unknown exp]>(
            Int16.remainder(Int16.rightShift(x$24519, pos$24511.pos), 2i16),
            0i16
        )
    ) {
        0i32
    } else {
        1i32
    }
}

def Int16.highestOneBit(x$24401: Int16): Int16 = {
    Int16.bitPositionToInt16(Int16.highestOneBitPosition(x$24401))
}

def Int16.highestOneBitPosition(x$24324: Int16): Int32 = {
    Int16.oneBitPositionHelper(
        x$24324,
        <[unknown exp]>(Int16.size(()), 1i32),
        -1i32
    )
}

def Int16.leftShift(x$31916: Int16, y$31920: Int32): Int16 = {
    x$31916 shl y$31920
}

def Int16.log2(x$31880: Int16): Int16 = {
    if (<[unknown exp]>(x$31880, 0i16)) {
        0i16
    } else {
        let position$31895: Int32 = Int16.highestOneBitPosition(x$31880);
        Int32.clampToInt16(
            {+min = 0i16 | {}},
            {+max = Int16.maxValue(()) | {}},
            position$31895
        )
    }
}

def Int16.logicalRightShift(
    dist$24145: { dist = Int32 },
    x$24148: Int16
): Int16 = {
    if (
        <[unknown exp]>(
            x$24148,
            0i16
        ) and <[unknown exp]>(Int32.remainder(dist$24145.dist, 32i32), 0i32)
    ) {
        Int16.rightShift(
            Int16.bitwiseAnd(
                Int16.rightShift(x$24148, 1i32),
                Int16.maxValue(())
            ),
            <[unknown exp]>(dist$24145.dist, 1i32)
        )
    } else {
        Int16.rightShift(x$24148, dist$24145.dist)
    }
}

def Int16.lowestOneBit(x$24419: Int16): Int16 = {
    Int16.bitPositionToInt16(Int16.lowestOneBitPosition(x$24419))
}

def Int16.lowestOneBitPosition(x$24341: Int16): Int32 = {
    Int16.oneBitPositionHelper(x$24341, 0i32, 1i32)
}

def Int16.max(x$23990: Int16, y$23992: Int16): Int16 = {
    if (<[unknown exp]>(x$23990, y$23992)) {x$23990} else {y$23992}
}

def Int16.maxValue(_unit$23962: Unit): Int16 = {
    Int16.bitwiseNot(Int16.minValue(()))
}

def Int16.min(x$23973: Int16, y$23975: Int16): Int16 = {
    if (<[unknown exp]>(x$23973, y$23975)) {x$23973} else {y$23975}
}

def Int16.minValue(_unit$23932: Unit): Int16 = {
    Int16.leftShift(1i16, <[unknown exp]>(Int16.size(()), 1i32))
}

def Int16.modulo(x$24019: Int16, n$24021: Int16): Int16 = {
    if (<[unknown exp]>(n$24021, 0i16)) {
        0i16
    } else {
        <[unknown exp]>(x$24019 rem n$24021, n$24021) rem n$24021
    }
}

def Int16.numberOfLeadingZeros(x$24464: Int16): Int32 = {
    if (<[unknown exp]>(x$24464, 0i16)) {
        Int16.size(())
    } else {
        <[unknown exp]>(
            <[unknown exp]>(Int16.size(()), 1i32),
            Int16.highestOneBitPosition(x$24464)
        )
    }
}

def Int16.numberOfTrailingZeros(x$24494: Int16): Int32 = {
    if (<[unknown exp]>(x$24494, 0i16)) {
        Int16.size(())
    } else {
        Int16.lowestOneBitPosition(x$24494)
    }
}

def Int16.oneBitPositionHelper(
    x$24360: Int16,
    position$24362: Int32,
    delta$24364: Int32
): Int32 = {
    if (<[unknown exp]>(position$24362, 0i32)) {
        -1i32
    } else {
        if (
            <[unknown exp]>(
                position$24362,
                <[unknown exp]>(Int16.size(()), 1i32)
            )
        ) {
            -1i32
        } else {
            if (
                <[unknown exp]>(
                    Int16.getBit({+pos = position$24362 | {}}, x$24360),
                    1i32
                )
            ) {
                position$24362
            } else {
                if (<[unknown exp]>(delta$24364, 0i32)) {
                    -1i32
                } else {
                    Int16.oneBitPositionHelper(
                        x$24360,
                        <[unknown exp]>(position$24362, delta$24364),
                        delta$24364
                    )
                }
            }
        }
    }
}

def Int16.pow(b$24133: Int16, n$24140: Int16): Int16 = {b$24133 ** n$24140}

def Int16.remainder(x$24042: Int16, n$24044: Int16): Int16 = {
    if (<[unknown exp]>(n$24044, 0i16)) {0i16} else {x$24042 rem n$24044}
}

def Int16.reverse(x$24252: Int16): Int16 = {
    Int16.reverseHelper(x$24252, 0i32, <[unknown exp]>(Int16.size(()), 1i32))
}

def Int16.reverseHelper(
    x$24261: Int16,
    l$24263: Int32,
    r$24266: Int32
): Int16 = {
    if (<[unknown exp]>(l$24263, r$24266)) {
        x$24261
    } else {
        Int16.reverseHelper(
            Int16.swap(x$24261, l$24263, r$24266),
            <[unknown exp]>(l$24263, 1i32),
            <[unknown exp]>(r$24266, 1i32)
        )
    }
}

def Int16.rightShift(x$31942: Int16, y$31948: Int32): Int16 = {
    x$31942 shr y$31948
}

def Int16.rotateLeft(dist$24218: { dist = Int32 }, x$24220: Int16): Int16 = {
    let rem1$24226: Int32 = Int32.remainder(dist$24218.dist, Int16.size(()));
    let rot$24230: Int32 = if (<[unknown exp]>(rem1$24226, 0i32)) {
        rem1$24226
    } else {
        <[unknown exp]>(rem1$24226, Int16.size(()))
    };
    Int16.bitwiseOr(
        Int16.logicalRightShift(
            {+dist = <[unknown exp]>(Int16.size(()), rot$24230) | {}},
            x$24220
        ),
        Int16.leftShift(x$24220, rot$24230)
    )
}

def Int16.rotateRight(dist$24200: { dist = Int32 }, x$24204: Int16): Int16 = {
    let rem1$24210: Int32 = Int32.remainder(dist$24200.dist, Int16.size(()));
    let rot$24213: Int32 = if (<[unknown exp]>(rem1$24210, 0i32)) {
        rem1$24210
    } else {
        <[unknown exp]>(rem1$24210, Int16.size(()))
    };
    Int16.bitwiseOr(
        Int16.logicalRightShift({+dist = rot$24213 | {}}, x$24204),
        Int16.leftShift(x$24204, <[unknown exp]>(Int16.size(()), rot$24213))
    )
}

def Int16.setBit(pos$24547: { pos = Int32 }, x$24551: Int16): Int16 = {
    Int16.bitwiseOr(x$24551, Int16.leftShift(1i16, pos$24547.pos))
}

def Int16.shortValue(i$34555: java.lang.Short): Int16 = {
    let shortValue$34564: (java.lang.Short -> Int16) = obj$$34566 ->
        <[unknown exp]>;
    shortValue$34564(i$34555)
}

def Int16.signum(x$24107: Int16): Int32 = {Int16.compare(x$24107, 0i16)}

def Int16.size(_unit$23920: Unit): Int32 = {16i32}

def Int16.swap(x$24293: Int16, l$24295: Int32, r$24297: Int32): Int16 = {
    match (
        Int16.getBit({+pos = l$24295 | {}}, x$24293),
        Int16.getBit({+pos = r$24297 | {}}, x$24293)
    ) {
        case (1i32, 0i32) =>
            Int16.clearBit(
                {+pos = l$24295 | {}},
                Int16.setBit({+pos = r$24297 | {}}, x$24293)
            )
        case (0i32, 1i32) =>
            Int16.clearBit(
                {+pos = r$24297 | {}},
                Int16.setBit({+pos = l$24295 | {}}, x$24293)
            )
        case _ =>
            x$24293
    }
}

def Int16.toBigDecimal(x$34230: Int16): BigDecimal = {
    let fromInt32$34248: (Int32 -> BigDecimal) = a0$34250 ->
        <[unknown exp]>;
    |>(Int16.toInt32(x$34230), fromInt32$34248)
}

def Int16.toBigInt(x$32283: Int16): BigInt = {
    let i16ValueOf$32293: (Int16 -> java.lang.Short) = a0$$32295 ->
        <[unknown exp]>;
    let longValue$32297: (java.lang.Short -> Int64) = obj$$32299 ->
        <[unknown exp]>;
    let asBigInt$32301: (Int64 -> BigInt) = a0$$32303 ->
        <[unknown exp]>;
    |>(|>(i16ValueOf$32293(x$32283), longValue$32297), asBigInt$32301)
}

def Int16.toFloat32(x$32316: Int16): Float32 = {
    let valueOf$32321: (Int16 -> java.lang.Short) = a0$$32323 ->
        <[unknown exp]>;
    let floatValue$32325: (java.lang.Short -> Float32) = obj$$32327 ->
        <[unknown exp]>;
    |>(valueOf$32321(x$32316), floatValue$32325)
}

def Int16.toFloat64(x$32342: Int16): Float64 = {
    let valueOf$32344: (Int16 -> java.lang.Short) = a0$$32346 ->
        <[unknown exp]>;
    let doubleValue$32348: (java.lang.Short -> Float64) = obj$$32350 ->
        <[unknown exp]>;
    |>(valueOf$32344(x$32342), doubleValue$32348)
}

def Int16.toInt32(x$32230: Int16): Int32 = {
    let valueOf$32232: (Int16 -> java.lang.Short) = a0$$32234 ->
        <[unknown exp]>;
    let intValue$32236: (java.lang.Short -> Int32) = obj$$32238 ->
        <[unknown exp]>;
    |>(valueOf$32232(x$32230), intValue$32236)
}

def Int16.toInt64(x$32249: Int16): Int64 = {
    let valueOf$32254: (Int16 -> java.lang.Short) = a0$$32257 ->
        <[unknown exp]>;
    let longValue$32276: (java.lang.Short -> Int64) = obj$$32278 ->
        <[unknown exp]>;
    |>(valueOf$32254(x$32249), longValue$32276)
}

def Int16.toString(x$32090: Int16): String = {<[unknown exp]>(x$32090)}

def Int16.tryToInt8(x$32208: Int16): Option[Int8] = {
    let valueOf$32211: (Int16 -> java.lang.Short) = a0$$32213 ->
        <[unknown exp]>;
    let byteValue$32215: (java.lang.Short -> Int8) = obj$$32217 ->
        <[unknown exp]>;
    if (
        <[unknown exp]>(
            x$32208,
            Int8.toInt16(Int8.minValue(()))
        ) or <[unknown exp]>(x$32208, Int8.toInt16(Int8.maxValue(())))
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$32211(x$32208), byteValue$32215))
    }
}

def Int16.valueOf(i$34628: Int16): java.lang.Short = {
    let valueOf$34652: (Int16 -> java.lang.Short) = a0$$34658 ->
        <[unknown exp]>;
    valueOf$34652(i$34628)
}

def Int32.abs(x$14460: Int32): Int32 = {
    if (<[unknown exp]>(x$14460, 0i32)) {
        x$14460
    } else {
        if (<[unknown exp]>(x$14460, Int32.minValue(()))) {
            -1i32
        } else {
            <[unknown exp]>(x$14460)
        }
    }
}

def Int32.bitCount(x$14585: Int32): Int32 = {
    if (<[unknown exp]>(x$14585, 0i32)) {
        0i32
    } else {
        if (<[unknown exp]>(Int32.remainder(x$14585, 2i32), 0i32)) {
            <[unknown exp]>(
                Int32.bitCount(
                    Int32.logicalRightShift({+dist = 1i32 | {}}, x$14585)
                ),
                1i32
            )
        } else {
            Int32.bitCount(
                Int32.logicalRightShift({+dist = 1i32 | {}}, x$14585)
            )
        }
    }
}

def Int32.bitPositionToInt32(position$14738: Int32): Int32 = {
    if (
        <[unknown exp]>(
            position$14738,
            0i32
        ) or <[unknown exp]>(
            position$14738,
            <[unknown exp]>(Int32.size(()), 1i32)
        )
    ) {
        0i32
    } else {
        Int32.leftShift(1i32, position$14738)
    }
}

def Int32.bitwiseAnd(x$14842: Int32, y$14844: Int32): Int32 = {
    x$14842 and y$14844
}

def Int32.bitwiseNot(x$14865: Int32): Int32 = {!x$14865}

def Int32.bitwiseOr(x$14885: Int32, y$14887: Int32): Int32 = {
    x$14885 or y$14887
}

def Int32.bitwiseXor(x$14894: Int32, y$14898: Int32): Int32 = {
    x$14894 xor y$14898
}

def Int32.clamp(
    min$21306: { min = Int32 },
    max$21308: { max = Int32 },
    x$21316: Int32
): Int32 = {
    if (<[unknown exp]>(x$21316, min$21306.min)) {
        min$21306.min
    } else {
        if (<[unknown exp]>(x$21316, max$21308.max)) {
            max$21308.max
        } else {
            x$21316
        }
    }
}

def Int32.clampToInt16(
    min$24652: { min = Int16 },
    max$24654: { max = Int16 },
    x$24656: Int32
): Int16 = {
    let valueOf$24659: (Int32 -> java.lang.Integer) = a0$$24661 ->
        <[unknown exp]>;
    let shortValue$24663: (java.lang.Integer -> Int16) = obj$$24665 ->
        <[unknown exp]>;
    let mini32$24667: Int32 = Int16.toInt32(min$24652.min);
    let maxi32$24669: Int32 = Int16.toInt32(max$24654.max);
    |>(
        valueOf$24659(
            Int32.clamp(
                {+min = mini32$24667 | {}},
                {+max = maxi32$24669 | {}},
                x$24656
            )
        ),
        shortValue$24663
    )
}

def Int32.clampToInt8(
    min$21793: { min = Int8 },
    max$22542: { max = Int8 },
    x$23792: Int32
): Int8 = {
    let valueOf$23824: (Int32 -> java.lang.Integer) = a0$$23833 ->
        <[unknown exp]>;
    let byteValue$23858: (java.lang.Integer -> Int8) = obj$$23860 ->
        <[unknown exp]>;
    let mini32$23889: Int32 = Int8.toInt32(min$21793.min);
    let maxi32$23905: Int32 = Int8.toInt32(max$22542.max);
    |>(
        valueOf$23824(
            Int32.clamp(
                {+min = mini32$23889 | {}},
                {+max = maxi32$23905 | {}},
                x$23792
            )
        ),
        byteValue$23858
    )
}

def Int32.clearBit(pos$14786: { pos = Int32 }, x$14788: Int32): Int32 = {
    Int32.bitwiseAnd(
        x$14788,
        Int32.bitwiseNot(Int32.leftShift(1i32, pos$14786.pos))
    )
}

def Int32.compare(x$14526: Int32, y$14530: Int32): Int32 = {
    if (<[unknown exp]>(x$14526, y$14530)) {
        0i32
    } else {
        if (<[unknown exp]>(x$14526, y$14530)) {-1i32} else {1i32}
    }
}

def Int32.dist(x$14503: Int32, y$14505: Int32): Int32 = {
    if (<[unknown exp]>(x$14503, 0i32) and <[unknown exp]>(y$14505, 0i32)) {
        Int32.abs(<[unknown exp]>(x$14503, y$14505))
    } else {
        if (<[unknown exp]>(x$14503, 0i32) and <[unknown exp]>(y$14505, 0i32)) {
            Int32.abs(<[unknown exp]>(x$14503, y$14505))
        } else {
            if (
                <[unknown exp]>(
                    x$14503,
                    Int32.minValue(())
                ) or <[unknown exp]>(y$14505, Int32.minValue(()))
            ) {
                -1i32
            } else {
                if (
                    <[unknown exp]>(
                        <[unknown exp]>(
                            <[unknown exp]>(
                                Int32.minValue(()),
                                Int32.abs(x$14503)
                            ),
                            Int32.abs(y$14505)
                        ),
                        0i32
                    )
                ) {
                    -1i32
                } else {
                    Int32.abs(<[unknown exp]>(x$14503, y$14505))
                }
            }
        }
    }
}

def Int32.factorial(x$14918: Int32): Int32 = {
    if (<[unknown exp]>(x$14918, 0i32)) {
        0i32
    } else {
        letrec loop$14921: (Int32 -> Int32 -> Int32) = y$14926 ->
            acc$14928 ->
                match y$14926 {
                    case 0i32 =>
                        acc$14928
                    case _ =>
                        loop$14921(
                            <[unknown exp]>(y$14926, 1i32)
                        )(<[unknown exp]>(y$14926, acc$14928))
                };
        loop$14921(x$14918)(1i32)
    }
}

def Int32.flipBit(pos$14796: { pos = Int32 }, x$14798: Int32): Int32 = {
    Int32.bitwiseXor(x$14798, Int32.leftShift(1i32, pos$14796.pos))
}

def Int32.fromString(s$14945: String): Option[Int32] = {
    try {
        let strip$14949: (String -> String) = obj$$14951 ->
            <[unknown exp]>;
        let parseInt$14959: (String -> Int32) = a0$$14961 ->
            <[unknown exp]>;
        Option.Some(|>(|>(s$14945, strip$14949), parseInt$14959))
    } catch {case _$14977: ##java.lang.NumberFormatException => Option.None}
}

def Int32.getBit(pos$14759: { pos = Int32 }, x$14766: Int32): Int32 = {
    if (
        <[unknown exp]>(
            Int32.remainder(Int32.rightShift(x$14766, pos$14759.pos), 2i32),
            0i32
        )
    ) {
        0i32
    } else {
        1i32
    }
}

def Int32.highestOneBit(x$14724: Int32): Int32 = {
    Int32.bitPositionToInt32(Int32.highestOneBitPosition(x$14724))
}

def Int32.highestOneBitPosition(x$14669: Int32): Int32 = {
    Int32.oneBitPositionHelper(
        x$14669,
        <[unknown exp]>(Int32.size(()), 1i32),
        -1i32
    )
}

def Int32.intValue(i$24677: java.lang.Integer): Int32 = {
    let intValue$24687: (java.lang.Integer -> Int32) = obj$$24690 ->
        <[unknown exp]>;
    intValue$24687(i$24677)
}

def Int32.leftShift(x$14831: Int32, y$14833: Int32): Int32 = {
    x$14831 shl y$14833
}

def Int32.log2(x$14810: Int32): Int32 = {
    if (<[unknown exp]>(x$14810, 0i32)) {
        0i32
    } else {
        Int32.highestOneBitPosition(x$14810)
    }
}

def Int32.logicalRightShift(
    dist$14565: { dist = Int32 },
    x$14569: Int32
): Int32 = {
    if (
        <[unknown exp]>(
            x$14569,
            0i32
        ) and <[unknown exp]>(
            Int32.remainder(dist$14565.dist, Int32.size(())),
            0i32
        )
    ) {
        Int32.rightShift(
            Int32.bitwiseAnd(
                Int32.rightShift(x$14569, 1i32),
                Int32.maxValue(())
            ),
            <[unknown exp]>(dist$14565.dist, 1i32)
        )
    } else {
        Int32.rightShift(x$14569, dist$14565.dist)
    }
}

def Int32.lowestOneBit(x$14732: Int32): Int32 = {
    Int32.bitPositionToInt32(Int32.lowestOneBitPosition(x$14732))
}

def Int32.lowestOneBitPosition(x$14677: Int32): Int32 = {
    Int32.oneBitPositionHelper(x$14677, 0i32, 1i32)
}

def Int32.max(x$14423: Int32, y$14428: Int32): Int32 = {
    if (<[unknown exp]>(x$14423, y$14428)) {x$14423} else {y$14428}
}

def Int32.maxValue(_unit$14400: Unit): Int32 = {
    Int32.bitwiseNot(Int32.minValue(()))
}

def Int32.min(x$14407: Int32, y$14410: Int32): Int32 = {
    if (<[unknown exp]>(x$14407, y$14410)) {x$14407} else {y$14410}
}

def Int32.minValue(_unit$14391: Unit): Int32 = {
    Int32.leftShift(1i32, <[unknown exp]>(Int32.size(()), 1i32))
}

def Int32.modulo(x$14466: Int32, n$14468: Int32): Int32 = {
    if (<[unknown exp]>(n$14468, 0i32)) {
        0i32
    } else {
        <[unknown exp]>(x$14466 rem n$14468, n$14468) rem n$14468
    }
}

def Int32.numberOfLeadingZeros(x$14745: Int32): Int32 = {
    <[unknown exp]>(
        <[unknown exp]>(Int32.size(()), 1i32),
        Int32.highestOneBitPosition(x$14745)
    )
}

def Int32.numberOfTrailingZeros(x$14753: Int32): Int32 = {
    if (<[unknown exp]>(x$14753, 0i32)) {
        32i32
    } else {
        Int32.lowestOneBitPosition(x$14753)
    }
}

def Int32.oneBitPositionHelper(
    x$14688: Int32,
    position$14692: Int32,
    delta$14694: Int32
): Int32 = {
    if (<[unknown exp]>(position$14692, 0i32)) {
        -1i32
    } else {
        if (
            <[unknown exp]>(
                position$14692,
                <[unknown exp]>(Int32.size(()), 1i32)
            )
        ) {
            -1i32
        } else {
            if (
                <[unknown exp]>(
                    Int32.getBit({+pos = position$14692 | {}}, x$14688),
                    1i32
                )
            ) {
                position$14692
            } else {
                if (<[unknown exp]>(delta$14694, 0i32)) {
                    -1i32
                } else {
                    Int32.oneBitPositionHelper(
                        x$14688,
                        <[unknown exp]>(position$14692, delta$14694),
                        delta$14694
                    )
                }
            }
        }
    }
}

def Int32.parse(radix$14993: Int32, s$14995: String): Result[String, Int32] = {
    try {
        let strip$15009: (String -> String) = obj$$15011 ->
            <[unknown exp]>;
        let parseInt$15015: (String -> Int32 -> Int32) = a0$$15020 ->
            a1$$15022 ->
                <[unknown exp]>;
        Result.Ok(parseInt$15015(strip$15009(s$14995))(radix$14993))
    } catch {
        case _$15047: ##java.lang.NumberFormatException =>
            Result.Err("""Int32.parse""")
    }
}

def Int32.pow(b$14550: Int32, n$14553: Int32): Int32 = {b$14550 ** n$14553}

def Int32.remainder(x$14489: Int32, n$14492: Int32): Int32 = {
    if (<[unknown exp]>(n$14492, 0i32)) {0i32} else {x$14489 rem n$14492}
}

def Int32.reverse(x$14629: Int32): Int32 = {
    Int32.reverseHelper(x$14629, 0i32, <[unknown exp]>(Int32.size(()), 1i32))
}

def Int32.reverseHelper(
    x$14639: Int32,
    l$14641: Int32,
    r$14643: Int32
): Int32 = {
    if (<[unknown exp]>(l$14641, r$14643)) {
        x$14639
    } else {
        Int32.reverseHelper(
            Int32.swap(x$14639, l$14641, r$14643),
            <[unknown exp]>(l$14641, 1i32),
            <[unknown exp]>(r$14643, 1i32)
        )
    }
}

def Int32.rightShift(x$14838: Int32, y$14840: Int32): Int32 = {
    x$14838 shr y$14840
}

def Int32.rotateLeft(dist$14604: { dist = Int32 }, x$14611: Int32): Int32 = {
    Int32.bitwiseOr(
        Int32.logicalRightShift(
            {+dist = <[unknown exp]>(dist$14604.dist) | {}},
            x$14611
        ),
        Int32.leftShift(x$14611, dist$14604.dist)
    )
}

def Int32.rotateRight(dist$14600: { dist = Int32 }, x$14602: Int32): Int32 = {
    Int32.bitwiseOr(
        Int32.logicalRightShift({+dist = dist$14600.dist | {}}, x$14602),
        Int32.leftShift(x$14602, <[unknown exp]>(dist$14600.dist))
    )
}

def Int32.setBit(pos$14771: { pos = Int32 }, x$14773: Int32): Int32 = {
    Int32.bitwiseOr(x$14773, Int32.leftShift(1i32, pos$14771.pos))
}

def Int32.signum(x$14548: Int32): Int32 = {Int32.compare(x$14548, 0i32)}

def Int32.size(_unit$14375: Unit): Int32 = {32i32}

def Int32.swap(x$14645: Int32, l$14647: Int32, r$14649: Int32): Int32 = {
    match (
        Int32.getBit({+pos = l$14647 | {}}, x$14645),
        Int32.getBit({+pos = r$14649 | {}}, x$14645)
    ) {
        case (1i32, 0i32) =>
            Int32.clearBit(
                {+pos = l$14647 | {}},
                Int32.setBit({+pos = r$14649 | {}}, x$14645)
            )
        case (0i32, 1i32) =>
            Int32.clearBit(
                {+pos = r$14649 | {}},
                Int32.setBit({+pos = l$14647 | {}}, x$14645)
            )
        case _ =>
            x$14645
    }
}

def Int32.toBigDecimal(x$20735: Int32): BigDecimal = {
    let fromInt32$20813: (Int32 -> BigDecimal) = a0$20815 ->
        <[unknown exp]>;
    fromInt32$20813(x$20735)
}

def Int32.toBigInt(x$15280: Int32): BigInt = {
    let i16ValueOf$15282: (Int32 -> java.lang.Integer) = a0$$15284 ->
        <[unknown exp]>;
    let longValue$15334: (java.lang.Integer -> Int64) = obj$$15336 ->
        <[unknown exp]>;
    let asBigInt$15354: (Int64 -> BigInt) = a0$$15357 ->
        <[unknown exp]>;
    |>(|>(i16ValueOf$15282(x$15280), longValue$15334), asBigInt$15354)
}

def Int32.toFloat32(x$18685: Int32): Float32 = {
    let valueOf$19116: (Int32 -> java.lang.Integer) = a0$$19118 ->
        <[unknown exp]>;
    let floatValue$19254: (java.lang.Integer -> Float32) = obj$$19259 ->
        <[unknown exp]>;
    |>(valueOf$19116(x$18685), floatValue$19254)
}

def Int32.toFloat64(x$19374: Int32): Float64 = {
    let valueOf$19378: (Int32 -> java.lang.Integer) = a0$$19384 ->
        <[unknown exp]>;
    let doubleValue$19409: (java.lang.Integer -> Float64) = obj$$19411 ->
        <[unknown exp]>;
    |>(valueOf$19378(x$19374), doubleValue$19409)
}

def Int32.toInt64(x$15181: Int32): Int64 = {
    let valueOf$15194: (Int32 -> java.lang.Integer) = a0$$15198 ->
        <[unknown exp]>;
    let longValue$15215: (java.lang.Integer -> Int64) = obj$$15219 ->
        <[unknown exp]>;
    |>(valueOf$15194(x$15181), longValue$15215)
}

def Int32.toString(x$14936: Int32): String = {<[unknown exp]>(x$14936)}

def Int32.tryToInt16(x$15136: Int32): Option[Int16] = {
    let valueOf$15139: (Int32 -> java.lang.Integer) = a0$$15141 ->
        <[unknown exp]>;
    let shortValue$15147: (java.lang.Integer -> Int16) = obj$$15149 ->
        <[unknown exp]>;
    if (
        <[unknown exp]>(
            x$15136,
            Int16.toInt32(Int16.minValue(()))
        ) or <[unknown exp]>(x$15136, Int16.toInt32(Int16.maxValue(())))
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$15139(x$15136), shortValue$15147))
    }
}

def Int32.tryToInt8(x$15082: Int32): Option[Int8] = {
    let valueOf$15088: (Int32 -> java.lang.Integer) = a0$$15090 ->
        <[unknown exp]>;
    let byteValue$15105: (java.lang.Integer -> Int8) = obj$$15107 ->
        <[unknown exp]>;
    if (
        <[unknown exp]>(
            x$15082,
            Int8.toInt32(Int8.minValue(()))
        ) or <[unknown exp]>(x$15082, Int8.toInt32(Int8.maxValue(())))
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$15088(x$15082), byteValue$15105))
    }
}

def Int32.valueOf(i$24724: Int32): java.lang.Integer = {
    let valueOf$24726: (Int32 -> java.lang.Integer) = a0$$24728 ->
        <[unknown exp]>;
    valueOf$24726(i$24724)
}

def Int64.abs(x$17264: Int64): Int64 = {
    if (<[unknown exp]>(x$17264, 0i64)) {
        x$17264
    } else {
        if (<[unknown exp]>(x$17264, Int64.minValue(()))) {
            -1i64
        } else {
            <[unknown exp]>(x$17264)
        }
    }
}

def Int64.bitCount(x$17568: Int64): Int32 = {
    if (<[unknown exp]>(x$17568, 0i64)) {
        0i32
    } else {
        if (<[unknown exp]>(Int64.remainder(x$17568, 2i64), 0i64)) {
            <[unknown exp]>(
                Int64.bitCount(
                    Int64.logicalRightShift({+dist = 1i32 | {}}, x$17568)
                ),
                1i32
            )
        } else {
            Int64.bitCount(
                Int64.logicalRightShift({+dist = 1i32 | {}}, x$17568)
            )
        }
    }
}

def Int64.bitPositionToInt64(position$17811: Int32): Int64 = {
    if (
        <[unknown exp]>(
            position$17811,
            0i32
        ) or <[unknown exp]>(
            position$17811,
            <[unknown exp]>(Int64.size(()), 1i32)
        )
    ) {
        0i64
    } else {
        Int64.leftShift(1i64, position$17811)
    }
}

def Int64.bitwiseAnd(x$18024: Int64, y$18028: Int64): Int64 = {
    x$18024 + y$18028
}

def Int64.bitwiseNot(x$18046: Int64): Int64 = {!x$18046}

def Int64.bitwiseOr(x$18065: Int64, y$18071: Int64): Int64 = {
    x$18065 or y$18071
}

def Int64.bitwiseXor(x$18081: Int64, y$18087: Int64): Int64 = {
    x$18081 xor y$18087
}

def Int64.clamp(
    min$18496: { min = Int64 },
    max$18499: { max = Int64 },
    x$18507: Int64
): Int64 = {
    if (<[unknown exp]>(x$18507, min$18496.min)) {
        min$18496.min
    } else {
        if (<[unknown exp]>(x$18507, max$18499.max)) {
            max$18499.max
        } else {
            x$18507
        }
    }
}

def Int64.clampToInt16(
    min$18683: { min = Int16 },
    max$18717: { max = Int16 },
    x$18730: Int64
): Int16 = {
    let valueOf$18733: (Int64 -> java.lang.Long) = a0$$18740 ->
        <[unknown exp]>;
    let shortValue$18754: (java.lang.Long -> Int16) = obj$$18756 ->
        <[unknown exp]>;
    let mini64$18768: Int64 = Int16.toInt64(min$18683.min);
    let maxi64$18781: Int64 = Int16.toInt64(max$18717.max);
    |>(
        valueOf$18733(
            Int64.clamp(
                {+min = mini64$18768 | {}},
                {+max = maxi64$18781 | {}},
                x$18730
            )
        ),
        shortValue$18754
    )
}

def Int64.clampToInt32(
    min$18800: { min = Int32 },
    max$18817: { max = Int32 },
    x$18821: Int64
): Int32 = {
    let valueOf$18830: (Int64 -> java.lang.Long) = a0$$18833 ->
        <[unknown exp]>;
    let intValue$18847: (java.lang.Long -> Int32) = obj$$18851 ->
        <[unknown exp]>;
    let mini64$18870: Int64 = Int32.toInt64(min$18800.min);
    let maxi64$18872: Int64 = Int32.toInt64(max$18817.max);
    |>(
        valueOf$18830(
            Int64.clamp(
                {+min = mini64$18870 | {}},
                {+max = maxi64$18872 | {}},
                x$18821
            )
        ),
        intValue$18847
    )
}

def Int64.clampToInt8(
    min$18523: { min = Int8 },
    max$18525: { max = Int8 },
    x$18528: Int64
): Int8 = {
    let valueOf$18532: (Int64 -> java.lang.Long) = a0$$18534 ->
        <[unknown exp]>;
    let byteValue$18545: (java.lang.Long -> Int8) = obj$$18547 ->
        <[unknown exp]>;
    let mini64$18562: Int64 = Int8.toInt64(min$18523.min);
    let maxi64$18568: Int64 = Int8.toInt64(max$18525.max);
    |>(
        valueOf$18532(
            Int64.clamp(
                {+min = mini64$18562 | {}},
                {+max = maxi64$18568 | {}},
                x$18528
            )
        ),
        byteValue$18545
    )
}

def Int64.clearBit(pos$17914: { pos = Int32 }, x$17916: Int64): Int64 = {
    Int64.bitwiseAnd(
        x$17916,
        Int64.bitwiseNot(Int64.leftShift(1i64, pos$17914.pos))
    )
}

def Int64.compare(x$17423: Int64, y$17428: Int64): Int32 = {
    if (<[unknown exp]>(x$17423, y$17428)) {
        0i32
    } else {
        if (<[unknown exp]>(x$17423, y$17428)) {-1i32} else {1i32}
    }
}

def Int64.dist(x$17358: Int64, y$17361: Int64): Int64 = {
    if (<[unknown exp]>(x$17358, 0i64) and <[unknown exp]>(y$17361, 0i64)) {
        Int64.abs(<[unknown exp]>(x$17358, y$17361))
    } else {
        if (<[unknown exp]>(x$17358, 0i64) and <[unknown exp]>(y$17361, 0i64)) {
            Int64.abs(<[unknown exp]>(x$17358, y$17361))
        } else {
            if (
                <[unknown exp]>(
                    x$17358,
                    Int64.minValue(())
                ) or <[unknown exp]>(y$17361, Int64.minValue(()))
            ) {
                -1i64
            } else {
                if (
                    <[unknown exp]>(
                        <[unknown exp]>(
                            <[unknown exp]>(
                                Int64.minValue(()),
                                Int64.abs(x$17358)
                            ),
                            Int64.abs(y$17361)
                        ),
                        0i64
                    )
                ) {
                    -1i64
                } else {
                    Int64.abs(<[unknown exp]>(x$17358, y$17361))
                }
            }
        }
    }
}

def Int64.factorial(x$18110: Int64): Int64 = {
    if (<[unknown exp]>(x$18110, 0i64)) {
        0i64
    } else {
        letrec loop$18122: (Int64 -> Int64 -> Int64) = y$18128 ->
            acc$18130 ->
                match y$18128 {
                    case 0i64 =>
                        acc$18130
                    case _ =>
                        loop$18122(
                            <[unknown exp]>(y$18128, 1i64)
                        )(<[unknown exp]>(y$18128, acc$18130))
                };
        loop$18122(x$18110)(1i64)
    }
}

def Int64.flipBit(pos$17938: { pos = Int32 }, x$17940: Int64): Int64 = {
    Int64.bitwiseXor(x$17940, Int64.leftShift(1i64, pos$17938.pos))
}

def Int64.fromString(s$18165: String): Option[Int64] = {
    try {
        let strip$18172: (String -> String) = obj$$18174 ->
            <[unknown exp]>;
        let parseLong$18181: (String -> Int64) = a0$$18183 ->
            <[unknown exp]>;
        Option.Some(|>(|>(s$18165, strip$18172), parseLong$18181))
    } catch {case _$18197: ##java.lang.NumberFormatException => Option.None}
}

def Int64.getBit(pos$17857: { pos = Int32 }, x$17866: Int64): Int32 = {
    if (
        <[unknown exp]>(
            Int64.remainder(Int64.rightShift(x$17866, pos$17857.pos), 2i64),
            0i64
        )
    ) {
        0i32
    } else {
        1i32
    }
}

def Int64.highestOneBit(x$17768: Int64): Int64 = {
    Int64.bitPositionToInt64(Int64.highestOneBitPosition(x$17768))
}

def Int64.highestOneBitPosition(x$17702: Int64): Int32 = {
    Int64.oneBitPositionHelper(
        x$17702,
        <[unknown exp]>(Int64.size(()), 1i32),
        -1i32
    )
}

def Int64.leftShift(x$17978: Int64, y$17981: Int32): Int64 = {
    x$17978 shl y$17981
}

def Int64.log2(x$17958: Int64): Int64 = {
    if (<[unknown exp]>(x$17958, 0i64)) {
        0i64
    } else {
        |>(
            Int64.highestOneBitPosition(x$17958),
            $0$45987 ->
                Int32.toInt64($0$45987)
        )
    }
}

def Int64.logicalRightShift(
    dist$17510: { dist = Int32 },
    x$17518: Int64
): Int64 = {
    if (
        <[unknown exp]>(
            x$17518,
            0i64
        ) and <[unknown exp]>(
            Int32.remainder(dist$17510.dist, Int64.size(())),
            0i32
        )
    ) {
        Int64.rightShift(
            Int64.bitwiseAnd(
                Int64.rightShift(x$17518, 1i32),
                Int64.maxValue(())
            ),
            <[unknown exp]>(dist$17510.dist, 1i32)
        )
    } else {
        Int64.rightShift(x$17518, dist$17510.dist)
    }
}

def Int64.longValue(i$19043: java.lang.Long): Int64 = {
    let longValue$19081: (java.lang.Long -> Int64) = obj$$19083 ->
        <[unknown exp]>;
    longValue$19081(i$19043)
}

def Int64.lowestOneBit(x$17790: Int64): Int64 = {
    Int64.bitPositionToInt64(Int64.lowestOneBitPosition(x$17790))
}

def Int64.lowestOneBitPosition(x$17718: Int64): Int32 = {
    Int64.oneBitPositionHelper(x$17718, 0i32, 1i32)
}

def Int64.max(x$17249: Int64, y$17256: Int64): Int64 = {
    if (<[unknown exp]>(x$17249, y$17256)) {x$17249} else {y$17256}
}

def Int64.maxValue(_unit$17210: Unit): Int64 = {
    Int64.bitwiseNot(Int64.minValue(()))
}

def Int64.min(x$17228: Int64, y$17232: Int64): Int64 = {
    if (<[unknown exp]>(x$17228, y$17232)) {x$17228} else {y$17232}
}

def Int64.minValue(_unit$17183: Unit): Int64 = {
    Int64.leftShift(1i64, <[unknown exp]>(Int64.size(()), 1i32))
}

def Int64.modulo(x$17289: Int64, n$17295: Int64): Int64 = {
    if (<[unknown exp]>(n$17295, 0i64)) {
        0i64
    } else {
        <[unknown exp]>(x$17289 rem n$17295, n$17295) rem n$17295
    }
}

def Int64.numberOfLeadingZeros(x$17824: Int64): Int32 = {
    if (<[unknown exp]>(x$17824, 0i64)) {
        Int64.size(())
    } else {
        <[unknown exp]>(
            <[unknown exp]>(Int64.size(()), 1i32),
            Int64.highestOneBitPosition(x$17824)
        )
    }
}

def Int64.numberOfTrailingZeros(x$17841: Int64): Int32 = {
    if (<[unknown exp]>(x$17841, 0i64)) {
        Int64.size(())
    } else {
        Int64.lowestOneBitPosition(x$17841)
    }
}

def Int64.oneBitPositionHelper(
    x$17733: Int64,
    position$17735: Int32,
    delta$17737: Int32
): Int32 = {
    if (<[unknown exp]>(position$17735, 0i32)) {
        -1i32
    } else {
        if (
            <[unknown exp]>(
                position$17735,
                <[unknown exp]>(Int64.size(()), 1i32)
            )
        ) {
            -1i32
        } else {
            if (
                <[unknown exp]>(
                    Int64.getBit({+pos = position$17735 | {}}, x$17733),
                    1i32
                )
            ) {
                position$17735
            } else {
                if (<[unknown exp]>(delta$17737, 0i32)) {
                    -1i32
                } else {
                    Int64.oneBitPositionHelper(
                        x$17733,
                        <[unknown exp]>(position$17735, delta$17737),
                        delta$17737
                    )
                }
            }
        }
    }
}

def Int64.parse(radix$18222: Int32, s$18232: String): Result[String, Int64] = {
    try {
        let strip$18236: (String -> String) = obj$$18240 ->
            <[unknown exp]>;
        let parseLong$18246: (String -> Int32 -> Int64) = a0$$18248 ->
            a1$$18250 ->
                <[unknown exp]>;
        Result.Ok(parseLong$18246(strip$18236(s$18232))(radix$18222))
    } catch {
        case _$18257: ##java.lang.NumberFormatException =>
            Result.Err("""Int64.parse""")
    }
}

def Int64.pow(b$17470: Int64, n$17474: Int64): Int64 = {b$17470 ** n$17474}

def Int64.remainder(x$17354: Int64, n$17356: Int64): Int64 = {
    if (<[unknown exp]>(n$17356, 0i64)) {0i64} else {x$17354 rem n$17356}
}

def Int64.reverse(x$17629: Int64): Int64 = {
    Int64.reverseHelper(x$17629, 0i32, <[unknown exp]>(Int64.size(()), 1i32))
}

def Int64.reverseHelper(
    x$17656: Int64,
    l$17658: Int32,
    r$17660: Int32
): Int64 = {
    if (<[unknown exp]>(l$17658, r$17660)) {
        x$17656
    } else {
        Int64.reverseHelper(
            Int64.swap(x$17656, l$17658, r$17660),
            <[unknown exp]>(l$17658, 1i32),
            <[unknown exp]>(r$17660, 1i32)
        )
    }
}

def Int64.rightShift(x$18006: Int64, y$18008: Int32): Int64 = {
    x$18006 shr y$18008
}

def Int64.rotateLeft(dist$17614: { dist = Int32 }, x$17617: Int64): Int64 = {
    Int64.bitwiseOr(
        Int64.logicalRightShift(
            {+dist = <[unknown exp]>(dist$17614.dist) | {}},
            x$17617
        ),
        Int64.leftShift(x$17617, dist$17614.dist)
    )
}

def Int64.rotateRight(dist$17600: { dist = Int32 }, x$17602: Int64): Int64 = {
    Int64.bitwiseOr(
        Int64.logicalRightShift({+dist = dist$17600.dist | {}}, x$17602),
        Int64.leftShift(x$17602, <[unknown exp]>(dist$17600.dist))
    )
}

def Int64.setBit(pos$17884: { pos = Int32 }, x$17891: Int64): Int64 = {
    Int64.bitwiseOr(x$17891, Int64.leftShift(1i64, pos$17884.pos))
}

def Int64.signum(x$17463: Int64): Int32 = {Int64.compare(x$17463, 0i64)}

def Int64.size(_unit$17157: Unit): Int32 = {64i32}

def Int64.swap(x$17676: Int64, l$17679: Int32, r$17683: Int32): Int64 = {
    match (
        Int64.getBit({+pos = l$17679 | {}}, x$17676),
        Int64.getBit({+pos = r$17683 | {}}, x$17676)
    ) {
        case (1i32, 0i32) =>
            Int64.clearBit(
                {+pos = l$17679 | {}},
                Int64.setBit({+pos = r$17683 | {}}, x$17676)
            )
        case (0i32, 1i32) =>
            Int64.clearBit(
                {+pos = r$17683 | {}},
                Int64.setBit({+pos = l$17679 | {}}, x$17676)
            )
        case _ =>
            x$17676
    }
}

def Int64.toBigDecimal(x$18475: Int64): BigDecimal = {
    let fromInt64$18484: (Int64 -> BigDecimal) = a0$18486 ->
        <[unknown exp]>;
    fromInt64$18484(x$18475)
}

def Int64.toBigInt(x$18385: Int64): BigInt = {
    let i64ValueOf$18389: (Int64 -> java.lang.Long) = a0$$18392 ->
        <[unknown exp]>;
    let longValue$18396: (java.lang.Long -> Int64) = obj$$18399 ->
        <[unknown exp]>;
    let asBigInt$18402: (Int64 -> BigInt) = a0$$18406 ->
        <[unknown exp]>;
    |>(|>(i64ValueOf$18389(x$18385), longValue$18396), asBigInt$18402)
}

def Int64.toFloat32(x$18418: Int64): Float32 = {
    let valueOf$18424: (Int64 -> java.lang.Long) = a0$$18426 ->
        <[unknown exp]>;
    let floatValue$18435: (java.lang.Long -> Float32) = obj$$18437 ->
        <[unknown exp]>;
    |>(valueOf$18424(x$18418), floatValue$18435)
}

def Int64.toFloat64(x$18442: Int64): Float64 = {
    let valueOf$18447: (Int64 -> java.lang.Long) = a0$$18449 ->
        <[unknown exp]>;
    let doubleValue$18453: (java.lang.Long -> Float64) = obj$$18458 ->
        <[unknown exp]>;
    |>(valueOf$18447(x$18442), doubleValue$18453)
}

def Int64.toString(x$18146: Int64): String = {<[unknown exp]>(x$18146)}

def Int64.tryToInt16(x$18316: Int64): Option[Int16] = {
    let valueOf$18318: (Int64 -> java.lang.Long) = a0$$18320 ->
        <[unknown exp]>;
    let shortValue$18330: (java.lang.Long -> Int16) = obj$$18333 ->
        <[unknown exp]>;
    if (
        <[unknown exp]>(
            x$18316,
            Int16.toInt64(Int16.minValue(()))
        ) or <[unknown exp]>(x$18316, Int16.toInt64(Int16.maxValue(())))
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$18318(x$18316), shortValue$18330))
    }
}

def Int64.tryToInt32(x$18354: Int64): Option[Int32] = {
    let valueOf$18362: (Int64 -> java.lang.Long) = a0$$18364 ->
        <[unknown exp]>;
    let intValue$18371: (java.lang.Long -> Int32) = obj$$18373 ->
        <[unknown exp]>;
    if (
        <[unknown exp]>(
            x$18354,
            Int32.toInt64(Int32.minValue(()))
        ) or <[unknown exp]>(x$18354, Int32.toInt64(Int32.maxValue(())))
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$18362(x$18354), intValue$18371))
    }
}

def Int64.tryToInt8(x$18274: Int64): Option[Int8] = {
    let valueOf$18280: (Int64 -> java.lang.Long) = a0$$18282 ->
        <[unknown exp]>;
    let byteValue$18285: (java.lang.Long -> Int8) = obj$$18287 ->
        <[unknown exp]>;
    if (
        <[unknown exp]>(
            x$18274,
            Int8.toInt64(Int8.minValue(()))
        ) or <[unknown exp]>(x$18274, Int8.toInt64(Int8.maxValue(())))
    ) {
        Option.None
    } else {
        Option.Some(|>(valueOf$18280(x$18274), byteValue$18285))
    }
}

def Int64.valueOf(i$19108: Int64): java.lang.Long = {
    let valueOf$19125: (Int64 -> java.lang.Long) = a0$$19128 ->
        <[unknown exp]>;
    valueOf$19125(i$19108)
}

def Int8.abs(x$20386: Int8): Int8 = {
    if (<[unknown exp]>(x$20386, 0i8)) {
        x$20386
    } else {
        if (<[unknown exp]>(x$20386, Int8.minValue(()))) {
            -1i8
        } else {
            <[unknown exp]>(x$20386)
        }
    }
}

def Int8.bitCount(x$20527: Int8): Int32 = {
    if (<[unknown exp]>(x$20527, 0i8)) {
        0i32
    } else {
        if (<[unknown exp]>(Int8.remainder(x$20527, 2i8), 0i8)) {
            <[unknown exp]>(
                Int8.bitCount(
                    Int8.logicalRightShift({+dist = 1i32 | {}}, x$20527)
                ),
                1i32
            )
        } else {
            Int8.bitCount(Int8.logicalRightShift({+dist = 1i32 | {}}, x$20527))
        }
    }
}

def Int8.bitPositionToInt8(position$20872: Int32): Int8 = {
    if (
        <[unknown exp]>(
            position$20872,
            0i32
        ) or <[unknown exp]>(
            position$20872,
            <[unknown exp]>(Int8.size(()), 1i32)
        )
    ) {
        0i8
    } else {
        Int8.leftShift(1i8, position$20872)
    }
}

def Int8.bitwiseAnd(x$22755: Int8, y$22757: Int8): Int8 = {x$22755 and y$22757}

def Int8.bitwiseNot(x$22779: Int8): Int8 = {!x$22779}

def Int8.bitwiseOr(x$22793: Int8, y$22796: Int8): Int8 = {x$22793 or y$22796}

def Int8.bitwiseXor(x$22822: Int8, y$22826: Int8): Int8 = {x$22822 xor y$22826}

def Int8.byteValue(i$27804: java.lang.Byte): Int8 = {
    let byteValue$27810: (java.lang.Byte -> Int8) = obj$$27812 ->
        <[unknown exp]>;
    byteValue$27810(i$27804)
}

def Int8.clearBit(pos$22629: { pos = Int32 }, x$22637: Int8): Int8 = {
    Int8.bitwiseAnd(
        x$22637,
        Int8.bitwiseNot(Int8.leftShift(1i8, pos$22629.pos))
    )
}

def Int8.compare(x$20462: Int8, y$20472: Int8): Int32 = {
    if (<[unknown exp]>(x$20462, y$20472)) {
        0i32
    } else {
        if (<[unknown exp]>(x$20462, y$20472)) {-1i32} else {1i32}
    }
}

def Int8.dist(x$20437: Int8, y$20440: Int8): Int8 = {
    if (<[unknown exp]>(x$20437, 0i8) and <[unknown exp]>(y$20440, 0i8)) {
        Int8.abs(<[unknown exp]>(x$20437, y$20440))
    } else {
        if (<[unknown exp]>(x$20437, 0i8) and <[unknown exp]>(y$20440, 0i8)) {
            Int8.abs(<[unknown exp]>(x$20437, y$20440))
        } else {
            if (
                <[unknown exp]>(
                    x$20437,
                    Int8.minValue(())
                ) or <[unknown exp]>(y$20440, Int8.minValue(()))
            ) {
                -1i8
            } else {
                if (
                    <[unknown exp]>(
                        <[unknown exp]>(
                            <[unknown exp]>(
                                Int8.minValue(()),
                                Int8.abs(x$20437)
                            ),
                            Int8.abs(y$20440)
                        ),
                        0i8
                    )
                ) {
                    -1i8
                } else {
                    Int8.abs(<[unknown exp]>(x$20437, y$20440))
                }
            }
        }
    }
}

def Int8.factorial(x$22836: Int8): Int32 = {
    |>(Int8.toInt32(x$22836), $0$46160 -> Int32.factorial($0$46160))
}

def Int8.flipBit(pos$22670: { pos = Int32 }, x$22675: Int8): Int8 = {
    Int8.bitwiseXor(x$22675, Int8.leftShift(1i8, pos$22670.pos))
}

def Int8.fromString(s$22873: String): Option[Int8] = {
    try {
        let strip$22877: (String -> String) = obj$$22879 ->
            <[unknown exp]>;
        let parseByte$22889: (String -> Int8) = a0$$22892 ->
            <[unknown exp]>;
        Option.Some(|>(|>(s$22873, strip$22877), parseByte$22889))
    } catch {case _$22899: ##java.lang.NumberFormatException => Option.None}
}

def Int8.getBit(pos$22099: { pos = Int32 }, x$22256: Int8): Int32 = {
    if (
        <[unknown exp]>(
            Int8.remainder(Int8.rightShift(x$22256, pos$22099.pos), 2i8),
            0i8
        )
    ) {
        0i32
    } else {
        1i32
    }
}

def Int8.highestOneBit(x$20817: Int8): Int8 = {
    Int8.bitPositionToInt8(Int8.highestOneBitPosition(x$20817))
}

def Int8.highestOneBitPosition(x$20634: Int8): Int32 = {
    Int8.oneBitPositionHelper(
        x$20634,
        <[unknown exp]>(Int8.size(()), 1i32),
        -1i32
    )
}

def Int8.leftShift(x$22712: Int8, y$22717: Int32): Int8 = {x$22712 shl y$22717}

def Int8.log2(x$22688: Int8): Int8 = {
    if (<[unknown exp]>(x$22688, 0i8)) {
        0i8
    } else {
        let position$22697: Int32 = Int8.highestOneBitPosition(x$22688);
        Int32.clampToInt8(
            {+min = 0i8 | {}},
            {+max = Int8.maxValue(()) | {}},
            position$22697
        )
    }
}

def Int8.logicalRightShift(
    dist$20515: { dist = Int32 },
    x$20524: Int8
): Int8 = {
    if (
        <[unknown exp]>(
            x$20524,
            0i8
        ) and <[unknown exp]>(Int32.remainder(dist$20515.dist, 32i32), 0i32)
    ) {
        Int8.rightShift(
            Int8.bitwiseAnd(Int8.rightShift(x$20524, 1i32), Int8.maxValue(())),
            <[unknown exp]>(dist$20515.dist, 1i32)
        )
    } else {
        Int8.rightShift(x$20524, dist$20515.dist)
    }
}

def Int8.lowestOneBit(x$20853: Int8): Int8 = {
    Int8.bitPositionToInt8(Int8.lowestOneBitPosition(x$20853))
}

def Int8.lowestOneBitPosition(x$20676: Int8): Int32 = {
    Int8.oneBitPositionHelper(x$20676, 0i32, 1i32)
}

def Int8.max(x$20376: Int8, y$20378: Int8): Int8 = {
    if (<[unknown exp]>(x$20376, y$20378)) {x$20376} else {y$20378}
}

def Int8.maxValue(_unit$20352: Unit): Int8 = {
    Int8.bitwiseNot(Int8.minValue(()))
}

def Int8.min(x$20368: Int8, y$20370: Int8): Int8 = {
    if (<[unknown exp]>(x$20368, y$20370)) {x$20368} else {y$20370}
}

def Int8.minValue(_unit$20343: Unit): Int8 = {
    Int8.leftShift(1i8, <[unknown exp]>(Int8.size(()), 1i32))
}

def Int8.modulo(x$20403: Int8, n$20406: Int8): Int8 = {
    if (<[unknown exp]>(n$20406, 0i8)) {
        0i8
    } else {
        <[unknown exp]>(x$20403 rem n$20406, n$20406) rem n$20406
    }
}

def Int8.numberOfLeadingZeros(x$20892: Int8): Int32 = {
    if (<[unknown exp]>(x$20892, 0i8)) {
        Int8.size(())
    } else {
        <[unknown exp]>(
            <[unknown exp]>(Int8.size(()), 1i32),
            Int8.highestOneBitPosition(x$20892)
        )
    }
}

def Int8.numberOfTrailingZeros(x$20904: Int8): Int32 = {
    if (<[unknown exp]>(x$20904, 0i8)) {
        Int8.size(())
    } else {
        Int8.lowestOneBitPosition(x$20904)
    }
}

def Int8.oneBitPositionHelper(
    x$20719: Int8,
    position$20721: Int32,
    delta$20725: Int32
): Int32 = {
    if (<[unknown exp]>(position$20721, 0i32)) {
        -1i32
    } else {
        if (
            <[unknown exp]>(
                position$20721,
                <[unknown exp]>(Int8.size(()), 1i32)
            )
        ) {
            -1i32
        } else {
            if (
                <[unknown exp]>(
                    Int8.getBit({+pos = position$20721 | {}}, x$20719),
                    1i32
                )
            ) {
                position$20721
            } else {
                if (<[unknown exp]>(delta$20725, 0i32)) {
                    -1i32
                } else {
                    Int8.oneBitPositionHelper(
                        x$20719,
                        <[unknown exp]>(position$20721, delta$20725),
                        delta$20725
                    )
                }
            }
        }
    }
}

def Int8.pow(b$20500: Int8, n$20502: Int8): Int8 = {b$20500 ** n$20502}

def Int8.remainder(x$20424: Int8, n$20426: Int8): Int8 = {
    if (<[unknown exp]>(n$20426, 0i8)) {0i8} else {x$20424 rem n$20426}
}

def Int8.reverse(x$20577: Int8): Int8 = {
    Int8.reverseHelper(x$20577, 0i32, <[unknown exp]>(Int8.size(()), 1i32))
}

def Int8.reverseHelper(x$20583: Int8, l$20588: Int32, r$20590: Int32): Int8 = {
    if (<[unknown exp]>(l$20588, r$20590)) {
        x$20583
    } else {
        Int8.reverseHelper(
            Int8.swap(x$20583, l$20588, r$20590),
            <[unknown exp]>(l$20588, 1i32),
            <[unknown exp]>(r$20590, 1i32)
        )
    }
}

def Int8.rightShift(x$22734: Int8, y$22740: Int32): Int8 = {x$22734 shr y$22740}

def Int8.rotateLeft(dist$20559: { dist = Int32 }, x$20561: Int8): Int8 = {
    let rem1$20563: Int32 = Int32.remainder(dist$20559.dist, Int8.size(()));
    let rot$20565: Int32 = if (<[unknown exp]>(rem1$20563, 0i32)) {
        rem1$20563
    } else {
        <[unknown exp]>(rem1$20563, Int8.size(()))
    };
    Int8.bitwiseOr(
        Int8.logicalRightShift(
            {+dist = <[unknown exp]>(Int8.size(()), rot$20565) | {}},
            x$20561
        ),
        Int8.leftShift(x$20561, rot$20565)
    )
}

def Int8.rotateRight(dist$20539: { dist = Int32 }, x$20542: Int8): Int8 = {
    let rem1$20544: Int32 = Int32.remainder(dist$20539.dist, Int8.size(()));
    let rot$20547: Int32 = if (<[unknown exp]>(rem1$20544, 0i32)) {
        rem1$20544
    } else {
        <[unknown exp]>(rem1$20544, Int8.size(()))
    };
    Int8.bitwiseOr(
        Int8.logicalRightShift({+dist = rot$20547 | {}}, x$20542),
        Int8.leftShift(x$20542, <[unknown exp]>(Int8.size(()), rot$20547))
    )
}

def Int8.setBit(pos$22503: { pos = Int32 }, x$22513: Int8): Int8 = {
    Int8.bitwiseOr(x$22513, Int8.leftShift(1i8, pos$22503.pos))
}

def Int8.signum(x$20487: Int8): Int32 = {Int8.compare(x$20487, 0i8)}

def Int8.size(_unit$20334: Unit): Int32 = {8i32}

def Int8.swap(x$20599: Int8, l$20601: Int32, r$20604: Int32): Int8 = {
    match (
        Int8.getBit({+pos = l$20601 | {}}, x$20599),
        Int8.getBit({+pos = r$20604 | {}}, x$20599)
    ) {
        case (1i32, 0i32) =>
            Int8.clearBit(
                {+pos = l$20601 | {}},
                Int8.setBit({+pos = r$20604 | {}}, x$20599)
            )
        case (0i32, 1i32) =>
            Int8.clearBit(
                {+pos = r$20604 | {}},
                Int8.setBit({+pos = l$20601 | {}}, x$20599)
            )
        case _ =>
            x$20599
    }
}

def Int8.toBigDecimal(x$24125: Int8): BigDecimal = {
    let fromInt32$27027: (Int32 -> BigDecimal) = a0$27029 ->
        <[unknown exp]>;
    |>(Int8.toInt32(x$24125), fromInt32$27027)
}

def Int8.toBigInt(x$23808: Int8): BigInt = {
    let i8ValueOf$23815: (Int8 -> java.lang.Byte) = a0$$23844 ->
        <[unknown exp]>;
    let longValue$23847: (java.lang.Byte -> Int64) = obj$$23850 ->
        <[unknown exp]>;
    let asBigInt$23909: (Int64 -> BigInt) = a0$$23911 ->
        <[unknown exp]>;
    |>(|>(i8ValueOf$23815(x$23808), longValue$23847), asBigInt$23909)
}

def Int8.toFloat32(x$23930: Int8): Float32 = {
    let valueOf$23942: (Int8 -> java.lang.Byte) = a0$$23944 ->
        <[unknown exp]>;
    let floatValue$23956: (java.lang.Byte -> Float32) = obj$$23958 ->
        <[unknown exp]>;
    |>(valueOf$23942(x$23930), floatValue$23956)
}

def Int8.toFloat64(x$23997: Int8): Float64 = {
    let valueOf$24003: (Int8 -> java.lang.Byte) = a0$$24005 ->
        <[unknown exp]>;
    let doubleValue$24032: (java.lang.Byte -> Float64) = obj$$24034 ->
        <[unknown exp]>;
    |>(valueOf$24003(x$23997), doubleValue$24032)
}

def Int8.toInt16(x$22919: Int8): Int16 = {
    let valueOf$22927: (Int8 -> java.lang.Byte) = a0$$22929 ->
        <[unknown exp]>;
    let shortValue$22938: (java.lang.Byte -> Int16) = obj$$22940 ->
        <[unknown exp]>;
    |>(valueOf$22927(x$22919), shortValue$22938)
}

def Int8.toInt32(x$22955: Int8): Int32 = {
    let valueOf$22963: (Int8 -> java.lang.Byte) = a0$$22965 ->
        <[unknown exp]>;
    let intValue$22969: (java.lang.Byte -> Int32) = obj$$22971 ->
        <[unknown exp]>;
    |>(valueOf$22963(x$22955), intValue$22969)
}

def Int8.toInt64(x$22987: Int8): Int64 = {
    let valueOf$22994: (Int8 -> java.lang.Byte) = a0$$22996 ->
        <[unknown exp]>;
    let longValue$22998: (java.lang.Byte -> Int64) = obj$$23000 ->
        <[unknown exp]>;
    |>(valueOf$22994(x$22987), longValue$22998)
}

def Int8.toString(x$22853: Int8): String = {<[unknown exp]>(x$22853)}

def Int8.valueOf(i$27836: Int8): java.lang.Byte = {
    let valueOf$27838: (Int8 -> java.lang.Byte) = a0$$27840 ->
        <[unknown exp]>;
    valueOf$27838(i$27836)
}

enum Iterator[a, ef, r] {case Iterator(Region[r], Unit -> Step[a] \ r + ef)}

def Iterator.append(
    iter1$4539: Iterator[a, ef1, r],
    iter2$4558: Iterator[a, ef2, r]
): Iterator[a, ef1 + ef2, r] = {
    match iter1$4539 {
        case Iterator.Iterator(rc$4582, iter1F$4584) =>
            match iter2$4558 {
                case Iterator.Iterator(_, iter2F$4588) =>
                    letrec loop2$4592: (Step[a] -> Step[a]) = x$4594 ->
                        match x$4594 {
                            case Iterator.Step.Ans(a$4598) =>
                                Iterator.Step.Ans(a$4598)
                            case Iterator.Step.Skip =>
                                loop2$4592(iter2F$4588(()))
                            case Iterator.Step.Done =>
                                Iterator.Step.Done
                        };
                    letrec loop1$4603: (Step[a] -> Step[a]) = x$4605 ->
                        match x$4605 {
                            case Iterator.Step.Ans(a$4608) =>
                                Iterator.Step.Ans(a$4608)
                            case Iterator.Step.Skip =>
                                loop1$4603(iter1F$4584(()))
                            case Iterator.Step.Done =>
                                loop2$4592(iter2F$4588(()))
                        };
                    let iter3F$4616: (Unit -> Step[a]) = _unit$4618 ->
                        loop1$4603(iter1F$4584(()));
                    Iterator.Iterator(rc$4582, iter3F$4616)
            }
    }
}

def Iterator.cons(
    x$6417: a,
    iter$6422: Iterator[a, ef, r]
): Iterator[a, ef, r] \ r = {
    match iter$6422 {
        case Iterator.Iterator(rc$6427, iterF$6431) =>
            let first$6433: Ref[Bool, r] = (ref true) @ rc$6427;
            let f$6437: (Unit -> Step[a]) = _unit$6439 ->
                if (deref first$6433) {
                    Ref.put(false, first$6433); Iterator.Step.Ans(x$6417)
                } else {
                    iterF$6431(())
                };
            let iter1F$6446: (Unit -> Step[a]) = _unit$6448 ->
                f$6437(());
            Iterator.Iterator(rc$6427, iter1F$6446)
    }
}

def Iterator.drop(
    n$5531: Int32,
    iter$5534: Iterator[a, ef, r]
): Iterator[a, ef + r, r] \ r = {
    match iter$5534 {
        case Iterator.Iterator(rc$5536, iterF$5538) =>
            let ix$5541: Ref[Int32, r] = (ref n$5531) @ rc$5536;
            letrec loop$5546: (Unit -> Step[a]) = _unit$5550 ->
                {
                    let i$5556: Int32 = deref ix$5541;
                    Ref.put(<[unknown exp]>(i$5556, 1i32), ix$5541);
                    match iterF$5538(()) {
                        case Iterator.Step.Ans(a$5570) =>
                            if (<[unknown exp]>(i$5556, 0i32)) {
                                loop$5546(())
                            } else {
                                Iterator.Step.Ans(a$5570)
                            }
                        case Iterator.Step.Skip =>
                            loop$5546(())
                        case Iterator.Step.Done =>
                            Iterator.Step.Done
                    }
                };
            let iter1F$5588: (Unit -> Step[a]) = _unit$5590 ->
                loop$5546(());
            Iterator.Iterator(rc$5536, iter1F$5588)
    }
}

def Iterator.dropWhile(
    f$5802: a -> Bool,
    iter$5808: Iterator[a, ef1, r]
): Iterator[a, r + ef1 + ef2, r] \ r = {
    match iter$5808 {
        case Iterator.Iterator(rc$5820, iterF$5826) =>
            let start$5829: Ref[Bool, r] = (ref true) @ rc$5820;
            letrec loop$5831: (Unit -> Step[a]) = _unit$5834 ->
                match iterF$5826(()) {
                    case Iterator.Step.Ans(a$5842) =>
                        if (deref start$5829) {
                            if (f$5802(a$5842)) {
                                Iterator.Step.Skip
                            } else {
                                Ref.put(false, start$5829);
                                Iterator.Step.Ans(a$5842)
                            }
                        } else {
                            Iterator.Step.Ans(a$5842)
                        }
                    case Iterator.Step.Skip =>
                        Iterator.Step.Skip
                    case Iterator.Step.Done =>
                        Iterator.Step.Done
                };
            let iter1F$5860: (Unit -> Step[a]) = _unit$5862 ->
                loop$5831(());
            Iterator.Iterator(rc$5820, iter1F$5860)
    }
}

def Iterator.empty(rc$513: Region[r]): Iterator[a, r, r] = {
    let f$515: (Unit -> Step[a]) = constant(Iterator.Step.Done);
    Iterator.Iterator(rc$513, f$515)
}

def Iterator.enumerator(
    iter$5075: Iterator[a, ef, r]
): Iterator[(Int32, a), ef + r, r] \ r = {
    Iterator.zipWithIndex(iter$5075)
}

def Iterator.filter(
    f$1170: a -> Bool,
    iter$1179: Iterator[a, ef1, r]
): Iterator[a, ef1 + ef2, r] = {
    match iter$1179 {
        case Iterator.Iterator(rc$1185, iterF$1187) =>
            let step$1191: (Step[a] -> Step[a]) = x$1193 ->
                match x$1193 {
                    case Iterator.Step.Ans(a$1195) =>
                        if (f$1170(a$1195)) {
                            Iterator.Step.Ans(a$1195)
                        } else {
                            Iterator.Step.Skip
                        }
                    case Iterator.Step.Skip =>
                        Iterator.Step.Skip
                    case Iterator.Step.Done =>
                        Iterator.Step.Done
                };
            let iterF1$1203: (Unit -> Step[a]) = _unit$1205 ->
                step$1191(iterF$1187(()));
            Iterator.Iterator(rc$1185, iterF1$1203)
    }
}

def Iterator.filterMap(
    f$6348: a -> Option[b],
    iter$6362: Iterator[a, ef1, r]
): Iterator[b, ef1 + ef2, r] = {
    match iter$6362 {
        case Iterator.Iterator(rc$6370, iterF$6373) =>
            let step$6375: (Step[a] -> Step[b]) = x$6377 ->
                match x$6377 {
                    case Iterator.Step.Ans(a$6385) =>
                        match f$6348(a$6385) {
                            case Option.Some(a1$6391) =>
                                Iterator.Step.Ans(a1$6391)
                            case Option.None =>
                                Iterator.Step.Skip
                        }
                    case Iterator.Step.Skip =>
                        Iterator.Step.Skip
                    case Iterator.Step.Done =>
                        Iterator.Step.Done
                };
            let iterF1$6394: (Unit -> Step[b]) = _unit$6396 ->
                step$6375(iterF$6373(()));
            Iterator.Iterator(rc$6370, iterF1$6394)
    }
}

def Iterator.flatMap(
    f$5890: a -> Iterator[b, ef2, r],
    ma$5897: Iterator[a, ef1, r]
): Iterator[b, r + ef1 + ef2 + ef3, r] \ r = {
    match ma$5897 {
        case Iterator.Iterator(rc$5910, iterF$5914) =>
            let innerIter$5916: Ref[Iterator[b, ef2, r], r] = (
                ref Iterator.polymorphicEmpty(rc$5910)
            ) @ rc$5910;
            let inside$5922: Ref[Bool, r] = (ref false) @ rc$5910;
            letrec innerLoop$5928: (Unit -> Step[b]) = _unit$5930 ->
                match deref innerIter$5916 {
                    case Iterator.Iterator(_, innerF$5938) =>
                        match innerF$5938(()) {
                            case Iterator.Step.Ans(b$5943) =>
                                Iterator.Step.Ans(b$5943)
                            case Iterator.Step.Skip =>
                                innerLoop$5928(())
                            case Iterator.Step.Done =>
                                Iterator.Step.Done
                        }
                };
            letrec outerLoop$5947: (Unit -> Step[b]) = _unit$5949 ->
                if (deref inside$5922) {
                    match innerLoop$5928(()) {
                        case Iterator.Step.Done =>
                            Ref.put(false, inside$5922); outerLoop$5947(())
                        case ans$5958 =>
                            ans$5958
                    }
                } else {
                    match iterF$5914(()) {
                        case Iterator.Step.Ans(a$5962) =>
                            Ref.put(true, inside$5922);
                            Ref.put(f$5890(a$5962), innerIter$5916);
                            outerLoop$5947(())
                        case Iterator.Step.Skip =>
                            outerLoop$5947(())
                        case Iterator.Step.Done =>
                            Iterator.Step.Done
                    }
                };
            let iter1F$5967: (Unit -> Step[b]) = _unit$5969 ->
                outerLoop$5947(());
            Iterator.Iterator(rc$5910, iter1F$5967)
    }
}

def Iterator.flatten(
    iter$6478: Iterator[Iterator[a, ef1, r], ef2, r]
): Iterator[a, r + ef1 + ef2, r] \ r = {
    Iterator.flatMap($0$45447 -> identity($0$45447), iter$6478)
}

def Iterator.foldLeft(
    f$5115: b -> a -> b \ ef2,
    s$5117: b,
    iter$5119: Iterator[a, ef1, r]
): b \ ef1 + ef2 + r = {
    match iter$5119 {
        case Iterator.Iterator(_, iterF$5123) =>
            letrec loop$5130: (b -> b) = acc$5133 ->
                match iterF$5123(()) {
                    case Iterator.Step.Skip =>
                        loop$5130(acc$5133)
                    case Iterator.Step.Ans(a$5145) =>
                        loop$5130(f$5115(acc$5133)(a$5145))
                    case Iterator.Step.Done =>
                        acc$5133
                };
            loop$5130(s$5117)
    }
}

def Iterator.foldMap(
    f$5355: a -> b,
    iter$5361: Iterator[a, ef1, r]
): b \ ef1 + ef2 + r = {
    Iterator.foldLeft(
        acc$5369 ->
            x$5373 ->
                <[unknown exp]>(acc$5369, f$5355(x$5373)),
        <[unknown exp]>(()),
        iter$5361
    )
}

def Iterator.foldRight(
    f$5184: a -> b -> b \ ef2,
    s$5186: b,
    iter$5188: Iterator[a, ef1, r]
): b \ ef1 + ef2 + r = {
    match iter$5188 {
        case Iterator.Iterator(_, iterF$5207) =>
            letrec loop$5215: (
                b -> b \ (e117916 & (r + ef1 + ef2)) + ef2 -> b
            ) = k$5217 ->
                match iterF$5207(()) {
                    case Iterator.Step.Skip =>
                        loop$5215(k$5217)
                    case Iterator.Step.Ans(a$5222) =>
                        loop$5215(ks$5226 -> k$5217(f$5184(a$5222)(ks$5226)))
                    case Iterator.Step.Done =>
                        k$5217(s$5186)
                };
            loop$5215($0$45394 -> eidentity($0$45394))
    }
}

def Iterator.foldRightWithCont(
    f$5281: a -> (Unit -> b \ ef + r) -> b \ ef,
    z$5287: b,
    iter$5290: Iterator[a, ef, r]
): b \ ef + r = {
    match iter$5290 {
        case Iterator.Iterator(_, iterF$5296) =>
            letrec loop$5300: (Unit -> b) = _unit$5304 ->
                match iterF$5296(()) {
                    case Iterator.Step.Skip =>
                        loop$5300(())
                    case Iterator.Step.Ans(a$5308) =>
                        f$5281(a$5308)(_$5322 -> loop$5300(()))
                    case Iterator.Step.Done =>
                        z$5287
                };
            loop$5300(())
    }
}

def Iterator.forEach(
    f$1019: a -> Unit,
    iter$1021: Iterator[a, ef1, r]
): Unit \ ef1 + ef2 + r = {
    match iter$1021 {
        case Iterator.Iterator(_, iterF$1032) =>
            letrec loop$1034: (Unit -> Unit) = _unit$1036 ->
                match iterF$1032(()) {
                    case Iterator.Step.Skip =>
                        loop$1034(())
                    case Iterator.Step.Ans(a$1044) =>
                        f$1019(a$1044); loop$1034(())
                    case Iterator.Step.Done =>
                        ()
                };
            loop$1034(())
    }
}

def Iterator.forEachWithIndex(
    f$1086: Int32 -> a -> Unit \ ef2,
    iter$1094: Iterator[a, ef1, r]
): Unit \ ef1 + ef2 + r = {
    match iter$1094 {
        case Iterator.Iterator(_, iterF$1115) =>
            letrec loop$1122: (Int32 -> Unit) = i$1124 ->
                match iterF$1115(()) {
                    case Iterator.Step.Skip =>
                        loop$1122(i$1124)
                    case Iterator.Step.Ans(a$1136) =>
                        f$1086(i$1124)(a$1136);
                        loop$1122(<[unknown exp]>(i$1124, 1i32))
                    case Iterator.Step.Done =>
                        ()
                };
            loop$1122(0i32)
    }
}

def Iterator.intercalate(
    sep$6120: t[a],
    iter$6126: Iterator[Iterator[a, ef, r], ef, r]
): Iterator[a, ef + r, r] \ r = {
    match iter$6126 {
        case Iterator.Iterator(rc$6145, _) =>
            let start$6147: Ref[Bool, r] = (ref true) @ rc$6145;
            let sepL$6150: List[a] = <[unknown exp]>(sep$6120);
            let step$6155: (
                Iterator[a, ef, r] -> Iterator[a, ef, r]
            ) = innerIter$6157 ->
                if (deref start$6147) {
                    Ref.put(false, start$6147); innerIter$6157
                } else {
                    Iterator.append(
                        Iterator.ofList(rc$6145, sepL$6150),
                        innerIter$6157
                    )
                };
            Iterator.flatMap(step$6155, iter$6126)
    }
}

def Iterator.intersperse(
    sep$6035: a,
    iter$6044: Iterator[a, ef, r]
): Iterator[a, ef + r, r] \ r = {
    match iter$6044 {
        case Iterator.Iterator(rc$6056, _) =>
            let start$6061: Ref[Bool, r] = (ref true) @ rc$6056;
            let step$6063: (a -> Iterator[a, r, r]) = x$6068 ->
                if (deref start$6061) {
                    Ref.put(false, start$6061);
                    Iterator.singleton(rc$6056, x$6068)
                } else {
                    Iterator.cons(sep$6035, Iterator.singleton(rc$6056, x$6068))
                };
            Iterator.flatMap(step$6063, iter$6044)
    }
}

def Iterator.iterate(
    rc$189: Region[r],
    f$191: Unit -> Option[a]
): Iterator[a, ef, r] = {
    let f1$193: (Unit -> Step[a]) = _unit$198 ->
        match f$191(()) {
            case Option.Some(a$259) =>
                Iterator.Step.Ans(a$259)
            case Option.None =>
                Iterator.Step.Done
        };
    let iterF$319: (Unit -> Step[a]) = _unit$321 ->
        <[unknown exp]>;
    Iterator.Iterator(rc$189, iterF$319)
}

def Iterator.join(
    sep$6237: String,
    iter$6239: Iterator[a, ef, r]
): String \ ef + r = {
    Iterator.joinWith(
        $0$45445 ->
            <[unknown exp]>($0$45445),
        sep$6237,
        iter$6239
    )
}

def Iterator.joinWith(
    f$6263: a -> String,
    sep$6267: String,
    iter$6271: Iterator[a, ef1, r]
): String \ ef1 + ef2 + r = {
    region rc$6277 {
        let sb$6280: StringBuilder[rc] = StringBuilder.empty(rc$6277);
        match Iterator.next(iter$6271) {
            case Option.Some(a$6283) =>
                StringBuilder.append!(f$6263(a$6283), sb$6280);
                Iterator.forEach(
                    x$6287 ->
                        {
                            StringBuilder.append!(sep$6267, sb$6280);
                            StringBuilder.append!(f$6263(x$6287), sb$6280)
                        },
                    iter$6271
                )
            case Option.None =>
                ()
        };
        StringBuilder.toString(sb$6280)
    }
}

def Iterator.map(
    f$1232: a -> b,
    iter$1236: Iterator[a, ef1, r]
): Iterator[b, ef1 + ef2, r] = {
    match iter$1236 {
        case Iterator.Iterator(rc$1248, iterF$1250) =>
            let step$1252: (Step[a] -> Step[b]) = x$1254 ->
                match x$1254 {
                    case Iterator.Step.Ans(a$1258) =>
                        Iterator.Step.Ans(f$1232(a$1258))
                    case Iterator.Step.Skip =>
                        Iterator.Step.Skip
                    case Iterator.Step.Done =>
                        Iterator.Step.Done
                };
            let iterF1$1266: (Unit -> Step[b]) = _unit$1268 ->
                {let x$1272: Step[a] = iterF$1250(()); step$1252(x$1272)};
            Iterator.Iterator(rc$1248, iterF1$1266)
    }
}

def Iterator.mapWithIndex(
    f$1301: Int32 -> a -> b \ ef2,
    iter$1309: Iterator[a, ef1, r]
): Iterator[b, ef1 + ef2, r] \ r = {
    match iter$1309 {
        case Iterator.Iterator(rc$1313, iterF$1315) =>
            let ix$1317: Ref[Int32, r] = (ref 0i32) @ rc$1313;
            let step$1321: (Step[a] -> Step[b]) = x$1323 ->
                match x$1323 {
                    case Iterator.Step.Ans(a$1325) =>
                        let i$1327: Int32 = deref ix$1317;
                        Ref.put(<[unknown exp]>(i$1327, 1i32), ix$1317);
                        Iterator.Step.Ans(f$1301(i$1327)(a$1325))
                    case Iterator.Step.Skip =>
                        Iterator.Step.Skip
                    case Iterator.Step.Done =>
                        Iterator.Step.Done
                };
            let iterF1$1348: (Unit -> Step[b]) = _unit$1350 ->
                {let x$1354: Step[a] = iterF$1315(()); step$1321(x$1354)};
            Iterator.Iterator(rc$1313, iterF1$1348)
    }
}

def Iterator.next(iter$526: Iterator[a, ef, r]): Option[a] \ ef + r = {
    match iter$526 {
        case Iterator.Iterator(_, iterF$528) =>
            letrec loop$530: (Unit -> Option[a]) = _unit$532 ->
                match iterF$528(()) {
                    case Iterator.Step.Ans(a$534) =>
                        Option.Some(a$534)
                    case Iterator.Step.Skip =>
                        loop$530(())
                    case Iterator.Step.Done =>
                        Option.None
                };
            loop$530(())
    }
}

def Iterator.ofList(
    rc$6178: Region[r],
    xs$6180: List[a]
): Iterator[a, Pure, r] \ r = {
    let ls$6190: Ref[List[a], r] = (ref xs$6180) @ rc$6178;
    let next$6194: (Unit -> Step[a]) = _unit$6198 ->
        match deref ls$6190 {
            case List.Nil =>
                Iterator.Step.Done
            case List.Cons(x$6204, rs$6206) =>
                Ref.put(rs$6206, ls$6190); Iterator.Step.Ans(x$6204)
        };
    Iterator.Iterator(rc$6178, next$6194)
}

def Iterator.polymorphicEmpty(rc$5998: Region[r]): Iterator[a, ef, r] = {
    let f$6006: (Unit -> Step[a]) = constant(Iterator.Step.Done);
    Iterator.Iterator(rc$5998, f$6006)
}

def Iterator.range(
    rc$606: Region[r],
    b$611: Int32,
    e$614: Int32
): Iterator[Int32, r, r] \ r = {
    let pos$620: Ref[Int32, r] = (ref b$611) @ rc$606;
    if (<[unknown exp]>(e$614, b$611)) {
        Iterator.empty(rc$606)
    } else {
        let iterF$624: (Unit -> Step[Int32]) = _unit$626 ->
            match deref pos$620 {
                case i$630 if <[unknown exp]>(i$630, e$614) =>
                    Ref.put(<[unknown exp]>(i$630, 1i32), pos$620);
                    Iterator.Step.Ans(i$630)
                case _ =>
                    Iterator.Step.Done
            };
        Iterator.Iterator(rc$606, iterF$624)
    }
}

def Iterator.reduceLeft(
    f$5417: a -> a -> a \ ef2,
    iter$5419: Iterator[a, ef1, r]
): Option[a] \ ef1 + ef2 + r = {
    match Iterator.next(iter$5419) {
        case Option.Some(x$5430) =>
            |>(
                Iterator.foldLeft(f$5417, x$5430, iter$5419),
                x$$45396 ->
                    Option.Some(x$$45396)
            )
        case Option.None =>
            Option.None
    }
}

def Iterator.repeat(
    rc$656: Region[r],
    n$658: Int32,
    x$660: a
): Iterator[a, r, r] \ r = {
    let ix$662: Ref[Int32, r] = (ref n$658) @ rc$656;
    let iterF$664: (Unit -> Step[a]) = _unit$666 ->
        {
            let i$668: Int32 = deref ix$662;
            if (<[unknown exp]>(i$668, 1i32)) {
                Iterator.Step.Done
            } else {
                Ref.put(<[unknown exp]>(i$668, 1i32), ix$662);
                Iterator.Step.Ans(x$660)
            }
        };
    Iterator.Iterator(rc$656, iterF$664)
}

def Iterator.replace(
    src$1391: { src = a },
    dst$3493: { dst = a },
    iter$3496: Iterator[a, ef, r]
): Iterator[a, ef, r] = {
    Iterator.map(
        a$3507 ->
            if (<[unknown exp]>(a$3507, src$1391.src)) {
                dst$3493.dst
            } else {
                a$3507
            },
        iter$3496
    )
}

def Iterator.singleton(rc$519: Region[r], x$521: a): Iterator[a, r, r] \ r = {
    Iterator.repeat(rc$519, 1i32, x$521)
}

def Iterator.sum(iter$678: Iterator[Int32, ef, r]): Int32 \ ef + r = {
    Iterator.foldLeft(
        acc$680 ->
            x$682 ->
                <[unknown exp]>(acc$680, x$682),
        0i32,
        iter$678
    )
}

def Iterator.sumWith(
    f$688: a -> Int32,
    iter$690: Iterator[a, ef1, r]
): Int32 \ ef1 + ef2 + r = {
    Iterator.foldLeft(
        acc$692 ->
            x$694 ->
                <[unknown exp]>(acc$692, f$688(x$694)),
        0i32,
        iter$690
    )
}

def Iterator.take(
    n$5601: Int32,
    iter$5603: Iterator[a, ef, r]
): Iterator[a, ef + r, r] \ r = {
    match iter$5603 {
        case Iterator.Iterator(rc$5627, iterF$5629) =>
            let ix$5631: Ref[Int32, r] = (ref n$5601) @ rc$5627;
            letrec loop$5633: (Unit -> Step[a]) = _unit$5637 ->
                {
                    let i$5643: Int32 = deref ix$5631;
                    if (<[unknown exp]>(i$5643, 1i32)) {
                        Iterator.Step.Done
                    } else {
                        match iterF$5629(()) {
                            case Iterator.Step.Ans(a$5667) =>
                                Ref.put(<[unknown exp]>(i$5643, 1i32), ix$5631);
                                Iterator.Step.Ans(a$5667)
                            case Iterator.Step.Skip =>
                                Iterator.Step.Skip
                            case Iterator.Step.Done =>
                                Iterator.Step.Done
                        }
                    }
                };
            let iter1F$5699: (Unit -> Step[a]) = _unit$5701 ->
                loop$5633(());
            Iterator.Iterator(rc$5627, iter1F$5699)
    }
}

def Iterator.takeWhile(
    f$5720: a -> Bool,
    iter$5723: Iterator[a, ef1, r]
): Iterator[a, ef1 + ef2, r] = {
    match iter$5723 {
        case Iterator.Iterator(rc$5743, iterF$5748) =>
            letrec loop$5750: (Step[a] -> Step[a]) = x$5752 ->
                match x$5752 {
                    case Iterator.Step.Ans(a$5755) =>
                        if (f$5720(a$5755)) {
                            Iterator.Step.Ans(a$5755)
                        } else {
                            Iterator.Step.Done
                        }
                    case Iterator.Step.Skip =>
                        loop$5750(iterF$5748(()))
                    case Iterator.Step.Done =>
                        Iterator.Step.Done
                };
            let iter1F$5767: (Unit -> Step[a]) = _unit$5769 ->
                loop$5750(iterF$5748(()));
            Iterator.Iterator(rc$5743, iter1F$5767)
    }
}

def Iterator.toArray(
    rc$711: Region[r1],
    iter$718: Iterator[a, ef, r2]
): Array[a, r1] \ ef + r2 + r1 = {
    region rc1$729 {
        let m$734: MutList[a, rc1] = MutList.empty(rc1$729);
        Iterator.forEach(a$738 -> MutList.push!(a$738, m$734), iter$718);
        MutList.toArray(rc$711, m$734)
    }
}

def Iterator.toChain(iter$792: Iterator[a, ef, r]): Chain[a] \ ef + r = {
    Iterator.foldLeft(
        acc$794 ->
            a$796 ->
                Chain.snoc(acc$794, a$796),
        Chain.empty(()),
        iter$792
    )
}

def Iterator.toList(iter$769: Iterator[a, ef, r]): List[a] \ ef + r = {
    Iterator.foldRight(
        a$775 ->
            acc$777 ->
                List.Cons(a$775, acc$777),
        List.Nil,
        iter$769
    )
}

def Iterator.toMap(iter$904: Iterator[(k, v), ef, r]): Map[k, v] \ ef + r = {
    Iterator.foldLeft(
        acc$910 ->
            a$912 ->
                (
                    pat$0$914 ->
                        match pat$0$914 {
                            case (k$916, v$918) =>
                                Map.insert(k$916, v$918, acc$910)
                        }
                )(a$912),
        Map.empty(()),
        iter$904
    )
}

def Iterator.toMutDeque(
    rc$973: Region[r1],
    iter$975: Iterator[a, ef, r2]
): MutDeque[a, r1] \ ef + r2 + r1 = {
    let d$977: MutDeque[a, r1] = MutDeque.empty(rc$973);
    Iterator.forEach(x$981 -> MutDeque.pushBack(x$981, d$977), iter$975);
    d$977
}

def Iterator.toNec(iter$946: Iterator[a, ef, r]): Option[Nec[a]] \ ef + r = {
    match Iterator.next(iter$946) {
        case Option.Some(a$948) =>
            |>(
                Iterator.foldLeft(
                    acc$950 ->
                        x$953 ->
                            Nec.snoc(acc$950, x$953),
                    Nec.singleton(a$948),
                    iter$946
                ),
                x$$45340 ->
                    Option.Some(x$$45340)
            )
        case Option.None =>
            Option.None
    }
}

def Iterator.toNel(iter$939: Iterator[a, ef, r]): Option[Nel[a]] \ ef + r = {
    |>(Iterator.toList(iter$939), $0$45338 -> List.toNel($0$45338))
}

def Iterator.toSet(iter$994: Iterator[a, ef, r]): Set[a] \ ef + r = {
    Iterator.foldLeft(
        acc$1000 ->
            a$1002 ->
                Set.insert(a$1002, acc$1000),
        Set.empty(()),
        iter$994
    )
}

def Iterator.toVector(iter$745: Iterator[a, ef, r]): Vector[a] \ ef + r = {
    region rc$748 {
        let m$754: MutList[a, rc] = MutList.empty(rc$748);
        Iterator.forEach(a$758 -> MutList.push!(a$758, m$754), iter$745);
        MutList.toVector(m$754)
    }
}

def Iterator.unfoldWithOk(
    rc$5460: Region[r],
    f$5464: Unit -> Result[e, a]
): Iterator[a, ef, r] = {
    let iterF$5472: (Unit -> Option[a]) = _unit$5474 ->
        Result.toOption(f$5464(()));
    Iterator.iterate(rc$5460, iterF$5472)
}

def Iterator.zip(
    iterA$4659: Iterator[a, ef1, r1],
    iterB$4669: Iterator[b, ef2, r2]
): Iterator[(a, b), r2 + ef1 + ef2, r1] = {
    Iterator.zipWith(
        a$4682 ->
            b$4688 ->
                (a$4682, b$4688),
        iterA$4659,
        iterB$4669
    )
}

def Iterator.zipWith(
    f$4748: a -> b -> c \ ef3,
    iterA$4757: Iterator[a, ef1, r1],
    iterB$4759: Iterator[b, ef2, r2]
): Iterator[c, r2 + ef1 + ef2 + ef3, r1] = {
    match iterA$4757 {
        case Iterator.Iterator(rc$4782, iter1F$4784) =>
            match iterB$4759 {
                case Iterator.Iterator(_, iter2F$4790) =>
                    let step$4792: (
                        Step[a] ->
                            Step[b] -> Step[c] \ r1 + ef1 + ef3 + r2 + ef2 + ef3 + ef3
                    ) = l$4800 ->
                        r$4813 ->
                            match (l$4800, r$4813) {
                                case (
                                    Iterator.Step.Ans(a$4816),
                                    Iterator.Step.Ans(b$4819)
                                ) =>
                                    Iterator.Step.Ans(f$4748(a$4816)(b$4819))
                                case (
                                    Iterator.Step.Ans(a$4825),
                                    Iterator.Step.Skip
                                ) =>
                                    Iterator.zipWithGoRight(
                                        b$4827 ->
                                            f$4748(a$4825)(b$4827),
                                        iter2F$4790
                                    )
                                case (
                                    Iterator.Step.Skip,
                                    Iterator.Step.Ans(b$4829)
                                ) =>
                                    Iterator.zipWithGoLeft(
                                        iter1F$4784,
                                        a$4831 ->
                                            f$4748(a$4831)(b$4829)
                                    )
                                case (Iterator.Step.Skip, Iterator.Step.Skip) =>
                                    Iterator.Step.Skip
                                case (_, _) =>
                                    Iterator.Step.Done
                            };
                    let iter3F$4849: (Unit -> Step[c]) = _unit$4859 ->
                        step$4792(iter1F$4784(()))(iter2F$4790(()));
                    Iterator.Iterator(rc$4782, iter3F$4849)
            }
    }
}

def Iterator.zipWithGoLeft(
    iter$4874: Unit -> Step[a],
    f$4883: a -> c
): Step[c] \ ef1 + ef2 = {
    match iter$4874(()) {
        case Iterator.Step.Ans(a$4891) =>
            Iterator.Step.Ans(f$4883(a$4891))
        case Iterator.Step.Skip =>
            Iterator.zipWithGoLeft(iter$4874, f$4883)
        case Iterator.Step.Done =>
            Iterator.Step.Done
    }
}

def Iterator.zipWithGoRight(
    f$4945: b -> c,
    iter$4947: Unit -> Step[b]
): Step[c] \ ef1 + ef2 = {
    match iter$4947(()) {
        case Iterator.Step.Ans(b$4966) =>
            Iterator.Step.Ans(f$4945(b$4966))
        case Iterator.Step.Skip =>
            Iterator.zipWithGoRight(f$4945, iter$4947)
        case Iterator.Step.Done =>
            Iterator.Step.Done
    }
}

def Iterator.zipWithIndex(
    iter$5008: Iterator[a, ef, r]
): Iterator[(Int32, a), ef + r, r] \ r = {
    match iter$5008 {
        case Iterator.Iterator(rc$5021, _) =>
            let ix$5023: Ref[Int32, r] = (ref 0i32) @ rc$5021;
            Iterator.map(
                x$5027 ->
                    {
                        let i$5029: Int32 = deref ix$5023;
                        Ref.put(<[unknown exp]>(i$5029, 1i32), ix$5023);
                        (i$5029, x$5027)
                    },
                iter$5008
            )
    }
}

enum Iterator.Step[a] {case Ans(a) case Skip(Unit) case Done(Unit)}

enum List[t] {case Nil(Unit) case Cons(t, List[t])}

def List.agreeHelper(
    f$12997: a -> a -> Bool,
    a$13004: a,
    l$13007: List[a]
): Bool = {
    match l$13007 {
        case List.Nil =>
            true
        case List.Cons(x$13016, xs$13018) =>
            if (f$12997(x$13016)(a$13004) and f$12997(a$13004)(x$13016)) {
                List.agreeHelper(f$12997, a$13004, xs$13018)
            } else {
                false
            }
    }
}

def List.ap(f$10046: List[a -> b \ ef], x$10050: List[a]): List[b] \ ef = {
    |>(
        List.map(g$10071 -> List.map(g$10071, x$10050), f$10046),
        $0$45752 ->
            List.flatten($0$45752)
    )
}

def List.append(l1$9195: List[a], l2$9204: List[a]): List[a] = {
    List.foldRight(
        x$9208 ->
            acc$9210 ->
                List.Cons(x$9208, acc$9210),
        l2$9204,
        l1$9195
    )
}

def List.applyHelper(a$10944: a, l$10947: List[List[a]]): List[List[a]] = {
    letrec loop$10956: (
        List[List[a]] -> (List[List[a]] -> List[List[a]]) -> List[List[a]]
    ) = ll$10959 ->
        k$10963 ->
            match ll$10959 {
                case List.Nil =>
                    k$10963(List.Nil)
                case List.Cons(x$10969, xs$10971) =>
                    loop$10956(
                        xs$10971
                    )(
                        ks$10981 ->
                            k$10963(
                                List.Cons(List.Cons(a$10944, x$10969), ks$10981)
                            )
                    )
            };
    loop$10956(l$10947)($0$45782 -> identity($0$45782))
}

def List.applyListHelper(
    l1$11283: List[a],
    l2$11294: List[List[a]]
): List[List[a]] = {
    match (l1$11283, l2$11294) {
        case (List.Nil, List.Nil) =>
            List.Nil
        case (List.Cons(x$11313, xs$11317), List.Cons(y$11321, ys$11325)) =>
            List.Cons(
                List.Cons(x$11313, y$11321),
                List.applyListHelper(xs$11317, ys$11325)
            )
        case _ =>
            unreachable!(())
    }
}

def List.at(i$10819: Int32, l$10821: List[a]): a = {
    match (i$10819, l$10821) {
        case (0i32, List.Cons(x$10827, _)) =>
            x$10827
        case (p$10833, List.Cons(_, xs$10835)) =>
            List.at(<[unknown exp]>(p$10833, 1i32), xs$10835)
        case _ =>
            unreachable!(())
    }
}

def List.consA(mx$16822: f[a], ml$16824: f[List[a]]): f[List[a]] = {
    <[unknown exp]>
}

def List.count(f$11812: a -> Bool, l$11827: List[a]): Int32 \ ef = {
    List.foldLeft(
        acc$11837 ->
            x$11841 ->
                if (f$11812(x$11841)) {
                    <[unknown exp]>(acc$11837, 1i32)
                } else {
                    acc$11837
                },
        0i32,
        l$11827
    )
}

def List.distinct(l$16492: List[a]): List[a] = {
    letrec loop$16565: (
        List[a] -> List[a] -> ((List[a] -> List[a]) -> List[a])
    ) = ll1$16567 ->
        ll2$16573 ->
            k$16575 ->
                match ll1$16567 {
                    case List.Nil =>
                        k$16575(List.Nil)
                    case List.Cons(x$16583, xs$16585) =>
                        if (List.memberOf(x$16583, ll2$16573)) {
                            loop$16565(xs$16585)(ll2$16573)(k$16575)
                        } else {
                            loop$16565(
                                xs$16585
                            )(
                                List.Cons(x$16583, ll2$16573)
                            )(ks$16589 -> k$16575(List.Cons(x$16583, ks$16589)))
                        }
                };
    loop$16565(l$16492)(List.Nil)($0$45981 -> identity($0$45981))
}

def List.distinctWith(f$16609: a -> a -> Bool, l$16617: List[a]): List[a] = {
    letrec loop$16621: (
        List[a] -> List[a] -> ((List[a] -> List[a]) -> List[a])
    ) = ll1$16623 ->
        ll2$16625 ->
            k$16627 ->
                match ll1$16623 {
                    case List.Nil =>
                        k$16627(List.Nil)
                    case List.Cons(x$16630, xs$16634) =>
                        if (List.exists(f$16609(x$16630), ll2$16625)) {
                            loop$16621(xs$16634)(ll2$16625)(k$16627)
                        } else {
                            loop$16621(
                                xs$16634
                            )(
                                List.Cons(x$16630, ll2$16625)
                            )(ks$16641 -> k$16627(List.Cons(x$16630, ks$16641)))
                        }
                };
    loop$16621(l$16617)(List.Nil)($0$45985 -> identity($0$45985))
}

def List.drop(n$12446: Int32, l$12452: List[a]): List[a] = {
    match l$12452 {
        case _ if <[unknown exp]>(n$12446, 0i32) =>
            l$12452
        case List.Nil =>
            List.Nil
        case List.Cons(_, xs$12459) =>
            List.drop(<[unknown exp]>(n$12446, 1i32), xs$12459)
    }
}

def List.dropWhile(f$12511: a -> Bool, l$12531: List[a]): List[a] \ ef = {
    match l$12531 {
        case List.Nil =>
            List.Nil
        case List.Cons(x$12547, xs$12551) =>
            if (f$12511(x$12547)) {
                List.dropWhile(f$12511, xs$12551)
            } else {
                l$12531
            }
    }
}

def List.empty(_unit$9029: Unit): List[a] = {List.Nil}

def List.enumerator(
    rc$16760: Region[r],
    l$16765: List[a]
): Iterator[(Int32, a), r, r] \ r = {
    |>(
        List.iterator(rc$16760, l$16765),
        $0$45991 ->
            Iterator.zipWithIndex($0$45991)
    )
}

def List.exists(f$11935: a -> Bool, l$11942: List[a]): Bool \ ef = {
    match l$11942 {
        case List.Nil =>
            false
        case List.Cons(x$11945, xs$11947) =>
            if (f$11935(x$11945)) {true} else {List.exists(f$11935, xs$11947)}
    }
}

def List.extractHelper(
    f$12953: a -> a -> Bool,
    l1$12957: List[a],
    l2$12959: List[a]
): (List[a], List[a]) = {
    letrec loop$12961: (
        List[a] -> List[a] -> ((List[a] -> List[a]) -> (List[a], List[a]))
    ) = ll$12965 ->
        ll2$12969 ->
            k$12974 ->
                match ll$12965 {
                    case List.Nil =>
                        (List.reverse(ll2$12969), k$12974(List.Nil))
                    case List.Cons(x$12978, xs$12982) =>
                        if (List.agreeHelper(f$12953, x$12978, ll2$12969)) {
                            loop$12961(
                                xs$12982
                            )(List.Cons(x$12978, ll2$12969))(k$12974)
                        } else {
                            loop$12961(
                                xs$12982
                            )(
                                ll2$12969
                            )(ks$12988 -> k$12974(List.Cons(x$12978, ks$12988)))
                        }
                };
    loop$12961(l1$12957)(l2$12959)($0$45873 -> identity($0$45873))
}

def List.filter(f$11987: a -> Bool, l$11994: List[a]): List[a] \ ef = {
    letrec loop$12017: (
        List[a] -> (List[a] -> List[a]) -> List[a] \ ef
    ) = ll$12020 ->
        k$12022 ->
            match ll$12020 {
                case List.Nil =>
                    k$12022(List.Nil)
                case List.Cons(x$12024, xs$12026) =>
                    if (f$11987(x$12024)) {
                        loop$12017(
                            xs$12026
                        )(ks$12037 -> k$12022(List.Cons(x$12024, ks$12037)))
                    } else {
                        loop$12017(xs$12026)(k$12022)
                    }
            };
    loop$12017(l$11994)($0$45796 -> identity($0$45796))
}

def List.filterMap(f$13808: a -> Option[b], l$13812: List[a]): List[b] \ ef = {
    letrec loop$13829: (
        List[a] -> (List[b] -> List[b]) -> List[b] \ ef
    ) = ll$13831 ->
        k$13833 ->
            match ll$13831 {
                case List.Nil =>
                    k$13833(List.Nil)
                case List.Cons(x$13839, xs$13841) =>
                    match f$13808(x$13839) {
                        case Option.None =>
                            loop$13829(xs$13841)(k$13833)
                        case Option.Some(v$13847) =>
                            loop$13829(
                                xs$13841
                            )(ks$13849 -> k$13833(List.Cons(v$13847, ks$13849)))
                    }
            };
    loop$13829(l$13812)($0$45893 -> identity($0$45893))
}

def List.find(f$9469: a -> Bool, l$9480: List[a]): Option[a] \ ef = {
    List.findLeft(f$9469, l$9480)
}

def List.findLeft(f$9517: a -> Bool, l$9520: List[a]): Option[a] \ ef = {
    match l$9520 {
        case List.Nil =>
            Option.None
        case List.Cons(x$9527, xs$9530) =>
            if (f$9517(x$9527)) {
                Option.Some(x$9527)
            } else {
                List.findLeft(f$9517, xs$9530)
            }
    }
}

def List.findMap(f$13881: a -> Option[b], l$13898: List[a]): Option[b] \ ef = {
    match l$13898 {
        case List.Nil =>
            Option.None
        case List.Cons(x$13918, xs$13923) =>
            match f$13881(x$13918) {
                case Option.None =>
                    List.findMap(f$13881, xs$13923)
                case Option.Some(v$13939) =>
                    Option.Some(v$13939)
            }
    }
}

def List.findRight(f$9574: a -> Bool, l$9576: List[a]): Option[a] \ ef = {
    letrec loop$9583: (
        List[a] ->
            (Unit -> Option[a] \ (e126867 & ef) + ef) -> Option[a] \ ef + (e126867 & ef) + ef
    ) = ll$9586 ->
        k$9588 ->
            match ll$9586 {
                case List.Nil =>
                    k$9588(())
                case List.Cons(x$9591, xs$9593) =>
                    loop$9583(
                        xs$9593
                    )(
                        _unit$9595 ->
                            if (f$9574(x$9591)) {
                                Option.Some(x$9591)
                            } else {
                                k$9588(())
                            }
                    )
            };
    loop$9583(l$9576)(constant(Option.None))
}

def List.flatMap(f$10433: a -> List[b], l$10439: List[a]): List[b] \ ef = {
    letrec loop$10442: (List[a] -> List[b] -> List[b] \ ef) = ll$10444 ->
        acc$10446 ->
            match ll$10444 {
                case List.Nil =>
                    acc$10446
                case List.Cons(x$10448, xs$10450) =>
                    loop$10442(
                        xs$10450
                    )(List.append(acc$10446, f$10433(x$10448)))
            };
    loop$10442(l$10439)(List.Nil)
}

def List.flatten(l$11861: List[List[a]]): List[a] = {
    letrec loop$11879: (
        List[List[a]] -> (List[a] -> List[a]) -> List[a]
    ) = ll$11882 ->
        k$11885 ->
            match ll$11882 {
                case List.Nil =>
                    k$11885(List.Nil)
                case List.Cons(x$11894, xs$11899) =>
                    loop$11879(
                        xs$11899
                    )(ks$11907 -> k$11885(List.append(x$11894, ks$11907)))
            };
    loop$11879(l$11861)($0$45794 -> identity($0$45794))
}

def List.fold(l$11460: List[a]): a = {Foldable.fold(l$11460)}

def List.fold2(
    f$13598: c -> a -> (b -> c \ ef),
    c$13602: c,
    l1$13604: List[a],
    l2$13609: List[b]
): c \ ef = {
    List.foldLeft2(f$13598, c$13602, l1$13604, l2$13609)
}

def List.foldLeft(
    f$11492: b -> a -> b \ ef,
    s$11502: b,
    l$11511: List[a]
): b \ ef = {
    match l$11511 {
        case List.Nil =>
            s$11502
        case List.Cons(x$11528, xs$11531) =>
            List.foldLeft(f$11492, f$11492(s$11502)(x$11528), xs$11531)
    }
}

def List.foldLeft2(
    f$13639: c -> a -> (b -> c \ ef),
    c$13645: c,
    l1$13647: List[a],
    l2$13649: List[b]
): c \ ef = {
    match (l1$13647, l2$13649) {
        case (List.Cons(x$13656, xs$13658), List.Cons(y$13660, ys$13662)) =>
            List.foldLeft2(
                f$13639,
                f$13639(c$13645)(x$13656)(y$13660),
                xs$13658,
                ys$13662
            )
        case _ =>
            c$13645
    }
}

def List.foldMap(f$13758: a -> b, l$13765: List[a]): b \ ef = {
    List.foldLeft(
        acc$13773 ->
            x$13775 ->
                <[unknown exp]>(acc$13773, f$13758(x$13775)),
        <[unknown exp]>(()),
        l$13765
    )
}

def List.foldRight(
    f$11561: a -> b -> b \ ef,
    s$11565: b,
    l$11567: List[a]
): b \ ef = {
    letrec loop$11581: (
        List[a] ->
            (b -> b \ (e127702 & ef) + ef) -> b \ ef + (e127702 & ef) + ef
    ) = ll$11587 ->
        k$11591 ->
            match ll$11587 {
                case List.Nil =>
                    k$11591(s$11565)
                case List.Cons(x$11593, xs$11595) =>
                    loop$11581(
                        xs$11595
                    )(ks$11598 -> k$11591(f$11561(x$11593)(ks$11598)))
            };
    loop$11581(l$11567)($0$45790 -> eidentity($0$45790))
}

def List.foldRight2(
    f$13682: a -> b -> (c -> c \ ef),
    c$13691: c,
    l1$13693: List[a],
    l2$13701: List[b]
): c \ ef = {
    letrec loop$13706: (
        List[a] ->
            List[b] -> ((c -> c \ (e110771 & ef) + ef) -> c \ (e110771 & ef) + ef + ef)
    ) = ll1$13710 ->
        ll2$13713 ->
            k$13715 ->
                match (ll1$13710, ll2$13713) {
                    case (
                        List.Cons(x$13717, xs$13719),
                        List.Cons(y$13721, ys$13723)
                    ) =>
                        loop$13706(
                            xs$13719
                        )(
                            ys$13723
                        )(
                            ks$13725 ->
                                k$13715(f$13682(x$13717)(y$13721)(ks$13725))
                        )
                    case _ =>
                        k$13715(c$13691)
                };
    let len1$13731: Int32 = List.length(l1$13693);
    let len2$13736: Int32 = List.length(l2$13701);
    loop$13706(
        List.drop(<[unknown exp]>(len1$13731, len2$13736), l1$13693)
    )(
        List.drop(<[unknown exp]>(len2$13736, len1$13731), l2$13701)
    )($0$45891 -> eidentity($0$45891))
}

def List.foldRightWithCont(
    f$11619: a -> (Unit -> b \ ef) -> b \ ef,
    z$11621: b,
    l$11623: List[a]
): b \ ef = {
    match l$11623 {
        case List.Nil =>
            z$11621
        case List.Cons(x$11631, xs$11635) =>
            f$11619(
                x$11631
            )(_$11641 -> List.foldRightWithCont(f$11619, z$11621, xs$11635))
    }
}

def List.forAll(f$11953: a -> Bool, l$11955: List[a]): Bool \ ef = {
    match l$11955 {
        case List.Nil =>
            true
        case List.Cons(x$11977, xs$11981) =>
            if (f$11953(x$11977)) {List.forAll(f$11953, xs$11981)} else {false}
    }
}

def List.forEach(f$16022: a -> Unit, l$16031: List[a]): Unit \ ef = {
    match l$16031 {
        case List.Nil =>
            ()
        case List.Cons(x$16047, xs$16049) =>
            f$16022(x$16047); List.forEach(f$16022, xs$16049)
    }
}

def List.forEachWithIndex(
    f$16074: Int32 -> a -> Unit \ ef,
    l$16085: List[a]
): Unit \ ef = {
    letrec loop$16091: (
        List[a] -> Int32 -> Unit \ ef + ((e54799 + ef) & ef)
    ) = ll$16093 ->
        i$16095 ->
            match ll$16093 {
                case List.Nil =>
                    ()
                case List.Cons(x$16101, xs$16103) =>
                    f$16074(i$16095)(x$16101);
                    loop$16091(xs$16103)(<[unknown exp]>(i$16095, 1i32))
            };
    loop$16091(l$16085)(0i32)
}

def List.frequency(l$17098: List[t]): Map[t, Int32] = {
    letrec freq$17105: (List[t] -> Map[t, Int32] -> Map[t, Int32]) = ll$17107 ->
        m$17109 ->
            match ll$17107 {
                case List.Nil =>
                    m$17109
                case List.Cons(x$17114, xs$17116) =>
                    match Map.get(x$17114, m$17109) {
                        case Option.None =>
                            freq$17105(
                                xs$17116
                            )(Map.insert(x$17114, 1i32, m$17109))
                        case Option.Some(_) =>
                            freq$17105(
                                xs$17116
                            )(
                                Map.update(
                                    v$17123 ->
                                        Option.Some(
                                            <[unknown exp]>(v$17123, 1i32)
                                        ),
                                    x$17114,
                                    m$17109
                                )
                            )
                    }
            };
    freq$17105(l$17098)(Map.empty(()))
}

def List.groupBy(f$12871: a -> a -> Bool, l$12875: List[a]): List[List[a]] = {
    letrec loop$12880: (
        List[a] -> (List[List[a]] -> List[List[a]]) -> List[List[a]]
    ) = ll$12886 ->
        k$12890 ->
            match ll$12886 {
                case List.Nil =>
                    k$12890(List.Nil)
                case List.Cons(x$12903, xs$12911) =>
                    match List.extractHelper(
                        f$12871,
                        xs$12911,
                        List.Cons(x$12903, List.Nil)
                    ) {
                        case (r1$12927, r2$12931) =>
                            loop$12880(
                                r2$12931
                            )(
                                ks$12933 ->
                                    k$12890(List.Cons(r1$12927, ks$12933))
                            )
                    }
            };
    loop$12880(l$12875)($0$45856 -> identity($0$45856))
}

def List.head(l$9081: List[a]): Option[a] = {
    match l$9081 {
        case List.Nil =>
            Option.None
        case List.Cons(x$9105, _) =>
            Option.Some(x$9105)
    }
}

def List.indexOf(a$9415: a, l$9418: List[a]): Option[Int32] = {
    letrec loop$9426: (List[a] -> Int32 -> Option[Int32]) = ll$9428 ->
        acc$9430 ->
            match ll$9428 {
                case List.Nil =>
                    Option.None
                case List.Cons(x$9439, xs$9441) =>
                    if (<[unknown exp]>(a$9415, x$9439)) {
                        Option.Some(acc$9430)
                    } else {
                        loop$9426(xs$9441)(<[unknown exp]>(acc$9430, 1i32))
                    }
            };
    loop$9426(l$9418)(0i32)
}

def List.init(l$12076: List[a]): Option[List[a]] = {
    letrec loop$12091: (
        List[a] -> (List[a] -> List[a]) -> Option[List[a]]
    ) = ll$12094 ->
        k$12096 ->
            match ll$12094 {
                case List.Nil =>
                    Option.None
                case List.Cons(_, List.Nil) =>
                    Option.Some(k$12096(List.Nil))
                case List.Cons(x$12104, xs$12106) =>
                    loop$12091(
                        xs$12106
                    )(ks$12108 -> k$12096(List.Cons(x$12104, ks$12108)))
            };
    loop$12091(l$12076)($0$45798 -> identity($0$45798))
}

def List.intercalate(l1$11089: List[a], l2$11093: List[List[a]]): List[a] = {
    letrec loop$11102: (
        List[List[a]] -> (List[a] -> List[a]) -> List[a]
    ) = ll$11104 ->
        k$11106 ->
            match ll$11104 {
                case List.Nil =>
                    k$11106(List.Nil)
                case List.Cons(y$11114, List.Nil) =>
                    k$11106(y$11114)
                case List.Cons(y1$11125, List.Cons(y2$11131, ys$11134)) =>
                    loop$11102(
                        List.Cons(y2$11131, ys$11134)
                    )(
                        ks$11139 ->
                            k$11106(
                                List.append(
                                    y1$11125,
                                    List.append(l1$11089, ks$11139)
                                )
                            )
                    )
            };
    loop$11102(l2$11093)($0$45786 -> identity($0$45786))
}

def List.intersperse(a$11018: a, l$11024: List[a]): List[a] = {
    letrec loop$11040: (
        List[a] -> (List[a] -> List[a]) -> List[a]
    ) = ll$11044 ->
        k$11046 ->
            match ll$11044 {
                case List.Cons(x1$11050, List.Cons(x2$11053, xs$11055)) =>
                    loop$11040(
                        List.Cons(x2$11053, xs$11055)
                    )(
                        ks$11060 ->
                            k$11046(
                                List.Cons(
                                    x1$11050,
                                    List.Cons(a$11018, ks$11060)
                                )
                            )
                    )
                case _ =>
                    k$11046(ll$11044)
            };
    loop$11040(l$11024)($0$45784 -> identity($0$45784))
}

def List.isEmpty(l$9041: List[a]): Bool = {
    match l$9041 {case List.Nil => true case _ => false}
}

def List.isInfixOf(l1$11381: List[a], l2$11392: List[a]): Bool = {
    match (l1$11381, l2$11392) {
        case (List.Nil, _) =>
            true
        case (_, List.Nil) =>
            false
        case (_, List.Cons(_, ys$11400)) =>
            if (List.isPrefixOf(l1$11381, l2$11392)) {
                true
            } else {
                List.isInfixOf(l1$11381, ys$11400)
            }
    }
}

def List.isPrefixOf(l1$11349: List[a], l2$11351: List[a]): Bool = {
    match (l1$11349, l2$11351) {
        case (List.Nil, _) =>
            true
        case (_, List.Nil) =>
            false
        case (List.Cons(x$11360, xs$11364), List.Cons(y$11368, ys$11372)) =>
            if (<[unknown exp]>(x$11360, y$11368)) {
                List.isPrefixOf(xs$11364, ys$11372)
            } else {
                false
            }
    }
}

def List.isSuffixOf(l1$11421: List[a], l2$11423: List[a]): Bool = {
    List.isPrefixOf(List.reverse(l1$11421), List.reverse(l2$11423))
}

def List.iterator(
    rc$16708: Region[r],
    xs$16712: List[a]
): Iterator[a, r, r] \ r = {
    let ls$16720: Ref[List[a], r] = (ref xs$16712) @ rc$16708;
    let next$16725: (Unit -> Option[a]) = _unit$16728 ->
        match deref ls$16720 {
            case List.Nil =>
                Option.None
            case List.Cons(x$16733, rs$16736) =>
                Ref.put(rs$16736, ls$16720); Option.Some(x$16733)
        };
    Iterator.iterate(rc$16708, next$16725)
}

def List.join(sep$13965: String, l$13967: List[a]): String = {
    <[unknown exp]>(sep$13965, l$13967)
}

def List.joinWith(
    f$13991: a -> String,
    sep$13997: String,
    l$14001: List[a]
): String \ ef = {
    <[unknown exp]>(f$13991, sep$13997, l$14001)
}

def List.last(l$9113: List[a]): Option[a] = {
    match l$9113 {
        case List.Nil =>
            Option.None
        case List.Cons(x$9121, List.Nil) =>
            Option.Some(x$9121)
        case List.Cons(_, rs$9135) =>
            List.last(rs$9135)
    }
}

def List.length(l$9148: List[a]): Int32 = {
    letrec loop$9152: (List[a] -> Int32 -> Int32) = ll$9154 ->
        acc$9156 ->
            match ll$9154 {
                case List.Nil =>
                    acc$9156
                case List.Cons(_, xs$9158) =>
                    loop$9152(xs$9158)(<[unknown exp]>(acc$9156, 1i32))
            };
    loop$9152(l$9148)(0i32)
}

def List.map(f$9925: a -> b, l$9935: List[a]): List[b] \ ef = {
    letrec loop$9941: (
        List[a] -> (List[b] -> List[b]) -> List[b] \ ef
    ) = ll$9943 ->
        k$9950 ->
            match ll$9943 {
                case List.Nil =>
                    k$9950(List.Nil)
                case List.Cons(x$9954, xs$9956) =>
                    let y$9958: b = f$9925(x$9954);
                    loop$9941(
                        xs$9956
                    )(ys$9960 -> k$9950(List.Cons(y$9958, ys$9960)))
            };
    loop$9941(l$9935)($0$45750 -> identity($0$45750))
}

def List.map2(
    f$10130: t1 -> t2 -> r \ ef,
    l1$10154: List[t1],
    l2$10168: List[t2]
): List[r] \ ef = {
    <[unknown exp]>(f$10130, l1$10154, l2$10168)
}

def List.map3(
    f$10206: t1 -> t2 -> (t3 -> r \ ef),
    l1$10213: List[t1],
    l2$10218: List[t2],
    l3$10220: List[t3]
): List[r] \ ef = {
    <[unknown exp]>(f$10206, l1$10213, l2$10218, l3$10220)
}

def List.map4(
    f$10258: t1 -> t2 -> (t3 -> (t4 -> r \ ef)),
    l1$10262: List[t1],
    l2$10268: List[t2],
    l3$10273: List[t3],
    l4$10277: List[t4]
): List[r] \ ef = {
    <[unknown exp]>(f$10258, l1$10262, l2$10268, l3$10273, l4$10277)
}

def List.map5(
    f$10304: t1 -> t2 -> (t3 -> (t4 -> (t5 -> r \ ef))),
    l1$10320: List[t1],
    l2$10322: List[t2],
    l3$10326: List[t3],
    l4$10330: List[t4],
    l5$10332: List[t5]
): List[r] \ ef = {
    <[unknown exp]>(f$10304, l1$10320, l2$10322, l3$10326, l4$10330, l5$10332)
}

def List.mapWithIndex(
    f$10361: Int32 -> a -> b \ ef,
    l$10366: List[a]
): List[b] \ ef = {
    letrec loop$10372: (
        List[a] -> Int32 -> ((List[b] -> List[b]) -> List[b] \ ef)
    ) = ll$10374 ->
        i$10376 ->
            k$10378 ->
                match ll$10374 {
                    case List.Nil =>
                        k$10378(List.Nil)
                    case List.Cons(x$10390, xs$10394) =>
                        let y$10396: b = f$10361(i$10376)(x$10390);
                        loop$10372(
                            xs$10394
                        )(
                            <[unknown exp]>(i$10376, 1i32)
                        )(ys$10402 -> k$10378(List.Cons(y$10396, ys$10402)))
                };
    loop$10372(l$10366)(0i32)($0$45754 -> identity($0$45754))
}

def List.maximum(l$9329: List[a]): Option[a] = {
    List.reduceLeft(
        $0$45738 ->
            $1$45740 ->
                <[unknown exp]>($0$45738, $1$45740),
        l$9329
    )
}

def List.maximumBy(
    cmp$9368: a -> a -> Comparison,
    l$9376: List[a]
): Option[a] = {
    List.reduceLeft(
        (
            $0$45742 ->
                $1$45744 ->
                    $2$45746 ->
                        Order.maxBy($0$45742, $1$45744, $2$45746)
        )(cmp$9368),
        l$9376
    )
}

def List.memberOf(a$9219: a, l$9221: List[a]): Bool = {
    match l$9221 {
        case List.Nil =>
            false
        case List.Cons(x$9232, xs$9234) =>
            if (<[unknown exp]>(a$9219, x$9232)) {
                true
            } else {
                List.memberOf(a$9219, xs$9234)
            }
    }
}

def List.merge(l1$17008: List[a], l2$17010: List[a]): List[a] = {
    letrec loop$17018: (
        List[a] -> List[a] -> ((List[a] -> List[a]) -> List[a])
    ) = acc1$17020 ->
        acc2$17024 ->
            k$17029 ->
                match (acc1$17020, acc2$17024) {
                    case (
                        List.Cons(x$17033, xs$17036),
                        List.Cons(y$17038, ys$17040)
                    ) =>
                        let cmp$17042: Comparison = <[unknown exp]>(
                            x$17033,
                            y$17038
                        );
                        if (
                            <[unknown exp]>(
                                cmp$17042,
                                Comparison.LessThan
                            ) or <[unknown exp]>(cmp$17042, Comparison.EqualTo)
                        ) {
                            loop$17018(
                                xs$17036
                            )(
                                acc2$17024
                            )(ks$17044 -> k$17029(List.Cons(x$17033, ks$17044)))
                        } else {
                            loop$17018(
                                acc1$17020
                            )(
                                ys$17040
                            )(ks$17047 -> k$17029(List.Cons(y$17038, ks$17047)))
                        }
                    case (List.Nil, List.Cons(y$17052, ys$17055)) =>
                        k$17029(List.Cons(y$17052, ys$17055))
                    case (List.Cons(x$17061, xs$17064), List.Nil) =>
                        k$17029(List.Cons(x$17061, xs$17064))
                    case (List.Nil, List.Nil) =>
                        k$17029(List.Nil)
                };
    loop$17018(l1$17008)(l2$17010)($0$46011 -> identity($0$46011))
}

def List.minimum(l$9248: List[a]): Option[a] = {
    List.reduceLeft(
        $0$45728 ->
            $1$45730 ->
                <[unknown exp]>($0$45728, $1$45730),
        l$9248
    )
}

def List.minimumBy(
    cmp$9299: a -> a -> Comparison,
    l$9301: List[a]
): Option[a] = {
    List.reduceLeft(
        (
            $0$45732 ->
                $1$45734 ->
                    $2$45736 ->
                        Order.minBy($0$45732, $1$45734, $2$45736)
        )(cmp$9299),
        l$9301
    )
}

def List.nonEmpty(l$9057: List[a]): Bool = {!List.isEmpty(l$9057)}

def List.partition(
    f$12252: a -> Bool,
    l$12256: List[a]
): (List[a], List[a]) \ ef = {
    letrec loop$12260: (
        List[a] ->
            (((List[a], List[a])) -> (List[a], List[a])) -> (List[a], List[a]) \ ef
    ) = ll$12262 ->
        k$12264 ->
            match ll$12262 {
                case List.Nil =>
                    k$12264((List.Nil, List.Nil))
                case List.Cons(x$12272, xs$12277) =>
                    if (f$12252(x$12272)) {
                        loop$12260(
                            xs$12277
                        )(
                            pat$25$12285 ->
                                match pat$25$12285 {
                                    case (ks$12289, ls$12293) =>
                                        k$12264(
                                            (
                                                List.Cons(x$12272, ks$12289),
                                                ls$12293
                                            )
                                        )
                                }
                        )
                    } else {
                        loop$12260(
                            xs$12277
                        )(
                            pat$26$12297 ->
                                match pat$26$12297 {
                                    case (ks$12301, ls$12303) =>
                                        k$12264(
                                            (
                                                ks$12301,
                                                List.Cons(x$12272, ls$12303)
                                            )
                                        )
                                }
                        )
                    }
            };
    loop$12260(l$12256)($0$45806 -> identity($0$45806))
}

def List.patch(
    i$10676: Int32,
    n$10682: Int32,
    l1$10684: List[a],
    l2$10688: List[a]
): List[a] = {
    letrec loop$10691: (
        List[a] -> List[a] -> (Int32 -> ((List[a] -> List[a]) -> List[a]))
    ) = ll1$10693 ->
        ll2$10695 ->
            c$10697 ->
                k$10701 ->
                    match (ll1$10693, ll2$10695) {
                        case (
                            List.Cons(x$10710, xs$10713),
                            List.Cons(y$10716, ys$10721)
                        ) =>
                            if (
                                <[unknown exp]>(
                                    c$10697,
                                    i$10676
                                ) and <[unknown exp]>(
                                    c$10697,
                                    <[unknown exp]>(i$10676, n$10682)
                                )
                            ) {
                                loop$10691(
                                    xs$10713
                                )(
                                    ys$10721
                                )(
                                    <[unknown exp]>(c$10697, 1i32)
                                )(
                                    ks$10737 ->
                                        k$10701(List.Cons(x$10710, ks$10737))
                                )
                            } else {
                                loop$10691(
                                    l1$10684
                                )(
                                    ys$10721
                                )(
                                    <[unknown exp]>(c$10697, 1i32)
                                )(
                                    ks$10741 ->
                                        k$10701(List.Cons(y$10716, ks$10741))
                                )
                            }
                        case _ =>
                            k$10701(ll2$10695)
                    };
    loop$10691(
        List.drop(<[unknown exp]>(i$10676), l1$10684)
    )(l2$10688)(0i32)($0$45766 -> identity($0$45766))
}

def List.permutationHelper(i$10786: Int32, l$10793: List[a]): List[List[a]] = {
    if (<[unknown exp]>(i$10786, List.length(l$10793))) {
        List.Nil
    } else {
        List.append(
            List.applyHelper(
                List.at(i$10786, l$10793),
                List.permutations(List.removeIndex(i$10786, l$10793))
            ),
            List.permutationHelper(<[unknown exp]>(i$10786, 1i32), l$10793)
        )
    }
}

def List.permutations(l$10771: List[a]): List[List[a]] = {
    match l$10771 {
        case List.Nil =>
            List.Cons(List.Nil, List.Nil)
        case _ =>
            List.permutationHelper(0i32, l$10771)
    }
}

def List.point(a$10002: a): List[a] = {List.Cons(a$10002, List.Nil)}

def List.range(b$9615: Int32, e$9617: Int32): List[Int32] = {
    letrec loop$9620: (Int32 -> List[Int32] -> List[Int32]) = i$9623 ->
        acc$9625 ->
            if (<[unknown exp]>(i$9623, b$9615)) {
                acc$9625
            } else {
                loop$9620(
                    <[unknown exp]>(i$9623, 1i32)
                )(List.Cons(i$9623, acc$9625))
            };
    loop$9620(<[unknown exp]>(e$9617, 1i32))(List.Nil)
}

def List.reduceLeft(
    f$11671: a -> a -> a \ ef,
    l$11677: List[a]
): Option[a] \ ef = {
    match l$11677 {
        case List.Nil =>
            Option.None
        case List.Cons(x$11689, xs$11693) =>
            Option.Some(List.foldLeft(f$11671, x$11689, xs$11693))
    }
}

def List.reduceRight(
    f$11732: a -> a -> a \ ef,
    l$11741: List[a]
): Option[a] \ ef = {
    letrec loop$11749: (
        List[a] ->
            (Option[a] -> Option[a] \ (e113988 & ef) + ef) -> Option[a] \ ef + (e113988 & ef) + ef
    ) = ll$11751 ->
        k$11753 ->
            match ll$11751 {
                case List.Nil =>
                    k$11753(Option.None)
                case List.Cons(x$11762, xs$11768) =>
                    loop$11749(
                        xs$11768
                    )(
                        ks$11775 ->
                            k$11753(
                                match ks$11775 {
                                    case Option.None =>
                                        Option.Some(x$11762)
                                    case Option.Some(v$11779) =>
                                        Option.Some(f$11732(x$11762)(v$11779))
                                }
                            )
                    )
            };
    loop$11749(l$11741)($0$45792 -> eidentity($0$45792))
}

def List.removeIndex(i$10864: Int32, l$10870: List[a]): List[a] = {
    match (i$10864, l$10870) {
        case (_, List.Nil) =>
            l$10870
        case (0i32, List.Cons(_, xs$10886)) =>
            xs$10886
        case (p$10890, List.Cons(x$10894, xs$10896)) =>
            List.Cons(
                x$10894,
                List.removeIndex(<[unknown exp]>(p$10890, 1i32), xs$10896)
            )
    }
}

def List.repeat(n$9634: Int32, a$9638: a): List[a] = {
    letrec loop$9644: (Int32 -> List[a] -> List[a]) = i$9649 ->
        acc$9654 ->
            if (<[unknown exp]>(i$9649, n$9634)) {
                acc$9654
            } else {
                loop$9644(
                    <[unknown exp]>(i$9649, 1i32)
                )(List.Cons(a$9638, acc$9654))
            };
    loop$9644(0i32)(List.Nil)
}

def List.replace(
    src$10635: { src = a },
    dst$10643: { dst = a },
    l$10647: List[a]
): List[a] = {
    List.map(
        e$10655 ->
            if (<[unknown exp]>(e$10655, src$10635.src)) {
                dst$10643.dst
            } else {
                e$10655
            },
        l$10647
    )
}

def List.reverse(l$10473: List[a]): List[a] = {
    letrec loop$10485: (List[a] -> List[a] -> List[a]) = ll$10487 ->
        acc$10489 ->
            match ll$10487 {
                case List.Nil =>
                    acc$10489
                case List.Cons(x$10495, xs$10497) =>
                    loop$10485(xs$10497)(List.Cons(x$10495, acc$10489))
            };
    loop$10485(l$10473)(List.Nil)
}

def List.rotateLeft(n$10524: Int32, l$10528: List[a]): List[a] = {
    let len$10532: Int32 = List.length(l$10528);
    if (<[unknown exp]>(len$10532, 0i32)) {
        l$10528
    } else {
        let rem1$10534: Int32 = Int32.remainder(n$10524, len$10532);
        let rotate$10536: Int32 = if (<[unknown exp]>(rem1$10534, 0i32)) {
            <[unknown exp]>(rem1$10534, len$10532)
        } else {
            rem1$10534
        };
        List.append(
            List.drop(rotate$10536, l$10528),
            List.take(rotate$10536, l$10528)
        )
    }
}

def List.rotateRight(n$10542: Int32, l$10545: List[a]): List[a] = {
    List.rotateLeft(<[unknown exp]>(n$10542), l$10545)
}

def List.scan(
    f$9682: b -> a -> b \ ef,
    s$9689: b,
    l$9692: List[a]
): List[b] \ ef = {
    List.scanLeft(f$9682, s$9689, l$9692)
}

def List.scanLeft(
    f$9732: b -> a -> b \ ef,
    s$9738: b,
    l$9740: List[a]
): List[b] \ ef = {
    letrec loop$9744: (
        List[a] -> (List[b] -> List[b]) -> (b -> List[b] \ ef)
    ) = ll$9747 ->
        k$9752 ->
            acc$9754 ->
                match ll$9747 {
                    case List.Nil =>
                        k$9752(List.Nil)
                    case List.Cons(x$9756, xs$9758) =>
                        let y$9760: b = f$9732(acc$9754)(x$9756);
                        loop$9744(
                            xs$9758
                        )(ks$9762 -> k$9752(List.Cons(y$9760, ks$9762)))(y$9760)
                };
    loop$9744(l$9740)(ks$9774 -> List.Cons(s$9738, ks$9774))(s$9738)
}

def List.scanRight(
    f$9831: a -> b -> b \ ef,
    s$9836: b,
    l$9838: List[a]
): List[b] \ ef = {
    letrec loop$9848: (
        List[a] ->
            (List[b] -> List[b] \ (e128087 + ef) & ef) -> List[b] \ ef + ((e128087 + ef) & ef)
    ) = ll$9850 ->
        k$9852 ->
            match ll$9850 {
                case List.Nil =>
                    k$9852(List.Cons(s$9836, List.Nil))
                case List.Cons(x$9856, xs$9858) =>
                    loop$9848(
                        xs$9858
                    )(
                        ks$9862 ->
                            match ks$9862 {
                                case List.Cons(ss$9868, _) =>
                                    k$9852(
                                        List.Cons(
                                            f$9831(x$9856)(ss$9868),
                                            ks$9862
                                        )
                                    )
                                case _ =>
                                    unreachable!(())
                            }
                    )
            };
    loop$9848(l$9838)($0$45748 -> eidentity($0$45748))
}

def List.sequence(l$16864: List[m[a]]): m[List[a]] = {
    letrec loop$16877: (
        List[m[a]] -> (m[List[a]] -> m[List[a]]) -> m[List[a]]
    ) = ll$16880 ->
        k$16885 ->
            match ll$16880 {
                case List.Nil =>
                    k$16885(<[unknown exp]>(List.Nil))
                case List.Cons(mx$16892, rs$16897) =>
                    loop$16877(
                        rs$16897
                    )(ks$16899 -> k$16885(List.consA(mx$16892, ks$16899)))
            };
    loop$16877(l$16864)($0$45999 -> identity($0$45999))
}

def List.shuffle(rnd$17074: Random, l$17076: List[a]): List[a] \ IO = {
    region rc$17085 {
        |>(
            !>(
                List.toArray(rc$17085, l$17076),
                (
                    $0$46017 ->
                        $1$46019 ->
                            Array.shuffle($0$46017, $1$46019)
                )(rnd$17074)
            ),
            $0$46021 ->
                Array.toList($0$46021)
        )
    }
}

def List.slice(
    start$12143: { start = Int32 },
    end$12147: { end = Int32 },
    l$12149: List[a]
): List[a] = {
    letrec loop$12159: (
        List[a] -> Int32 -> ((List[a] -> List[a]) -> List[a])
    ) = ll$12165 ->
        i$12171 ->
            k$12176 ->
                match ll$12165 {
                    case List.Nil =>
                        k$12176(List.Nil)
                    case List.Cons(x$12180, xs$12182) =>
                        if (<[unknown exp]>(i$12171, start$12143.start)) {
                            loop$12159(
                                xs$12182
                            )(<[unknown exp]>(i$12171, 1i32))(k$12176)
                        } else {
                            if (<[unknown exp]>(i$12171, end$12147.end)) {
                                k$12176(List.Nil)
                            } else {
                                loop$12159(
                                    xs$12182
                                )(
                                    <[unknown exp]>(i$12171, 1i32)
                                )(
                                    ks$12220 ->
                                        k$12176(List.Cons(x$12180, ks$12220))
                                )
                            }
                        }
                };
    if (<[unknown exp]>(start$12143.start, end$12147.end)) {
        loop$12159(l$12149)(0i32)($0$45804 -> identity($0$45804))
    } else {
        List.Nil
    }
}

def List.sort(l$16261: List[a]): List[a] = {
    region rc$16271 {
        |>(
            !>(
                List.toArray(rc$16271, l$16261),
                $0$45929 ->
                    Array.sort!($0$45929)
            ),
            $0$45933 ->
                Array.toList($0$45933)
        )
    }
}

def List.sortBy(f$16289: a -> b, l$16295: List[a]): List[a] = {
    region rc$16304 {
        |>(
            !>(
                List.toArray(rc$16304, l$16295),
                (
                    $0$45935 ->
                        $1$45937 ->
                            Array.sortBy!($0$45935, $1$45937)
                )(f$16289)
            ),
            $0$45939 ->
                Array.toList($0$45939)
        )
    }
}

def List.sortWith(
    cmp$16315: a -> a -> Comparison,
    l$16317: List[a]
): List[a] = {
    region rc$16324 {
        |>(
            !>(
                List.toArray(rc$16324, l$16317),
                (
                    $0$45941 ->
                        $1$45943 ->
                            Array.sortWith!($0$45941, $1$45943)
                )(cmp$16315)
            ),
            $0$45945 ->
                Array.toList($0$45945)
        )
    }
}

def List.span(f$12360: a -> Bool, l$12374: List[a]): (List[a], List[a]) = {
    letrec loop$12378: (
        List[a] ->
            (((List[a], List[a])) -> (List[a], List[a])) -> (List[a], List[a])
    ) = ll$12380 ->
        k$12382 ->
            match ll$12380 {
                case List.Nil =>
                    k$12382((List.Nil, List.Nil))
                case List.Cons(x$12384, xs$12386) =>
                    if (f$12360(x$12384)) {
                        loop$12378(
                            xs$12386
                        )(
                            pat$27$12392 ->
                                match pat$27$12392 {
                                    case (ks$12398, ls$12400) =>
                                        k$12382(
                                            (
                                                List.Cons(x$12384, ks$12398),
                                                ls$12400
                                            )
                                        )
                                }
                        )
                    } else {
                        k$12382((List.Nil, ll$12380))
                    }
            };
    loop$12378(l$12374)($0$45808 -> identity($0$45808))
}

def List.splitAt(n$12838: Int32, xs$12842: List[a]): (List[a], List[a]) = {
    (List.take(n$12838, xs$12842), List.drop(n$12838, xs$12842))
}

def List.subsequences(l$10904: List[a]): List[List[a]] = {
    match l$10904 {
        case List.Nil =>
            List.Cons(List.Nil, List.Nil)
        case List.Cons(x$10917, xs$10919) =>
            let r$10924: List[List[a]] = List.subsequences(xs$10919);
            List.append(List.applyHelper(x$10917, r$10924), r$10924)
    }
}

def List.sum(l$16665: List[Int32]): Int32 = {<[unknown exp]>(l$16665)}

def List.sumWith(f$16680: a -> Int32, l$16685: List[a]): Int32 \ ef = {
    <[unknown exp]>(f$16680, l$16685)
}

def List.take(n$12570: Int32, l$12572: List[a]): List[a] = {
    letrec loop$12579: (
        List[a] -> Int32 -> ((List[a] -> List[a]) -> List[a])
    ) = ll$12581 ->
        i$12585 ->
            k$12587 ->
                if (<[unknown exp]>(i$12585, 0i32)) {
                    k$12587(List.Nil)
                } else {
                    match ll$12581 {
                        case List.Nil =>
                            k$12587(List.Nil)
                        case List.Cons(x$12590, xs$12592) =>
                            loop$12579(
                                xs$12592
                            )(
                                <[unknown exp]>(i$12585, 1i32)
                            )(ks$12599 -> k$12587(List.Cons(x$12590, ks$12599)))
                    }
                };
    loop$12579(l$12572)(n$12570)($0$45810 -> identity($0$45810))
}

def List.takeWhile(f$12765: a -> Bool, l$12767: List[a]): List[a] \ ef = {
    letrec loop$12782: (
        List[a] -> (List[a] -> List[a]) -> List[a] \ ef
    ) = ll$12793 ->
        k$12797 ->
            match ll$12793 {
                case List.Nil =>
                    k$12797(List.Nil)
                case List.Cons(x$12805, xs$12807) =>
                    if (f$12765(x$12805)) {
                        loop$12782(
                            xs$12807
                        )(ks$12809 -> k$12797(List.Cons(x$12805, ks$12809)))
                    } else {
                        k$12797(List.Nil)
                    }
            };
    loop$12782(l$12767)($0$45812 -> identity($0$45812))
}

def List.toArray(rc$16128: Region[r], l$16132: List[a]): Array[a, r] \ r = {
    match List.head(l$16132) {
        case Option.None =>
            [] @ rc$16128
        case Option.Some(_) =>
            let a$16135: Array[a, r] = Array.empty(
                rc$16128,
                List.length(l$16132)
            );
            List.forEach(
                pat$53$16137 ->
                    match pat$53$16137 {
                        case (i$16139, b$16141) =>
                            Array.put(b$16141, i$16139, a$16135)
                    },
                List.zipWithIndex(l$16132)
            );
            a$16135
    }
}

def List.toChain(l$15318: List[a]): Chain[a] = {
    List.foldLeft(
        $0$45899 ->
            $1$45903 ->
                Chain.snoc($0$45899, $1$45903),
        Chain.empty(()),
        l$15318
    )
}

def List.toDelayList(l$14018: List[a]): DelayList[a] = {
    match l$14018 {
        case List.Nil =>
            DelayList.ENil
        case List.Cons(x$14035, xs$14037) =>
            DelayList.LCons(x$14035, lazy List.toDelayList(xs$14037))
    }
}

def List.toDelayMap(l$16781: List[(a, b)]): DelayMap[a, b] = {
    List.foldRight(
        x$16784 ->
            acc$16789 ->
                DelayMap.insert(fst(x$16784), snd(x$16784), acc$16789),
        DelayMap.empty(()),
        l$16781
    )
}

def List.toMap(l$15950: List[(a, b)]): Map[a, b] = {
    List.foldRight(
        x$15959 ->
            acc$15963 ->
                Map.insert(fst(x$15959), snd(x$15959), acc$15963),
        Map.empty(()),
        l$15950
    )
}

def List.toMapWith(f$15979: a -> b, l$15984: List[a]): Map[a, b] = {
    List.foldRight(
        x$15997 ->
            acc$15999 ->
                Map.insert(x$15997, f$15979(x$15997), acc$15999),
        Map.empty(()),
        l$15984
    )
}

def List.toMutDeque(
    rc$15358: Region[r],
    l$15361: List[a]
): MutDeque[a, r] \ r = {
    let d$15403: MutDeque[a, r] = MutDeque.empty(rc$15358);
    List.forEach(x$15412 -> MutDeque.pushBack(x$15412, d$15403), l$15361);
    d$15403
}

def List.toMutList(rc$15882: Region[r], l$15884: List[a]): MutList[a, r] \ r = {
    region rc2$15894 {
        Array.toMutList(rc$15882, List.toArray(rc2$15894, l$15884))
    }
}

def List.toNec(l$16225: List[a]): Option[Nec[a]] = {
    match l$16225 {
        case List.Nil =>
            Option.None
        case List.Cons(x$16232, xs$16234) =>
            Option.Some(
                List.foldLeft(
                    $0$45925 ->
                        $1$45927 ->
                            Nec.snoc($0$45925, $1$45927),
                    Nec.singleton(x$16232),
                    xs$16234
                )
            )
    }
}

def List.toNel(l$16194: List[a]): Option[Nel[a]] = {
    match l$16194 {
        case List.Nil =>
            Option.None
        case List.Cons(x$16199, xs$16201) =>
            Option.Some(Nel.Nel(x$16199, xs$16201))
    }
}

def List.toSet(l$15910: List[a]): Set[a] = {
    List.foldRight(
        x$15918 ->
            acc$15922 ->
                Set.insert(x$15918, acc$15922),
        Set.empty(()),
        l$15910
    )
}

def List.toString(l$8983: List[a]): String = {
    region rc$8997 {
        let sb$9000: StringBuilder[rc] = StringBuilder.empty(rc$8997);
        region reg$11$9004 {
            Iterator.forEach(
                pat$12$9007 ->
                    match pat$12$9007 {
                        case x$9009 =>
                            StringBuilder.appendString!(
                                ("""""" + <[unknown exp]>(x$9009)) + """ :: """,
                                sb$9000
                            )
                    },
                <[unknown exp]>(reg$11$9004, l$8983)
            )
        };
        StringBuilder.appendString!("""Nil""", sb$9000);
        StringBuilder.toString(sb$9000)
    }
}

def List.toVector(l$16163: List[a]): Vector[a] = {
    region rc$16165 {
        let arr$16168: Array[a, rc] = Array.empty(
            rc$16165,
            List.length(l$16163)
        );
        List.forEachWithIndex(
            i$16172 ->
                x$16176 ->
                    Array.put(x$16176, i$16172, arr$16168),
            l$16163
        );
        Array.toVector(arr$16168)
    }
}

def List.transpose(l$11155: List[List[a]]): List[List[a]] = {
    match l$11155 {
        case List.Nil =>
            List.Nil
        case List.Cons(x$11163, _) =>
            let len$11167: Int32 = List.length(x$11163);
            if (
                (
                    !List.uniformHelper(l$11155, len$11167)
                ) or <[unknown exp]>(len$11167, 0i32)
            ) {
                l$11155
            } else {
                List.transposeHelper(l$11155, len$11167)
            }
    }
}

def List.transposeHelper(
    l$11244: List[List[a]],
    len$11246: Int32
): List[List[a]] = {
    match l$11244 {
        case List.Nil =>
            List.repeat(len$11246, List.Nil)
        case List.Cons(x$11255, xs$11259) =>
            List.applyListHelper(
                x$11255,
                List.transposeHelper(xs$11259, len$11246)
            )
    }
}

def List.traverse(f$16935: a -> m[b], l$16953: List[a]): m[List[b]] \ ef = {
    letrec loop$16959: (
        List[a] -> (m[List[b]] -> m[List[b]]) -> m[List[b]] \ ef
    ) = ll$16961 ->
        k$16963 ->
            match ll$16961 {
                case List.Nil =>
                    k$16963(<[unknown exp]>(List.Nil))
                case List.Cons(x$16965, xs$16967) =>
                    let ans$16969: m[b] = f$16935(x$16965);
                    loop$16959(
                        xs$16967
                    )(ks$16972 -> k$16963(List.consA(ans$16969, ks$16972)))
            };
    loop$16959(l$16953)($0$46007 -> identity($0$46007))
}

def List.unfold(f$16345: s -> Option[(a, s)], st$16357: s): List[a] \ ef = {
    letrec loop$16364: (
        s -> (List[a] -> List[a]) -> List[a] \ ef
    ) = sst$16366 ->
        k$16368 ->
            match f$16345(sst$16366) {
                case Option.None =>
                    k$16368(List.Nil)
                case Option.Some(a$16373, st1$16375) =>
                    loop$16364(
                        st1$16375
                    )(ks$16378 -> k$16368(List.Cons(a$16373, ks$16378)))
            };
    loop$16364(st$16357)($0$45959 -> identity($0$45959))
}

def List.unfoldWithIter(next$16397: Unit -> Option[a]): List[a] \ ef = {
    letrec loop$16401: (List[a] -> List[a] -> List[a]) = k$16404 ->
        match next$16397(()) {
            case Option.None =>
                k$16404(List.Nil)
            case Option.Some(x$16410) =>
                loop$16401(ks$16412 -> k$16404(List.Cons(x$16410, ks$16412)))
        };
    loop$16401($0$45973 -> identity($0$45973))
}

def List.unfoldWithOkIter(
    next$16441: Unit -> Result[e, Option[a]]
): Result[e, List[a]] \ ef = {
    letrec loop$16451: (
        Result[e, List[a]] -> Result[e, List[a]] -> Result[e, List[a]]
    ) = k$16453 ->
        match next$16441(()) {
            case Result.Ok(Option.None) =>
                k$16453(Result.Ok(List.Nil))
            case Result.Err(e$16458) =>
                k$16453(Result.Err(e$16458))
            case Result.Ok(Option.Some(x$16461)) =>
                loop$16451(
                    (
                        $0$45975 ->
                            $1$45977 ->
                                Result.flatMap($0$45975, $1$45977)
                    )(
                        ks$16464 ->
                            k$16453(Result.Ok(List.Cons(x$16461, ks$16464)))
                    )
                )
        };
    loop$16451($0$45979 -> identity($0$45979))
}

def List.uniformHelper(l$11187: List[List[a]], len$11209: Int32): Bool = {
    match l$11187 {
        case List.Nil =>
            true
        case List.Cons(x$11225, xs$11227) =>
            if (<[unknown exp]>(List.length(x$11225), len$11209)) {
                List.uniformHelper(xs$11227, len$11209)
            } else {
                false
            }
    }
}

def List.unzip(l$13308: List[(a, b)]): (List[a], List[b]) = {
    letrec loop$13321: (
        List[(a, b)] ->
            (((List[a], List[b])) -> (List[a], List[b])) -> (List[a], List[b])
    ) = ll$13323 ->
        k$13329 ->
            match ll$13323 {
                case List.Nil =>
                    k$13329((List.Nil, List.Nil))
                case List.Cons((x1$13331, x2$13333), xs$13336) =>
                    loop$13321(
                        xs$13336
                    )(
                        pat$28$13340 ->
                            match pat$28$13340 {
                                case (ks$13342, ls$13344) =>
                                    k$13329(
                                        (
                                            List.Cons(x1$13331, ks$13342),
                                            List.Cons(x2$13333, ls$13344)
                                        )
                                    )
                            }
                    )
            };
    loop$13321(l$13308)($0$45883 -> identity($0$45883))
}

def List.unzip3(l$13502: List[(a, b, c)]): (List[a], List[b], List[c]) = {
    letrec loop$13513: (
        List[(a, b, c)] ->
            (((List[a], List[b], List[c])) -> (List[a], List[b], List[c])) -> (List[a], List[b], List[c])
    ) = ll$13516 ->
        k$13520 ->
            match ll$13516 {
                case List.Nil =>
                    k$13520((List.Nil, List.Nil, List.Nil))
                case List.Cons((x$13523, y$13526, z$13529), xs$13531) =>
                    loop$13513(
                        xs$13531
                    )(
                        pat$29$13533 ->
                            match pat$29$13533 {
                                case (ks$13537, ls$13539, ms$13541) =>
                                    k$13520(
                                        (
                                            List.Cons(x$13523, ks$13537),
                                            List.Cons(y$13526, ls$13539),
                                            List.Cons(z$13529, ms$13541)
                                        )
                                    )
                            }
                    )
            };
    loop$13513(l$13502)($0$45887 -> identity($0$45887))
}

def List.update(i$10565: Int32, a$10567: a, l$10571: List[a]): List[a] = {
    letrec loop$10583: (
        List[a] -> Int32 -> ((List[a] -> List[a]) -> List[a])
    ) = ll$10587 ->
        j$10589 ->
            k$10593 ->
                match (j$10589, ll$10587) {
                    case (_, List.Nil) =>
                        k$10593(List.Nil)
                    case (0i32, List.Cons(_, xs$10601)) =>
                        k$10593(List.Cons(a$10567, xs$10601))
                    case (_, List.Cons(x$10603, xs$10605)) =>
                        loop$10583(
                            xs$10605
                        )(
                            <[unknown exp]>(j$10589, 1i32)
                        )(ks$10609 -> k$10593(List.Cons(x$10603, ks$10609)))
                };
    loop$10583(l$10571)(i$10565)($0$45764 -> identity($0$45764))
}

def List.zip(l1$13033: List[a], l2$13036: List[b]): List[(a, b)] = {
    letrec loop$13046: (
        List[a] -> List[b] -> ((List[(a, b)] -> List[(a, b)]) -> List[(a, b)])
    ) = ll1$13050 ->
        ll2$13054 ->
            k$13056 ->
                match (ll1$13050, ll2$13054) {
                    case (
                        List.Cons(x$13058, xs$13060),
                        List.Cons(y$13062, ys$13064)
                    ) =>
                        loop$13046(
                            xs$13060
                        )(
                            ys$13064
                        )(
                            ks$13069 ->
                                k$13056(List.Cons((x$13058, y$13062), ks$13069))
                        )
                    case _ =>
                        k$13056(List.Nil)
                };
    loop$13046(l1$13033)(l2$13036)($0$45875 -> identity($0$45875))
}

def List.zip3(
    l1$13370: List[a],
    l2$13372: List[b],
    l3$13375: List[c]
): List[(a, b, c)] = {
    List.zipWith3(
        x$13383 ->
            y$13387 ->
                z$13390 ->
                    (x$13383, y$13387, z$13390),
        l1$13370,
        l2$13372,
        l3$13375
    )
}

def List.zipWith(
    f$13097: a -> b -> c \ ef,
    l1$13101: List[a],
    l2$13103: List[b]
): List[c] \ ef = {
    letrec loop$13116: (
        List[a] -> List[b] -> ((List[c] -> List[c]) -> List[c] \ ef)
    ) = ll1$13118 ->
        ll2$13123 ->
            k$13125 ->
                match (ll1$13118, ll2$13123) {
                    case (
                        List.Cons(x$13128, xs$13130),
                        List.Cons(y$13135, ys$13137)
                    ) =>
                        let z$13139: c = f$13097(x$13128)(y$13135);
                        loop$13116(
                            xs$13130
                        )(
                            ys$13137
                        )(ks$13142 -> k$13125(List.Cons(z$13139, ks$13142)))
                    case _ =>
                        k$13125(List.Nil)
                };
    loop$13116(l1$13101)(l2$13103)($0$45877 -> identity($0$45877))
}

def List.zipWith3(
    f$13414: a -> b -> (c -> d \ ef),
    l1$13416: List[a],
    l2$13425: List[b],
    l3$13429: List[c]
): List[d] \ ef = {
    letrec loop$13435: (
        List[a] ->
            List[b] -> (List[c] -> ((List[d] -> List[d]) -> List[d] \ ef))
    ) = ll1$13437 ->
        ll2$13439 ->
            ll3$13442 ->
                k$13445 ->
                    match (ll1$13437, ll2$13439, ll3$13442) {
                        case (
                            List.Cons(x$13452, xs$13454),
                            List.Cons(y$13456, ys$13458),
                            List.Cons(z$13460, zs$13462)
                        ) =>
                            let r$13464: d = f$13414(x$13452)(y$13456)(z$13460);
                            loop$13435(
                                xs$13454
                            )(
                                ys$13458
                            )(
                                zs$13462
                            )(ks$13471 -> k$13445(List.Cons(r$13464, ks$13471)))
                        case _ =>
                            k$13445(List.Nil)
                    };
    loop$13435(l1$13416)(l2$13425)(l3$13429)($0$45885 -> identity($0$45885))
}

def List.zipWithA(
    f$13203: a -> b -> f[c] \ ef,
    xs$13212: List[a],
    ys$13217: List[b]
): f[List[c]] \ ef = {
    <[unknown exp]>
}

def List.zipWithIndex(l$13160: List[a]): List[(Int32, a)] = {
    letrec loop$13169: (
        List[a] ->
            Int32 -> ((List[(Int32, a)] -> List[(Int32, a)]) -> List[(Int32, a)])
    ) = ll$13171 ->
        i$13173 ->
            k$13175 ->
                match ll$13171 {
                    case List.Nil =>
                        k$13175(List.Nil)
                    case List.Cons(x$13182, xs$13184) =>
                        loop$13169(
                            xs$13184
                        )(
                            <[unknown exp]>(i$13173, 1i32)
                        )(
                            ks$13186 ->
                                k$13175(List.Cons((i$13173, x$13182), ks$13186))
                        )
                };
    loop$13169(l$13160)(0i32)($0$45879 -> identity($0$45879))
}

enum Map[k, v] {case Map(RedBlackTree[k, v])}

def Map.adjust(
    f$30146: v -> v,
    k$30155: k,
    m$30164: Map[k, v]
): Map[k, v] \ ef = {
    Map.adjustWithKey(
        _$30193 ->
            v1$30197 ->
                f$30146(v1$30197),
        k$30155,
        m$30164
    )
}

def Map.adjustWithKey(
    f$30222: k -> v -> v \ ef,
    k$30236: k,
    m$30242: Map[k, v]
): Map[k, v] \ ef = {
    Map.updateWithKey(
        k1$30252 ->
            v$30254 ->
                Option.Some(f$30222(k1$30252)(v$30254)),
        k$30236,
        m$30242
    )
}

def Map.count(f$31299: k -> v -> Bool \ ef, m$31327: Map[k, v]): Int32 \ ef = {
    letrec c$31367: (Unit -> Int32) = _unit$31369 ->
        Map.foldLeftWithKey(
            b$31373 ->
                k$31377 ->
                    v$31379 ->
                        if (f$31299(k$31377)(v$31379)) {
                            <[unknown exp]>(b$31373, 1i32)
                        } else {
                            b$31373
                        },
            0i32,
            m$31327
        );
    match purityOf2(f$31299) {
        case Purity2.Pure(g$31383) =>
            if (Map.useParallelEvaluation(m$31327)) {
                match m$31327 {
                    case Map.Map(t$31391) =>
                        RedBlackTree.parCount(
                            <[unknown exp]>(Map.threads(()), 1i32),
                            g$31383,
                            t$31391
                        )
                }
            } else {
                c$31367(())
            }
        case Purity2.Impure(_) =>
            c$31367(())
    }
}

def Map.difference(m1$31857: Map[k, v], m2$31861: Map[k, v]): Map[k, v] = {
    Map.differenceWithKey(
        _$31868 ->
            _$31870 ->
                _$31872 ->
                    Option.None,
        m1$31857,
        m2$31861
    )
}

def Map.differenceWith(
    f$31891: v -> v -> Option[v] \ ef,
    m1$31899: Map[k, v],
    m2$31901: Map[k, v]
): Map[k, v] \ ef = {
    Map.differenceWithKey(
        _$31903 ->
            v1$31905 ->
                v2$31907 ->
                    f$31891(v1$31905)(v2$31907),
        m1$31899,
        m2$31901
    )
}

def Map.differenceWithKey(
    f$31933: k -> v -> (v -> Option[v] \ ef),
    m1$31935: Map[k, v],
    m2$31937: Map[k, v]
): Map[k, v] \ ef = {
    let diff$32365: Map[k, v] = Map.filterWithKey(
        k$32367 ->
            _$32369 ->
                !Map.memberOf(k$32367, m2$31937),
        m1$31935
    );
    let g$32371: (k -> v -> (Map[k, v] -> Map[k, v] \ ef)) = k$32373 ->
        v$32375 ->
            acc$32377 ->
                if (Map.memberOf(k$32373, m1$31935)) {
                    match Map.get(k$32373, m1$31935) {
                        case Option.Some(v1$32381) =>
                            match f$31933(k$32373)(v1$32381)(v$32375) {
                                case Option.None =>
                                    acc$32377
                                case Option.Some(w$32387) =>
                                    Map.insert(k$32373, w$32387, acc$32377)
                            }
                        case Option.None =>
                            unreachable!(())
                    }
                } else {
                    acc$32377
                };
    Map.foldRightWithKey(g$32371, diff$32365, m2$31937)
}

def Map.empty(_unit$29156: Unit): Map[k, v] = {Map.Map(RedBlackTree.empty(()))}

def Map.exists(f$31500: k -> v -> Bool \ ef, m$31510: Map[k, v]): Bool \ ef = {
    match m$31510 {
        case Map.Map(t$31516) =>
            letrec e$31518: (Unit -> Bool) = _unit$31520 ->
                RedBlackTree.exists(f$31500, t$31516);
            match purityOf2(f$31500) {
                case Purity2.Pure(g$31522) =>
                    if (Map.useParallelEvaluation(m$31510)) {
                        RedBlackTree.parExists(
                            <[unknown exp]>(Map.threads(()), 1i32),
                            g$31522,
                            t$31516
                        )
                    } else {
                        e$31518(())
                    }
                case Purity2.Impure(_) =>
                    e$31518(())
            }
    }
}

def Map.explode(m$33120: Map[k, t[v]]): Set[(k, v)] = {
    Map.foldLeftWithKey(
        acc$33135 ->
            k$33137 ->
                t$33139 ->
                    |>(
                        |>(
                            <[unknown exp]>(t$33139),
                            (
                                $0$46494 ->
                                    $1$46496 ->
                                        Set.map($0$46494, $1$46496)
                            )(e$33141 -> (k$33137, e$33141))
                        ),
                        (
                            $0$46498 ->
                                $1$46500 ->
                                    Set.union($0$46498, $1$46500)
                        )(acc$33135)
                    ),
        Set.empty(()),
        m$33120
    )
}

def Map.filter(f$30529: v -> Bool, m$30535: Map[k, v]): Map[k, v] \ ef = {
    Map.filterWithKey(_$30545 -> v$30547 -> f$30529(v$30547), m$30535)
}

def Map.filterMap(
    f$30609: a -> Option[b],
    m$30611: Map[k, a]
): Map[k, b] \ ef = {
    let step$30623: (Map[k, b] -> k -> (a -> Map[k, b] \ ef)) = acc$30627 ->
        k$30629 ->
            a$30631 ->
                match f$30609(a$30631) {
                    case Option.Some(b$30633) =>
                        Map.insert(k$30629, b$30633, acc$30627)
                    case Option.None =>
                        acc$30627
                };
    Map.foldLeftWithKey(step$30623, Map.empty(()), m$30611)
}

def Map.filterMapWithKey(
    f$30649: k -> a -> Option[b] \ ef,
    m$30659: Map[k, a]
): Map[k, b] \ ef = {
    let step$30671: (Map[k, b] -> k -> (a -> Map[k, b] \ ef)) = acc$30673 ->
        k$30675 ->
            a$30677 ->
                match f$30649(k$30675)(a$30677) {
                    case Option.Some(b$30686) =>
                        Map.insert(k$30675, b$30686, acc$30673)
                    case Option.None =>
                        acc$30673
                };
    Map.foldLeftWithKey(step$30671, Map.empty(()), m$30659)
}

def Map.filterWithKey(
    f$30568: k -> v -> Bool \ ef,
    m$30570: Map[k, v]
): Map[k, v] \ ef = {
    Map.foldLeftWithKey(
        acc$30573 ->
            k$30577 ->
                v$30581 ->
                    if (f$30568(k$30577)(v$30581)) {
                        Map.insert(k$30577, v$30581, acc$30573)
                    } else {
                        acc$30573
                    },
        Map.empty(()),
        m$30570
    )
}

def Map.find(
    f$30475: k -> v -> Bool \ ef,
    m$30477: Map[k, v]
): Option[(k, v)] \ ef = {
    Map.findLeft(f$30475, m$30477)
}

def Map.findLeft(
    f$30495: k -> v -> Bool \ ef,
    m$30497: Map[k, v]
): Option[(k, v)] \ ef = {
    match m$30497 {
        case Map.Map(t$30499) =>
            RedBlackTree.findLeft(f$30495, t$30499)
    }
}

def Map.findRight(
    f$30513: k -> v -> Bool \ ef,
    m$30515: Map[k, v]
): Option[(k, v)] \ ef = {
    match m$30515 {
        case Map.Map(t$30517) =>
            RedBlackTree.findRight(f$30513, t$30517)
    }
}

def Map.foldLeft(
    f$30816: b -> v -> b \ ef,
    s$30818: b,
    m$30820: Map[k, v]
): b \ ef = {
    Map.foldLeftWithKey(
        acc$30823 ->
            _$30825 ->
                v$30827 ->
                    f$30816(acc$30823)(v$30827),
        s$30818,
        m$30820
    )
}

def Map.foldLeftWithKey(
    f$30860: b -> k -> (v -> b \ ef),
    s$30869: b,
    m$30871: Map[k, v]
): b \ ef = {
    match m$30871 {
        case Map.Map(xs$30873) =>
            RedBlackTree.foldLeft(f$30860, s$30869, xs$30873)
    }
}

def Map.foldMap(f$31072: v -> b, m$31078: Map[k, v]): b \ ef = {
    Map.foldMapWithKey(_$31080 -> f$31072, m$31078)
}

def Map.foldMapWithKey(
    f$31031: k -> v -> b \ ef,
    m$31034: Map[k, v]
): b \ ef = {
    Map.foldLeftWithKey(
        acc$31040 ->
            k$31042 ->
                v$31044 ->
                    <[unknown exp]>(acc$31040, f$31031(k$31042)(v$31044)),
        <[unknown exp]>(()),
        m$31034
    )
}

def Map.foldRight(
    f$30891: v -> b -> b \ ef,
    s$30893: b,
    m$30895: Map[k, v]
): b \ ef = {
    Map.foldRightWithKey(
        _$30897 ->
            v$30899 ->
                acc$30901 ->
                    f$30891(v$30899)(acc$30901),
        s$30893,
        m$30895
    )
}

def Map.foldRightWithCont(
    f$30955: v -> (Unit -> b \ ef) -> b \ ef,
    z$30957: b,
    m$30959: Map[k, v]
): b \ ef = {
    Map.foldRightWithKeyCont(
        _$30961 ->
            v$30963 ->
                c$30965 ->
                    f$30955(v$30963)(c$30965),
        z$30957,
        m$30959
    )
}

def Map.foldRightWithKey(
    f$30917: k -> v -> (b -> b \ ef),
    s$30919: b,
    m$30921: Map[k, v]
): b \ ef = {
    match m$30921 {
        case Map.Map(t$30923) =>
            RedBlackTree.foldRight(f$30917, s$30919, t$30923)
    }
}

def Map.foldRightWithKeyCont(
    f$30989: k -> v -> ((Unit -> b \ ef) -> b \ ef),
    z$30999: b,
    m$31003: Map[k, v]
): b \ ef = {
    match m$31003 {
        case Map.Map(t$31013) =>
            RedBlackTree.foldRightWithCont(f$30989, z$30999, t$31013)
    }
}

def Map.foldWithKey(
    f$30780: b -> k -> (v -> b \ ef),
    s$30783: b,
    m$30786: Map[k, v]
): b \ ef = {
    Map.foldLeftWithKey(f$30780, s$30783, m$30786)
}

def Map.forAll(f$31535: k -> v -> Bool \ ef, m$31537: Map[k, v]): Bool \ ef = {
    match m$31537 {
        case Map.Map(t$31539) =>
            letrec fa$31541: (Unit -> Bool) = _unit$31543 ->
                RedBlackTree.forAll(f$31535, t$31539);
            match purityOf2(f$31535) {
                case Purity2.Pure(g$31545) =>
                    if (Map.useParallelEvaluation(m$31537)) {
                        RedBlackTree.parForAll(
                            <[unknown exp]>(Map.threads(()), 1i32),
                            g$31545,
                            t$31539
                        )
                    } else {
                        fa$31541(())
                    }
                case Purity2.Impure(_) =>
                    fa$31541(())
            }
    }
}

def Map.forEach(f$32893: k -> v -> Unit \ ef, m$32899: Map[k, v]): Unit \ ef = {
    match m$32899 {
        case Map.Map(t$32917) =>
            RedBlackTree.forEach(f$32893, t$32917)
    }
}

def Map.forEachWithIndex(
    f$32940: Int32 -> k -> (v -> Unit \ ef),
    m$32951: Map[k, v]
): Unit \ ef = {
    match m$32951 {
        case Map.Map(t$32957) =>
            RedBlackTree.forEachWithIndex(f$32940, t$32957)
    }
}

def Map.get(k$29230: k, m$29232: Map[k, v]): Option[v] = {
    match m$29232 {case Map.Map(t$29235) => RedBlackTree.get(k$29230, t$29235)}
}

def Map.getWithDefault(k$29257: k, d$29263: v, m$29265: Map[k, v]): v = {
    Option.getWithDefault(d$29263, Map.get(k$29257, m$29265))
}

def Map.insert(k$29955: k, v$29957: v, m$29959: Map[k, v]): Map[k, v] = {
    match m$29959 {
        case Map.Map(t$29969) =>
            Map.Map(RedBlackTree.insert(k$29955, v$29957, t$29969))
    }
}

def Map.insertWith(
    f$30021: v -> v -> v \ ef,
    k$30023: k,
    v$30025: v,
    m$30027: Map[k, v]
): Map[k, v] \ ef = {
    Map.insertWithKey(
        _$30031 ->
            v1$30033 ->
                v2$30035 ->
                    f$30021(v1$30033)(v2$30035),
        k$30023,
        v$30025,
        m$30027
    )
}

def Map.insertWithKey(
    f$30075: k -> v -> (v -> v \ ef),
    k$30089: k,
    v$30091: v,
    m$30093: Map[k, v]
): Map[k, v] \ ef = {
    match m$30093 {
        case Map.Map(t$30095) =>
            Map.Map(RedBlackTree.insertWith(f$30075, k$30089, v$30091, t$30095))
    }
}

def Map.intersection(m1$31713: Map[k, v], m2$31722: Map[k, v]): Map[k, v] = {
    Map.filterWithKey(
        k$31738 ->
            _$31740 ->
                Map.memberOf(k$31738, m2$31722),
        m1$31713
    )
}

def Map.intersectionWith(
    f$31753: v1 -> v2 -> v3 \ ef,
    m1$31755: Map[k, v1],
    m2$31757: Map[k, v2]
): Map[k, v3] \ ef = {
    Map.intersectionWithKey(
        _$31767 ->
            v1$31769 ->
                v2$31771 ->
                    f$31753(v1$31769)(v2$31771),
        m1$31755,
        m2$31757
    )
}

def Map.intersectionWithKey(
    f$31807: k -> v1 -> (v2 -> v3 \ ef),
    m1$31813: Map[k, v1],
    m2$31815: Map[k, v2]
): Map[k, v3] \ ef = {
    Map.filterMapWithKey(
        k$31826 ->
            v1$31828 ->
                Option.map(
                    v2$31830 ->
                        f$31807(k$31826)(v1$31828)(v2$31830),
                    Map.get(k$31826, m2$31815)
                ),
        m1$31813
    )
}

def Map.invert(m$32421: Map[k, v]): Map[v, Set[k]] = {
    let f$32432: (Map[v, Set[k]] -> k -> (v -> Map[v, Set[k]])) = acc$32434 ->
        k$32436 ->
            v$32438 ->
                Map.insertWith(
                    $0$46488 ->
                        $1$46490 ->
                            Set.union($0$46488, $1$46490),
                    v$32438,
                    Set.insert(k$32436, Set.empty(())),
                    acc$32434
                );
    Map.foldLeftWithKey(f$32432, Map.empty(()), m$32421)
}

def Map.isEmpty(m$29181: Map[k, v]): Bool = {
    match m$29181 {case Map.Map(t$29183) => RedBlackTree.isEmpty(t$29183)}
}

def Map.isProperSubmapOf(m1$30441: Map[k, v], m2$30443: Map[k, v]): Bool = {
    <[unknown exp]>(
        Map.size(m1$30441),
        Map.size(m2$30443)
    ) and Map.isSubmapOf(m1$30441, m2$30443)
}

def Map.isSubmapOf(m1$30416: Map[k, v], m2$30418: Map[k, v]): Bool = {
    Map.forAll(
        k$30432 ->
            v$30434 ->
                <[unknown exp]>(
                    Map.get(k$30432, m2$30418),
                    Option.Some(v$30434)
                ),
        m1$30416
    )
}

def Map.iterator(
    rc$33333: Region[r],
    m$33335: Map[k, v]
): Iterator[(k, v), r, r] \ r = {
    match m$33335 {
        case Map.Map(t$33341) =>
            RedBlackTree.iterator(rc$33333, t$33341)
    }
}

def Map.iteratorKeys(
    rc$33378: Region[r],
    m$33380: Map[k, v]
): Iterator[k, r, r] \ r = {
    |>(
        Map.iterator(rc$33378, m$33380),
        (
            $0$46502 ->
                $1$46504 ->
                    Iterator.map($0$46502, $1$46504)
        )($0$46506 -> fst($0$46506))
    )
}

def Map.iteratorValues(
    rc$33401: Region[r],
    m$33404: Map[k, v]
): Iterator[v, r, r] \ r = {
    |>(
        Map.iterator(rc$33401, m$33404),
        (
            $0$46508 ->
                $1$46510 ->
                    Iterator.map($0$46508, $1$46510)
        )($0$46512 -> snd($0$46512))
    )
}

def Map.joinKeys(sep$33639: String, m$33643: Map[k, v]): String = {
    match m$33643 {
        case Map.Map(t$33654) =>
            RedBlackTree.joinKeys(sep$33639, t$33654)
    }
}

def Map.joinValues(sep$33665: String, m$33667: Map[k, v]): String = {
    match m$33667 {
        case Map.Map(t$33680) =>
            RedBlackTree.joinValues(sep$33665, t$33680)
    }
}

def Map.joinWith(
    f$33706: k -> v -> String \ ef,
    sep$33713: String,
    m$33717: Map[k, v]
): String \ ef = {
    match m$33717 {
        case Map.Map(t$33726) =>
            RedBlackTree.joinWith(f$33706, sep$33713, t$33726)
    }
}

def Map.keysOf(m$29869: Map[k, v]): Set[k] = {
    Map.foldLeftWithKey(
        acc$29877 ->
            k$29879 ->
                _$29881 ->
                    Set.insert(k$29879, acc$29877),
        Set.empty(()),
        m$29869
    )
}

def Map.map(f$30711: v1 -> v2, m$30717: Map[k, v1]): Map[k, v2] \ ef = {
    Map.mapWithKey(_$30719 -> v$30721 -> f$30711(v$30721), m$30717)
}

def Map.mapWithKey(
    f$30746: k -> v1 -> v2 \ ef,
    m$30757: Map[k, v1]
): Map[k, v2] \ ef = {
    match m$30757 {
        case Map.Map(t$30759) =>
            Map.Map(RedBlackTree.mapWithKey(f$30746, t$30759))
    }
}

def Map.maximumKey(m$29605: Map[k, v]): Option[(k, v)] = {
    match m$29605 {case Map.Map(t$29607) => RedBlackTree.maximumKey(t$29607)}
}

def Map.maximumKeyBy(
    cmp$29654: k -> k -> Comparison \ ef,
    m$29660: Map[k, v]
): Option[(k, v)] \ ef = {
    letrec max$29662: (Unit -> Option[(k, v)]) = _unit$29664 ->
        Map.reduceLeftWithKey(
            kl$29667 ->
                vl$29671 ->
                    kr$29673 ->
                        vr$29675 ->
                            if (
                                <[unknown exp]>(
                                    cmp$29654(kl$29667)(kr$29673),
                                    Comparison.GreaterThan
                                )
                            ) {
                                (kl$29667, vl$29671)
                            } else {
                                (kr$29673, vr$29675)
                            },
            m$29660
        );
    match purityOf2(cmp$29654) {
        case Purity2.Pure(g$29679) =>
            if (Map.useParallelEvaluation(m$29660)) {
                let h$29681: (k -> v -> (k -> (v -> Comparison))) = kl$29683 ->
                    _$29685 ->
                        kr$29687 ->
                            _$29689 ->
                                g$29679(kl$29683)(kr$29687);
                match m$29660 {
                    case Map.Map(t$29695) =>
                        RedBlackTree.parMaximumBy(
                            <[unknown exp]>(Map.threads(()), 1i32),
                            h$29681,
                            t$29695
                        )
                }
            } else {
                max$29662(())
            }
        case Purity2.Impure(_) =>
            max$29662(())
    }
}

def Map.maximumValue(m$29728: Map[k, v]): Option[(k, v)] = {
    Map.maximumValueBy(
        x$29742 ->
            y$29746 ->
                <[unknown exp]>(x$29742, y$29746),
        m$29728
    )
}

def Map.maximumValueBy(
    cmp$29778: v -> v -> Comparison \ ef,
    m$29785: Map[k, v]
): Option[(k, v)] \ ef = {
    letrec max$29800: (Unit -> Option[(k, v)]) = _unit$29803 ->
        Map.reduceLeftWithKey(
            kl$29806 ->
                vl$29809 ->
                    kr$29811 ->
                        vr$29813 ->
                            if (
                                <[unknown exp]>(
                                    cmp$29778(vl$29809)(vr$29813),
                                    Comparison.GreaterThan
                                )
                            ) {
                                (kl$29806, vl$29809)
                            } else {
                                (kr$29811, vr$29813)
                            },
            m$29785
        );
    match purityOf2(cmp$29778) {
        case Purity2.Pure(g$29821) =>
            if (Map.useParallelEvaluation(m$29785)) {
                let h$29823: (k -> v -> (k -> (v -> Comparison))) = _$29825 ->
                    vl$29827 ->
                        _$29829 ->
                            vr$29831 ->
                                g$29821(vl$29827)(vr$29831);
                match m$29785 {
                    case Map.Map(t$29841) =>
                        RedBlackTree.parMaximumBy(
                            <[unknown exp]>(Map.threads(()), 1i32),
                            h$29823,
                            t$29841
                        )
                }
            } else {
                max$29800(())
            }
        case Purity2.Impure(_) =>
            max$29800(())
    }
}

def Map.memberOf(k$29292: k, m$29294: Map[k, v]): Bool = {
    match m$29294 {
        case Map.Map(t$29296) =>
            RedBlackTree.memberOf(k$29292, t$29296)
    }
}

def Map.minimumKey(m$29313: Map[k, v]): Option[(k, v)] = {
    match m$29313 {case Map.Map(t$29329) => RedBlackTree.minimumKey(t$29329)}
}

def Map.minimumKeyBy(
    cmp$29359: k -> k -> Comparison \ ef,
    m$29365: Map[k, v]
): Option[(k, v)] \ ef = {
    letrec min$29392: (Unit -> Option[(k, v)]) = _unit$29394 ->
        Map.reduceLeftWithKey(
            kl$29398 ->
                vl$29402 ->
                    kr$29404 ->
                        vr$29406 ->
                            if (
                                <[unknown exp]>(
                                    cmp$29359(kl$29398)(kr$29404),
                                    Comparison.LessThan
                                )
                            ) {
                                (kl$29398, vl$29402)
                            } else {
                                (kr$29404, vr$29406)
                            },
            m$29365
        );
    match purityOf2(cmp$29359) {
        case Purity2.Pure(g$29414) =>
            if (Map.useParallelEvaluation(m$29365)) {
                let h$29416: (k -> v -> (k -> (v -> Comparison))) = kl$29418 ->
                    _$29420 ->
                        kr$29422 ->
                            _$29424 ->
                                g$29414(kl$29418)(kr$29422);
                match m$29365 {
                    case Map.Map(t$29426) =>
                        RedBlackTree.parMinimumBy(
                            <[unknown exp]>(Map.threads(()), 1i32),
                            h$29416,
                            t$29426
                        )
                }
            } else {
                min$29392(())
            }
        case Purity2.Impure(_) =>
            min$29392(())
    }
}

def Map.minimumValue(m$29466: Map[k, v]): Option[(k, v)] = {
    Map.minimumValueBy(
        x$29492 ->
            y$29494 ->
                <[unknown exp]>(x$29492, y$29494),
        m$29466
    )
}

def Map.minimumValueBy(
    cmp$29534: v -> v -> Comparison \ ef,
    m$29536: Map[k, v]
): Option[(k, v)] \ ef = {
    letrec min$29538: (Unit -> Option[(k, v)]) = _unit$29540 ->
        Map.reduceLeftWithKey(
            kl$29542 ->
                vl$29544 ->
                    kr$29546 ->
                        vr$29548 ->
                            if (
                                <[unknown exp]>(
                                    cmp$29534(vl$29544)(vr$29548),
                                    Comparison.LessThan
                                )
                            ) {
                                (kl$29542, vl$29544)
                            } else {
                                (kr$29546, vr$29548)
                            },
            m$29536
        );
    match purityOf2(cmp$29534) {
        case Purity2.Pure(g$29562) =>
            if (Map.useParallelEvaluation(m$29536)) {
                let h$29566: (k -> v -> (k -> (v -> Comparison))) = _$29568 ->
                    vl$29570 ->
                        _$29572 ->
                            vr$29574 ->
                                g$29562(vl$29570)(vr$29574);
                match m$29536 {
                    case Map.Map(t$29580) =>
                        RedBlackTree.parMinimumBy(
                            <[unknown exp]>(Map.threads(()), 1i32),
                            h$29566,
                            t$29580
                        )
                }
            } else {
                min$29538(())
            }
        case Purity2.Impure(_) =>
            min$29538(())
    }
}

def Map.nonEmpty(m$29203: Map[k, v]): Bool = {!Map.isEmpty(m$29203)}

def Map.rangeQuery(
    p$33186: k -> Comparison,
    m$33188: Map[k, v]
): List[(k, v)] \ ef = {
    match m$33188 {
        case Map.Map(t$33205) =>
            RedBlackTree.rangeQuery(
                p$33186,
                k$33210 ->
                    v$33212 ->
                        (k$33210, v$33212),
                t$33205
            )
    }
}

def Map.rangeQueryWith(
    p$33252: k -> Comparison,
    f$33281: k -> v -> Unit \ ef2,
    m$33283: Map[k, v]
): Unit \ ef1 + ef2 = {
    match m$33283 {
        case Map.Map(t$33285) =>
            RedBlackTree.rangeQueryWith(p$33252, f$33281, t$33285)
    }
}

def Map.reduceLeft(
    f$31090: v -> v -> v \ ef,
    m$31100: Map[k, v]
): Option[v] \ ef = {
    |>(
        Map.reduceLeftWithKey(
            k$31104 ->
                v1$31106 ->
                    _$31112 ->
                        v2$31116 ->
                            (k$31104, f$31090(v1$31106)(v2$31116)),
            m$31100
        ),
        (
            $0$46465 ->
                $1$46467 ->
                    Option.map($0$46465, $1$46467)
        )($0$46475 -> snd($0$46475))
    )
}

def Map.reduceLeftWithKey(
    f$31128: k -> v -> (k -> (v -> (k, v) \ ef)),
    m$31144: Map[k, v]
): Option[(k, v)] \ ef = {
    match m$31144 {
        case Map.Map(t$31154) =>
            RedBlackTree.reduceLeft(f$31128, t$31154)
    }
}

def Map.reduceRight(
    f$31179: v -> v -> v \ ef,
    m$31185: Map[k, v]
): Option[v] \ ef = {
    |>(
        Map.reduceRightWithKey(
            k$31189 ->
                v1$31191 ->
                    _$31193 ->
                        v2$31195 ->
                            (k$31189, f$31179(v1$31191)(v2$31195)),
            m$31185
        ),
        (
            $0$46478 ->
                $1$46480 ->
                    Option.map($0$46478, $1$46480)
        )($0$46482 -> snd($0$46482))
    )
}

def Map.reduceRightWithKey(
    f$31233: k -> v -> (k -> (v -> (k, v) \ ef)),
    m$31248: Map[k, v]
): Option[(k, v)] \ ef = {
    match m$31248 {
        case Map.Map(t$31260) =>
            RedBlackTree.reduceRight(f$31233, t$31260)
    }
}

def Map.remove(k$30389: k, m$30391: Map[k, v]): Map[k, v] = {
    match m$30391 {
        case Map.Map(t$30399) =>
            Map.Map(RedBlackTree.remove(k$30389, t$30399))
    }
}

def Map.sequence(m$33493: Map[k, m[v]]): m[Map[k, v]] = {
    match m$33493 {
        case Map.Map(t$33501) =>
            <[unknown exp]>(
                x$$46514 ->
                    Map.Map(x$$46514),
                <[unknown exp]>(t$33501)
            )
    }
}

def Map.singleton(k$29167: k, v$29169: v): Map[k, v] = {
    Map.insert(k$29167, v$29169, Map.empty(()))
}

def Map.size(m$29133: Map[k, v]): Int32 = {
    match m$29133 {case Map.Map(xs$29137) => RedBlackTree.size(xs$29137)}
}

def Map.sumKeys(m$31416: Map[Int32, v]): Int32 = {
    Map.sumWith(k$31424 -> _$31426 -> k$31424, m$31416)
}

def Map.sumValues(m$31435: Map[k, Int32]): Int32 = {
    Map.sumWith(_$31443 -> v$31445 -> v$31445, m$31435)
}

def Map.sumWith(
    f$31472: k -> v -> Int32 \ ef,
    m$31477: Map[k, v]
): Int32 \ ef = {
    match m$31477 {
        case Map.Map(t$31482) =>
            letrec sw$31484: (Unit -> Int32) = _unit$31486 ->
                RedBlackTree.sumWith(f$31472, t$31482);
            match purityOf2(f$31472) {
                case Purity2.Pure(g$31488) =>
                    if (Map.useParallelEvaluation(m$31477)) {
                        RedBlackTree.parSumWith(
                            <[unknown exp]>(Map.threads(()), 1i32),
                            g$31488,
                            t$31482
                        )
                    } else {
                        sw$31484(())
                    }
                case Purity2.Impure(_) =>
                    sw$31484(())
            }
    }
}

def Map.threads(_unit$29095: Unit): Int32 = {
    let multiplier$29097: Int32 = 4i32;
    <[unknown exp]>(multiplier$29097, Environment.getVirtualProcessors(()))
}

def Map.toArray(
    rc$32556: Region[r],
    m$32559: Map[k, v]
): Array[(k, v), r] \ r = {
    match Map.size(m$32559) {
        case 0i32 =>
            [] @ rc$32556
        case sz$32567 =>
            let a$32569: Array[(k, v), r] = Array.empty(rc$32556, sz$32567);
            Map.forEachWithIndex(
                i$32575 ->
                    k$32579 ->
                        v$32583 ->
                            Array.put((k$32579, v$32583), i$32575, a$32569),
                m$32559
            );
            a$32569
    }
}

def Map.toChain(m$32749: Map[a, b]): Chain[(a, b)] = {
    Map.foldLeftWithKey(
        acc$32757 ->
            k$32761 ->
                v$32763 ->
                    Chain.snoc(acc$32757, (k$32761, v$32763)),
        Chain.empty(()),
        m$32749
    )
}

def Map.toDelayList(m$32708: Map[k, v]): DelayList[(k, v)] = {
    Map.foldRightWithKey(
        k$32728 ->
            v$32730 ->
                acc$32732 ->
                    DelayList.ECons((k$32728, v$32730), acc$32732),
        DelayList.ENil,
        m$32708
    )
}

def Map.toDelayMap(m$33443: Map[k, v]): DelayMap[k, v] = {
    match m$33443 {
        case Map.Map(t$33447) =>
            let f$33453: (k -> v -> Lazy[v]) = _$33459 ->
                v$33469 ->
                    lazy v$33469;
            DelayMap.DMap(RedBlackTree.mapWithKey(f$33453, t$33447))
    }
}

def Map.toList(m$32525: Map[k, v]): List[(k, v)] = {
    Map.foldRightWithKey(
        k$32535 ->
            v$32537 ->
                acc$32539 ->
                    List.Cons((k$32535, v$32537), acc$32539),
        List.Nil,
        m$32525
    )
}

def Map.toMultiMap(m$32802: Map[k, v]): MultiMap[k, v] = {
    MultiMap.MultiMap(Map.map($0$46492 -> Set.singleton($0$46492), m$32802))
}

def Map.toMutDeque(
    rc$32853: Region[r],
    m$32855: Map[k, v]
): MutDeque[(k, v), r] \ r = {
    let d$32861: MutDeque[(k, v), r] = MutDeque.empty(rc$32853);
    Map.forEach(
        k$32863 ->
            v$32865 ->
                MutDeque.pushBack((k$32863, v$32865), d$32861),
        m$32855
    );
    d$32861
}

def Map.toMutMap(
    rc$32508: Region[r],
    m$32511: Map[k, v]
): MutMap[k, v, r] \ r = {
    MutMap.MutMap(rc$32508, (ref m$32511) @ rc$32508)
}

def Map.toSet(m$32637: Map[k, v]): Set[(k, v)] = {
    Map.foldLeftWithKey(
        acc$32639 ->
            k$32641 ->
                v$32643 ->
                    Set.insert((k$32641, v$32643), acc$32639),
        Set.empty(()),
        m$32637
    )
}

def Map.toString(m$29068: Map[k, v]): String = {
    region rc$29072 {
        let sb$29077: StringBuilder[rc] = StringBuilder.empty(rc$29072);
        StringBuilder.appendString!("""Map#{""", sb$29077);
        Map.forEachWithIndex(
            i$29079 ->
                k$29081 ->
                    v$29083 ->
                        if (<[unknown exp]>(i$29079, 1i32)) {
                            StringBuilder.appendString!(
                                (
                                    (
                                        """""" + <[unknown exp]>(k$29081)
                                    ) + """ => """
                                ) + <[unknown exp]>(v$29083),
                                sb$29077
                            )
                        } else {
                            StringBuilder.appendString!(
                                (
                                    (
                                        (
                                            """""" + """, """
                                        ) + <[unknown exp]>(k$29081)
                                    ) + """ => """
                                ) + <[unknown exp]>(v$29083),
                                sb$29077
                            )
                        },
            m$29068
        );
        StringBuilder.appendString!("""}""", sb$29077);
        StringBuilder.toString(sb$29077)
    }
}

def Map.toVector(m$32602: Map[k, v]): Vector[(k, v)] = {
    region rc$32604 {
        let arr$32607: Array[(k, v), rc] = Array.empty(
            rc$32604,
            Map.size(m$32602)
        );
        Map.forEachWithIndex(
            i$32609 ->
                k$32611 ->
                    v$32613 ->
                        Array.put((k$32611, v$32613), i$32609, arr$32607),
            m$32602
        );
        Array.toVector(arr$32607)
    }
}

def Map.traverse(
    f$33528: v1 -> m[v2],
    m$33530: Map[k, v1]
): m[Map[k, v2]] \ ef = {
    match m$33530 {
        case Map.Map(t$33569) =>
            <[unknown exp]>(
                x$$46516 ->
                    Map.Map(x$$46516),
                <[unknown exp]>(f$33528, t$33569)
            )
    }
}

def Map.traverseWithKey(
    f$33586: k -> v1 -> m[v2] \ ef,
    m$33593: Map[k, v1]
): m[Map[k, v2]] \ ef = {
    match m$33593 {
        case Map.Map(t$33606) =>
            <[unknown exp]>(
                x$$46518 ->
                    Map.Map(x$$46518),
                RedBlackTree.mapAWithKey(f$33586, t$33606)
            )
    }
}

def Map.unfold(f$32993: s -> Option[(k, v, s)], st$32995: s): Map[k, v] \ ef = {
    letrec loop$33005: (
        s -> Map[k, v] -> Map[k, v] \ (e81259 & ef) + ef + ef
    ) = sst$33007 ->
        m$33011 ->
            match f$32993(sst$33007) {
                case Option.None =>
                    m$33011
                case Option.Some(k$33016, v$33018, st1$33020) =>
                    loop$33005(st1$33020)(Map.insert(k$33016, v$33018, m$33011))
            };
    loop$33005(st$32995)(Map.empty(()))
}

def Map.unfoldWithIter(next$33058: Unit -> Option[(k, v)]): Map[k, v] \ ef = {
    letrec loop$33082: (Map[k, v] -> Map[k, v]) = m$33084 ->
        match next$33058(()) {
            case Option.None =>
                m$33084
            case Option.Some(k$33086, v$33088) =>
                loop$33082(Map.insert(k$33086, v$33088, m$33084))
        };
    loop$33082(Map.empty(()))
}

def Map.union(m1$31549: Map[k, v], m2$31551: Map[k, v]): Map[k, v] = {
    Map.unionWithKey(
        _$31555 ->
            v1$31557 ->
                _$31559 ->
                    v1$31557,
        m1$31549,
        m2$31551
    )
}

def Map.unionWith(
    f$31574: v -> v -> v \ ef,
    m1$31576: Map[k, v],
    m2$31578: Map[k, v]
): Map[k, v] \ ef = {
    Map.unionWithKey(
        _$31585 ->
            v1$31587 ->
                v2$31590 ->
                    f$31574(v1$31587)(v2$31590),
        m1$31576,
        m2$31578
    )
}

def Map.unionWithKey(
    f$31630: k -> v -> (v -> v \ ef),
    m1$31632: Map[k, v],
    m2$31634: Map[k, v]
): Map[k, v] \ ef = {
    <[unknown exp]>
}

def Map.update(
    f$30281: v -> Option[v],
    k$30283: k,
    m$30285: Map[k, v]
): Map[k, v] \ ef = {
    Map.updateWithKey(
        _$30299 ->
            v1$30302 ->
                f$30281(v1$30302),
        k$30283,
        m$30285
    )
}

def Map.updateWithKey(
    f$30349: k -> v -> Option[v] \ ef,
    k$30356: k,
    m$30360: Map[k, v]
): Map[k, v] \ ef = {
    match m$30360 {
        case Map.Map(t$30370) =>
            Map.Map(RedBlackTree.updateWith(f$30349, k$30356, t$30370))
    }
}

def Map.useParallelEvaluation(m$29117: Map[k, v]): Bool = {
    match m$29117 {
        case Map.Map(t$29120) =>
            let minSize$29123: Int32 = Int32.pow(
                2i32,
                RedBlackTree.blackHeight(t$29120)
            );
            <[unknown exp]>(minSize$29123, 1024i32)
    }
}

def Map.valuesOf(m$29913: Map[k, v]): List[v] = {
    Map.foldRight(
        v$29921 ->
            acc$29923 ->
                List.Cons(v$29921, acc$29923),
        List.Nil,
        m$29913
    )
}

def Monad.<=<(f1$4364: b -> m[c], f2$4371: a -> m[b]): a -> m[c] = {
    x$4376 ->
        Monad.kleisliRight(f1$4364, f2$4371, x$4376)
}

def Monad.=<<(k$4281: a -> m[b], x$4287: m[a]): m[b] \ ef = {
    <[unknown exp]>(k$4281, x$4287)
}

def Monad.>=>(f1$4324: a -> m[b], f2$4326: b -> m[c]): a -> m[c] = {
    x$4333 ->
        Monad.kleisliLeft(f1$4324, f2$4326, x$4333)
}

def Monad.>>=(x$4303: m[a], k$4305: a -> m[b]): m[b] \ ef = {
    <[unknown exp]>(k$4305, x$4303)
}

def Monad.flatten(x$4175: m[m[a]]): m[a] = {
    <[unknown exp]>($0$45442 -> identity($0$45442), x$4175)
}

def Monad.kleisliLeft(
    f1$4209: a -> m[b],
    f2$4213: b -> m[c],
    x$4223: a
): m[c] \ ef1 + ef2 = {
    <[unknown exp]>(x1$4231 -> f2$4213(x1$4231), f1$4209(x$4223))
}

def Monad.kleisliRight(
    f1$4252: b -> m[c],
    f2$4256: a -> m[b],
    x$4262: a
): m[c] \ ef1 + ef2 = {
    <[unknown exp]>(x1$4264 -> f1$4252(x1$4264), f2$4256(x$4262))
}

def Monoid.fold(f$2752: f[a]): a = {Foldable.fold(f$2752)}

enum MultiMap[k, v] {case MultiMap(Map[k, Set[v]])}

def MultiMap.adjust(
    f$7588: v -> v,
    k$7590: k,
    m$7592: MultiMap[k, v]
): MultiMap[k, v] \ ef = {
    MultiMap.adjustWithKey(_$7607 -> v1$7609 -> f$7588(v1$7609), k$7590, m$7592)
}

def MultiMap.adjustWithKey(
    f$7634: k -> v -> v \ ef,
    k$7636: k,
    m$7638: MultiMap[k, v]
): MultiMap[k, v] \ ef = {
    MultiMap.updateWithKey(
        k1$7640 ->
            v$7642 ->
                Option.Some(f$7634(k1$7640)(v$7642)),
        k$7636,
        m$7638
    )
}

def MultiMap.count(
    f$8783: k -> v -> Bool \ ef,
    m$8788: MultiMap[k, v]
): Int32 \ ef = {
    MultiMap.sumWith(
        k$8798 ->
            v$8800 ->
                if (f$8783(k$8798)(v$8800)) {1i32} else {0i32},
        m$8788
    )
}

def MultiMap.difference(
    m1$9125: MultiMap[k, v],
    m2$9139: MultiMap[k, v]
): MultiMap[k, v] = {
    match m1$9125 {
        case MultiMap.MultiMap(mm1$9145) =>
            match m2$9139 {
                case MultiMap.MultiMap(mm2$9150) =>
                    MultiMap.MultiMap(
                        Map.differenceWith(
                            $0$45636 ->
                                $1$45638 ->
                                    MultiMap.setDifference1($0$45636, $1$45638),
                            mm1$9145,
                            mm2$9150
                        )
                    )
            }
    }
}

def MultiMap.empty(_unit$7305: Unit): MultiMap[k, v] = {
    MultiMap.MultiMap(Map.empty(()))
}

def MultiMap.exists(
    f$8906: k -> v -> Bool \ ef,
    m$8910: MultiMap[k, v]
): Bool \ ef = {
    match m$8910 {
        case MultiMap.MultiMap(m1$8924) =>
            let outer$8928: (k -> Set[v] -> Bool \ ef) = k$8930 ->
                vs$8934 ->
                    Set.exists(v$8936 -> f$8906(k$8930)(v$8936), vs$8934);
            Map.exists(outer$8928, m1$8924)
    }
}

def MultiMap.filter(
    f$8032: v -> Bool,
    m$8034: MultiMap[k, v]
): MultiMap[k, v] \ ef = {
    MultiMap.filterWithKey(_$8042 -> v$8044 -> f$8032(v$8044), m$8034)
}

def MultiMap.filterWithKey(
    f$8071: k -> v -> Bool \ ef,
    m$8078: MultiMap[k, v]
): MultiMap[k, v] \ ef = {
    MultiMap.foldLeftWithKey(
        acc$8087 ->
            k$8089 ->
                v$8091 ->
                    if (f$8071(k$8089)(v$8091)) {
                        MultiMap.insert(k$8089, v$8091, acc$8087)
                    } else {
                        acc$8087
                    },
        MultiMap.empty(()),
        m$8078
    )
}

def MultiMap.find(
    f$7835: k -> v -> Bool \ ef,
    m$7859: MultiMap[k, v]
): Option[(k, v)] \ ef = {
    MultiMap.findLeft(f$7835, m$7859)
}

def MultiMap.findLeft(
    f$7879: k -> v -> Bool \ ef,
    m$7881: MultiMap[k, v]
): Option[(k, v)] \ ef = {
    match m$7881 {
        case MultiMap.MultiMap(m1$7894) =>
            let findGroup$7900: (k -> Set[v] -> Bool \ ef) = k$7902 ->
                s$7906 ->
                    Set.exists(f$7879(k$7902), s$7906);
            let findItem$7922: (
                k -> Set[v] -> Option[(k, v)] \ (e56220 + ef) & ef
            ) = k$7925 ->
                s$7928 ->
                    |>(
                        Set.findLeft(f$7879(k$7925), s$7928),
                        (
                            $0$45532 ->
                                $1$45534 ->
                                    Option.map($0$45532, $1$45534)
                        )(v1$7936 -> (k$7925, v1$7936))
                    );
            match Map.findLeft(findGroup$7900, m1$7894) {
                case Option.None =>
                    Option.None
                case Option.Some(k$7952, vs$7954) =>
                    findItem$7922(k$7952)(vs$7954)
            }
    }
}

def MultiMap.findRight(
    f$7971: k -> v -> Bool \ ef,
    m$7987: MultiMap[k, v]
): Option[(k, v)] \ ef = {
    match m$7987 {
        case MultiMap.MultiMap(m1$7991) =>
            let findGroup$7996: (k -> Set[v] -> Bool \ ef) = k$7999 ->
                s$8001 ->
                    Set.exists(f$7971(k$7999), s$8001);
            let findItem$8004: (
                k -> Set[v] -> Option[(k, v)] \ (e58087 + ef) & ef
            ) = k$8007 ->
                s$8009 ->
                    |>(
                        Set.findRight(f$7971(k$8007), s$8009),
                        (
                            $0$45542 ->
                                $1$45544 ->
                                    Option.map($0$45542, $1$45544)
                        )(v1$8015 -> (k$8007, v1$8015))
                    );
            match Map.findRight(findGroup$7996, m1$7991) {
                case Option.None =>
                    Option.None
                case Option.Some(k$8021, vs$8023) =>
                    findItem$8004(k$8021)(vs$8023)
            }
    }
}

def MultiMap.foldLeft(
    f$8166: b -> v -> b \ ef,
    s$8168: b,
    m$8170: MultiMap[k, v]
): b \ ef = {
    MultiMap.foldLeftWithKey(
        acc$8174 ->
            _$8177 ->
                v$8180 ->
                    f$8166(acc$8174)(v$8180),
        s$8168,
        m$8170
    )
}

def MultiMap.foldLeftWithKey(
    f$8199: b -> k -> (v -> b \ ef),
    s$8205: b,
    m$8207: MultiMap[k, v]
): b \ ef = {
    match m$8207 {
        case MultiMap.MultiMap(m1$8217) =>
            let outer$8220: (b -> k -> (Set[v] -> b \ ef)) = acc$8222 ->
                k$8225 ->
                    vs$8229 ->
                        Set.foldLeft(
                            acc1$8236 ->
                                v1$8239 ->
                                    f$8199(acc1$8236)(k$8225)(v1$8239),
                            acc$8222,
                            vs$8229
                        );
            Map.foldLeftWithKey(outer$8220, s$8205, m1$8217)
    }
}

def MultiMap.foldMap(f$8484: v -> b, m$8487: MultiMap[k, v]): b \ ef = {
    MultiMap.foldMapWithKey(_$8498 -> f$8484, m$8487)
}

def MultiMap.foldMapWithKey(
    f$8441: k -> v -> b \ ef,
    m$8454: MultiMap[k, v]
): b \ ef = {
    MultiMap.foldLeftWithKey(
        acc$8459 ->
            k$8461 ->
                v$8463 ->
                    <[unknown exp]>(acc$8459, f$8441(k$8461)(v$8463)),
        <[unknown exp]>(()),
        m$8454
    )
}

def MultiMap.foldRight(
    f$8272: v -> b -> b \ ef,
    s$8274: b,
    m$8277: MultiMap[k, v]
): b \ ef = {
    MultiMap.foldRightWithKey(
        _$8284 ->
            v$8289 ->
                acc$8293 ->
                    f$8272(v$8289)(acc$8293),
        s$8274,
        m$8277
    )
}

def MultiMap.foldRightWithCont(
    f$8365: v -> (Unit -> b \ ef) -> b \ ef,
    z$8368: b,
    m$8373: MultiMap[k, v]
): b \ ef = {
    MultiMap.foldRightWithKeyCont(
        _$8384 ->
            v$8388 ->
                c$8390 ->
                    f$8365(v$8388)(c$8390),
        z$8368,
        m$8373
    )
}

def MultiMap.foldRightWithKey(
    f$8319: k -> v -> (b -> b \ ef),
    s$8324: b,
    m$8328: MultiMap[k, v]
): b \ ef = {
    match m$8328 {
        case MultiMap.MultiMap(m1$8334) =>
            let outer$8336: (k -> Set[v] -> (b -> b \ ef)) = k$8338 ->
                vs$8340 ->
                    acc$8342 ->
                        Set.foldRight(
                            v1$8345 ->
                                acc1$8347 ->
                                    f$8319(k$8338)(v1$8345)(acc1$8347),
                            acc$8342,
                            vs$8340
                        );
            Map.foldRightWithKey(outer$8336, s$8324, m1$8334)
    }
}

def MultiMap.foldRightWithKeyCont(
    f$8411: k -> v -> ((Unit -> b \ ef) -> b \ ef),
    z$8420: b,
    m$8422: MultiMap[k, v]
): b \ ef = {
    match m$8422 {
        case MultiMap.MultiMap(m1$8424) =>
            Map.foldRightWithKeyCont(
                k$8426 ->
                    vs$8428 ->
                        b1$8430 ->
                            Set.foldRightWithCont(
                                v1$8432 ->
                                    fac$8434 ->
                                        f$8411(k$8426)(v1$8432)(fac$8434),
                                b1$8430(()),
                                vs$8428
                            ),
                z$8420,
                m1$8424
            )
    }
}

def MultiMap.foldWithKey(
    f$8143: b -> k -> (v -> b \ ef),
    s$8146: b,
    m$8148: MultiMap[k, v]
): b \ ef = {
    MultiMap.foldLeftWithKey(f$8143, s$8146, m$8148)
}

def MultiMap.forAll(
    f$8950: k -> v -> Bool \ ef,
    m$8955: MultiMap[k, v]
): Bool \ ef = {
    match m$8955 {
        case MultiMap.MultiMap(m1$8961) =>
            let outer$8968: (k -> Set[v] -> Bool \ ef) = k$8972 ->
                vs$8976 ->
                    Set.forAll(v$8978 -> f$8950(k$8972)(v$8978), vs$8976);
            Map.forAll(outer$8968, m1$8961)
    }
}

def MultiMap.forEach(
    f$9481: k -> v -> Unit \ ef,
    m$9491: MultiMap[k, v]
): Unit \ ef = {
    match m$9491 {
        case MultiMap.MultiMap(m1$9502) =>
            Map.forEach(
                k$9504 ->
                    s$9506 ->
                        Set.forEach(f$9481(k$9504), s$9506),
                m1$9502
            )
    }
}

def MultiMap.forEachWithIndex(
    f$9542: Int32 -> k -> (v -> Unit \ ef),
    m$9548: MultiMap[k, v]
): Unit \ ef = {
    region rc$9555 {
        let ix$9560: Ref[Int32, rc] = (ref 0i32) @ rc$9555;
        let f1$9562: (k -> v -> Unit \ rc + ef + rc) = k$9564 ->
            v$9566 ->
                {
                    let i$9568: Int32 = deref ix$9560;
                    f$9542(i$9568)(k$9564)(v$9566);
                    Ref.put(<[unknown exp]>(i$9568, 1i32), ix$9560)
                };
        MultiMap.forEach(f1$9562, m$9548)
    }
}

def MultiMap.get(k$7377: k, m$7381: MultiMap[k, v]): Set[v] = {
    match m$7381 {
        case MultiMap.MultiMap(t$7383) =>
            |>(
                Map.get(k$7377, t$7383),
                (
                    $0$45474 ->
                        $1$45476 ->
                            Option.getWithDefault($0$45474, $1$45476)
                )(Set.empty(()))
            )
    }
}

def MultiMap.insert(
    k$7496: k,
    v$7500: v,
    m$7502: MultiMap[k, v]
): MultiMap[k, v] = {
    match m$7502 {
        case MultiMap.MultiMap(m1$7508) =>
            MultiMap.MultiMap(
                Map.insertWith(
                    v1$7515 ->
                        v2$7518 ->
                            Set.union(v1$7515, v2$7518),
                    k$7496,
                    Set.singleton(v$7500),
                    m1$7508
                )
            )
    }
}

def MultiMap.insertAll(
    k$7538: k,
    vs$7542: t[v],
    m$7550: MultiMap[k, v]
): MultiMap[k, v] = {
    match <[unknown exp]>(vs$7542) {
        case s1$7557 if Set.isEmpty(s1$7557) =>
            m$7550
        case s1$7561 =>
            match m$7550 {
                case MultiMap.MultiMap(m1$7567) =>
                    MultiMap.MultiMap(
                        Map.insertWith(
                            v1$7574 ->
                                v2$7577 ->
                                    Set.union(v1$7574, v2$7577),
                            k$7538,
                            s1$7561,
                            m1$7567
                        )
                    )
            }
    }
}

def MultiMap.intersection(
    m1$9051: MultiMap[k, v],
    m2$9055: MultiMap[k, v]
): MultiMap[k, v] = {
    match m1$9051 {
        case MultiMap.MultiMap(mm1$9063) =>
            match m2$9055 {
                case MultiMap.MultiMap(mm2$9068) =>
                    let step$9070: (
                        Map[k, Set[v]] -> k -> (Set[v] -> Map[k, Set[v]])
                    ) = acc$9072 ->
                        k$9076 ->
                            s$9078 ->
                                match Map.get(k$9076, mm2$9068) {
                                    case Option.None =>
                                        acc$9072
                                    case Option.Some(s1$9083) =>
                                        match Set.intersection(
                                            s$9078,
                                            s1$9083
                                        ) {
                                            case s2$9087 if Set.isEmpty(
                                                s2$9087
                                            ) =>
                                                acc$9072
                                            case s2$9098 =>
                                                Map.insert(
                                                    k$9076,
                                                    s2$9098,
                                                    acc$9072
                                                )
                                        }
                                };
                    MultiMap.MultiMap(
                        Map.foldLeftWithKey(step$9070, Map.empty(()), mm1$9063)
                    )
            }
    }
}

def MultiMap.isEmpty(m$7329: MultiMap[k, v]): Bool = {
    match m$7329 {case MultiMap.MultiMap(m1$7333) => Map.isEmpty(m1$7333)}
}

def MultiMap.iterator(
    rc$9606: Region[r],
    m$9612: MultiMap[k, v]
): Iterator[(k, Set[v]), r, r] \ r = {
    match m$9612 {
        case MultiMap.MultiMap(m1$9619) =>
            Map.iterator(rc$9606, m1$9619)
    }
}

def MultiMap.keysOf(m$7438: MultiMap[k, v]): Set[k] = {
    match m$7438 {case MultiMap.MultiMap(m1$7449) => Map.keysOf(m1$7449)}
}

def MultiMap.map(
    f$8102: v1 -> v2,
    m$8104: MultiMap[k, v1]
): MultiMap[k, v2] \ ef = {
    MultiMap.mapWithKey(_$8107 -> v$8109 -> f$8102(v$8109), m$8104)
}

def MultiMap.mapWithKey(
    f$8117: k -> v1 -> v2 \ ef,
    m$8120: MultiMap[k, v1]
): MultiMap[k, v2] \ ef = {
    match m$8120 {
        case MultiMap.MultiMap(m1$8123) =>
            let outer$8126: (k -> Set[v1] -> Set[v2] \ ef) = k$8128 ->
                vs$8130 ->
                    Set.map(f$8117(k$8128), vs$8130);
            MultiMap.MultiMap(Map.mapWithKey(outer$8126, m1$8123))
    }
}

def MultiMap.memberOf(k$7405: k, m$7409: MultiMap[k, v]): Bool = {
    match m$7409 {
        case MultiMap.MultiMap(m1$7413) =>
            Map.memberOf(k$7405, m1$7413)
    }
}

def MultiMap.nonEmpty(m$7348: MultiMap[k, v]): Bool = {
    !MultiMap.isEmpty(m$7348)
}

def MultiMap.reduceLeft(
    f$8525: v -> v -> v \ ef,
    m$8529: MultiMap[k, v]
): Option[v] \ ef = {
    |>(
        MultiMap.reduceLeftWithKey(
            k$8540 ->
                v1$8542 ->
                    _$8544 ->
                        v2$8546 ->
                            (k$8540, f$8525(v1$8542)(v2$8546)),
            m$8529
        ),
        (
            $0$45584 ->
                $1$45586 ->
                    Option.map($0$45584, $1$45586)
        )($0$45588 -> snd($0$45588))
    )
}

def MultiMap.reduceLeftWithKey(
    f$8572: k -> v -> (k -> (v -> (k, v) \ ef)),
    m$8581: MultiMap[k, v]
): Option[(k, v)] \ ef = {
    match m$8581 {
        case MultiMap.MultiMap(m1$8602) =>
            let inner$8604: (
                k -> Option[(k, v)] -> (v -> Option[(k, v)] \ ef)
            ) = k$8607 ->
                acc$8612 ->
                    v$8617 ->
                        match acc$8612 {
                            case Option.None =>
                                Option.Some(k$8607, v$8617)
                            case Option.Some(kacc$8629, vacc$8633) =>
                                Option.Some(
                                    f$8572(kacc$8629)(vacc$8633)(k$8607)(v$8617)
                                )
                        };
            let outer$8641: (
                Option[(k, v)] -> k -> (Set[v] -> Option[(k, v)] \ ef)
            ) = acc$8645 ->
                k$8649 ->
                    vs$8652 ->
                        Set.foldLeft(inner$8604(k$8649), acc$8645, vs$8652);
            Map.foldLeftWithKey(outer$8641, Option.None, m1$8602)
    }
}

def MultiMap.reduceRight(
    f$8688: v -> v -> v \ ef,
    m$8693: MultiMap[k, v]
): Option[v] \ ef = {
    |>(
        MultiMap.reduceRightWithKey(
            k$8702 ->
                v1$8704 ->
                    _$8706 ->
                        v2$8708 ->
                            (k$8702, f$8688(v1$8704)(v2$8708)),
            m$8693
        ),
        (
            $0$45602 ->
                $1$45604 ->
                    Option.map($0$45602, $1$45604)
        )($0$45606 -> snd($0$45606))
    )
}

def MultiMap.reduceRightWithKey(
    f$8723: k -> v -> (k -> (v -> (k, v) \ ef)),
    m$8728: MultiMap[k, v]
): Option[(k, v)] \ ef = {
    match m$8728 {
        case MultiMap.MultiMap(m1$8734) =>
            let inner$8738: (
                k -> v -> (Option[(k, v)] -> Option[(k, v)] \ ef)
            ) = k$8741 ->
                v$8743 ->
                    acc$8748 ->
                        match acc$8748 {
                            case Option.None =>
                                Option.Some(k$8741, v$8743)
                            case Option.Some(kacc$8750, vacc$8752) =>
                                Option.Some(
                                    f$8723(k$8741)(v$8743)(kacc$8750)(vacc$8752)
                                )
                        };
            let outer$8756: (
                k -> Set[v] -> (Option[(k, v)] -> Option[(k, v)] \ ef)
            ) = k$8758 ->
                vs$8760 ->
                    acc$8762 ->
                        Set.foldRight(inner$8738(k$8758), acc$8762, vs$8760);
            Map.foldRightWithKey(outer$8756, Option.None, m1$8734)
    }
}

def MultiMap.remove(k$7741: k, m$7744: MultiMap[k, v]): MultiMap[k, v] = {
    match m$7744 {
        case MultiMap.MultiMap(m1$7750) =>
            MultiMap.MultiMap(Map.remove(k$7741, m1$7750))
    }
}

def MultiMap.removeWithValue(
    k$7770: k,
    v$7773: v,
    m$7776: MultiMap[k, v]
): MultiMap[k, v] = {
    match m$7776 {
        case MultiMap.MultiMap(m1$7784) =>
            match Map.get(k$7770, m1$7784) {
                case Option.None =>
                    m$7776
                case Option.Some(s$7792) if !Set.memberOf(v$7773, s$7792) =>
                    m$7776
                case Option.Some(
                    s$7796
                ) if <[unknown exp]>(
                    s$7796,
                    Set.insert(v$7773, Set.empty(()))
                ) =>
                    MultiMap.remove(k$7770, m$7776)
                case Option.Some(_) =>
                    MultiMap.MultiMap(
                        Map.adjust(
                            s1$7804 ->
                                Set.remove(v$7773, s1$7804),
                            k$7770,
                            m1$7784
                        )
                    )
            }
    }
}

def MultiMap.setDifference1(
    s1$9173: Set[v],
    s2$9175: Set[v]
): Option[Set[v]] = {
    match Set.difference(s1$9173, s2$9175) {
        case s$9196 if Set.isEmpty(s$9196) =>
            Option.None
        case s$9205 =>
            Option.Some(s$9205)
    }
}

def MultiMap.singleton(k$7320: k, v$7322: v): MultiMap[k, v] = {
    MultiMap.MultiMap(Map.singleton(k$7320, Set.singleton(v$7322)))
}

def MultiMap.sumKeys(m$8812: MultiMap[Int32, v]): Int32 = {
    MultiMap.sumWith(k$8815 -> _$8819 -> k$8815, m$8812)
}

def MultiMap.sumValues(m$8838: MultiMap[k, Int32]): Int32 = {
    MultiMap.sumWith(_$8847 -> v$8849 -> v$8849, m$8838)
}

def MultiMap.sumWith(
    f$8865: k -> v -> Int32 \ ef,
    m$8872: MultiMap[k, v]
): Int32 \ ef = {
    match m$8872 {
        case MultiMap.MultiMap(m1$8882) =>
            let outer$8884: (k -> Set[v] -> Int32 \ ef) = k$8886 ->
                vs$8889 ->
                    Set.sumWith(v$8891 -> f$8865(k$8886)(v$8891), vs$8889);
            Map.sumWith(outer$8884, m1$8882)
    }
}

def MultiMap.toAscList(m$9243: MultiMap[k, v]): List[(k, v)] = {
    MultiMap.foldRightWithKey(
        k$9245 ->
            v$9249 ->
                acc$9256 ->
                    List.Cons((k$9245, v$9249), acc$9256),
        List.Nil,
        m$9243
    )
}

def MultiMap.toAssocList(m$9339: MultiMap[k, v]): List[(k, Set[v])] = {
    match m$9339 {
        case MultiMap.MultiMap(m1$9347) =>
            Map.foldRightWithKey(
                k$9349 ->
                    vs$9351 ->
                        acc$9354 ->
                            List.Cons((k$9349, vs$9351), acc$9354),
                List.Nil,
                m1$9347
            )
    }
}

def MultiMap.toDescList(m$9296: MultiMap[k, v]): List[(k, v)] = {
    MultiMap.foldLeftWithKey(
        acc$9303 ->
            k$9309 ->
                v$9312 ->
                    List.Cons((k$9309, v$9312), acc$9303),
        List.Nil,
        m$9296
    )
}

def MultiMap.toList(m$9216: MultiMap[k, v]): List[(k, v)] = {
    MultiMap.toAscList(m$9216)
}

def MultiMap.toMap(m$9388: MultiMap[k, v]): Map[k, Set[v]] = {
    match m$9388 {case MultiMap.MultiMap(m1$9393) => m1$9393}
}

def MultiMap.toMutDeque(
    rc$9436: Region[r],
    m$9443: MultiMap[k, v]
): MutDeque[(k, Set[v]), r] \ r = {
    match m$9443 {
        case MultiMap.MultiMap(m1$9445) =>
            Map.toMutDeque(rc$9436, m1$9445)
    }
}

def MultiMap.toString(m$7265: MultiMap[k, v]): String = {
    region rc$7267 {
        let sb$7271: StringBuilder[rc] = StringBuilder.empty(rc$7267);
        match m$7265 {
            case MultiMap.MultiMap(m1$7275) =>
                StringBuilder.appendString!("""MultiMap#{""", sb$7271);
                Map.forEachWithIndex(
                    i$7277 ->
                        k$7279 ->
                            v$7281 ->
                                if (<[unknown exp]>(i$7277, 1i32)) {
                                    StringBuilder.appendString!(
                                        (
                                            (
                                                """""" + <[unknown exp]>(k$7279)
                                            ) + """ => """
                                        ) + <[unknown exp]>(v$7281),
                                        sb$7271
                                    )
                                } else {
                                    StringBuilder.appendString!(
                                        (
                                            (
                                                (
                                                    """""" + """, """
                                                ) + <[unknown exp]>(k$7279)
                                            ) + """ => """
                                        ) + <[unknown exp]>(v$7281),
                                        sb$7271
                                    )
                                },
                    m1$7275
                );
                StringBuilder.appendString!("""}""", sb$7271);
                StringBuilder.toString(sb$7271)
        }
    }
}

def MultiMap.union(
    m1$9013: MultiMap[k, v],
    m2$9017: MultiMap[k, v]
): MultiMap[k, v] = {
    match m1$9013 {
        case MultiMap.MultiMap(mm1$9020) =>
            match m2$9017 {
                case MultiMap.MultiMap(mm2$9022) =>
                    MultiMap.MultiMap(
                        Map.unionWith(
                            s1$9026 ->
                                s2$9031 ->
                                    Set.union(s1$9026, s2$9031),
                            mm1$9020,
                            mm2$9022
                        )
                    )
            }
    }
}

def MultiMap.update(
    f$7668: v -> Option[v],
    k$7670: k,
    m$7672: MultiMap[k, v]
): MultiMap[k, v] \ ef = {
    MultiMap.updateWithKey(_$7679 -> v1$7682 -> f$7668(v1$7682), k$7670, m$7672)
}

def MultiMap.updateWithKey(
    f$7699: k -> v -> Option[v] \ ef,
    k$7704: k,
    m$7708: MultiMap[k, v]
): MultiMap[k, v] \ ef = {
    match m$7708 {
        case MultiMap.MultiMap(m1$7716) =>
            let outer$7718: (k -> Set[v] -> Set[v] \ ef) = k1$7720 ->
                s$7722 ->
                    if (<[unknown exp]>(k1$7720, k$7704)) {
                        Set.map(
                            v1$7724 ->
                                Option.getWithDefault(
                                    v1$7724,
                                    f$7699(k1$7720)(v1$7724)
                                ),
                            s$7722
                        )
                    } else {
                        s$7722
                    };
            MultiMap.MultiMap(Map.mapWithKey(outer$7718, m1$7716))
    }
}

def MultiMap.valuesOf(m$7468: MultiMap[k, v]): List[v] = {
    match m$7468 {
        case MultiMap.MultiMap(m1$7472) =>
            |>(
                |>(
                    Map.valuesOf(m1$7472),
                    (
                        $0$45486 ->
                            $1$45488 ->
                                List.map($0$45486, $1$45488)
                    )($0$45490 -> Set.toList($0$45490))
                ),
                $0$45492 ->
                    List.flatten($0$45492)
            )
    }
}

enum MutDeque[a, r] {
    case MutDeque(Region[r], Ref[Array[a, r], r], Ref[Int32, r], Ref[Int32, r])
}

def MutDeque.capacity(d$2013: MutDeque[a, r]): Int32 \ r = {
    match d$2013 {
        case MutDeque.MutDeque(_, a$2022, _, _) =>
            Array.length(deref a$2022)
    }
}

def MutDeque.compress!(d$898: MutDeque[a, r]): Unit \ r = {
    if (MutDeque.shouldCompress(d$898)) {MutDeque.shrink!(d$898)} else {()}
}

def MutDeque.computeSize(c$540: Int32, f$542: Int32, b$544: Int32): Int32 = {
    if (<[unknown exp]>(f$542, b$544)) {
        <[unknown exp]>(b$544, f$542)
    } else {
        <[unknown exp]>(c$540, <[unknown exp]>(f$542, b$544))
    }
}

def MutDeque.copyElements!(
    rc2$957: Region[r2],
    f$959: Int32,
    b$961: Int32,
    a$963: Array[a, r1],
    a1$965: Array[a, r2]
): Unit \ r1 + r2 = {
    let c$967: Int32 = Array.length(a$963);
    if (<[unknown exp]>(f$959, b$961)) {
        Array.updateSequence!(
            0i32,
            Array.slice(
                rc2$957,
                {+start = f$959 | {}},
                {+end = b$961 | {}},
                a$963
            ),
            a1$965
        )
    } else {
        Array.updateSequence!(
            0i32,
            Array.slice(
                rc2$957,
                {+start = f$959 | {}},
                {+end = c$967 | {}},
                a$963
            ),
            a1$965
        );
        Array.updateSequence!(
            <[unknown exp]>(c$967, f$959),
            Array.slice(
                rc2$957,
                {+start = 0i32 | {}},
                {+end = b$961 | {}},
                a$963
            ),
            a1$965
        )
    }
}

def MutDeque.empty(rc$305: Region[r]): MutDeque[a, r] \ r = {
    MutDeque.MutDeque(
        rc$305,
        (ref Array.empty(rc$305, MutDeque.minCapacity(()))) @ rc$305,
        (ref 0i32) @ rc$305,
        (ref 0i32) @ rc$305
    )
}

def MutDeque.expand!(d$874: MutDeque[a, r]): Unit \ r = {
    if (MutDeque.shouldExpand(d$874)) {MutDeque.grow!(d$874)} else {()}
}

def MutDeque.foldLeft(
    f$576: b -> a -> b \ ef,
    s$578: b,
    d$580: MutDeque[a, r]
): b \ ef + r = {
    match d$580 {
        case MutDeque.MutDeque(_, ar_$582, front_$584, back_$586) =>
            let ar$588: Array[a, r] = deref ar_$582;
            let front$590: Int32 = deref front_$584;
            let back$592: Int32 = deref back_$586;
            let c$594: Int32 = <[unknown exp]>(MutDeque.capacity(d$580), 1i32);
            letrec loop$596: (Int32 -> Int32 -> (b -> b \ ef + r)) = i$598 ->
                e$600 ->
                    acc$602 ->
                        if (<[unknown exp]>(i$598, e$600)) {
                            acc$602
                        } else {
                            loop$596(
                                Int32.bitwiseAnd(
                                    <[unknown exp]>(i$598, 1i32),
                                    c$594
                                )
                            )(e$600)(f$576(acc$602)(Array.get(i$598, ar$588)))
                        };
            loop$596(front$590)(back$592)(s$578)
    }
}

def MutDeque.foldMap(f$755: a -> b, d$760: MutDeque[a, r]): b \ ef + r = {
    MutDeque.foldLeft(
        acc$762 ->
            x$764 ->
                <[unknown exp]>(acc$762, f$755(x$764)),
        <[unknown exp]>(()),
        d$760
    )
}

def MutDeque.foldRight(
    f$615: a -> b -> b \ ef,
    s$618: b,
    d$622: MutDeque[a, r]
): b \ ef + r = {
    match d$622 {
        case MutDeque.MutDeque(_, ar_$628, front_$632, back_$634) =>
            let ar$636: Array[a, r] = deref ar_$628;
            let front$638: Int32 = deref front_$632;
            let back$640: Int32 = deref back_$634;
            let c$642: Int32 = <[unknown exp]>(MutDeque.capacity(d$622), 1i32);
            letrec loop$644: (Int32 -> Int32 -> (b -> b \ ef + r)) = i$646 ->
                e$648 ->
                    acc$650 ->
                        if (<[unknown exp]>(i$646, e$648)) {
                            acc$650
                        } else {
                            let j$652: Int32 = Int32.bitwiseAnd(
                                <[unknown exp]>(i$646, 1i32),
                                c$642
                            );
                            loop$644(
                                j$652
                            )(e$648)(f$615(Array.get(j$652, ar$636))(acc$650))
                        };
            loop$644(back$640)(front$638)(s$618)
    }
}

def MutDeque.foldRightWithCont(
    f$674: a -> (Unit -> b \ ef + r) -> b \ ef + r,
    s$700: b,
    d$702: MutDeque[a, r]
): b \ ef + r = {
    match d$702 {
        case MutDeque.MutDeque(_, ar_$707, front_$710, back_$714) =>
            let ar$716: Array[a, r] = deref ar_$707;
            let front$720: Int32 = deref front_$710;
            let back$722: Int32 = deref back_$714;
            let c$724: Int32 = <[unknown exp]>(MutDeque.capacity(d$702), 1i32);
            letrec loop$727: (Int32 -> Int32 -> b \ ef + r) = i$731 ->
                e$736 ->
                    if (<[unknown exp]>(i$731, e$736)) {
                        s$700
                    } else {
                        f$674(
                            Array.get(i$731, ar$716)
                        )(
                            _$740 ->
                                loop$727(
                                    Int32.bitwiseAnd(
                                        <[unknown exp]>(i$731, 1i32),
                                        c$724
                                    )
                                )(e$736)
                        )
                    };
            loop$727(front$720)(back$722)
    }
}

def MutDeque.forEach(
    f$3784: a -> Unit,
    d$3790: MutDeque[a, r]
): Unit \ ef + r = {
    match d$3790 {
        case MutDeque.MutDeque(_, a$3798, front$3802, back$3804) =>
            let c$3808: Int32 = <[unknown exp]>(
                MutDeque.capacity(d$3790),
                1i32
            );
            letrec loop$3810: (Int32 -> Unit) = i$3814 ->
                if (<[unknown exp]>(i$3814, deref back$3804)) {
                    ()
                } else {
                    match Array.nth(i$3814, deref a$3798) {
                        case Option.Some(x$3826) =>
                            f$3784(x$3826)
                        case Option.None =>
                            bug!("""An error occurred in MutDeque.forEach!""")
                    };
                    loop$3810(
                        Int32.bitwiseAnd(<[unknown exp]>(i$3814, 1i32), c$3808)
                    )
                };
            loop$3810(deref front$3802)
    }
}

def MutDeque.forEachWithIndex(
    f$3861: Int32 -> a -> Unit \ ef,
    d$3868: MutDeque[a, r]
): Unit \ ef + r = {
    region rc$3870 {
        let ix$3873: Ref[Int32, rc] = (ref 0i32) @ rc$3870;
        MutDeque.forEach(
            x$3877 ->
                {
                    let i$3879: Int32 = deref ix$3873;
                    f$3861(i$3879)(x$3877);
                    Ref.put(<[unknown exp]>(i$3879, 1i32), ix$3873)
                },
            d$3868
        )
    }
}

def MutDeque.grow!(d$882: MutDeque[a, r]): Unit \ r = {
    match d$882 {
        case MutDeque.MutDeque(r$884, a$886, f$888, b$890) =>
            let c$892: Int32 = MutDeque.capacity(d$882);
            let arr$894: Array[a, r] = Array.empty(
                r$884,
                Int32.leftShift(c$892, 1i32)
            );
            MutDeque.copyElements!(
                r$884,
                deref f$888,
                deref b$890,
                deref a$886,
                arr$894
            );
            Ref.put(arr$894, a$886);
            Ref.put(
                MutDeque.computeSize(c$892, deref f$888, deref b$890),
                b$890
            );
            Ref.put(0i32, f$888)
    }
}

def MutDeque.isEmpty(d$548: MutDeque[a, r]): Bool \ r = {
    match d$548 {
        case MutDeque.MutDeque(_, _, f$550, b$552) =>
            <[unknown exp]>(deref f$550, deref b$552)
    }
}

def MutDeque.iterator(
    rc$3716: Region[r1],
    d$3718: MutDeque[a, r2]
): Iterator[a, r1 + r2, r1] \ r1 + r2 = {
    match d$3718 {
        case MutDeque.MutDeque(_, a$3726, f$3728, b$3730) =>
            let i$3734: Ref[Int32, r1] = (ref (deref f$3728)) @ rc$3716;
            let next$3740: (Unit -> Option[a]) = _unit$3745 ->
                if (<[unknown exp]>(deref i$3734, deref b$3730)) {
                    let x$3749: a = Array.get(deref i$3734, deref a$3726);
                    Ref.put(
                        <[unknown exp]>(
                            deref i$3734,
                            Int32.bitwiseAnd(
                                1i32,
                                <[unknown exp]>(MutDeque.capacity(d$3718), 1i32)
                            )
                        ),
                        i$3734
                    );
                    Option.Some(x$3749)
                } else {
                    Option.None
                };
            Iterator.iterate(rc$3716, next$3740)
    }
}

def MutDeque.join(sep$2237: String, d$2240: MutDeque[a, r]): String \ r = {
    MutDeque.joinWith($0$45398 -> <[unknown exp]>($0$45398), sep$2237, d$2240)
}

def MutDeque.joinWith(
    f$2255: a -> String,
    sep$2257: String,
    d$2259: MutDeque[a, r]
): String \ ef + r = {
    region rc1$2261 {<[unknown exp]>}
}

def MutDeque.loadFactorOf(s$1996: Int32, c$1998: Int32): Float32 = {
    <[unknown exp]>(Int32.toFloat32(s$1996), Int32.toFloat32(c$1998))
}

def MutDeque.maxLoadFactor(_unit$224: Unit): Float32 = {
    <[unknown exp]>(3.0f32, 4.0f32)
}

def MutDeque.minCapacity(_unit$171: Unit): Int32 = {8i32}

def MutDeque.minLoadFactor(_unit$218: Unit): Float32 = {
    <[unknown exp]>(1.0f32, 4.0f32)
}

def MutDeque.nonEmpty(d$556: MutDeque[a, r]): Bool \ r = {
    !MutDeque.isEmpty(d$556)
}

def MutDeque.peekBack(d$856: MutDeque[a, r]): Option[a] \ r = {
    match d$856 {
        case MutDeque.MutDeque(_, a$858, f$860, b$862) =>
            let f1$864: Int32 = deref f$860;
            let b1$866: Int32 = deref b$862;
            if (<[unknown exp]>(f1$864, b1$866)) {
                Option.None
            } else {
                let c$868: Int32 = <[unknown exp]>(
                    MutDeque.capacity(d$856),
                    1i32
                );
                let i$870: Int32 = Int32.bitwiseAnd(
                    <[unknown exp]>(b1$866, 1i32),
                    c$868
                );
                Option.Some(Array.get(i$870, deref a$858))
            }
    }
}

def MutDeque.peekFront(d$842: MutDeque[a, r]): Option[a] \ r = {
    match d$842 {
        case MutDeque.MutDeque(_, a$844, f$846, b$848) =>
            let f1$850: Int32 = deref f$846;
            let b1$852: Int32 = deref b$848;
            if (<[unknown exp]>(f1$850, b1$852)) {
                Option.None
            } else {
                Option.Some(Array.get(f1$850, deref a$844))
            }
    }
}

def MutDeque.popBack(d$800: MutDeque[a, r]): Option[a] \ r = {
    if (MutDeque.isEmpty(d$800)) {
        Option.None
    } else {
        match d$800 {
            case MutDeque.MutDeque(_, a$802, _, b$804) =>
                let a1$806: Array[a, r] = deref a$802;
                let b1$808: Int32 = Int32.modulo(
                    <[unknown exp]>(deref b$804, 1i32),
                    MutDeque.capacity(d$800)
                );
                let x$810: a = Array.get(b1$808, a1$806);
                Ref.put(b1$808, b$804);
                MutDeque.compress!(d$800);
                Option.Some(x$810)
        }
    }
}

def MutDeque.popFront(d$773: MutDeque[a, r]): Option[a] \ r = {
    if (MutDeque.isEmpty(d$773)) {
        Option.None
    } else {
        match d$773 {
            case MutDeque.MutDeque(_, a$779, f$781, _) =>
                let a1$783: Array[a, r] = deref a$779;
                let f1$785: Int32 = deref f$781;
                let x$787: a = Array.get(f1$785, a1$783);
                Ref.put(
                    Int32.modulo(
                        <[unknown exp]>(f1$785, 1i32),
                        MutDeque.capacity(d$773)
                    ),
                    f$781
                );
                MutDeque.compress!(d$773);
                Option.Some(x$787)
        }
    }
}

def MutDeque.pushBack(x$828: a, d$830: MutDeque[a, r]): Unit \ r = {
    match d$830 {
        case MutDeque.MutDeque(_, a$832, _, b$834) =>
            let a1$836: Array[a, r] = deref a$832;
            let b1$838: Int32 = deref b$834;
            Array.put(x$828, b1$838, a1$836);
            Ref.put(
                Int32.modulo(
                    <[unknown exp]>(b1$838, 1i32),
                    MutDeque.capacity(d$830)
                ),
                b$834
            );
            MutDeque.expand!(d$830)
    }
}

def MutDeque.pushFront(x$814: a, d$816: MutDeque[a, r]): Unit \ r = {
    match d$816 {
        case MutDeque.MutDeque(_, a$818, f$820, _) =>
            let a1$822: Array[a, r] = deref a$818;
            let f1$824: Int32 = Int32.modulo(
                <[unknown exp]>(deref f$820, 1i32),
                MutDeque.capacity(d$816)
            );
            Array.put(x$814, f1$824, a1$822);
            Ref.put(f1$824, f$820);
            MutDeque.expand!(d$816)
    }
}

def MutDeque.sameElements(
    d1$2045: MutDeque[t, r1],
    d2$2047: MutDeque[t, r2]
): Bool \ r1 + r2 = {
    region rc3$2052 {
        let aSize$2055: Int32 = MutDeque.size(d1$2045);
        let bSize$2062: Int32 = MutDeque.size(d2$2047);
        if (<[unknown exp]>(aSize$2055, bSize$2062)) {
            match d1$2045 {
                case MutDeque.MutDeque(
                    _,
                    aArray$2066,
                    aFront$2068,
                    aBack$2070
                ) =>
                    match d2$2047 {
                        case MutDeque.MutDeque(
                            _,
                            bArray$2077,
                            bFront$2081,
                            bBack$2083
                        ) =>
                            let a1$2087: Array[t, rc3] = Array.empty(
                                rc3$2052,
                                aSize$2055
                            );
                            let b1$2093: Array[t, rc3] = Array.empty(
                                rc3$2052,
                                bSize$2062
                            );
                            MutDeque.copyElements!(
                                rc3$2052,
                                deref aFront$2068,
                                deref aBack$2070,
                                deref aArray$2066,
                                a1$2087
                            );
                            MutDeque.copyElements!(
                                rc3$2052,
                                deref bFront$2081,
                                deref bBack$2083,
                                deref bArray$2077,
                                b1$2093
                            );
                            Array.sameElements(a1$2087, b1$2093)
                    }
            }
        } else {
            false
        }
    }
}

def MutDeque.shouldCompress(d$908: MutDeque[a, r]): Bool \ r = {
    <[unknown exp]>(
        MutDeque.loadFactorOf(MutDeque.size(d$908), MutDeque.capacity(d$908)),
        MutDeque.minLoadFactor(())
    )
}

def MutDeque.shouldExpand(d$878: MutDeque[a, r]): Bool \ r = {
    <[unknown exp]>(
        MutDeque.loadFactorOf(MutDeque.size(d$878), MutDeque.capacity(d$878)),
        MutDeque.maxLoadFactor(())
    )
}

def MutDeque.shrink!(d$922: MutDeque[a, r]): Unit \ r = {
    match d$922 {
        case MutDeque.MutDeque(r$924, a$926, f$928, b$930) =>
            let mc$932: Int32 = MutDeque.minCapacity(());
            let c$934: Int32 = MutDeque.capacity(d$922);
            if (<[unknown exp]>(c$934, mc$932)) {
                let arr$941: Array[a, r] = Array.empty(
                    r$924,
                    Int32.rightShift(c$934, 1i32)
                );
                MutDeque.copyElements!(
                    r$924,
                    deref f$928,
                    deref b$930,
                    deref a$926,
                    arr$941
                );
                Ref.put(arr$941, a$926);
                Ref.put(
                    MutDeque.computeSize(c$934, deref f$928, deref b$930),
                    b$930
                );
                Ref.put(0i32, f$928)
            } else {
                ()
            }
    }
}

def MutDeque.shuffle(
    rc1$3908: Region[r1],
    rnd$3910: Random,
    d$3914: MutDeque[a, r2]
): MutDeque[a, r1] \ r2 + r1 + IO = {
    region rc3$3928 {
        |>(
            !>(
                MutDeque.toArray(rc3$3928, d$3914),
                (
                    $0$45404 ->
                        $1$45406 ->
                            Array.shuffle($0$45404, $1$45406)
                )(rnd$3910)
            ),
            (
                $0$45408 ->
                    $1$45410 ->
                        Array.toMutDeque($0$45408, $1$45410)
            )(rc1$3908)
        )
    }
}

def MutDeque.size(d$483: MutDeque[a, r]): Int32 \ r = {
    match d$483 {
        case MutDeque.MutDeque(_, _, f$485, b$487) =>
            MutDeque.computeSize(
                MutDeque.capacity(d$483),
                deref f$485,
                deref b$487
            )
    }
}

def MutDeque.sum(d$559: MutDeque[Int32, r]): Int32 \ r = {
    MutDeque.sumWith($0$45346 -> identity($0$45346), d$559)
}

def MutDeque.sumWith(
    f$564: a -> Int32,
    d$566: MutDeque[a, r]
): Int32 \ ef + r = {
    MutDeque.foldLeft(
        acc$568 ->
            x$570 ->
                <[unknown exp]>(f$564(x$570), acc$568),
        0i32,
        d$566
    )
}

def MutDeque.toArray(
    rc1$2127: Region[r1],
    d$2131: MutDeque[a, r2]
): Array[a, r1] \ r2 + r1 = {
    match d$2131 {
        case MutDeque.MutDeque(_, a$2147, f$2149, b$2151) =>
            let len$2157: Int32 = MutDeque.capacity(d$2131);
            let i$2163: Int32 = deref f$2149;
            let j$2169: Int32 = deref b$2151;
            if (<[unknown exp]>(i$2163, j$2169)) {
                [] @ rc1$2127
            } else {
                if (<[unknown exp]>(i$2163, j$2169)) {
                    Array.copyOfRange(rc1$2127, i$2163, j$2169, deref a$2147)
                } else {
                    Array.append(
                        rc1$2127,
                        Array.copyOfRange(
                            rc1$2127,
                            i$2163,
                            len$2157,
                            deref a$2147
                        ),
                        Array.copyOfRange(rc1$2127, 0i32, j$2169, deref a$2147)
                    )
                }
            }
    }
}

def MutDeque.toList(d$2106: MutDeque[a, r]): List[a] \ r = {
    MutDeque.foldRight(
        x$2110 ->
            acc$2112 ->
                List.Cons(x$2110, acc$2112),
        List.Nil,
        d$2106
    )
}

def MutDeque.toString(d$232: MutDeque[a, r]): String \ r = {
    region rc2$234 {
        let sb$237: StringBuilder[rc2] = StringBuilder.empty(rc2$234);
        StringBuilder.appendString!("""MutDeque#{""", sb$237);
        MutDeque.forEachWithIndex(
            i$239 ->
                x$241 ->
                    if (<[unknown exp]>(i$239, 1i32)) {
                        StringBuilder.appendString!(
                            """""" + <[unknown exp]>(x$241),
                            sb$237
                        )
                    } else {
                        StringBuilder.appendString!(
                            ("""""" + """, """) + <[unknown exp]>(x$241),
                            sb$237
                        )
                    },
            d$232
        );
        StringBuilder.appendString!("""}""", sb$237);
        StringBuilder.toString(sb$237)
    }
}

def MutDeque.toVector(d$2187: MutDeque[a, r]): Vector[a] \ r = {
    region rc$2198 {
        let arr$2202: Array[a, rc] = Array.empty(
            rc$2198,
            MutDeque.size(d$2187)
        );
        MutDeque.forEachWithIndex(
            i$2211 ->
                x$2213 ->
                    Array.put(x$2213, i$2211, arr$2202),
            d$2187
        );
        Array.toVector(arr$2202)
    }
}

enum MutDisjointSets[t, r] {
    case MutDisjointSets({ forest = MutMap[t, Node[t, r], r], rc = Region[r] })
}

def MutDisjointSets.empty(rc$4957: Region[r]): MutDisjointSets[t, r] \ r = {
    MutDisjointSets.MutDisjointSets(
        {+rc = rc$4957, +forest = MutMap.empty(rc$4957) | {}}
    )
}

def MutDisjointSets.equal(x$14044: Node[t, r], y$14048: Node[t, r]): Bool = {
    match (x$14044, y$14048) {
        case (
            MutDisjointSets.Node.Node({+value = xVal$14058 | _}),
            MutDisjointSets.Node.Node({+value = yVal$14062 | _})
        ) =>
            <[unknown exp]>(xVal$14058, yVal$14062)
    }
}

def MutDisjointSets.equivalent(
    x$14006: t,
    y$14008: t,
    s$14010: MutDisjointSets[t, r]
): Bool \ r = {
    match (
        MutDisjointSets.findSet(x$14006, s$14010),
        MutDisjointSets.findSet(y$14008, s$14010)
    ) {
        case (Option.Some(xn$14020), Option.Some(yn$14023)) =>
            MutDisjointSets.equal(xn$14020, yn$14023)
        case _ =>
            false
    }
}

def MutDisjointSets.find(
    x$13767: t,
    s$13771: MutDisjointSets[t, r]
): Option[t] \ r = {
    |>(
        MutDisjointSets.findSet(x$13767, s$13771),
        (
            $0$45590 ->
                $1$45592 ->
                    Option.map($0$45590, $1$45592)
        )(
            pat$80$13778 ->
                match pat$80$13778 {
                    case MutDisjointSets.Node.Node(
                        {+value = value$13790 | _}
                    ) =>
                        value$13790
                }
        )
    )
}

def MutDisjointSets.findSet(
    x$13814: t,
    s$13819: MutDisjointSets[t, r]
): Option[Node[t, r]] \ r = {
    letrec findRoot$13835: (Node[t, r] -> Node[t, r]) = y$13837 ->
        match y$13837 {
            case MutDisjointSets.Node.Node({+parent = parent$13845 | _}) =>
                match Ref.get(parent$13845) {
                    case Option.Some(p$13851) =>
                        let root$13853: Node[t, r] = findRoot$13835(p$13851);
                        Ref.put(Option.Some(root$13853), parent$13845);
                        root$13853
                    case Option.None =>
                        y$13837
                }
        };
    match s$13819 {
        case MutDisjointSets.MutDisjointSets({+forest = forest$13858 | _}) =>
            |>(
                MutMap.get(x$13814, forest$13858),
                (
                    $0$45594 ->
                        $1$45596 ->
                            Option.map($0$45594, $1$45596)
                )(findRoot$13835)
            )
    }
}

def MutDisjointSets.makeSet(
    x$4993: t,
    s$4996: MutDisjointSets[t, r]
): Unit \ r = {
    letrec singleton$5004: (Region[r] -> t -> Node[t, r] \ r) = rc$5006 ->
        y$5010 ->
            MutDisjointSets.Node.Node(
                {
                    +rc = rc$5006,
                    +value = y$5010,
                    +parent = Ref.fresh(rc$5006, Option.None),
                    +rank = Ref.fresh(rc$5006, 0i32) |
                    {}
                }
            );
    match s$4996 {
        case MutDisjointSets.MutDisjointSets(
            {+rc = rc$7129, +forest = forest$7226 | {}}
        ) =>
            if (!MutDisjointSets.memberOf(x$4993, s$4996)) {
                MutMap.put!(
                    x$4993,
                    singleton$5004(rc$7129)(x$4993),
                    forest$7226
                )
            } else {
                ()
            }
    }
}

def MutDisjointSets.makeSets(
    m$12824: m,
    s$12828: MutDisjointSets[elt, r]
): Unit \ r + Aef[m] = {
    region rc$13688 {
        |>(
            <[unknown exp]>(rc$13688, m$12824),
            (
                $0$45580 ->
                    $1$45582 ->
                        Iterator.forEach($0$45580, $1$45582)
            )(x$13695 -> MutDisjointSets.makeSet(x$13695, s$12828))
        )
    }
}

def MutDisjointSets.memberOf(
    x$13729: t,
    s$13734: MutDisjointSets[t, r]
): Bool \ r = {
    match s$13734 {
        case MutDisjointSets.MutDisjointSets({+forest = forest$13740 | _}) =>
            MutMap.memberOf(x$13729, forest$13740)
    }
}

def MutDisjointSets.size(s$14079: MutDisjointSets[t, r]): Int32 \ r = {
    match s$14079 {
        case MutDisjointSets.MutDisjointSets({+forest = forest$14095 | _}) =>
            MutMap.size(forest$14095)
    }
}

def MutDisjointSets.union(
    x$13902: t,
    y$13908: t,
    s$13914: MutDisjointSets[t, r]
): Unit \ r = {
    letrec link$13926: (Node[t, r] -> Node[t, r] -> Unit \ r) = x1$13929 ->
        y1$13932 ->
            if (!MutDisjointSets.equal(x1$13929, y1$13932)) {
                match x1$13929 {
                    case MutDisjointSets.Node.Node(
                        {+parent = xParent$13947, +rank = xr$13949 | _}
                    ) =>
                        match y1$13932 {
                            case MutDisjointSets.Node.Node(
                                {+parent = yParent$13951, +rank = yr$13953 | _}
                            ) =>
                                let xRank$13955: Int32 = Ref.get(xr$13949);
                                let yRank$13957: Int32 = Ref.get(yr$13953);
                                if (<[unknown exp]>(xRank$13955, yRank$13957)) {
                                    Ref.put(
                                        Option.Some(x1$13929),
                                        yParent$13951
                                    )
                                } else {
                                    Ref.put(
                                        Option.Some(y1$13932),
                                        xParent$13947
                                    )
                                };
                                if (<[unknown exp]>(xRank$13955, yRank$13957)) {
                                    Ref.put(
                                        <[unknown exp]>(yRank$13957, 1i32),
                                        yr$13953
                                    )
                                } else {
                                    ()
                                }
                        }
                }
            } else {
                ()
            };
    match (
        MutDisjointSets.findSet(x$13902, s$13914),
        MutDisjointSets.findSet(y$13908, s$13914)
    ) {
        case (Option.Some(xn$13969), Option.Some(yn$13971)) =>
            link$13926(xn$13969)(yn$13971)
        case (Option.Some(_), Option.None) =>
            MutDisjointSets.makeSet(y$13908, s$13914);
            MutDisjointSets.union(x$13902, y$13908, s$13914)
        case (Option.None, Option.Some(_)) =>
            MutDisjointSets.makeSet(y$13908, s$13914);
            MutDisjointSets.union(x$13902, y$13908, s$13914)
        case (Option.None, Option.None) =>
            MutDisjointSets.makeSet(x$13902, s$13914);
            MutDisjointSets.makeSet(y$13908, s$13914);
            MutDisjointSets.union(x$13902, y$13908, s$13914)
    }
}

enum MutDisjointSets.Node[t, r] {
    case Node(
        { parent = Ref[Option[Node[t, r]], r], rank = Ref[Int32, r], rc = Region[r], value = t }
    )
}

enum MutList[a, r] {case MutList(Region[r], Ref[Array[a, r], r], Ref[Int32, r])}

def MutList.append!(m$36638: m[a], v$36645: MutList[a, r]): Unit \ r = {
    MutList.pushAll!(m$36638, v$36645)
}

def MutList.capacity(v$37567: MutList[a, r]): Int32 \ r = {
    match v$37567 {
        case MutList.MutList(_, a$37569, _) =>
            Array.length(deref a$37569)
    }
}

def MutList.clear!(v$36117: MutList[a, r]): Unit \ r = {
    match v$36117 {
        case MutList.MutList(r$36130, a$36132, l$36136) =>
            Ref.put(Array.empty(r$36130, Array.length(deref a$36132)), a$36132);
            Ref.put(0i32, l$36136)
    }
}

def MutList.compress!(v$37543: MutList[a, r]): Unit \ r = {
    let c$37549: Int32 = MutList.capacity(v$37543);
    let len$37551: Int32 = MutList.length(v$37543);
    let loadFactor$37553: Float32 = <[unknown exp]>(
        Int32.toFloat32(len$37551),
        Int32.toFloat32(c$37549)
    );
    if (
        <[unknown exp]>(
            loadFactor$37553,
            <[unknown exp]>(1.0f32, 4.0f32)
        ) and <[unknown exp]>(len$37551, 0i32)
    ) {
        if (<[unknown exp]>(len$37551, 1i32)) {
            MutList.shrinkTo!(1i32, v$37543)
        } else {
            MutList.shrinkTo!(<[unknown exp]>(c$37549, 2i32), v$37543)
        }
    } else {
        ()
    }
}

def MutList.copy(
    rc1$36193: Region[r1],
    v$36205: MutList[a, r]
): MutList[a, r1] \ r + r1 = {
    match v$36205 {
        case MutList.MutList(_, a$36211, l$36213) =>
            let len$36215: Int32 = deref l$36213;
            if (<[unknown exp]>(len$36215, MutList.minCapacity(()))) {
                MutList.MutList(
                    rc1$36193,
                    (
                        ref Array.copyOfRange(
                            rc1$36193,
                            0i32,
                            len$36215,
                            deref a$36211
                        )
                    ) @ rc1$36193,
                    (ref len$36215) @ rc1$36193
                )
            } else {
                MutList.MutList(
                    rc1$36193,
                    (
                        ref Array.copyOfRange(
                            rc1$36193,
                            0i32,
                            MutList.capacity(v$36205),
                            deref a$36211
                        )
                    ) @ rc1$36193,
                    (ref len$36215) @ rc1$36193
                )
            }
    }
}

def MutList.count(
    f$33202: a -> Bool,
    v$33207: MutList[a, r]
): Int32 \ ef + r = {
    MutList.foldLeft(
        acc$33224 ->
            x$33226 ->
                if (f$33202(x$33226)) {
                    <[unknown exp]>(acc$33224, 1i32)
                } else {
                    acc$33224
                },
        0i32,
        v$33207
    )
}

def MutList.empty(rc$32679: Region[r]): MutList[a, r] \ r = {
    MutList.MutList(
        rc$32679,
        (ref Array.empty(rc$32679, MutList.minCapacity(()))) @ rc$32679,
        (ref 0i32) @ rc$32679
    )
}

def MutList.exists(
    f$34279: a -> Bool,
    v$34281: MutList[a, r]
): Bool \ ef + r = {
    match v$34281 {
        case MutList.MutList(_, ra$34287, rl$34291) =>
            let a$34293: Array[a, r] = deref ra$34287;
            let l$34295: Int32 = deref rl$34291;
            letrec loop$34297: (Int32 -> Bool) = i$34299 ->
                if (<[unknown exp]>(i$34299, l$34295)) {
                    false
                } else {
                    if (f$34279(Array.get(i$34299, a$34293))) {
                        true
                    } else {
                        loop$34297(<[unknown exp]>(i$34299, 1i32))
                    }
                };
            loop$34297(0i32)
    }
}

def MutList.find(f$34824: a -> Bool, v$34837: MutList[a, r]): Option[a] \ r = {
    MutList.findLeft(f$34824, v$34837)
}

def MutList.findLeft(
    f$34855: a -> Bool,
    v$34857: MutList[a, r]
): Option[a] \ r = {
    match v$34857 {
        case MutList.MutList(_, ra$34866, rl$34868) =>
            let a$34870: Array[a, r] = deref ra$34866;
            let l$34877: Int32 = deref rl$34868;
            letrec loop$34881: (Int32 -> Option[a]) = i$34883 ->
                if (<[unknown exp]>(i$34883, l$34877)) {
                    Option.None
                } else {
                    if (f$34855(Array.get(i$34883, a$34870))) {
                        Option.Some(Array.get(i$34883, a$34870))
                    } else {
                        loop$34881(<[unknown exp]>(i$34883, 1i32))
                    }
                };
            loop$34881(0i32)
    }
}

def MutList.findRight(
    f$34917: a -> Bool,
    v$34923: MutList[a, r]
): Option[a] \ r = {
    match v$34923 {
        case MutList.MutList(_, ra$34935, rl$34937) =>
            let a$34941: Array[a, r] = deref ra$34935;
            let l$34945: Int32 = deref rl$34937;
            letrec loop$34947: (Int32 -> Option[a]) = i$34949 ->
                if (<[unknown exp]>(i$34949, 0i32)) {
                    Option.None
                } else {
                    if (f$34917(Array.get(i$34949, a$34941))) {
                        Option.Some(Array.get(i$34949, a$34941))
                    } else {
                        loop$34947(<[unknown exp]>(i$34949, 1i32))
                    }
                };
            loop$34947(<[unknown exp]>(l$34945, 1i32))
    }
}

def MutList.flatMap(
    rc1$35337: Region[r1],
    f$35339: a -> MutList[b, r1],
    v$35342: MutList[a, r]
): MutList[b, r1] \ ef + r + r1 = {
    |>(
        MutList.map(rc1$35337, f$35339, v$35342),
        ($0$46616 -> $1$46618 -> MutList.flatten($0$46616, $1$46618))(rc1$35337)
    )
}

def MutList.flatten(
    rc1$35276: Region[r1],
    v$35279: MutList[MutList[a, r], r]
): MutList[a, r1] \ r + r1 = {
    let rdestIndex$35285: Ref[Int32, r1] = (ref 0i32) @ rc1$35276;
    let size$35287: Int32 = MutList.sumWith(
        $0$46610 ->
            MutList.length($0$46610),
        v$35279
    );
    let destArray$35289: Array[a, r1] = Array.empty(
        rc1$35276,
        Int32.max(size$35287, MutList.minCapacity(()))
    );
    |>(
        v$35279,
        (
            $0$46612 ->
                $1$46614 ->
                    MutList.forEach($0$46612, $1$46614)
        )(
            bs$35291 ->
                match bs$35291 {
                    case MutList.MutList(_, rb$35293, rbl$35295) =>
                        let bl$35297: Int32 = deref rbl$35295;
                        let destIndex$35299: Int32 = deref rdestIndex$35285;
                        Array.patch!(
                            destIndex$35299,
                            bl$35297,
                            deref rb$35293,
                            destArray$35289
                        );
                        Ref.put(
                            <[unknown exp]>(destIndex$35299, bl$35297),
                            rdestIndex$35285
                        )
                }
        )
    );
    MutList.MutList(
        rc1$35276,
        (ref destArray$35289) @ rc1$35276,
        (ref size$35287) @ rc1$35276
    )
}

def MutList.foldLeft(
    f$35587: b -> a -> b \ ef,
    s$35591: b,
    v$35593: MutList[a, r]
): b \ ef + r = {
    match v$35593 {
        case MutList.MutList(_, ra$35617, rl$35621) =>
            let a$35627: Array[a, r] = deref ra$35617;
            let l$35635: Int32 = deref rl$35621;
            letrec loop$35637: (Int32 -> b -> b \ ef + r + ef + r) = i$35639 ->
                acc$35641 ->
                    if (<[unknown exp]>(i$35639, l$35635)) {
                        acc$35641
                    } else {
                        let s1$35643: b = f$35587(
                            acc$35641
                        )(Array.get(i$35639, a$35627));
                        loop$35637(<[unknown exp]>(i$35639, 1i32))(s1$35643)
                    };
            loop$35637(0i32)(s$35591)
    }
}

def MutList.foldMap(f$35898: a -> b, v$35904: MutList[a, r]): b \ ef + r = {
    MutList.foldLeft(
        acc$35924 ->
            x$35927 ->
                <[unknown exp]>(acc$35924, f$35898(x$35927)),
        <[unknown exp]>(()),
        v$35904
    )
}

def MutList.foldRight(
    f$35688: a -> b -> b \ ef,
    s$35690: b,
    v$35694: MutList[a, r]
): b \ ef + r = {
    match v$35694 {
        case MutList.MutList(_, ra$35720, rl$35722) =>
            let a$35724: Array[a, r] = deref ra$35720;
            let l$35726: Int32 = deref rl$35722;
            letrec loop$35728: (Int32 -> b -> b \ ef + r + ef + r) = i$35730 ->
                acc$35732 ->
                    if (<[unknown exp]>(i$35730, 0i32)) {
                        acc$35732
                    } else {
                        let s1$35734: b = f$35688(
                            Array.get(i$35730, a$35724)
                        )(acc$35732);
                        loop$35728(<[unknown exp]>(i$35730, 1i32))(s1$35734)
                    };
            loop$35728(<[unknown exp]>(l$35726, 1i32))(s$35690)
    }
}

def MutList.foldRightWithCont(
    f$35791: a -> (Unit -> b \ ef + r) -> b \ ef + r,
    z$35823: b,
    v$35825: MutList[a, r]
): b \ ef + r = {
    match v$35825 {
        case MutList.MutList(_, ra$35833, rl$35836) =>
            let a$35840: Array[a, r] = deref ra$35833;
            let l$35842: Int32 = deref rl$35836;
            letrec loop$35845: (Int32 -> b) = i$35850 ->
                if (<[unknown exp]>(i$35850, l$35842)) {
                    z$35823
                } else {
                    f$35791(
                        Array.get(i$35850, a$35840)
                    )(_$35862 -> loop$35845(<[unknown exp]>(i$35850, 1i32)))
                };
            loop$35845(0i32)
    }
}

def MutList.forAll(
    f$34372: a -> Bool,
    v$34383: MutList[a, r]
): Bool \ ef + r = {
    match v$34383 {
        case MutList.MutList(_, ra$34394, rl$34396) =>
            let a$34398: Array[a, r] = deref ra$34394;
            let l$34403: Int32 = deref rl$34396;
            letrec loop$34406: (Int32 -> Bool) = i$34409 ->
                if (<[unknown exp]>(i$34409, l$34403)) {
                    true
                } else {
                    if (f$34372(Array.get(i$34409, a$34398))) {
                        loop$34406(<[unknown exp]>(i$34409, 1i32))
                    } else {
                        false
                    }
                };
            loop$34406(0i32)
    }
}

def MutList.forEach(
    f$37445: a -> Unit,
    v$37447: MutList[a, r]
): Unit \ ef + r = {
    match v$37447 {
        case MutList.MutList(_, ra$37456, rl$37458) =>
            let a$37460: Array[a, r] = deref ra$37456;
            let l$37468: Int32 = deref rl$37458;
            letrec loop$37470: (Int32 -> Unit) = i$37472 ->
                if (<[unknown exp]>(i$37472, l$37468)) {
                    ()
                } else {
                    f$37445(Array.get(i$37472, a$37460));
                    loop$37470(<[unknown exp]>(i$37472, 1i32))
                };
            loop$37470(0i32)
    }
}

def MutList.forEachWithIndex(
    f$37497: Int32 -> a -> Unit \ ef,
    v$37503: MutList[a, r]
): Unit \ ef + r = {
    match v$37503 {
        case MutList.MutList(_, ra$37509, rl$37511) =>
            let a$37513: Array[a, r] = deref ra$37509;
            let l$37515: Int32 = deref rl$37511;
            letrec loop$37517: (Int32 -> Unit) = i$37519 ->
                if (<[unknown exp]>(i$37519, l$37515)) {
                    ()
                } else {
                    f$37497(i$37519)(Array.get(i$37519, a$37513));
                    loop$37517(<[unknown exp]>(i$37519, 1i32))
                };
            loop$37517(0i32)
    }
}

def MutList.head(v$34465: MutList[a, r]): Option[a] \ r = {
    match v$34465 {
        case MutList.MutList(_, a$34478, _) =>
            if (MutList.isEmpty(v$34465)) {
                Option.None
            } else {
                Array.head(deref a$34478)
            }
    }
}

def MutList.indexOf(x$34610: a, v$34612: MutList[a, r]): Option[Int32] \ r = {
    MutList.indexOfLeft(x$34610, v$34612)
}

def MutList.indexOfLeft(
    x$34679: a,
    v$34681: MutList[a, r]
): Option[Int32] \ r = {
    match v$34681 {
        case MutList.MutList(_, ra$34693, rl$34695) =>
            let a$34697: Array[a, r] = deref ra$34693;
            let l$34699: Int32 = deref rl$34695;
            letrec loop$34701: (Int32 -> Option[Int32]) = i$34703 ->
                if (<[unknown exp]>(i$34703, l$34699)) {
                    Option.None
                } else {
                    if (<[unknown exp]>(x$34679, Array.get(i$34703, a$34697))) {
                        Option.Some(i$34703)
                    } else {
                        loop$34701(<[unknown exp]>(i$34703, 1i32))
                    }
                };
            loop$34701(0i32)
    }
}

def MutList.indexOfRight(
    x$34752: a,
    v$34754: MutList[a, r]
): Option[Int32] \ r = {
    match v$34754 {
        case MutList.MutList(_, ra$34760, rl$34762) =>
            let a$34764: Array[a, r] = deref ra$34760;
            let l$34771: Int32 = deref rl$34762;
            letrec loop$34775: (Int32 -> Option[Int32]) = i$34777 ->
                if (<[unknown exp]>(i$34777, 0i32)) {
                    Option.None
                } else {
                    if (<[unknown exp]>(x$34752, Array.get(i$34777, a$34764))) {
                        Option.Some(i$34777)
                    } else {
                        loop$34775(<[unknown exp]>(i$34777, 1i32))
                    }
                };
            loop$34775(<[unknown exp]>(l$34771, 1i32))
    }
}

def MutList.insert!(
    x$36364: a,
    i$36366: Int32,
    v$36368: MutList[a, r]
): Unit \ r = {
    match v$36368 {
        case MutList.MutList(r$36381, a$36383, l$36385) =>
            let len$36387: Int32 = deref l$36385;
            if (
                <[unknown exp]>(
                    <[unknown exp]>(MutList.capacity(v$36368), len$36387),
                    0i32
                )
            ) {
                MutList.reserve!(len$36387, v$36368)
            } else {
                ()
            };
            let sub$36405: Array[a, r] = Array.copyOfRange(
                r$36381,
                i$36366,
                len$36387,
                deref a$36383
            );
            Array.updateSequence!(
                <[unknown exp]>(i$36366, 1i32),
                sub$36405,
                deref a$36383
            );
            Array.put(x$36364, i$36366, deref a$36383);
            Ref.put(<[unknown exp]>(len$36387, 1i32), l$36385)
    }
}

def MutList.isEmpty(v$32930: MutList[a, r]): Bool \ r = {
    <[unknown exp]>(MutList.length(v$32930), 0i32)
}

def MutList.iterator(
    rc$37375: Region[r1],
    l$37377: MutList[a, r2]
): Iterator[a, r1 + r2, r1] \ r1 + r2 = {
    match l$37377 {
        case MutList.MutList(_, a$37381, len$37383) =>
            let len1$37388: Int32 = deref len$37383;
            let ix$37392: Ref[Int32, r1] = (ref 0i32) @ rc$37375;
            let next$37398: (Unit -> Option[a]) = _unit$37400 ->
                {
                    let i$37402: Int32 = deref ix$37392;
                    if (<[unknown exp]>(i$37402, len1$37388)) {
                        let x$37406: a = Array.get(i$37402, deref a$37381);
                        Ref.put(<[unknown exp]>(i$37402, 1i32), ix$37392);
                        Option.Some(x$37406)
                    } else {
                        Option.None
                    }
                };
            Iterator.iterate(rc$37375, next$37398)
    }
}

def MutList.join(sep$37284: String, v$37286: MutList[a, r]): String \ r = {
    MutList.joinWith($0$46632 -> <[unknown exp]>($0$46632), sep$37284, v$37286)
}

def MutList.joinWith(
    f$37325: a -> String,
    sep$37332: String,
    v$37334: MutList[a, r]
): String \ ef + r = {
    region rc1$37336 {
        let sb$37339: StringBuilder[rc1] = StringBuilder.empty(rc1$37336);
        let step$37341: (
            Int32 -> a -> Unit \ rc1 + ef + rc1 + rc1 + ef
        ) = i$37343 ->
            x$37348 ->
                if (<[unknown exp]>(i$37343, 0i32)) {
                    StringBuilder.appendString!(f$37325(x$37348), sb$37339)
                } else {
                    StringBuilder.appendString!(sep$37332, sb$37339);
                    StringBuilder.appendString!(f$37325(x$37348), sb$37339)
                };
        MutList.forEachWithIndex(step$37341, v$37334);
        StringBuilder.toString(sb$37339)
    }
}

def MutList.last(v$34538: MutList[a, r]): Option[a] \ r = {
    match v$34538 {
        case MutList.MutList(_, a$34549, l$34551) =>
            let len$34553: Int32 = deref l$34551;
            if (<[unknown exp]>(len$34553, 0i32)) {
                Option.Some(
                    Array.get(<[unknown exp]>(len$34553, 1i32), deref a$34549)
                )
            } else {
                Option.None
            }
    }
}

def MutList.length(v$32888: MutList[a, r]): Int32 \ r = {
    match v$32888 {case MutList.MutList(_, _, l$32895) => deref l$32895}
}

def MutList.map(
    rc1$35207: Region[r1],
    f$35211: a -> b,
    v$35221: MutList[a, r]
): MutList[b, r1] \ ef + r + r1 = {
    if (MutList.isEmpty(v$35221)) {
        MutList.empty(rc1$35207)
    } else {
        match v$35221 {
            case MutList.MutList(_, ra$35232, rl$35234) =>
                let a$35236: Array[a, r] = deref ra$35232;
                let l$35238: Int32 = deref rl$35234;
                let x$35240: b = f$35211(Array.get(0i32, a$35236));
                let b$35246: Array[b, r1] = Array.repeat(
                    rc1$35207,
                    Array.length(a$35236),
                    x$35240
                );
                letrec loop$35248: (Int32 -> Unit) = i$35251 ->
                    if (<[unknown exp]>(i$35251, l$35238)) {
                        ()
                    } else {
                        Array.put(
                            f$35211(Array.get(i$35251, a$35236)),
                            i$35251,
                            b$35246
                        );
                        loop$35248(<[unknown exp]>(i$35251, 1i32))
                    };
                loop$35248(1i32);
                MutList.MutList(
                    rc1$35207,
                    (ref b$35246) @ rc1$35207,
                    (ref l$35238) @ rc1$35207
                )
        }
    }
}

def MutList.mapWithIndex(
    rc1$35373: Region[r1],
    f$35375: Int32 -> a -> b \ ef,
    v$35377: MutList[a, r]
): MutList[b, r1] \ ef + r + r1 = {
    if (MutList.isEmpty(v$35377)) {
        MutList.empty(rc1$35373)
    } else {
        match v$35377 {
            case MutList.MutList(_, ra$35391, rl$35393) =>
                let a$35398: Array[a, r] = deref ra$35391;
                let l$35404: Int32 = deref rl$35393;
                let x$35408: b = f$35375(0i32)(Array.get(0i32, a$35398));
                let b$35412: Array[b, r1] = Array.repeat(
                    rc1$35373,
                    Array.length(a$35398),
                    x$35408
                );
                letrec loop$35416: (Int32 -> Unit) = i$35418 ->
                    if (<[unknown exp]>(i$35418, l$35404)) {
                        ()
                    } else {
                        Array.put(
                            f$35375(i$35418)(Array.get(i$35418, a$35398)),
                            i$35418,
                            b$35412
                        );
                        loop$35416(<[unknown exp]>(i$35418, 1i32))
                    };
                loop$35416(1i32);
                MutList.MutList(
                    rc1$35373,
                    (ref b$35412) @ rc1$35373,
                    (ref l$35404) @ rc1$35373
                )
        }
    }
}

def MutList.maximum(v$33125: MutList[a, r]): Option[a] \ r = {
    MutList.reduceLeft(
        $0$46594 ->
            $1$46596 ->
                <[unknown exp]>($0$46594, $1$46596),
        v$33125
    )
}

def MutList.maximumBy(
    cmp$33169: a -> a -> Comparison,
    v$33171: MutList[a, r]
): Option[a] \ r = {
    MutList.reduceLeft(
        (
            $0$46598 ->
                $1$46600 ->
                    $2$46602 ->
                        Order.maxBy($0$46598, $1$46600, $2$46602)
        )(cmp$33169),
        v$33171
    )
}

def MutList.memberOf(x$33009: a, v$33013: MutList[a, r]): Bool \ r = {
    MutList.exists(y$33026 -> <[unknown exp]>(y$33026, x$33009), v$33013)
}

def MutList.minCapacity(_unit$32547: Unit): Int32 = {8i32}

def MutList.minimum(v$33044: MutList[a, r]): Option[a] \ r = {
    MutList.reduceLeft(
        $0$46584 ->
            $1$46586 ->
                <[unknown exp]>($0$46584, $1$46586),
        v$33044
    )
}

def MutList.minimumBy(
    cmp$33092: a -> a -> Comparison,
    v$33094: MutList[a, r]
): Option[a] \ r = {
    MutList.reduceLeft(
        (
            $0$46588 ->
                $1$46590 ->
                    $2$46592 ->
                        Order.minBy($0$46588, $1$46590, $2$46592)
        )(cmp$33092),
        v$33094
    )
}

def MutList.nonEmpty(v$32985: MutList[a, r]): Bool \ r = {
    !MutList.isEmpty(v$32985)
}

def MutList.nth(i$32842: Int32, v$32846: MutList[a, r]): Option[a] \ r = {
    match v$32846 {
        case MutList.MutList(_, a$32857, l$32859) =>
            if (
                <[unknown exp]>(
                    0i32,
                    i$32842
                ) and <[unknown exp]>(i$32842, deref l$32859)
            ) {
                Array.nth(i$32842, deref a$32857)
            } else {
                Option.None
            }
    }
}

def MutList.pop!(v$36258: MutList[a, r]): Option[a] \ r = {
    match v$36258 {
        case MutList.MutList(_, a$36263, l$36266) =>
            let len$36270: Int32 = deref l$36266;
            if (<[unknown exp]>(len$36270, 0i32)) {
                let last$36277: a = Array.get(
                    <[unknown exp]>(len$36270, 1i32),
                    deref a$36263
                );
                Ref.put(<[unknown exp]>(len$36270, 1i32), l$36266);
                Array.put(
                    Reflect.default(()),
                    <[unknown exp]>(len$36270, 1i32),
                    deref a$36263
                );
                MutList.compress!(v$36258);
                Option.Some(last$36277)
            } else {
                Option.None
            }
    }
}

def MutList.push!(x$36296: a, v$36299: MutList[a, r]): Unit \ r = {
    match v$36299 {
        case MutList.MutList(_, a$36307, l$36309) =>
            let len$36311: Int32 = deref l$36309;
            if (
                <[unknown exp]>(
                    <[unknown exp]>(MutList.capacity(v$36299), len$36311),
                    0i32
                )
            ) {
                MutList.reserve!(len$36311, v$36299)
            } else {
                ()
            };
            Array.put(x$36296, len$36311, deref a$36307);
            Ref.put(<[unknown exp]>(len$36311, 1i32), l$36309)
    }
}

def MutList.pushAll!(m$36555: m[a], v$36558: MutList[a, r]): Unit \ r = {
    <[unknown exp]>(x$36596 -> MutList.push!(x$36596, v$36558), m$36555)
}

def MutList.range(
    rc$32766: Region[r],
    b$32770: Int32,
    e$32772: Int32
): MutList[Int32, r] \ r = {
    let minCap$32788: Int32 = MutList.minCapacity(());
    let d$32790: Int32 = <[unknown exp]>(e$32772, b$32770);
    let c$32792: Int32 = <[unknown exp]>(d$32790, minCap$32788);
    let f$32794: (Int32 -> Int32) = i$32796 ->
        {
            let x$32798: Int32 = <[unknown exp]>(b$32770, i$32796);
            if (<[unknown exp]>(x$32798, e$32772)) {
                x$32798
            } else {
                Reflect.default(())
            }
        };
    MutList.MutList(
        rc$32766,
        (ref Array.init(rc$32766, f$32794, c$32792)) @ rc$32766,
        (ref d$32790) @ rc$32766
    )
}

def MutList.reduceLeft(
    f$35985: a -> a -> a \ ef,
    v$36013: MutList[a, r]
): Option[a] \ ef + r = {
    MutList.foldLeft(
        acc$36029 ->
            x$36031 ->
                match acc$36029 {
                    case Option.Some(y$36036) =>
                        Option.Some(f$35985(y$36036)(x$36031))
                    case Option.None =>
                        Option.Some(x$36031)
                },
        Option.None,
        v$36013
    )
}

def MutList.reduceRight(
    f$36054: a -> a -> a \ ef,
    v$36056: MutList[a, r]
): Option[a] \ ef + r = {
    MutList.foldRight(
        x$36070 ->
            acc$36080 ->
                match acc$36080 {
                    case Option.Some(y$36092) =>
                        Option.Some(f$36054(x$36070)(y$36092))
                    case Option.None =>
                        Option.Some(x$36070)
                },
        Option.None,
        v$36056
    )
}

def MutList.remove!(i$36438: Int32, v$36440: MutList[a, r]): Unit \ r = {
    match v$36440 {
        case MutList.MutList(_, ra$36449, rl$36453) =>
            let a$36457: Array[a, r] = deref ra$36449;
            let l$36486: Int32 = deref rl$36453;
            let n$36488: Int32 = <[unknown exp]>(l$36486, 1i32);
            letrec loop$36490: (Int32 -> Unit) = i1$36492 ->
                if (<[unknown exp]>(i1$36492, n$36488)) {
                    Array.put(
                        Array.get(<[unknown exp]>(i1$36492, 1i32), a$36457),
                        i1$36492,
                        a$36457
                    );
                    loop$36490(<[unknown exp]>(i1$36492, 1i32))
                } else {
                    if (<[unknown exp]>(i1$36492, n$36488)) {
                        Array.put(Reflect.default(()), i1$36492, a$36457)
                    } else {
                        ()
                    }
                };
            if (<[unknown exp]>(i$36438, l$36486)) {
                loop$36490(i$36438);
                Ref.put(n$36488, rl$36453);
                MutList.compress!(v$36440)
            } else {
                ()
            }
    }
}

def MutList.replace!(
    src$36737: { src = a },
    dst$36748: { dst = a },
    v$36754: MutList[a, r]
): Unit \ r = {
    MutList.transform!(
        e$36760 ->
            if (<[unknown exp]>(e$36760, src$36737.src)) {
                dst$36748.dst
            } else {
                e$36760
            },
        v$36754
    )
}

def MutList.reserve!(n$37018: Int32, v$37022: MutList[a, r]): Unit \ r = {
    match v$37022 {
        case MutList.MutList(r$37030, a$37032, l$37034) =>
            Ref.put(
                Array.copyOfRange(
                    r$37030,
                    0i32,
                    <[unknown exp]>(deref l$37034, n$37018),
                    deref a$37032
                ),
                a$37032
            )
    }
}

def MutList.retain!(f$36669: a -> Bool, v$36679: MutList[a, r]): Unit \ r = {
    match v$36679 {
        case MutList.MutList(r$36682, a1$36688, l1$36691) =>
            let l$36693: MutList[a, r] = MutList.empty(r$36682);
            MutList.forEach(
                e$36697 ->
                    if (f$36669(e$36697)) {
                        MutList.push!(e$36697, l$36693)
                    } else {
                        ()
                    },
                v$36679
            );
            match l$36693 {
                case MutList.MutList(_, a2$36709, l2$36711) =>
                    Ref.put(deref a2$36709, a1$36688);
                    Ref.put(deref l2$36711, l1$36691)
            }
    }
}

def MutList.reverse!(v$36793: MutList[a, r]): Unit \ r = {
    match v$36793 {
        case MutList.MutList(_, ra$36803, rl$36805) =>
            let a$36807: Array[a, r] = deref ra$36803;
            let l$36811: Int32 = deref rl$36805;
            let halflen$36813: Int32 = <[unknown exp]>(l$36811, 2i32);
            letrec loop$36819: (Int32 -> Int32 -> Unit \ r) = i$36821 ->
                j$36823 ->
                    if (<[unknown exp]>(i$36821, halflen$36813)) {
                        ()
                    } else {
                        let x$36827: a = Array.get(i$36821, a$36807);
                        let y$36829: a = Array.get(j$36823, a$36807);
                        Array.put(y$36829, i$36821, a$36807);
                        Array.put(x$36827, j$36823, a$36807);
                        loop$36819(
                            <[unknown exp]>(i$36821, 1i32)
                        )(<[unknown exp]>(j$36823, 1i32))
                    };
            loop$36819(0i32)(<[unknown exp]>(l$36811, 1i32))
    }
}

def MutList.sameElements(
    v1$37218: MutList[a, r1],
    v2$37220: MutList[a, r2]
): Bool \ r1 + r2 = {
    match v1$37218 {
        case MutList.MutList(_, ra1$37226, rl1$37228) =>
            match v2$37220 {
                case MutList.MutList(_, ra2$37232, rl2$37234) =>
                    let a1$37236: Array[a, r1] = deref ra1$37226;
                    let a2$37240: Array[a, r2] = deref ra2$37232;
                    let l1$37242: Int32 = deref rl1$37228;
                    let l2$37244: Int32 = deref rl2$37234;
                    letrec loop$37246: (Int32 -> Bool) = i$37248 ->
                        if (<[unknown exp]>(i$37248, l1$37242)) {
                            true
                        } else {
                            if (
                                <[unknown exp]>(
                                    Array.get(i$37248, a1$37236),
                                    Array.get(i$37248, a2$37240)
                                )
                            ) {
                                loop$37246(<[unknown exp]>(i$37248, 1i32))
                            } else {
                                false
                            }
                        };
                    if (<[unknown exp]>(l1$37242, l2$37244)) {
                        loop$37246(0i32)
                    } else {
                        false
                    }
            }
    }
}

def MutList.scan(
    rc1$34994: Region[r1],
    f$34996: b -> a -> b \ ef,
    s$34998: b,
    v$35000: MutList[a, r2]
): MutList[b, r1] \ ef + r2 + r1 = {
    MutList.scanLeft(rc1$34994, f$34996, s$34998, v$35000)
}

def MutList.scanLeft(
    rc1$35037: Region[r1],
    f$35039: b -> a -> b \ ef,
    s$35047: b,
    v$35050: MutList[a, r2]
): MutList[b, r1] \ ef + r2 + r1 = {
    match v$35050 {
        case MutList.MutList(_, ra$35059, rl$35061) =>
            let a$35063: Array[a, r2] = deref ra$35059;
            let l$35067: Int32 = deref rl$35061;
            let n$35069: Int32 = <[unknown exp]>(l$35067, 1i32);
            let b$35071: Array[b, r1] = Array.repeat(
                rc1$35037,
                n$35069,
                s$35047
            );
            letrec loop$35073: (
                Int32 -> b -> Unit \ ef + r2 + r1 + r1 + ef + r2
            ) = i$35075 ->
                acc$35077 ->
                    if (<[unknown exp]>(i$35075, n$35069)) {
                        ()
                    } else {
                        let s1$35079: b = f$35039(
                            acc$35077
                        )(Array.get(<[unknown exp]>(i$35075, 1i32), a$35063));
                        Array.put(s1$35079, i$35075, b$35071);
                        loop$35073(<[unknown exp]>(i$35075, 1i32))(s1$35079)
                    };
            loop$35073(1i32)(s$35047);
            MutList.MutList(
                rc1$35037,
                (ref b$35071) @ rc1$35037,
                (ref n$35069) @ rc1$35037
            )
    }
}

def MutList.scanRight(
    rc1$35117: Region[r1],
    f$35119: a -> b -> b \ ef,
    s$35121: b,
    v$35123: MutList[a, r2]
): MutList[b, r1] \ ef + r2 + r1 = {
    match v$35123 {
        case MutList.MutList(_, ra$35130, rl$35134) =>
            let a$35138: Array[a, r2] = deref ra$35130;
            let l$35142: Int32 = deref rl$35134;
            let n$35147: Int32 = <[unknown exp]>(l$35142, 1i32);
            let b$35155: Array[b, r1] = Array.repeat(
                rc1$35117,
                n$35147,
                s$35121
            );
            letrec loop$35157: (
                Int32 -> b -> Unit \ ef + r2 + r1 + r1 + ef + r2
            ) = i$35159 ->
                acc$35161 ->
                    if (<[unknown exp]>(i$35159, 0i32)) {
                        ()
                    } else {
                        let s1$35176: b = f$35119(
                            Array.get(i$35159, a$35138)
                        )(acc$35161);
                        Array.put(s1$35176, i$35159, b$35155);
                        loop$35157(<[unknown exp]>(i$35159, 1i32))(s1$35176)
                    };
            loop$35157(<[unknown exp]>(l$35142, 1i32))(s$35121);
            MutList.MutList(
                rc1$35117,
                (ref b$35155) @ rc1$35117,
                (ref n$35147) @ rc1$35117
            )
    }
}

def MutList.shrink!(v$36951: MutList[a, r]): Unit \ r = {
    MutList.shrinkTo!(MutList.length(v$36951), v$36951)
}

def MutList.shrinkTo!(n$36890: Int32, v$36892: MutList[a, r]): Unit \ r = {
    let minCap$36894: Int32 = MutList.minCapacity(());
    let capv$36896: Int32 = MutList.capacity(v$36892);
    match v$36892 {
        case MutList.MutList(r$36898, a$36900, l$36902) =>
            if (
                <[unknown exp]>(
                    n$36890,
                    capv$36896
                ) and <[unknown exp]>(capv$36896, minCap$36894)
            ) {
                let len$36904: Int32 = deref l$36902;
                let newCap$36910: Int32 = <[unknown exp]>(
                    n$36890,
                    minCap$36894
                );
                Ref.put(
                    Array.copyOfRange(
                        r$36898,
                        0i32,
                        newCap$36910,
                        deref a$36900
                    ),
                    a$36900
                );
                Ref.put(<[unknown exp]>(len$36904, newCap$36910), l$36902)
            } else {
                ()
            }
    }
}

def MutList.shuffle(
    rc1$37802: Region[r1],
    rnd$37804: Random,
    v$37806: MutList[a, r1]
): MutList[a, r1] \ r1 + IO = {
    region rc2$37808 {
        |>(
            !>(
                MutList.toArray(rc2$37808, v$37806),
                (
                    $0$46680 ->
                        $1$46682 ->
                            Array.shuffle($0$46680, $1$46682)
                )(rnd$37804)
            ),
            (
                $0$46686 ->
                    $1$46688 ->
                        Array.toMutList($0$46686, $1$46688)
            )(rc1$37802)
        )
    }
}

def MutList.sort(
    rc1$37582: Region[r1],
    v$37587: MutList[a, r]
): MutList[a, r1] \ r + r1 = {
    MutList.sortWith(
        rc1$37582,
        $0$46640 ->
            $1$46642 ->
                <[unknown exp]>($0$46640, $1$46642),
        v$37587
    )
}

def MutList.sort!(v$37688: MutList[a, r]): Unit \ r = {
    MutList.sortWith!(
        $0$46658 ->
            $1$46660 ->
                <[unknown exp]>($0$46658, $1$46660),
        v$37688
    )
}

def MutList.sortBy(
    rc1$37602: Region[r1],
    f$37604: a -> b,
    v$37607: MutList[a, r]
): MutList[a, r1] \ r + r1 = {
    MutList.sortWith(
        rc1$37602,
        (
            $0$46644 ->
                $1$46646 ->
                    $2$46648 ->
                        $3$46650 ->
                            on($0$46644, $1$46646, $2$46648, $3$46650)
        )($0$46652 -> $1$46654 -> <[unknown exp]>($0$46652, $1$46654))(f$37604),
        v$37607
    )
}

def MutList.sortBy!(f$37722: a -> b, v$37731: MutList[a, r]): Unit \ r = {
    MutList.sortWith!(
        (
            $0$46662 ->
                $1$46664 ->
                    $2$46666 ->
                        $3$46668 ->
                            on($0$46662, $1$46664, $2$46666, $3$46668)
        )($0$46670 -> $1$46672 -> <[unknown exp]>($0$46670, $1$46672))(f$37722),
        v$37731
    )
}

def MutList.sortWith(
    rc1$37629: Region[r1],
    cmp$37631: a -> a -> Comparison,
    v$37634: MutList[a, r]
): MutList[a, r1] \ r + r1 = {
    let vCopy$37655: MutList[a, r1] = MutList.copy(rc1$37629, v$37634);
    MutList.sortWith!(cmp$37631, vCopy$37655);
    vCopy$37655
}

def MutList.sortWith!(
    cmp$37760: a -> a -> Comparison,
    v$37773: MutList[a, r]
): Unit \ r = {
    match v$37773 {
        case MutList.MutList(_, a$37777, l$37779) =>
            Array.sortWithin!(
                cmp$37760,
                0i32,
                <[unknown exp]>(deref l$37779, 1i32),
                deref a$37777
            )
    }
}

def MutList.sum(v$33256: MutList[Int32, r]): Int32 \ r = {
    MutList.foldLeft(
        acc$33682 ->
            x$33684 ->
                <[unknown exp]>(acc$33682, x$33684),
        0i32,
        v$33256
    )
}

def MutList.sumWith(
    f$34148: a -> Int32,
    v$34154: MutList[a, r]
): Int32 \ ef + r = {
    MutList.foldLeft(
        acc$34160 ->
            x$34228 ->
                <[unknown exp]>(acc$34160, f$34148(x$34228)),
        0i32,
        v$34154
    )
}

def MutList.toArray(
    rc1$37083: Region[r1],
    v$37087: MutList[a, r2]
): Array[a, r1] \ r2 + r1 = {
    match v$37087 {
        case MutList.MutList(_, a$37102, l$37104) =>
            Array.copyOfRange(rc1$37083, 0i32, deref l$37104, deref a$37102)
    }
}

def MutList.toChain(xs$37162: MutList[a, r]): Chain[a] \ r = {
    MutList.foldLeft(
        ac$37165 ->
            x$37171 ->
                Chain.snoc(ac$37165, x$37171),
        Chain.empty(()),
        xs$37162
    )
}

def MutList.toList(v$37052: MutList[a, r]): List[a] \ r = {
    MutList.foldRight(
        x$37058 ->
            acc$37060 ->
                List.Cons(x$37058, acc$37060),
        List.Nil,
        v$37052
    )
}

def MutList.toMutDeque(
    rc1$37184: Region[r1],
    v$37186: MutList[a, r2]
): MutDeque[a, r1] \ r2 + r1 = {
    let d$37188: MutDeque[a, r1] = MutDeque.empty(rc1$37184);
    MutList.forEach(x$37192 -> MutDeque.pushBack(x$37192, d$37188), v$37186);
    d$37188
}

def MutList.toString(l$32580: MutList[a, r]): String \ r = {
    region rc2$32585 {
        let sb$32588: StringBuilder[rc2] = StringBuilder.empty(rc2$32585);
        StringBuilder.appendString!("""MutList#{""", sb$32588);
        MutList.forEachWithIndex(
            i$32590 ->
                x$32592 ->
                    if (<[unknown exp]>(i$32590, 1i32)) {
                        StringBuilder.appendString!(
                            """""" + <[unknown exp]>(x$32592),
                            sb$32588
                        )
                    } else {
                        StringBuilder.appendString!(
                            ("""""" + """, """) + <[unknown exp]>(x$32592),
                            sb$32588
                        )
                    },
            l$32580
        );
        StringBuilder.appendString!("""}""", sb$32588);
        StringBuilder.toString(sb$32588)
    }
}

def MutList.toVector(xs$37121: MutList[a, r]): Vector[a] \ r = {
    region rc$37133 {
        let arr$37136: Array[a, rc] = Array.empty(
            rc$37133,
            MutList.length(xs$37121)
        );
        MutList.forEachWithIndex(
            i$37138 ->
                x$37140 ->
                    Array.put(x$37140, i$37138, arr$37136),
            xs$37121
        );
        Array.toVector(arr$37136)
    }
}

def MutList.transform!(f$35445: a -> a, v$35453: MutList[a, r]): Unit \ r = {
    match v$35453 {
        case MutList.MutList(_, ra$35460, rl$35463) =>
            let a$35467: Array[a, r] = deref ra$35460;
            let l$35471: Int32 = deref rl$35463;
            letrec loop$35473: (Int32 -> Unit) = i$35477 ->
                if (<[unknown exp]>(i$35477, l$35471)) {
                    ()
                } else {
                    Array.put(
                        f$35445(Array.get(i$35477, a$35467)),
                        i$35477,
                        a$35467
                    );
                    loop$35473(<[unknown exp]>(i$35477, 1i32))
                };
            loop$35473(0i32)
    }
}

def MutList.transformWithIndex!(
    f$35513: Int32 -> a -> a,
    v$35518: MutList[a, r]
): Unit \ r = {
    match v$35518 {
        case MutList.MutList(_, ra$35532, rl$35534) =>
            let a$35536: Array[a, r] = deref ra$35532;
            let l$35538: Int32 = deref rl$35534;
            letrec loop$35540: (Int32 -> Unit) = i$35542 ->
                if (<[unknown exp]>(i$35542, l$35538)) {
                    ()
                } else {
                    Array.put(
                        f$35513(i$35542)(Array.get(i$35542, a$35536)),
                        i$35542,
                        a$35536
                    );
                    loop$35540(<[unknown exp]>(i$35542, 1i32))
                };
            loop$35540(0i32)
    }
}

def MutList.truncate!(l$36983: Int32, v$36985: MutList[a, r]): Unit \ r = {
    if (<[unknown exp]>(l$36983, 0i32)) {
        MutList.clear!(v$36985)
    } else {
        if (<[unknown exp]>(l$36983, MutList.length(v$36985))) {
            match v$36985 {
                case MutList.MutList(r$36987, a$36989, l0$36991) =>
                    let minCap$36993: Int32 = MutList.minCapacity(());
                    let c$36995: Int32 = <[unknown exp]>(l$36983, minCap$36993);
                    Ref.put(l$36983, l0$36991);
                    Array.updateSequence!(
                        0i32,
                        deref a$36989,
                        Array.empty(r$36987, c$36995)
                    )
            }
        } else {
            ()
        }
    }
}

enum MutMap[k, v, r] {case MutMap(Region[r], Ref[Map[k, v], r])}

def MutMap.adjust!(
    f$34622: v -> v,
    k$34624: k,
    m$34626: MutMap[k, v, r]
): Unit \ ef + r = {
    MutMap.adjustWithKey!(
        _$34671 ->
            v1$34673 ->
                f$34622(v1$34673),
        k$34624,
        m$34626
    )
}

def MutMap.adjustWithKey!(
    f$34714: k -> v -> v \ ef,
    k$34720: k,
    m$34722: MutMap[k, v, r]
): Unit \ ef + r = {
    match m$34722 {
        case MutMap.MutMap(_, mm$34747) =>
            Ref.put(
                Map.adjustWithKey(f$34714, k$34720, deref mm$34747),
                mm$34747
            )
    }
}

def MutMap.clear!(m$34773: MutMap[k, v, r]): Unit \ r = {
    match m$34773 {
        case MutMap.MutMap(_, mm$34789) =>
            Ref.put(Map.empty(()), mm$34789)
    }
}

def MutMap.copy(
    rc$36695: Region[r1],
    m$36700: MutMap[k, v, r]
): MutMap[k, v, r1] \ r + r1 = {
    match m$36700 {
        case MutMap.MutMap(_, mm$36713) =>
            MutMap.MutMap(rc$36695, (ref (deref mm$36713)) @ rc$36695)
    }
}

def MutMap.count(
    f$36333: k -> v -> Bool \ ef,
    m$36341: MutMap[k, v, r]
): Int32 \ ef + r = {
    match m$36341 {
        case MutMap.MutMap(_, mm$36345) =>
            Map.count(f$36333, deref mm$36345)
    }
}

def MutMap.empty(rc$33754: Region[r]): MutMap[k, v, r] \ r = {
    MutMap.MutMap(rc$33754, (ref Map.empty(())) @ rc$33754)
}

def MutMap.exists(
    f$36554: k -> v -> Bool \ ef,
    m$36564: MutMap[k, v, r]
): Bool \ ef + r = {
    match m$36564 {
        case MutMap.MutMap(_, mm$36609) =>
            Map.exists(f$36554, deref mm$36609)
    }
}

def MutMap.find(
    f$35361: k -> v -> Bool,
    m$35363: MutMap[k, v, r]
): Option[(k, v)] \ r = {
    MutMap.findLeft(f$35361, m$35363)
}

def MutMap.findLeft(
    f$35402: k -> v -> Bool,
    m$35420: MutMap[k, v, r]
): Option[(k, v)] \ r = {
    match m$35420 {
        case MutMap.MutMap(_, mm$35422) =>
            Map.findLeft(f$35402, deref mm$35422)
    }
}

def MutMap.findRight(
    f$35437: k -> v -> Bool,
    m$35455: MutMap[k, v, r]
): Option[(k, v)] \ r = {
    match m$35455 {
        case MutMap.MutMap(_, mm$35459) =>
            Map.findRight(f$35437, deref mm$35459)
    }
}

def MutMap.foldLeft(
    f$35712: b -> v -> b \ ef,
    i$35716: b,
    m$35718: MutMap[k, v, r]
): b \ ef + r = {
    match m$35718 {
        case MutMap.MutMap(_, mm$35736) =>
            Map.foldLeft(f$35712, i$35716, deref mm$35736)
    }
}

def MutMap.foldLeftWithKey(
    f$35788: b -> k -> (v -> b \ ef),
    i$35819: b,
    m$35821: MutMap[k, v, r]
): b \ ef + r = {
    match m$35821 {
        case MutMap.MutMap(_, mm$35832) =>
            Map.foldLeftWithKey(f$35788, i$35819, deref mm$35832)
    }
}

def MutMap.foldRight(
    f$35889: v -> b -> b \ ef,
    s$35899: b,
    m$35902: MutMap[k, v, r]
): b \ ef + r = {
    MutMap.foldRightWithKey(
        _$35906 ->
            v$35908 ->
                b$35911 ->
                    f$35889(v$35908)(b$35911),
        s$35899,
        m$35902
    )
}

def MutMap.foldRightWithCont(
    f$36049: v -> (Unit -> b \ ef) -> b \ ef,
    z$36058: b,
    m$36062: MutMap[k, v, r]
): b \ ef + r = {
    MutMap.foldRightWithKeyCont(
        _$36069 ->
            v$36078 ->
                b$36088 ->
                    f$36049(v$36078)(b$36088),
        z$36058,
        m$36062
    )
}

def MutMap.foldRightWithKey(
    f$35964: k -> v -> (b -> b \ ef),
    s$35981: b,
    m$35989: MutMap[k, v, r]
): b \ ef + r = {
    match m$35989 {
        case MutMap.MutMap(_, mm$36023) =>
            Map.foldRightWithKey(f$35964, s$35981, deref mm$36023)
    }
}

def MutMap.foldRightWithKeyCont(
    f$36124: k -> v -> ((Unit -> b \ ef) -> b \ ef),
    z$36128: b,
    m$36133: MutMap[k, v, r]
): b \ ef + r = {
    match m$36133 {
        case MutMap.MutMap(_, mm$36168) =>
            Map.foldRightWithKeyCont(f$36124, z$36128, deref mm$36168)
    }
}

def MutMap.foldWithKey(
    f$35670: b -> k -> (v -> b \ ef),
    i$35674: b,
    m$35676: MutMap[k, v, r]
): b \ ef + r = {
    MutMap.foldLeftWithKey(f$35670, i$35674, m$35676)
}

def MutMap.forAll(
    f$36648: k -> v -> Bool \ ef,
    m$36656: MutMap[k, v, r]
): Bool \ ef + r = {
    match m$36656 {
        case MutMap.MutMap(_, mm$36660) =>
            Map.forAll(f$36648, deref mm$36660)
    }
}

def MutMap.forEach(
    f$37041: k -> v -> Unit \ ef,
    m$37043: MutMap[k, v, r]
): Unit \ ef + r = {
    match m$37043 {
        case MutMap.MutMap(_, mm$37048) =>
            Map.forEach(f$37041, deref mm$37048)
    }
}

def MutMap.forEachWithIndex(
    f$37074: Int32 -> k -> (v -> Unit \ ef),
    m$37078: MutMap[k, v, r]
): Unit \ ef + r = {
    region rc$37097 {
        let ix$37100: Ref[Int32, rc] = (ref 0i32) @ rc$37097;
        MutMap.forEach(
            k$37106 ->
                v$37108 ->
                    {
                        let i$37110: Int32 = deref ix$37100;
                        f$37074(i$37110)(k$37106)(v$37108);
                        Ref.put(<[unknown exp]>(i$37110, 1i32), ix$37100)
                    },
            m$37078
        )
    }
}

def MutMap.get(k$34339: k, m$34341: MutMap[k, v, r]): Option[v] \ r = {
    match m$34341 {
        case MutMap.MutMap(_, mm$34351) =>
            Map.get(k$34339, deref mm$34351)
    }
}

def MutMap.getOrElsePut!(
    k$34823: k,
    d$34829: v,
    m$34831: MutMap[k, v, r]
): v \ r = {
    match m$34831 {
        case MutMap.MutMap(_, mm$34846) =>
            match Map.get(k$34823, deref mm$34846) {
                case Option.None =>
                    Ref.put(
                        Map.insert(k$34823, d$34829, deref mm$34846),
                        mm$34846
                    );
                    d$34829
                case Option.Some(v$34851) =>
                    v$34851
            }
    }
}

def MutMap.getWithDefault(
    k$34405: k,
    d$34411: v,
    m$34413: MutMap[k, v, r]
): v \ r = {
    match m$34413 {
        case MutMap.MutMap(_, mm$34420) =>
            Map.getWithDefault(k$34405, d$34411, deref mm$34420)
    }
}

def MutMap.isEmpty(m$33878: MutMap[k, v, r]): Bool \ r = {
    match m$33878 {
        case MutMap.MutMap(_, mm$33888) =>
            Map.isEmpty(deref mm$33888)
    }
}

def MutMap.isProperSubmapOf(
    m1$35318: MutMap[k, v, r1],
    m2$35320: MutMap[k, v, r2]
): Bool \ r1 + r2 = {
    match m1$35318 {
        case MutMap.MutMap(_, mm1$35323) =>
            match m2$35320 {
                case MutMap.MutMap(_, mm2$35326) =>
                    Map.isProperSubmapOf(deref mm1$35323, deref mm2$35326)
            }
    }
}

def MutMap.isSubmapOf(
    m1$35264: MutMap[k, v, r1],
    m2$35267: MutMap[k, v, r2]
): Bool \ r1 + r2 = {
    match m1$35264 {
        case MutMap.MutMap(_, mm1$35281) =>
            match m2$35267 {
                case MutMap.MutMap(_, mm2$35283) =>
                    Map.isSubmapOf(deref mm1$35281, deref mm2$35283)
            }
    }
}

def MutMap.iterator(
    rc$37129: Region[r1],
    m$37131: MutMap[k, v, r2]
): Iterator[(k, v), r1 + r2, r1] \ r1 + r2 = {
    match m$37131 {
        case MutMap.MutMap(_, mm$37146) =>
            |>(
                Map.iterator(rc$37129, deref mm$37146),
                (
                    $0$46713 ->
                        $1$46715 ->
                            Iterator.map($0$46713, $1$46715)
                )(x$37152 -> {discard (deref mm$37146); x$37152})
            )
    }
}

def MutMap.iteratorKeys(
    rc$37173: Region[r1],
    m$37175: MutMap[k, v, r2]
): Iterator[k, r1 + r2, r1] \ r1 + r2 = {
    match m$37175 {
        case MutMap.MutMap(_, mm$37177) =>
            |>(
                Map.iteratorKeys(rc$37173, deref mm$37177),
                (
                    $0$46718 ->
                        $1$46720 ->
                            Iterator.map($0$46718, $1$46720)
                )(x$37179 -> {discard (deref mm$37177); x$37179})
            )
    }
}

def MutMap.iteratorValues(
    rc$37200: Region[r1],
    m$37202: MutMap[k, v, r2]
): Iterator[v, r1 + r2, r1] \ r1 + r2 = {
    match m$37202 {
        case MutMap.MutMap(_, mm$37207) =>
            |>(
                Map.iteratorValues(rc$37200, deref mm$37207),
                (
                    $0$46723 ->
                        $1$46725 ->
                            Iterator.map($0$46723, $1$46725)
                )(x$37213 -> {discard (deref mm$37207); x$37213})
            )
    }
}

def MutMap.joinKeys(sep$37424: String, m$37430: MutMap[k, v, r]): String \ r = {
    match m$37430 {
        case MutMap.MutMap(_, mm$37434) =>
            Map.joinKeys(sep$37424, deref mm$37434)
    }
}

def MutMap.joinValues(
    sep$37481: String,
    m$37486: MutMap[k, v, r]
): String \ r = {
    match m$37486 {
        case MutMap.MutMap(_, mm$37523) =>
            Map.joinValues(sep$37481, deref mm$37523)
    }
}

def MutMap.joinWith(
    f$37586: k -> v -> String \ ef,
    sep$37658: String,
    m$37660: MutMap[k, v, r]
): String \ ef + r = {
    match m$37660 {
        case MutMap.MutMap(_, mm$37670) =>
            Map.joinWith(f$37586, sep$37658, deref mm$37670)
    }
}

def MutMap.keysOf(m$34198: MutMap[k, v, r]): Set[k] \ r = {
    match m$34198 {
        case MutMap.MutMap(_, mm$34225) =>
            Map.keysOf(deref mm$34225)
    }
}

def MutMap.map(
    rc1$35503: Region[r1],
    f$35507: v1 -> v2,
    m$35515: MutMap[k, v1, r]
): MutMap[k, v2, r1] \ ef + r + r1 = {
    MutMap.mapWithKey(rc1$35503, _$35530 -> f$35507, m$35515)
}

def MutMap.mapWithKey(
    rc$35573: Region[r1],
    f$35575: k -> v1 -> v2 \ ef,
    m$35579: MutMap[k, v1, r]
): MutMap[k, v2, r1] \ ef + r + r1 = {
    match m$35579 {
        case MutMap.MutMap(_, mm$35589) =>
            MutMap.MutMap(
                rc$35573,
                (ref Map.mapWithKey(f$35575, deref mm$35589)) @ rc$35573
            )
    }
}

def MutMap.maximumKey(m$34030: MutMap[k, v, r]): Option[(k, v)] \ r = {
    match m$34030 {
        case MutMap.MutMap(_, mm$34034) =>
            Map.maximumKey(deref mm$34034)
    }
}

def MutMap.maximumKeyBy(
    cmp$34054: k -> k -> Comparison \ ef,
    m$34056: MutMap[k, v, r]
): Option[(k, v)] \ ef + r = {
    match m$34056 {
        case MutMap.MutMap(_, mm$34069) =>
            Map.maximumKeyBy(cmp$34054, deref mm$34069)
    }
}

def MutMap.maximumValue(m$34084: MutMap[k, v, r]): Option[(k, v)] \ r = {
    match m$34084 {
        case MutMap.MutMap(_, mm$34094) =>
            Map.maximumValue(deref mm$34094)
    }
}

def MutMap.maximumValueBy(
    cmp$34115: v -> v -> Comparison \ ef,
    m$34123: MutMap[k, v, r]
): Option[(k, v)] \ ef + r = {
    match m$34123 {
        case MutMap.MutMap(_, mm$34156) =>
            Map.maximumValueBy(cmp$34115, deref mm$34156)
    }
}

def MutMap.memberOf(k$33847: k, m$33849: MutMap[k, v, r]): Bool \ r = {
    match m$33849 {
        case MutMap.MutMap(_, mm$33859) =>
            Map.memberOf(k$33847, deref mm$33859)
    }
}

def MutMap.merge!(
    m1$34885: MutMap[k, v, r1],
    m2$34891: MutMap[k, v, r2]
): Unit \ r1 + r2 = {
    MutMap.mergeWithKey!(
        _$34895 ->
            v1$34898 ->
                _$34900 ->
                    v1$34898,
        m1$34885,
        m2$34891
    )
}

def MutMap.mergeWith!(
    f$34919: v -> v -> v \ ef,
    m1$34925: MutMap[k, v, r1],
    m2$34929: MutMap[k, v, r2]
): Unit \ ef + r1 + r2 = {
    MutMap.mergeWithKey!(_$34943 -> f$34919, m1$34925, m2$34929)
}

def MutMap.mergeWithKey!(
    f$34972: k -> v -> (v -> v \ ef),
    m1$34983: MutMap[k, v, r1],
    m2$34988: MutMap[k, v, r2]
): Unit \ ef + r1 + r2 = {
    match m1$34983 {
        case MutMap.MutMap(_, mm1$35002) =>
            match m2$34988 {
                case MutMap.MutMap(_, mm2$35004) =>
                    Ref.put(
                        Map.unionWithKey(
                            f$34972,
                            deref mm1$35002,
                            deref mm2$35004
                        ),
                        mm2$35004
                    )
            }
    }
}

def MutMap.minimumKey(m$33929: MutMap[k, v, r]): Option[(k, v)] \ r = {
    match m$33929 {
        case MutMap.MutMap(_, mm$33938) =>
            Map.minimumKey(deref mm$33938)
    }
}

def MutMap.minimumKeyBy(
    cmp$33957: k -> k -> Comparison \ ef,
    m$33959: MutMap[k, v, r]
): Option[(k, v)] \ ef + r = {
    match m$33959 {
        case MutMap.MutMap(_, mm$33962) =>
            Map.minimumKeyBy(cmp$33957, deref mm$33962)
    }
}

def MutMap.minimumValue(m$33983: MutMap[k, v, r]): Option[(k, v)] \ r = {
    match m$33983 {
        case MutMap.MutMap(_, mm$33989) =>
            Map.minimumValue(deref mm$33989)
    }
}

def MutMap.minimumValueBy(
    cmp$34010: v -> v -> Comparison \ ef,
    m$34016: MutMap[k, v, r]
): Option[(k, v)] \ ef + r = {
    match m$34016 {
        case MutMap.MutMap(_, mm$34021) =>
            Map.minimumValueBy(cmp$34010, deref mm$34021)
    }
}

def MutMap.nonEmpty(m$33911: MutMap[k, v, r]): Bool \ r = {
    !MutMap.isEmpty(m$33911)
}

def MutMap.put!(k$34466: k, v$34469: v, m$34471: MutMap[k, v, r]): Unit \ r = {
    match m$34471 {
        case MutMap.MutMap(_, mm$34480) =>
            Ref.put(Map.insert(k$34466, v$34469, deref mm$34480), mm$34480)
    }
}

def MutMap.putWith!(
    f$34541: v -> v -> v \ ef,
    k$34543: k,
    v$34545: v,
    m$34547: MutMap[k, v, r]
): Unit \ ef + r = {
    match m$34547 {
        case MutMap.MutMap(_, mm$34570) =>
            Ref.put(
                Map.insertWith(f$34541, k$34543, v$34545, deref mm$34570),
                mm$34570
            )
    }
}

def MutMap.rangeQuery(
    p$37259: k -> Comparison,
    m$37262: MutMap[k, v, r]
): List[(k, v)] \ ef + r = {
    match m$37262 {
        case MutMap.MutMap(_, mm$37273) =>
            Map.rangeQuery(p$37259, deref mm$37273)
    }
}

def MutMap.rangeQueryWith(
    p$37299: k -> Comparison,
    f$37306: k -> v -> Unit \ ef2,
    m$37314: MutMap[k, v, r]
): Unit \ ef1 + ef2 + r = {
    match m$37314 {
        case MutMap.MutMap(_, mm$37324) =>
            Map.rangeQueryWith(p$37299, f$37306, deref mm$37324)
    }
}

def MutMap.reduceLeft(
    f$36207: v -> v -> v \ ef,
    m$36209: MutMap[k, v, r]
): Option[v] \ ef + r = {
    match m$36209 {
        case MutMap.MutMap(_, mm$36218) =>
            Map.reduceLeft(f$36207, deref mm$36218)
    }
}

def MutMap.reduceLeftWithKey(
    f$36260: k -> v -> (k -> (v -> (k, v) \ ef)),
    m$36268: MutMap[k, v, r]
): Option[(k, v)] \ ef + r = {
    match m$36268 {
        case MutMap.MutMap(_, mm$36281) =>
            Map.reduceLeftWithKey(f$36260, deref mm$36281)
    }
}

def MutMap.reduceRight(
    f$36295: v -> v -> v \ ef,
    m$36303: MutMap[k, v, r]
): Option[v] \ ef + r = {
    match m$36303 {
        case MutMap.MutMap(_, mm$36305) =>
            Map.reduceRight(f$36295, deref mm$36305)
    }
}

def MutMap.reduceRightWithKey(
    f$36317: k -> v -> (k -> (v -> (k, v) \ ef)),
    m$36319: MutMap[k, v, r]
): Option[(k, v)] \ ef + r = {
    match m$36319 {
        case MutMap.MutMap(_, mm$36321) =>
            Map.reduceRightWithKey(f$36317, deref mm$36321)
    }
}

def MutMap.refine!(f$35033: v -> Bool, m$35041: MutMap[k, v, r]): Unit \ r = {
    MutMap.refineWithKey!(_$35057 -> f$35033, m$35041)
}

def MutMap.refineWithKey!(
    f$35087: k -> v -> Bool,
    m$35097: MutMap[k, v, r]
): Unit \ r = {
    match m$35097 {
        case MutMap.MutMap(_, mm$35103) =>
            Ref.put(Map.filterWithKey(f$35087, deref mm$35103), mm$35103)
    }
}

def MutMap.remove!(k$35131: k, m$35140: MutMap[k, v, r]): Unit \ r = {
    match m$35140 {
        case MutMap.MutMap(_, mm$35167) =>
            Ref.put(Map.remove(k$35131, deref mm$35167), mm$35167)
    }
}

def MutMap.sameElements(
    a$37361: MutMap[k, v, r1],
    b$37363: MutMap[k, v, r2]
): Bool \ r1 + r2 = {
    MutMap.isSubmapOf(a$37361, b$37363) and MutMap.isSubmapOf(b$37363, a$37361)
}

def MutMap.singleton(
    rc$33822: Region[r],
    k$33826: k,
    v$33828: v
): MutMap[k, v, r] \ r = {
    MutMap.MutMap(rc$33822, (ref Map.singleton(k$33826, v$33828)) @ rc$33822)
}

def MutMap.size(m$34306: MutMap[k, v, r]): Int32 \ r = {
    match m$34306 {case MutMap.MutMap(_, mm$34312) => Map.size(deref mm$34312)}
}

def MutMap.sumKeys(m$36391: MutMap[Int32, v, r]): Int32 \ r = {
    match m$36391 {
        case MutMap.MutMap(_, mm$36407) =>
            Map.sumKeys(deref mm$36407)
    }
}

def MutMap.sumValues(m$36459: MutMap[k, Int32, r]): Int32 \ r = {
    match m$36459 {
        case MutMap.MutMap(_, mm$36474) =>
            Map.sumValues(deref mm$36474)
    }
}

def MutMap.sumWith(
    f$36507: k -> v -> Int32 \ ef,
    m$36521: MutMap[k, v, r]
): Int32 \ ef + r = {
    match m$36521 {
        case MutMap.MutMap(_, mm$36533) =>
            Map.sumWith(f$36507, deref mm$36533)
    }
}

def MutMap.toArray(
    rc1$36966: Region[r1],
    m$36968: MutMap[k, v, r]
): Array[(k, v), r1] \ r + r1 = {
    match m$36968 {
        case MutMap.MutMap(_, mm$36978) =>
            Map.toArray(rc1$36966, deref mm$36978)
    }
}

def MutMap.toList(m$36861: MutMap[k, v, r]): List[(k, v)] \ r = {
    match m$36861 {
        case MutMap.MutMap(_, mm$36883) =>
            Map.toList(deref mm$36883)
    }
}

def MutMap.toMap(m$36736: MutMap[k, v, r]): Map[k, v] \ r = {
    match m$36736 {case MutMap.MutMap(_, mm$36756) => deref mm$36756}
}

def MutMap.toMutDeque(
    rc1$36787: Region[r1],
    m$36789: MutMap[k, v, r2]
): MutDeque[(k, v), r1] \ r2 + r1 = {
    match m$36789 {
        case MutMap.MutMap(_, mm$36798) =>
            Map.toMutDeque(rc1$36787, deref mm$36798)
    }
}

def MutMap.toSet(m$37000: MutMap[k, v, r]): Set[(k, v)] \ r = {
    match m$37000 {case MutMap.MutMap(_, mm$37006) => Map.toSet(deref mm$37006)}
}

def MutMap.toString(m$33701: MutMap[k, v, r]): String \ r = {
    region rc$33708 {
        let sb$33711: StringBuilder[rc] = StringBuilder.empty(rc$33708);
        StringBuilder.appendString!("""MutMap#{""", sb$33711);
        MutMap.forEachWithIndex(
            i$33715 ->
                k$33718 ->
                    v$33721 ->
                        if (<[unknown exp]>(i$33715, 1i32)) {
                            StringBuilder.appendString!(
                                (
                                    (
                                        """""" + <[unknown exp]>(k$33718)
                                    ) + """ => """
                                ) + <[unknown exp]>(v$33721),
                                sb$33711
                            )
                        } else {
                            StringBuilder.appendString!(
                                (
                                    (
                                        (
                                            """""" + """, """
                                        ) + <[unknown exp]>(k$33718)
                                    ) + """ => """
                                ) + <[unknown exp]>(v$33721),
                                sb$33711
                            )
                        },
            m$33701
        );
        StringBuilder.appendString!("""}""", sb$33711);
        StringBuilder.toString(sb$33711)
    }
}

def MutMap.toVector(m$36920: MutMap[k, v, r]): Vector[(k, v)] \ r = {
    match m$36920 {
        case MutMap.MutMap(_, mm$36927) =>
            Map.toVector(deref mm$36927)
    }
}

def MutMap.transform!(
    f$35182: v -> v,
    m$35184: MutMap[k, v, r]
): Unit \ ef + r = {
    match m$35184 {
        case MutMap.MutMap(_, mm$35191) =>
            Ref.put(Map.map(f$35182, deref mm$35191), mm$35191)
    }
}

def MutMap.transformWithKey!(
    f$35222: k -> v -> v \ ef,
    m$35228: MutMap[k, v, r]
): Unit \ ef + r = {
    match m$35228 {
        case MutMap.MutMap(_, mm$35244) =>
            Ref.put(Map.mapWithKey(f$35222, deref mm$35244), mm$35244)
    }
}

def MutMap.valuesOf(m$34255: MutMap[k, v, r]): List[v] \ r = {
    match m$34255 {
        case MutMap.MutMap(_, mm$34273) =>
            Map.valuesOf(deref mm$34273)
    }
}

enum MutQueue[a, r] {
    case MutQueue(Region[r], Ref[Array[a, r], r], Ref[Int32, r])
}

def MutQueue.dequeue(mq$28157: MutQueue[a, r]): Option[a] \ r = {
    match mq$28157 {
        case MutQueue.MutQueue(_, arr$28164, s$28166) =>
            if (<[unknown exp]>(deref s$28166, 0i32)) {
                let top$28170: Option[a] = MutQueue.peek(mq$28157);
                Array.put(
                    Array.get(
                        <[unknown exp]>(deref s$28166, 1i32),
                        deref arr$28164
                    ),
                    0i32,
                    deref arr$28164
                );
                MutQueue.heapifyDown(0i32, mq$28157);
                Ref.put(<[unknown exp]>(deref s$28166, 1i32), s$28166);
                top$28170
            } else {
                Option.None
            }
    }
}

def MutQueue.empty(rc$27960: Region[r]): MutQueue[a, r] \ r = {
    MutQueue.MutQueue(
        rc$27960,
        (ref Array.empty(rc$27960, 8i32)) @ rc$27960,
        (ref 0i32) @ rc$27960
    )
}

def MutQueue.enqueue(mq$28122: MutQueue[a, r], x$28128: a): Unit \ r = {
    match mq$28122 {
        case MutQueue.MutQueue(_, arr$28130, s$28132) =>
            MutQueue.expand(mq$28122);
            Array.put(x$28128, deref s$28132, deref arr$28130);
            MutQueue.heapifyUp(deref s$28132, mq$28122);
            Ref.put(<[unknown exp]>(deref s$28132, 1i32), s$28132)
    }
}

def MutQueue.enqueueAll(
    mq$28195: MutQueue[elt, r],
    m$28199: m
): Unit \ r + Aef[m] = {
    region reg$101$28219 {
        Iterator.forEach(
            pat$102$28224 ->
                match pat$102$28224 {
                    case x$28226 =>
                        MutQueue.enqueue(mq$28195, x$28226)
                },
            <[unknown exp]>(reg$101$28219, m$28199)
        )
    }
}

def MutQueue.expand(mq$28762: MutQueue[a, r]): Unit \ r = {
    match mq$28762 {
        case MutQueue.MutQueue(reg$28768, arr$28770, s$28772) =>
            let oldCapacity$28774: Int32 = Array.length(deref arr$28770);
            if (<[unknown exp]>(oldCapacity$28774, deref s$28772)) {
                let newCapacity$28780: Int32 = <[unknown exp]>(
                    2i32,
                    <[unknown exp]>(oldCapacity$28774, 2i32)
                );
                let newArr$28784: Array[a, r] = Array.empty(
                    reg$28768,
                    newCapacity$28780
                );
                Array.forEachWithIndex(
                    idx$28788 ->
                        x$28790 ->
                            Array.put(x$28790, idx$28788, newArr$28784),
                    deref arr$28770
                );
                Ref.put(newArr$28784, arr$28770)
            } else {
                ()
            }
    }
}

def MutQueue.heapifyDown(
    idx$28537: Int32,
    mq$28541: MutQueue[a, r]
): Unit \ r = {
    match mq$28541 {
        case MutQueue.MutQueue(_, arr$28558, s$28560) =>
            let size$28566: Int32 = deref s$28560;
            let lChildIdx$28568: Int32 = <[unknown exp]>(
                <[unknown exp]>(idx$28537, 2i32),
                1i32
            );
            let rChildIdx$28570: Int32 = <[unknown exp]>(
                <[unknown exp]>(idx$28537, 2i32),
                2i32
            );
            let cur$28572: a = Array.get(idx$28537, deref arr$28558);
            if (<[unknown exp]>(size$28566, rChildIdx$28570)) {
                if (<[unknown exp]>(size$28566, rChildIdx$28570)) {
                    let child$28574: a = Array.get(
                        lChildIdx$28568,
                        deref arr$28558
                    );
                    if (<[unknown exp]>(cur$28572, child$28574)) {
                        Array.put(child$28574, idx$28537, deref arr$28558);
                        Array.put(cur$28572, lChildIdx$28568, deref arr$28558)
                    } else {
                        ()
                    }
                } else {
                    let lChild$28576: a = Array.get(
                        lChildIdx$28568,
                        deref arr$28558
                    );
                    let rChild$28578: a = Array.get(
                        rChildIdx$28570,
                        deref arr$28558
                    );
                    if (
                        <[unknown exp]>(
                            lChild$28576,
                            cur$28572
                        ) or <[unknown exp]>(rChild$28578, cur$28572)
                    ) {
                        if (<[unknown exp]>(lChild$28576, rChild$28578)) {
                            Array.put(
                                cur$28572,
                                lChildIdx$28568,
                                deref arr$28558
                            );
                            Array.put(lChild$28576, idx$28537, deref arr$28558);
                            MutQueue.heapifyDown(lChildIdx$28568, mq$28541)
                        } else {
                            Array.put(
                                cur$28572,
                                rChildIdx$28570,
                                deref arr$28558
                            );
                            Array.put(rChild$28578, idx$28537, deref arr$28558);
                            MutQueue.heapifyDown(rChildIdx$28570, mq$28541)
                        }
                    } else {
                        ()
                    }
                }
            } else {
                ()
            }
    }
}

def MutQueue.heapifyUp(idx$28473: Int32, mq$28475: MutQueue[a, r]): Unit \ r = {
    match mq$28475 {
        case MutQueue.MutQueue(_, arr$28495, _) =>
            if (<[unknown exp]>(idx$28473, 0i32)) {
                let parentIdx$28499: Int32 = <[unknown exp]>(
                    <[unknown exp]>(idx$28473, 1i32),
                    2i32
                );
                let cur$28501: a = Array.get(idx$28473, deref arr$28495);
                let parent$28505: a = Array.get(
                    parentIdx$28499,
                    deref arr$28495
                );
                if (<[unknown exp]>(cur$28501, parent$28505)) {
                    Array.put(parent$28505, idx$28473, deref arr$28495);
                    Array.put(cur$28501, parentIdx$28499, deref arr$28495);
                    MutQueue.heapifyUp(parentIdx$28499, mq$28475)
                } else {
                    ()
                }
            } else {
                ()
            }
    }
}

def MutQueue.isEmpty(mq$28032: MutQueue[a, r]): Bool \ r = {
    match mq$28032 {
        case MutQueue.MutQueue(_, _, s$28047) =>
            <[unknown exp]>(deref s$28047, 0i32)
    }
}

def MutQueue.iterator(
    rc$28255: Region[r1],
    mq$28263: MutQueue[a, r2]
): Iterator[a, r1 + r2, r1] \ r1 + r2 = {
    match mq$28263 {
        case MutQueue.MutQueue(_, arr$28277, s$28279) =>
            let it1$28281: Iterator[Int32, r1, r1] = Iterator.range(
                rc$28255,
                0i32,
                deref s$28279
            );
            Iterator.map(
                x$28287 ->
                    Array.get(x$28287, deref arr$28277),
                it1$28281
            )
    }
}

def MutQueue.nonEmpty(mq$28063: MutQueue[a, r]): Bool \ r = {
    !MutQueue.isEmpty(mq$28063)
}

def MutQueue.peek(mq$28088: MutQueue[a, r]): Option[a] \ r = {
    match mq$28088 {
        case MutQueue.MutQueue(_, arr$28098, s$28100) =>
            if (<[unknown exp]>(deref s$28100, 0i32)) {
                Option.None
            } else {
                Option.Some(Array.get(0i32, deref arr$28098))
            }
    }
}

def MutQueue.size(mq$28002: MutQueue[a, r]): Int32 \ r = {
    match mq$28002 {case MutQueue.MutQueue(_, _, s$28010) => deref s$28010}
}

def MutQueue.toArray(
    rc$28395: Region[r1],
    mq$28401: MutQueue[a, r2]
): Array[a, r1] \ r1 + r2 = {
    match mq$28401 {
        case MutQueue.MutQueue(_, arr$28408, s$28410) =>
            Array.takeLeft(rc$28395, deref s$28410, deref arr$28408)
    }
}

def MutQueue.toList(mq$28299: MutQueue[a, r]): List[a] \ r = {
    match mq$28299 {
        case MutQueue.MutQueue(_, arr$28319, s$28321) =>
            List.take(
                deref s$28321,
                Array.foldRight(
                    x$28327 ->
                        acc$28329 ->
                            List.Cons(x$28327, acc$28329),
                    List.Nil,
                    deref arr$28319
                )
            )
    }
}

def MutQueue.toNel(mq$28361: MutQueue[a, r]): Option[Nel[a]] \ r = {
    List.toNel(MutQueue.toList(mq$28361))
}

def MutQueue.toString(mq$27917: MutQueue[a, r]): String \ r = {
    region reg$27919 {
        match mq$27917 {
            case MutQueue.MutQueue(_, arr$27924, s$27926) =>
                let sb$27929: StringBuilder[reg] = StringBuilder.empty(
                    reg$27919
                );
                StringBuilder.appendString!("""MutQueue {""", sb$27929);
                Array.forEachWithIndex(
                    i$27932 ->
                        x$27934 ->
                            if (<[unknown exp]>(i$27932, deref s$27926)) {
                                if (<[unknown exp]>(i$27932, 0i32)) {
                                    StringBuilder.appendString!(
                                        """""" + <[unknown exp]>(x$27934),
                                        sb$27929
                                    )
                                } else {
                                    StringBuilder.appendString!(
                                        (
                                            """""" + """, """
                                        ) + <[unknown exp]>(x$27934),
                                        sb$27929
                                    )
                                }
                            } else {
                                ()
                            },
                    deref arr$27924
                );
                StringBuilder.appendString!("""}""", sb$27929);
                StringBuilder.toString(sb$27929)
        }
    }
}

def MutQueue.toVector(mq$28432: MutQueue[a, r]): Vector[a] \ r = {
    region rc$28444 {
        |>(
            MutQueue.toArray(rc$28444, mq$28432),
            $0$46429 ->
                Array.toVector($0$46429)
        )
    }
}

enum MutSet[t, r] {case MutSet(Region[r], Ref[Set[t], r])}

def MutSet.add!(x$12422: a, s$12429: MutSet[a, r]): Unit \ r = {
    match s$12429 {
        case MutSet.MutSet(_, ms$12440) =>
            Ref.put(Set.insert(x$12422, deref ms$12440), ms$12440)
    }
}

def MutSet.addAll!(m$12457: m[a], s$12461: MutSet[a, r]): Unit \ r = {
    <[unknown exp]>(x$12485 -> MutSet.add!(x$12485, s$12461), m$12457)
}

def MutSet.clear!(s$12537: MutSet[a, r]): Unit \ r = {
    match s$12537 {
        case MutSet.MutSet(_, ms$12549) =>
            Ref.put(Set.empty(()), ms$12549)
    }
}

def MutSet.copy(
    rc1$13669: Region[r1],
    s$13671: MutSet[a, r]
): MutSet[a, r1] \ r + r1 = {
    match s$13671 {
        case MutSet.MutSet(_, ms$13686) =>
            MutSet.MutSet(rc1$13669, (ref (deref ms$13686)) @ rc1$13669)
    }
}

def MutSet.count(f$13482: a -> Bool, s$13487: MutSet[a, r]): Int32 \ ef + r = {
    match s$13487 {
        case MutSet.MutSet(_, ms$13493) =>
            Set.count(f$13482, deref ms$13493)
    }
}

def MutSet.empty(rc$12393: Region[r]): MutSet[a, r] \ r = {
    MutSet.MutSet(rc$12393, (ref Set.empty(())) @ rc$12393)
}

def MutSet.enumerator(
    rc$14183: Region[r1],
    s$14185: MutSet[a, r2]
): Iterator[(Int32, a), r1 + r2, r1] \ r1 + r2 = {
    |>(
        MutSet.iterator(rc$14183, s$14185),
        $0$45818 ->
            Iterator.zipWithIndex($0$45818)
    )
}

def MutSet.exists(f$13611: a -> Bool, s$13613: MutSet[a, r]): Bool \ ef + r = {
    match s$13613 {
        case MutSet.MutSet(_, ms$13621) =>
            Set.exists(f$13611, deref ms$13621)
    }
}

def MutSet.find(f$13190: a -> Bool, s$13192: MutSet[a, r]): Option[a] \ r = {
    MutSet.findLeft(f$13190, s$13192)
}

def MutSet.findLeft(
    f$13207: a -> Bool,
    s$13210: MutSet[a, r]
): Option[a] \ r = {
    match s$13210 {
        case MutSet.MutSet(_, ms$13214) =>
            Set.findLeft(f$13207, deref ms$13214)
    }
}

def MutSet.findRight(
    f$13226: a -> Bool,
    s$13228: MutSet[a, r]
): Option[a] \ r = {
    match s$13228 {
        case MutSet.MutSet(_, ms$13235) =>
            Set.findRight(f$13226, deref ms$13235)
    }
}

def MutSet.foldLeft(
    f$13255: b -> a -> b \ ef,
    i$13261: b,
    s$13265: MutSet[a, r]
): b \ ef + r = {
    match s$13265 {
        case MutSet.MutSet(_, ms$13271) =>
            Set.foldLeft(f$13255, i$13261, deref ms$13271)
    }
}

def MutSet.foldMap(f$13350: a -> b, s$13353: MutSet[a, r]): b \ ef + r = {
    MutSet.foldLeft(
        acc$13358 ->
            x$13362 ->
                <[unknown exp]>(acc$13358, f$13350(x$13362)),
        <[unknown exp]>(()),
        s$13353
    )
}

def MutSet.foldRight(
    f$13286: a -> b -> b \ ef,
    z$13296: b,
    s$13298: MutSet[a, r]
): b \ ef + r = {
    match s$13298 {
        case MutSet.MutSet(_, ms$13300) =>
            Set.foldRight(f$13286, z$13296, deref ms$13300)
    }
}

def MutSet.foldRightWithCont(
    f$13315: a -> (Unit -> b \ ef) -> b \ ef,
    z$13317: b,
    s$13319: MutSet[a, r]
): b \ ef + r = {
    match s$13319 {
        case MutSet.MutSet(_, ms$13325) =>
            Set.foldRightWithCont(f$13315, z$13317, deref ms$13325)
    }
}

def MutSet.forAll(f$13640: a -> Bool, s$13643: MutSet[a, r]): Bool \ ef + r = {
    match s$13643 {
        case MutSet.MutSet(_, ms$13654) =>
            Set.forAll(f$13640, deref ms$13654)
    }
}

def MutSet.forEach(f$14027: a -> Unit, s$14033: MutSet[a, r]): Unit \ ef + r = {
    match s$14033 {
        case MutSet.MutSet(_, ms$14039) =>
            Set.forEach(f$14027, deref ms$14039)
    }
}

def MutSet.forEachWithIndex(
    f$14070: Int32 -> a -> Unit \ ef,
    s$14073: MutSet[a, r]
): Unit \ ef + r = {
    region rc$14082 {
        let ix$14085: Ref[Int32, rc] = (ref 0i32) @ rc$14082;
        MutSet.forEach(
            x$14087 ->
                {
                    let i$14089: Int32 = deref ix$14085;
                    f$14070(i$14089)(x$14087);
                    Ref.put(<[unknown exp]>(i$14089, 1i32), ix$14085)
                },
            s$14073
        )
    }
}

def MutSet.isEmpty(s$12868: MutSet[a, r]): Bool \ r = {
    match s$12868 {
        case MutSet.MutSet(_, ms$12873) =>
            Set.isEmpty(deref ms$12873)
    }
}

def MutSet.isProperSubsetOf(
    s1$13165: MutSet[a, r1],
    s2$13167: MutSet[a, r2]
): Bool \ r1 + r2 = {
    match s1$13165 {
        case MutSet.MutSet(_, ms1$13178) =>
            match s2$13167 {
                case MutSet.MutSet(_, ms2$13180) =>
                    Set.isProperSubsetOf(deref ms1$13178, deref ms2$13180)
            }
    }
}

def MutSet.isSubsetOf(
    s1$13113: MutSet[a, r1],
    s2$13121: MutSet[a, r2]
): Bool \ r1 + r2 = {
    match s1$13113 {
        case MutSet.MutSet(_, ms1$13141) =>
            match s2$13121 {
                case MutSet.MutSet(_, ms2$13146) =>
                    Set.isSubsetOf(deref ms1$13141, deref ms2$13146)
            }
    }
}

def MutSet.iterator(
    rc$14110: Region[r1],
    s$14114: MutSet[a, r2]
): Iterator[a, r1 + r2, r1] \ r1 + r2 = {
    match s$14114 {
        case MutSet.MutSet(_, ms$14120) =>
            |>(
                Set.iterator(rc$14110, deref ms$14120),
                (
                    $0$45814 ->
                        $1$45816 ->
                            Iterator.map($0$45814, $1$45816)
                )(x$14124 -> {discard (deref ms$14120); x$14124})
            )
    }
}

def MutSet.join(sep$14237: String, s$14239: MutSet[a, r]): String \ r = {
    match s$14239 {
        case MutSet.MutSet(_, ms$14277) =>
            Set.join(sep$14237, deref ms$14277)
    }
}

def MutSet.joinWith(
    f$14306: a -> String,
    sep$14312: String,
    s$14314: MutSet[a, r]
): String \ ef + r = {
    match s$14314 {
        case MutSet.MutSet(_, ms$14326) =>
            Set.joinWith(f$14306, sep$14312, deref ms$14326)
    }
}

def MutSet.maximum(s$13023: MutSet[a, r]): Option[a] \ r = {
    match s$13023 {
        case MutSet.MutSet(_, ms$13028) =>
            Set.maximum(deref ms$13028)
    }
}

def MutSet.maximumBy(
    cmp$13040: a -> a -> Comparison \ ef,
    s$13048: MutSet[a, r]
): Option[a] \ ef + r = {
    match s$13048 {
        case MutSet.MutSet(_, ms$13066) =>
            Set.maximumBy(cmp$13040, deref ms$13066)
    }
}

def MutSet.memberOf(x$12943: a, s$12947: MutSet[a, r]): Bool \ r = {
    match s$12947 {
        case MutSet.MutSet(_, ms$12955) =>
            Set.memberOf(x$12943, deref ms$12955)
    }
}

def MutSet.minimum(s$12967: MutSet[a, r]): Option[a] \ r = {
    match s$12967 {
        case MutSet.MutSet(_, ms$12980) =>
            Set.minimum(deref ms$12980)
    }
}

def MutSet.minimumBy(
    cmp$12994: a -> a -> Comparison \ ef,
    s$12999: MutSet[a, r]
): Option[a] \ ef + r = {
    match s$12999 {
        case MutSet.MutSet(_, ms$13014) =>
            Set.minimumBy(cmp$12994, deref ms$13014)
    }
}

def MutSet.nonEmpty(s$12915: MutSet[a, r]): Bool \ r = {
    !MutSet.isEmpty(s$12915)
}

def MutSet.partition(
    rc1$13746: Region[r1],
    rc2$13752: Region[r2],
    f$13759: a -> Bool,
    s$13766: MutSet[a, r]
): (MutSet[a, r1], MutSet[a, r2]) \ r + r1 + r2 = {
    match s$13766 {
        case MutSet.MutSet(_, ms$13794) =>
            match Set.partition(f$13759, deref ms$13794) {
                case (ys$13797, zs$13800) =>
                    (
                        MutSet.MutSet(rc1$13746, (ref ys$13797) @ rc1$13746),
                        MutSet.MutSet(rc2$13752, (ref zs$13800) @ rc2$13752)
                    )
            }
    }
}

def MutSet.reduceLeft(
    f$13389: a -> a -> a \ ef,
    s$13395: MutSet[a, r]
): Option[a] \ ef + r = {
    match s$13395 {
        case MutSet.MutSet(_, ms$13401) =>
            Set.reduceLeft(f$13389, deref ms$13401)
    }
}

def MutSet.reduceRight(
    f$13423: a -> a -> a \ ef,
    s$13430: MutSet[a, r]
): Option[a] \ ef + r = {
    match s$13430 {
        case MutSet.MutSet(_, ms$13448) =>
            Set.reduceRight(f$13423, deref ms$13448)
    }
}

def MutSet.refine!(f$12670: a -> Bool, s$12674: MutSet[a, r]): Unit \ r = {
    match s$12674 {
        case MutSet.MutSet(_, ms$12683) =>
            Ref.put(Set.filter(f$12670, deref ms$12683), ms$12683)
    }
}

def MutSet.remove!(x$12565: a, s$12567: MutSet[a, r]): Unit \ r = {
    match s$12567 {
        case MutSet.MutSet(_, ms$12575) =>
            Ref.put(Set.remove(x$12565, deref ms$12575), ms$12575)
    }
}

def MutSet.removeAll!(m$12597: m[a], s$12601: MutSet[a, r]): Unit \ r = {
    match s$12601 {
        case MutSet.MutSet(_, ms$12609) =>
            let s2$12613: Set[a] = <[unknown exp]>(m$12597);
            Ref.put(Set.difference(deref ms$12609, s2$12613), ms$12609)
    }
}

def MutSet.replace!(
    src$12715: { src = a },
    dst$12734: { dst = a },
    s$12736: MutSet[a, r]
): Unit \ r = {
    match s$12736 {
        case MutSet.MutSet(_, ms$12761) =>
            Ref.put(
                Set.replace(
                    {+src = src$12715.src | {}},
                    {+dst = dst$12734.dst | {}},
                    deref ms$12761
                ),
                ms$12761
            )
    }
}

def MutSet.retainAll!(m$12631: m[a], s$12633: MutSet[a, r]): Unit \ r = {
    match s$12633 {
        case MutSet.MutSet(_, ms$12641) =>
            let s2$12647: Set[a] = <[unknown exp]>(m$12631);
            Ref.put(Set.intersection(s2$12647, deref ms$12641), ms$12641)
    }
}

def MutSet.sameElements(
    a$14207: MutSet[a, r],
    b$14220: MutSet[a, r]
): Bool \ r = {
    MutSet.isSubsetOf(a$14207, b$14220) and MutSet.isSubsetOf(b$14220, a$14207)
}

def MutSet.singleton(rc$12407: Region[r], x$12409: a): MutSet[a, r] \ r = {
    MutSet.MutSet(rc$12407, (ref Set.singleton(x$12409)) @ rc$12407)
}

def MutSet.size(s$13080: MutSet[a, r]): Int32 \ r = {
    match s$13080 {case MutSet.MutSet(_, ms$13089) => Set.size(deref ms$13089)}
}

def MutSet.sum(s$13518: MutSet[Int32, r]): Int32 \ r = {
    match s$13518 {case MutSet.MutSet(_, ms$13525) => Set.sum(deref ms$13525)}
}

def MutSet.sumWith(
    f$13555: a -> Int32,
    s$13568: MutSet[a, r]
): Int32 \ ef + r = {
    match s$13568 {
        case MutSet.MutSet(_, ms$13587) =>
            Set.sumWith(f$13555, deref ms$13587)
    }
}

def MutSet.toList(s$13862: MutSet[a, r]): List[a] \ r = {
    match s$13862 {
        case MutSet.MutSet(_, ms$13870) =>
            Set.toList(deref ms$13870)
    }
}

def MutSet.toMap(s$13936: MutSet[(a, b), r]): Map[a, b] \ r = {
    match s$13936 {case MutSet.MutSet(_, ms$13959) => Set.toMap(deref ms$13959)}
}

def MutSet.toMutDeque(
    rc1$13982: Region[r1],
    s$13985: MutSet[a, r2]
): MutDeque[a, r1] \ r2 + r1 = {
    match s$13985 {
        case MutSet.MutSet(_, ms$13999) =>
            Set.toMutDeque(rc1$13982, deref ms$13999)
    }
}

def MutSet.toSet(s$13827: MutSet[a, r]): Set[a] \ r = {
    match s$13827 {case MutSet.MutSet(_, ms$13843) => deref ms$13843}
}

def MutSet.toString(s$12314: MutSet[a, r]): String \ r = {
    region rc$12327 {
        let sb$12330: StringBuilder[rc] = StringBuilder.empty(rc$12327);
        StringBuilder.appendString!("""MutSet#{""", sb$12330);
        MutSet.forEachWithIndex(
            i$12334 ->
                x$12338 ->
                    if (<[unknown exp]>(i$12334, 0i32)) {
                        StringBuilder.appendString!(
                            """""" + <[unknown exp]>(x$12338),
                            sb$12330
                        )
                    } else {
                        StringBuilder.appendString!(
                            ("""""" + """, """) + <[unknown exp]>(x$12338),
                            sb$12330
                        )
                    },
            s$12314
        );
        StringBuilder.appendString!("""}""", sb$12330);
        StringBuilder.toString(sb$12330)
    }
}

def MutSet.transform!(f$12853: a -> a, s$12856: MutSet[a, r]): Unit \ ef + r = {
    match s$12856 {
        case MutSet.MutSet(_, ms$12859) =>
            Ref.put(Set.map(f$12853, deref ms$12859), ms$12859)
    }
}

enum Nec[t] {case NecOne(t) case Nec(Nec[t], Nec[t])}

def Nec.ap(f$27940: Nec[a -> b \ ef], c$27946: Nec[a]): Nec[b] \ ef = {
    letrec loop$27948: (
        Nec[a -> b \ ef] -> (Nec[b] -> Nec[b] \ ef) -> Nec[b] \ ef
    ) = f1$27950 ->
        k$27956 ->
            match Nec.viewLeft(f1$27950) {
                case Nec.ViewLeft.OneLeft(f2$27968) =>
                    k$27956(Nec.map(f2$27968, c$27946))
                case Nec.ViewLeft.SomeLeft(f2$27970, rs$27972) =>
                    loop$27948(
                        rs$27972
                    )(
                        ks$27974 ->
                            k$27956(
                                Nec.append(Nec.map(f2$27970, c$27946), ks$27974)
                            )
                    )
            };
    loop$27948(f$27940)($0$46164 -> eidentity($0$46164))
}

def Nec.append(c1$23980: Nec[a], c2$23982: Nec[a]): Nec[a] = {
    Nec.Nec(c1$23980, c2$23982)
}

def Nec.cons(x$23730: a, c$23738: Nec[a]): Nec[a] = {
    Nec.Nec(Nec.NecOne(x$23730), c$23738)
}

def Nec.consA(mx$30905: f[a], mxs$30907: f[Nec[a]]): f[Nec[a]] = {
    Applicative.<*>(
        Functor.<$>(
            x$30909 ->
                xs$30911 ->
                    Nec.cons(x$30909, xs$30911),
            mx$30905
        ),
        mxs$30907
    )
}

def Nec.count(f$28373: a -> Bool, c$28375: Nec[a]): Int32 \ ef = {
    letrec loop$28377: (
        Nec[a] -> Int32 -> Int32 \ ((e88085 + ef) & ef) + ef
    ) = c1$28379 ->
        acc$28381 ->
            match Nec.viewLeft(c1$28379) {
                case Nec.ViewLeft.OneLeft(x$28385) =>
                    if (f$28373(x$28385)) {
                        <[unknown exp]>(acc$28381, 1i32)
                    } else {
                        acc$28381
                    }
                case Nec.ViewLeft.SomeLeft(x$28396, rs$28399) =>
                    loop$28377(
                        rs$28399
                    )(
                        if (f$28373(x$28396)) {
                            <[unknown exp]>(acc$28381, 1i32)
                        } else {
                            acc$28381
                        }
                    )
            };
    loop$28377(c$28375)(0i32)
}

def Nec.dropWhileLeft(f$31349: a -> Bool, c$31357: Nec[a]): List[a] \ ef = {
    letrec loop$31359: (Nec[a] -> List[a]) = c1$31361 ->
        match Nec.viewLeft(c1$31361) {
            case Nec.ViewLeft.OneLeft(x$31363) =>
                if (f$31349(x$31363)) {
                    List.Nil
                } else {
                    List.Cons(x$31363, List.Nil)
                }
            case Nec.ViewLeft.SomeLeft(x$31371, rs$31375) =>
                if (f$31349(x$31371)) {
                    loop$31359(rs$31375)
                } else {
                    List.Cons(x$31371, Nec.toList(rs$31375))
                }
        };
    loop$31359(c$31357)
}

def Nec.dropWhileRight(f$31409: a -> Bool, c$31414: Nec[a]): List[a] \ ef = {
    letrec loop$31420: (Nec[a] -> List[a]) = c1$31422 ->
        match Nec.viewRight(c1$31422) {
            case Nec.ViewRight.OneRight(x$31428) =>
                if (f$31409(x$31428)) {
                    List.Nil
                } else {
                    List.Cons(x$31428, List.Nil)
                }
            case Nec.ViewRight.SomeRight(rs$31430, x$31432) =>
                if (f$31409(x$31432)) {
                    loop$31420(rs$31430)
                } else {
                    Nec.toList(Nec.snoc(rs$31430, x$31432))
                }
        };
    loop$31420(c$31414)
}

def Nec.enumerator(
    rc$30763: Region[r],
    c$30765: Nec[a]
): Iterator[(Int32, a), r, r] \ r = {
    |>(
        Nec.iterator(rc$30763, c$30765),
        $0$46352 ->
            Iterator.zipWithIndex($0$46352)
    )
}

def Nec.equals(c1$23642: Nec[a], c2$23651: Nec[a]): Bool = {
    <[unknown exp]>(Nec.viewLeft(c1$23642), Nec.viewLeft(c2$23651))
}

def Nec.exists(f$29382: a -> Bool, c$29390: Nec[a]): Bool \ ef = {
    match Nec.viewLeft(c$29390) {
        case Nec.ViewLeft.OneLeft(x$29408) =>
            f$29382(x$29408)
        case Nec.ViewLeft.SomeLeft(x$29410, rs$29412) =>
            if (f$29382(x$29410)) {true} else {Nec.exists(f$29382, rs$29412)}
    }
}

def Nec.filter(f$29498: a -> Bool, c$29505: Nec[a]): List[a] \ ef = {
    letrec loop$29513: (
        Nec[a] -> (List[a] -> List[a] \ ef) -> List[a] \ ef
    ) = c1$29515 ->
        k$29517 ->
            match Nec.viewLeft(c1$29515) {
                case Nec.ViewLeft.OneLeft(x$29519) =>
                    if (f$29498(x$29519)) {
                        k$29517(List.Cons(x$29519, List.Nil))
                    } else {
                        k$29517(List.Nil)
                    }
                case Nec.ViewLeft.SomeLeft(x$29525, rs$29527) =>
                    if (f$29498(x$29525)) {
                        loop$29513(
                            rs$29527
                        )(ks$29530 -> k$29517(List.Cons(x$29525, ks$29530)))
                    } else {
                        loop$29513(rs$29527)(k$29517)
                    }
            };
    loop$29513(c$29505)($0$46264 -> eidentity($0$46264))
}

def Nec.filterMap(f$29765: a -> Option[b], c$29767: Nec[a]): List[b] \ ef = {
    letrec loop$29769: (
        Nec[a] -> (List[b] -> List[b]) -> List[b] \ ef
    ) = l$29771 ->
        k$29775 ->
            match Nec.viewLeft(l$29771) {
                case Nec.ViewLeft.OneLeft(x$29780) =>
                    match f$29765(x$29780) {
                        case Option.Some(a$29782) =>
                            k$29775(List.Cons(a$29782, List.Nil))
                        case Option.None =>
                            k$29775(List.Nil)
                    }
                case Nec.ViewLeft.SomeLeft(x$29787, rs$29789) =>
                    match f$29765(x$29787) {
                        case Option.Some(a$29791) =>
                            loop$29769(
                                rs$29789
                            )(ks$29793 -> k$29775(List.Cons(a$29791, ks$29793)))
                        case Option.None =>
                            loop$29769(rs$29789)(k$29775)
                    }
            };
    loop$29769(c$29767)($0$46266 -> identity($0$46266))
}

def Nec.find(f$24405: a -> Bool, c$24411: Nec[a]): Option[a] \ ef = {
    Nec.findLeft(f$24405, c$24411)
}

def Nec.findLeft(f$24449: a -> Bool, c$24455: Nec[a]): Option[a] \ ef = {
    match Nec.viewLeft(c$24455) {
        case Nec.ViewLeft.OneLeft(x$24461) =>
            if (f$24449(x$24461)) {Option.Some(x$24461)} else {Option.None}
        case Nec.ViewLeft.SomeLeft(x$24466, rs$24469) =>
            if (f$24449(x$24466)) {
                Option.Some(x$24466)
            } else {
                Nec.findLeft(f$24449, rs$24469)
            }
    }
}

def Nec.findMap(f$29850: a -> Option[b], c$29852: Nec[a]): Option[b] \ ef = {
    match Nec.viewLeft(c$29852) {
        case Nec.ViewLeft.OneLeft(x$29854) =>
            f$29850(x$29854)
        case Nec.ViewLeft.SomeLeft(x$29856, rs$29858) =>
            match f$29850(x$29856) {
                case Option.Some(v$29860) =>
                    Option.Some(v$29860)
                case Option.None =>
                    Nec.findMap(f$29850, rs$29858)
            }
    }
}

def Nec.findRight(f$24499: a -> Bool, c$24501: Nec[a]): Option[a] \ ef = {
    match Nec.viewRight(c$24501) {
        case Nec.ViewRight.OneRight(x$24505) =>
            if (f$24499(x$24505)) {Option.Some(x$24505)} else {Option.None}
        case Nec.ViewRight.SomeRight(rs$24515, x$24517) =>
            if (f$24499(x$24517)) {
                Option.Some(x$24517)
            } else {
                Nec.findRight(f$24499, rs$24515)
            }
    }
}

def Nec.flatMap(f$27998: a -> Nec[b], c$28004: Nec[a]): Nec[b] \ ef = {
    letrec loop$28012: (
        Nec[a] -> (Nec[b] -> Nec[b] \ ef) -> Nec[b] \ ef
    ) = c1$28014 ->
        k$28021 ->
            match Nec.viewLeft(c1$28014) {
                case Nec.ViewLeft.OneLeft(x$28025) =>
                    let a$28029: Nec[b] = f$27998(x$28025); k$28021(a$28029)
                case Nec.ViewLeft.SomeLeft(x$28037, rs$28039) =>
                    loop$28012(
                        rs$28039
                    )(
                        ks$28041 ->
                            {
                                let a$28043: Nec[b] = f$27998(x$28037);
                                k$28021(Nec.append(a$28043, ks$28041))
                            }
                    )
            };
    loop$28012(c$28004)($0$46172 -> eidentity($0$46172))
}

def Nec.flatten(c$29348: Nec[Nec[a]]): Nec[a] = {
    match Nec.viewLeft(c$29348) {
        case Nec.ViewLeft.OneLeft(xs$29350) =>
            xs$29350
        case Nec.ViewLeft.SomeLeft(xs$29354, xss$29356) =>
            Nec.foldLeft(
                $0$46258 ->
                    $1$46260 ->
                        Nec.append($0$46258, $1$46260),
                xs$29354,
                xss$29356
            )
    }
}

def Nec.fold(l$29551: Nec[a]): a = {Foldable.fold(l$29551)}

def Nec.foldLeft(
    f$29589: b -> a -> b \ ef,
    acc$29591: b,
    c$29593: Nec[a]
): b \ ef = {
    match Nec.viewLeft(c$29593) {
        case Nec.ViewLeft.OneLeft(x$29595) =>
            f$29589(acc$29591)(x$29595)
        case Nec.ViewLeft.SomeLeft(x$29597, rs$29599) =>
            let b$29601: b = f$29589(acc$29591)(x$29597);
            Nec.foldLeft(f$29589, b$29601, rs$29599)
    }
}

def Nec.foldMap(f$29722: a -> b, c$29724: Nec[a]): b \ ef = {
    Nec.foldLeft(
        acc$29730 ->
            x$29733 ->
                <[unknown exp]>(acc$29730, f$29722(x$29733)),
        <[unknown exp]>(()),
        c$29724
    )
}

def Nec.foldRight(
    f$29619: a -> b -> b \ ef,
    s$29625: b,
    c$29627: Nec[a]
): b \ ef = {
    match Nec.viewRight(c$29627) {
        case Nec.ViewRight.OneRight(x$29629) =>
            f$29619(x$29629)(s$29625)
        case Nec.ViewRight.SomeRight(rs$29631, x$29633) =>
            let b$29635: b = f$29619(x$29633)(s$29625);
            Nec.foldRight(f$29619, b$29635, rs$29631)
    }
}

def Nec.foldRightWithCont(
    f$29677: a -> (Unit -> b \ ef) -> b \ ef,
    z$29691: b,
    c$29693: Nec[a]
): b \ ef = {
    match Nec.viewLeft(c$29693) {
        case Nec.ViewLeft.OneLeft(x$29705) =>
            f$29677(x$29705)(constant(z$29691))
        case Nec.ViewLeft.SomeLeft(x$29707, rs$29709) =>
            f$29677(
                x$29707
            )(_$29711 -> Nec.foldRightWithCont(f$29677, z$29691, rs$29709))
    }
}

def Nec.forAll(f$29450: a -> Bool, c$29452: Nec[a]): Bool \ ef = {
    match Nec.viewLeft(c$29452) {
        case Nec.ViewLeft.OneLeft(x$29458) =>
            f$29450(x$29458)
        case Nec.ViewLeft.SomeLeft(x$29460, rs$29462) =>
            if (!f$29450(x$29460)) {false} else {Nec.forAll(f$29450, rs$29462)}
    }
}

def Nec.forEach(f$30374: a -> Unit, c$30376: Nec[a]): Unit \ ef = {
    match Nec.viewLeft(c$30376) {
        case Nec.ViewLeft.OneLeft(x$30387) =>
            f$30374(x$30387)
        case Nec.ViewLeft.SomeLeft(x$30393, rs$30395) =>
            f$30374(x$30393); Nec.forEach(f$30374, rs$30395)
    }
}

def Nec.forEachWithIndex(
    f$30405: Int32 -> a -> Unit \ ef,
    c$30411: Nec[a]
): Unit \ ef = {
    letrec loop$30420: (
        ViewLeft[a] -> Int32 -> Unit \ ef + ((e58972 + ef) & ef) + ef
    ) = v$30422 ->
        i$30424 ->
            match v$30422 {
                case Nec.ViewLeft.OneLeft(x$30426) =>
                    f$30405(i$30424)(x$30426)
                case Nec.ViewLeft.SomeLeft(x$30428, rs$30430) =>
                    f$30405(i$30424)(x$30428);
                    loop$30420(
                        Nec.viewLeft(rs$30430)
                    )(<[unknown exp]>(i$30424, 1i32))
            };
    loop$30420(Nec.viewLeft(c$30411))(0i32)
}

def Nec.fromArray(arr$30792: Array[a, r]): Option[Nec[a]] \ r = {
    letrec loop$30794: (
        Int32 -> Int32 -> (Nec[a] -> Nec[a] \ r + (e78736 & r) + r)
    ) = ix$30796 ->
        end$30798 ->
            acc$30800 ->
                if (<[unknown exp]>(ix$30796, end$30798)) {
                    acc$30800
                } else {
                    let x$30802: a = Array.get(ix$30796, arr$30792);
                    loop$30794(
                        <[unknown exp]>(ix$30796, 1i32)
                    )(end$30798)(Nec.snoc(acc$30800, x$30802))
                };
    let len$30804: Int32 = Array.length(arr$30792);
    if (<[unknown exp]>(len$30804, 1i32)) {
        Option.None
    } else {
        let acc$30806: Nec[a] = Nec.singleton(Array.get(0i32, arr$30792));
        |>(
            loop$30794(1i32)(len$30804)(acc$30806),
            x$$46354 ->
                Option.Some(x$$46354)
        )
    }
}

def Nec.fromList(l$28230: List[a]): Option[Nec[a]] = {
    letrec loop$28242: (
        a -> List[a] -> ((Nec[a] -> Nec[a]) -> Nec[a])
    ) = x$28244 ->
        xs$28246 ->
            k$28248 ->
                match xs$28246 {
                    case List.Nil =>
                        k$28248(Nec.singleton(x$28244))
                    case List.Cons(x1$28257, rs$28259) =>
                        loop$28242(
                            x1$28257
                        )(
                            rs$28259
                        )(ks$28261 -> k$28248(Nec.cons(x$28244, ks$28261)))
                };
    match l$28230 {
        case List.Nil =>
            Option.None
        case List.Cons(x$28273, xs$28275) =>
            |>(
                loop$28242(x$28273)(xs$28275)(ks$28290 -> ks$28290),
                x$$46256 ->
                    Option.Some(x$$46256)
            )
    }
}

def Nec.head(c$23802: Nec[a]): a = {
    match Nec.viewLeft(c$23802) {
        case Nec.ViewLeft.OneLeft(x$23814) =>
            x$23814
        case Nec.ViewLeft.SomeLeft(x$23830, _) =>
            x$23830
    }
}

def Nec.indexOf(a$24343: a, c$24346: Nec[a]): Option[Int32] = {
    letrec loop$24348: (Int32 -> Nec[a] -> Option[Int32]) = acc$24350 ->
        c1$24352 ->
            match Nec.viewLeft(c1$24352) {
                case Nec.ViewLeft.OneLeft(x$24355) =>
                    if (<[unknown exp]>(x$24355, a$24343)) {
                        Option.Some(acc$24350)
                    } else {
                        Option.None
                    }
                case Nec.ViewLeft.SomeLeft(x$24366, c2$24368) =>
                    if (<[unknown exp]>(x$24366, a$24343)) {
                        Option.Some(acc$24350)
                    } else {
                        loop$24348(<[unknown exp]>(acc$24350, 1i32))(c2$24368)
                    }
            };
    loop$24348(0i32)(c$24346)
}

def Nec.init(c$23885: Nec[a]): List[a] = {
    match Nec.viewRight(c$23885) {
        case Nec.ViewRight.OneRight(_) =>
            List.Nil
        case Nec.ViewRight.SomeRight(rs$23897, _) =>
            Nec.toList(rs$23897)
    }
}

def Nec.intersperse(sep$28298: a, c$28302: Nec[a]): Nec[a] = {
    letrec loop$28310: (Nec[a] -> (Nec[a] -> Nec[a]) -> Nec[a]) = c1$28313 ->
        k$28323 ->
            match Nec.viewLeft(c1$28313) {
                case Nec.ViewLeft.OneLeft(x$28333) =>
                    k$28323(Nec.cons(sep$28298, Nec.singleton(x$28333)))
                case Nec.ViewLeft.SomeLeft(x$28337, rs$28339) =>
                    loop$28310(
                        rs$28339
                    )(
                        ks$28341 ->
                            k$28323(
                                Nec.cons(sep$28298, Nec.cons(x$28337, ks$28341))
                            )
                    )
            };
    match Nec.viewLeft(c$28302) {
        case Nec.ViewLeft.OneLeft(x$28343) =>
            Nec.singleton(x$28343)
        case Nec.ViewLeft.SomeLeft(x$28345, rs$28347) =>
            loop$28310(rs$28347)(ks$28349 -> Nec.cons(x$28345, ks$28349))
    }
}

def Nec.isSingleton(c$23704: Nec[a]): Bool = {
    match c$23704 {case Nec.NecOne(_) => true case _ => false}
}

def Nec.iterator(
    rc$30700: Region[r],
    c$30702: Nec[a]
): Iterator[a, r, r] \ r = {
    Nec.iteratorHelper(rc$30700, Option.Some(Nec.viewLeft(c$30702)))
}

def Nec.iteratorHelper(
    rc$30725: Region[r],
    vl$30727: Option[ViewLeft[a]]
): Iterator[a, r, r] \ r = {
    let cursor$30729: Ref[Option[ViewLeft[a]], r] = (ref vl$30727) @ rc$30725;
    let next$30731: (Unit -> Option[a]) = _unit$30733 ->
        match deref cursor$30729 {
            case Option.None =>
                Option.None
            case Option.Some(Nec.ViewLeft.OneLeft(x$30739)) =>
                Ref.put(Option.None, cursor$30729); Option.Some(x$30739)
            case Option.Some(Nec.ViewLeft.SomeLeft(x$30751, xs$30753)) =>
                Ref.put(Option.Some(Nec.viewLeft(xs$30753)), cursor$30729);
                Option.Some(x$30751)
        };
    Iterator.iterate(rc$30725, next$30731)
}

def Nec.join(sep$31036: String, c$31038: Nec[a]): String = {
    <[unknown exp]>(sep$31036, c$31038)
}

def Nec.joinWith(
    f$31065: a -> String,
    sep$31074: String,
    c$31076: Nec[a]
): String \ ef = {
    <[unknown exp]>(f$31065, sep$31074, c$31076)
}

def Nec.last(c$23854: Nec[a]): a = {
    match Nec.viewRight(c$23854) {
        case Nec.ViewRight.OneRight(x$23864) =>
            x$23864
        case Nec.ViewRight.SomeRight(_, x$23868) =>
            x$23868
    }
}

def Nec.length(c$23950: Nec[a]): Int32 = {
    Nec.foldRight(
        _$23954 ->
            acc$23959 ->
                <[unknown exp]>(acc$23959, 1i32),
        0i32,
        c$23950
    )
}

def Nec.map(f$24602: a -> b, c$24606: Nec[a]): Nec[b] \ ef = {
    letrec loop$25193: (
        Nec[a] -> (Nec[b] -> Nec[b] \ ef) -> Nec[b] \ ef
    ) = c1$25195 ->
        k$26347 ->
            match Nec.viewLeft(c1$25195) {
                case Nec.ViewLeft.OneLeft(x$27842) =>
                    let a$27844: b = f$24602(x$27842);
                    k$26347(Nec.NecOne(a$27844))
                case Nec.ViewLeft.SomeLeft(x$27846, rs$27848) =>
                    loop$25193(
                        rs$27848
                    )(
                        ks$27852 ->
                            {
                                let a$27854: b = f$24602(x$27846);
                                k$26347(Nec.cons(a$27854, ks$27852))
                            }
                    )
            };
    loop$25193(c$24606)($0$46146 -> eidentity($0$46146))
}

def Nec.mapAccumLeft(
    f$30213: s -> a -> (s, b) \ ef,
    start$30218: s,
    c$30220: Nec[a]
): (s, Nec[b]) \ ef = {
    letrec loop$30228: (
        s -> Nec[a] -> ((((s, Nec[b])) -> (s, Nec[b])) -> (s, Nec[b]) \ ef)
    ) = s1$30231 ->
        c1$30234 ->
            k$30238 ->
                match Nec.viewLeft(c1$30234) {
                    case Nec.ViewLeft.OneLeft(x$30244) =>
                        match f$30213(s1$30231)(x$30244) {
                            case (s2$30248, x1$30250) =>
                                k$30238((s2$30248, Nec.NecOne(x1$30250)))
                        }
                    case Nec.ViewLeft.SomeLeft(x$30258, rs$30260) =>
                        match f$30213(s1$30231)(x$30258) {
                            case (s2$30268, x1$30270) =>
                                loop$30228(
                                    s2$30268
                                )(
                                    rs$30260
                                )(
                                    pat$84$30272 ->
                                        match pat$84$30272 {
                                            case (s3$30274, ks$30276) =>
                                                k$30238(
                                                    (
                                                        s3$30274,
                                                        Nec.cons(
                                                            x1$30270,
                                                            ks$30276
                                                        )
                                                    )
                                                )
                                        }
                                )
                        }
                };
    loop$30228(start$30218)(c$30220)($0$46330 -> identity($0$46330))
}

def Nec.mapAccumRight(
    f$30304: s -> a -> (s, b) \ ef,
    start$30306: s,
    c$30310: Nec[a]
): (s, Nec[b]) \ ef = {
    letrec loop$30318: (
        s -> Nec[a] -> ((((s, Nec[b])) -> (s, Nec[b])) -> (s, Nec[b]) \ ef)
    ) = s1$30320 ->
        c1$30322 ->
            k$30324 ->
                match Nec.viewRight(c1$30322) {
                    case Nec.ViewRight.OneRight(x$30326) =>
                        match f$30304(s1$30320)(x$30326) {
                            case (s2$30328, x1$30330) =>
                                k$30324((s2$30328, Nec.NecOne(x1$30330)))
                        }
                    case Nec.ViewRight.SomeRight(rs$30332, x$30334) =>
                        match f$30304(s1$30320)(x$30334) {
                            case (s2$30336, x1$30338) =>
                                loop$30318(
                                    s2$30336
                                )(
                                    rs$30332
                                )(
                                    pat$85$30340 ->
                                        match pat$85$30340 {
                                            case (s3$30342, ks$30344) =>
                                                k$30324(
                                                    (
                                                        s3$30342,
                                                        Nec.snoc(
                                                            ks$30344,
                                                            x1$30338
                                                        )
                                                    )
                                                )
                                        }
                                )
                        }
                };
    loop$30318(start$30306)(c$30310)($0$46332 -> identity($0$46332))
}

def Nec.mapWithIndex(
    f$27869: Int32 -> a -> b \ ef,
    c$27873: Nec[a]
): Nec[b] \ ef = {
    letrec loop$27883: (
        Nec[a] -> Int32 -> ((Nec[b] -> Nec[b] \ ef) -> Nec[b] \ ef)
    ) = c1$27885 ->
        i$27887 ->
            k$27889 ->
                match Nec.viewLeft(c1$27885) {
                    case Nec.ViewLeft.OneLeft(x$27893) =>
                        let a$27895: b = f$27869(i$27887)(x$27893);
                        k$27889(Nec.NecOne(a$27895))
                    case Nec.ViewLeft.SomeLeft(x$27897, rs$27899) =>
                        loop$27883(
                            rs$27899
                        )(
                            <[unknown exp]>(i$27887, 1i32)
                        )(
                            ks$27903 ->
                                {
                                    let a$27905: b = f$27869(i$27887)(x$27897);
                                    k$27889(Nec.cons(a$27905, ks$27903))
                                }
                        )
                };
    loop$27883(c$27873)(0i32)($0$46148 -> eidentity($0$46148))
}

def Nec.maximum(c$24280: Nec[a]): a = {
    Nec.reduceLeft(
        $0$46130 ->
            $1$46132 ->
                <[unknown exp]>($0$46130, $1$46132),
        c$24280
    )
}

def Nec.maximumBy(cmp$24305: a -> a -> Comparison, c$24311: Nec[a]): a = {
    Nec.reduceLeft(
        (
            $0$46134 ->
                $1$46136 ->
                    $2$46138 ->
                        Order.maxBy($0$46134, $1$46136, $2$46138)
        )(cmp$24305),
        c$24311
    )
}

def Nec.memberOf(a$24168: a, c$24172: Nec[a]): Bool = {
    letrec loop$24181: (Nec[a] -> Bool) = c1$24183 ->
        match Nec.viewLeft(c1$24183) {
            case Nec.ViewLeft.OneLeft(x$24185) =>
                <[unknown exp]>(x$24185, a$24168)
            case Nec.ViewLeft.SomeLeft(
                x$24191,
                _
            ) if <[unknown exp]>(x$24191, a$24168) =>
                true
            case Nec.ViewLeft.SomeLeft(_, c2$24194) =>
                loop$24181(c2$24194)
        };
    loop$24181(c$24172)
}

def Nec.minimum(c$24216: Nec[a]): a = {
    Nec.reduceLeft(
        $0$46120 ->
            $1$46122 ->
                <[unknown exp]>($0$46120, $1$46122),
        c$24216
    )
}

def Nec.minimumBy(cmp$24250: a -> a -> Comparison, c$24254: Nec[a]): a = {
    Nec.reduceLeft(
        (
            $0$46124 ->
                $1$46126 ->
                    $2$46128 ->
                        Order.minBy($0$46124, $1$46126, $2$46128)
        )(cmp$24250),
        c$24254
    )
}

def Nec.permutations(c$28161: Nec[a]): Nec[List[a]] = {
    match Nec.viewLeft(c$28161) {
        case Nec.ViewLeft.OneLeft(x$28168) =>
            Nec.singleton(List.Cons(x$28168, List.Nil))
        case Nec.ViewLeft.SomeLeft(x$28172, xs$28174) =>
            match Nec.fromList(
                List.permutations(List.Cons(x$28172, Nec.toList(xs$28174)))
            ) {
                case Option.Some(ans$28176) =>
                    ans$28176
                case Option.None =>
                    unreachable!(())
            }
    }
}

def Nec.range(b$24549: Int32, e$24553: Int32): Option[Nec[Int32]] = {
    letrec loop$24555: (
        Int32 -> (Nec[Int32] -> Nec[Int32]) -> Nec[Int32]
    ) = ix$24557 ->
        k$24559 ->
            match <[unknown exp]>(e$24553, 1i32) {
                case e1$24561 if <[unknown exp]>(ix$24557, e1$24561) =>
                    k$24559(Nec.singleton(ix$24557))
                case e1$24567 if <[unknown exp]>(ix$24557, e1$24567) =>
                    loop$24555(
                        <[unknown exp]>(ix$24557, 1i32)
                    )(ks$24571 -> k$24559(Nec.cons(ix$24557, ks$24571)))
                case _ =>
                    unreachable!(())
            };
    if (<[unknown exp]>(b$24549, e$24553)) {
        |>(
            loop$24555(b$24549)(ks$24583 -> ks$24583),
            x$$46144 ->
                Option.Some(x$$46144)
        )
    } else {
        Option.None
    }
}

def Nec.reduce(c$31088: Nec[a]): a = {
    match Nec.viewLeft(c$31088) {
        case Nec.ViewLeft.OneLeft(x$31102) =>
            x$31102
        case Nec.ViewLeft.SomeLeft(x$31110, xs$31114) =>
            Nec.foldLeft(
                acc$31118 ->
                    y$31120 ->
                        <[unknown exp]>(acc$31118, y$31120),
                x$31110,
                xs$31114
            )
    }
}

def Nec.reduceLeft(f$31134: a -> a -> a \ ef, c$31142: Nec[a]): a \ ef = {
    match Nec.viewLeft(c$31142) {
        case Nec.ViewLeft.OneLeft(x$31150) =>
            x$31150
        case Nec.ViewLeft.SomeLeft(x$31160, xs$31162) =>
            Nec.foldLeft(f$31134, x$31160, xs$31162)
    }
}

def Nec.reduceLeftTo(
    f$31246: b -> a -> b \ ef1,
    g$31250: a -> b,
    c$31258: Nec[a]
): b \ ef1 + ef2 = {
    match Nec.viewLeft(c$31258) {
        case Nec.ViewLeft.OneLeft(x$31268) =>
            g$31250(x$31268)
        case Nec.ViewLeft.SomeLeft(x$31270, xs$31272) =>
            Nec.foldLeft(f$31246, g$31250(x$31270), xs$31272)
    }
}

def Nec.reduceRight(f$31183: a -> a -> a \ ef, c$31187: Nec[a]): a \ ef = {
    match Nec.viewRight(c$31187) {
        case Nec.ViewRight.OneRight(x$31207) =>
            x$31207
        case Nec.ViewRight.SomeRight(xs$31209, x$31211) =>
            Nec.foldRight(
                a$31213 ->
                    acc$31215 ->
                        f$31183(a$31213)(acc$31215),
                x$31211,
                xs$31209
            )
    }
}

def Nec.reduceRightTo(
    f$31305: a -> b -> b \ ef1,
    g$31307: a -> b,
    c$31309: Nec[a]
): b \ ef1 + ef2 = {
    match Nec.viewRight(c$31309) {
        case Nec.ViewRight.OneRight(x$31321) =>
            g$31307(x$31321)
        case Nec.ViewRight.SomeRight(xs$31323, x$31325) =>
            Nec.foldRight(
                a$31329 ->
                    acc$31331 ->
                        f$31305(a$31329)(acc$31331),
                g$31307(x$31325),
                xs$31323
            )
    }
}

def Nec.replace(
    src$28118: { src = a },
    dst$28123: { dst = a },
    l$28126: Nec[a]
): Nec[a] = {
    Nec.map(
        e$28135 ->
            if (<[unknown exp]>(e$28135, src$28118.src)) {
                dst$28123.dst
            } else {
                e$28135
            },
        l$28126
    )
}

def Nec.reverse(c$28066: Nec[a]): Nec[a] = {
    letrec loop$28068: (Nec[a] -> Nec[a] -> Nec[a]) = c1$28070 ->
        acc$28072 ->
            match Nec.viewLeft(c1$28070) {
                case Nec.ViewLeft.OneLeft(x$28075) =>
                    Nec.cons(x$28075, acc$28072)
                case Nec.ViewLeft.SomeLeft(x$28079, rs$28081) =>
                    loop$28068(rs$28081)(Nec.cons(x$28079, acc$28072))
            };
    match Nec.viewLeft(c$28066) {
        case Nec.ViewLeft.OneLeft(x$28092) =>
            Nec.singleton(x$28092)
        case Nec.ViewLeft.SomeLeft(x$28094, rs$28096) =>
            loop$28068(rs$28096)(Nec.singleton(x$28094))
    }
}

def Nec.sequence(c$30927: Nec[m[a]]): m[Nec[a]] = {
    letrec loop$30933: (
        Nec[m[a]] -> (m[Nec[a]] -> m[Nec[a]]) -> m[Nec[a]]
    ) = l2$30935 ->
        k$30937 ->
            match Nec.viewLeft(l2$30935) {
                case Nec.ViewLeft.OneLeft(x$30939) =>
                    k$30937(
                        Functor.<$>(x$$46380 -> Nec.NecOne(x$$46380), x$30939)
                    )
                case Nec.ViewLeft.SomeLeft(x$30943, rs$30945) =>
                    loop$30933(
                        rs$30945
                    )(ks$30947 -> k$30937(Nec.consA(x$30943, ks$30947)))
            };
    loop$30933(c$30927)(ks$30949 -> ks$30949)
}

def Nec.shuffle(rnd$31525: Random, c$31527: Nec[a]): Option[Nec[a]] \ IO = {
    region rc$31529 {
        |>(
            !>(
                Nec.toArray(rc$31529, c$31527),
                (
                    $0$46391 ->
                        $1$46393 ->
                            Array.shuffle($0$46391, $1$46393)
                )(rnd$31525)
            ),
            $0$46395 ->
                Array.toNec($0$46395)
        )
    }
}

def Nec.singleton(x$23683: a): Nec[a] = {Nec.NecOne(x$23683)}

def Nec.snoc(c$23766: Nec[a], x$23773: a): Nec[a] = {
    Nec.Nec(c$23766, Nec.NecOne(x$23773))
}

def Nec.sort(c$30828: Nec[a]): Nec[a] = {
    region rc$30834 {
        let ans$30839: Option[Nec[a]] = |>(
            !>(
                Nec.toArray(rc$30834, c$30828),
                $0$46356 ->
                    Array.sort!($0$46356)
            ),
            $0$46358 ->
                Nec.fromArray($0$46358)
        );
        match ans$30839 {
            case Option.Some(n1$30845) =>
                n1$30845
            case Option.None =>
                unreachable!(())
        }
    }
}

def Nec.sortBy(f$30852: a -> b, c$30857: Nec[a]): Nec[a] = {
    region rc$30862 {
        let ans$30865: Option[Nec[a]] = |>(
            !>(
                Nec.toArray(rc$30862, c$30857),
                (
                    $0$46360 ->
                        $1$46362 ->
                            Array.sortBy!($0$46360, $1$46362)
                )(f$30852)
            ),
            $0$46364 ->
                Nec.fromArray($0$46364)
        );
        match ans$30865 {
            case Option.Some(n1$30867) =>
                n1$30867
            case Option.None =>
                unreachable!(())
        }
    }
}

def Nec.sortWith(cmp$30876: a -> a -> Comparison, c$30878: Nec[a]): Nec[a] = {
    region rc$30880 {
        let ans$30883: Option[Nec[a]] = |>(
            !>(
                Nec.toArray(rc$30880, c$30878),
                (
                    $0$46366 ->
                        $1$46368 ->
                            Array.sortWith!($0$46366, $1$46368)
                )(cmp$30876)
            ),
            $0$46370 ->
                Nec.fromArray($0$46370)
        );
        match ans$30883 {
            case Option.Some(n1$30885) =>
                n1$30885
            case Option.None =>
                unreachable!(())
        }
    }
}

def Nec.subsequences(c$28191: Nec[a]): Nec[List[a]] = {
    match Nec.viewLeft(c$28191) {
        case Nec.ViewLeft.OneLeft(x$28211) =>
            Nec.cons(List.Cons(x$28211, List.Nil), Nec.singleton(List.Nil))
        case Nec.ViewLeft.SomeLeft(x$28215, xs$28217) =>
            match Nec.fromList(
                List.subsequences(List.Cons(x$28215, Nec.toList(xs$28217)))
            ) {
                case Option.Some(ans$28220) =>
                    ans$28220
                case Option.None =>
                    unreachable!(())
            }
    }
}

def Nec.sum(c$28423: Nec[Int32]): Int32 = {<[unknown exp]>(c$28423)}

def Nec.sumWith(f$29304: a -> Int32, c$29319: Nec[a]): Int32 \ ef = {
    <[unknown exp]>(f$29304, c$29319)
}

def Nec.tail(c$23924: Nec[a]): List[a] = {
    match Nec.viewLeft(c$23924) {
        case Nec.ViewLeft.OneLeft(_) =>
            List.Nil
        case Nec.ViewLeft.SomeLeft(_, rs$23928) =>
            Nec.toList(rs$23928)
    }
}

def Nec.takeWhileLeft(f$31457: a -> Bool, c$31459: Nec[a]): List[a] \ ef = {
    letrec loop$31461: (
        Nec[a] -> (List[a] -> List[a]) -> List[a] \ ef
    ) = c1$31463 ->
        k$31465 ->
            match Nec.viewLeft(c1$31463) {
                case Nec.ViewLeft.OneLeft(x$31467) =>
                    if (f$31457(x$31467)) {
                        k$31465(List.Cons(x$31467, List.Nil))
                    } else {
                        k$31465(List.Nil)
                    }
                case Nec.ViewLeft.SomeLeft(x$31474, rs$31476) =>
                    if (f$31457(x$31474)) {
                        loop$31461(
                            rs$31476
                        )(ks$31480 -> k$31465(List.Cons(x$31474, ks$31480)))
                    } else {
                        k$31465(List.Nil)
                    }
            };
    loop$31461(c$31459)($0$46388 -> identity($0$46388))
}

def Nec.takeWhileRight(f$31493: a -> Bool, c$31495: Nec[a]): List[a] \ ef = {
    letrec loop$31502: (Nec[a] -> List[a] -> List[a] \ ef) = c1$31504 ->
        ac$31506 ->
            match Nec.viewRight(c1$31504) {
                case Nec.ViewRight.OneRight(x$31508) =>
                    if (f$31493(x$31508)) {
                        List.Cons(x$31508, ac$31506)
                    } else {
                        ac$31506
                    }
                case Nec.ViewRight.SomeRight(rs$31512, x$31514) =>
                    if (f$31493(x$31514)) {
                        loop$31502(rs$31512)(List.Cons(x$31514, ac$31506))
                    } else {
                        ac$31506
                    }
            };
    loop$31502(c$31495)(List.Nil)
}

def Nec.toArray(rc$30615: Region[r], c$30619: Nec[a]): Array[a, r] \ r = {
    let x$30635: a = Nec.head(c$30619);
    let arr$30637: Array[a, r] = Array.repeat(
        rc$30615,
        Nec.length(c$30619),
        x$30635
    );
    Nec.forEach(
        pat$90$30639 ->
            match pat$90$30639 {
                case (i$30641, b$30643) =>
                    Array.put(b$30643, i$30641, arr$30637)
            },
        Nec.zipWithIndex(c$30619)
    );
    arr$30637
}

def Nec.toList(c$30439: Nec[a]): List[a] = {
    Nec.foldRight(
        x$30450 ->
            acc$30452 ->
                List.Cons(x$30450, acc$30452),
        List.Nil,
        c$30439
    )
}

def Nec.toMap(c$30551: Nec[(a, b)]): Map[a, b] = {
    Nec.foldRight(
        x$30561 ->
            acc$30563 ->
                Map.insert(fst(x$30561), snd(x$30561), acc$30563),
        Map.empty(()),
        c$30551
    )
}

def Nec.toMapWith(f$30585: a -> b, l$30591: Nec[a]): Map[a, b] = {
    Nec.foldRight(
        x$30601 ->
            acc$30603 ->
                Map.insert(x$30601, f$30585(x$30601), acc$30603),
        Map.empty(()),
        l$30591
    )
}

def Nec.toMutDeque(rc$30464: Region[r], c$30466: Nec[a]): MutDeque[a, r] \ r = {
    let d$30468: MutDeque[a, r] = MutDeque.empty(rc$30464);
    Nec.forEach(x$30470 -> MutDeque.pushBack(x$30470, d$30468), c$30466);
    d$30468
}

def Nec.toMutList(rc1$30503: Region[r], c$30505: Nec[a]): MutList[a, r] \ r = {
    region rc2$30507 {
        Array.toMutList(rc1$30503, Nec.toArray(rc2$30507, c$30505))
    }
}

def Nec.toSet(c$30520: Nec[a]): Set[a] = {
    Nec.foldRight(
        x$30522 ->
            acc$30524 ->
                Set.insert(x$30522, acc$30524),
        Set.empty(()),
        c$30520
    )
}

def Nec.toVector(c$30655: Nec[a]): Vector[a] = {
    region rc$30666 {
        let arr$30669: Array[a, rc] = Array.empty(
            rc$30666,
            Nec.length(c$30655)
        );
        Nec.forEachWithIndex(
            i$30679 ->
                x$30682 ->
                    Array.put(x$30682, i$30679, arr$30669),
            c$30655
        );
        Array.toVector(arr$30669)
    }
}

def Nec.traverse(f$30975: a -> m[b], c$30983: Nec[a]): m[Nec[b]] \ ef = {
    letrec loop$30993: (
        Nec[a] -> (m[Nec[b]] -> m[Nec[b]]) -> m[Nec[b]] \ ef
    ) = l2$30995 ->
        k$30997 ->
            match Nec.viewLeft(l2$30995) {
                case Nec.ViewLeft.OneLeft(x$31001) =>
                    k$30997(
                        Functor.<$>(
                            x$$46382 ->
                                Nec.NecOne(x$$46382),
                            f$30975(x$31001)
                        )
                    )
                case Nec.ViewLeft.SomeLeft(x$31005, rs$31007) =>
                    let ans$31009: m[b] = f$30975(x$31005);
                    loop$30993(
                        rs$31007
                    )(ks$31011 -> k$30997(Nec.consA(ans$31009, ks$31011)))
            };
    loop$30993(c$30983)($0$46384 -> identity($0$46384))
}

def Nec.unzip(c$30043: Nec[(a, b)]): (Nec[a], Nec[b]) = {
    letrec loop$30045: (
        Nec[(a, b)] ->
            (Nec[a] -> (Nec[b] -> (Nec[a], Nec[b]))) -> (Nec[a], Nec[b])
    ) = c1$30047 ->
        k$30049 ->
            match Nec.viewLeft(c1$30047) {
                case Nec.ViewLeft.OneLeft(a$30051, b$30053) =>
                    k$30049(Nec.singleton(a$30051))(Nec.singleton(b$30053))
                case Nec.ViewLeft.SomeLeft((a$30055, b$30058), rs$30061) =>
                    loop$30045(
                        rs$30061
                    )(
                        ks$30064 ->
                            ls$30066 ->
                                k$30049(
                                    Nec.cons(a$30055, ks$30064)
                                )(Nec.cons(b$30058, ls$30066))
                    )
            };
    loop$30045(c$30043)(ks$30077 -> ls$30079 -> (ks$30077, ls$30079))
}

def Nec.viewLeft(c$24013: Nec[a]): ViewLeft[a] = {
    letrec loop$24015: (
        Nec[a] ->
            Option[Nec[a]] -> ((ViewLeft[a] -> ViewLeft[a]) -> ViewLeft[a])
    ) = c1$24017 ->
        rs$24023 ->
            k$24029 ->
                match (c1$24017, rs$24023) {
                    case (Nec.NecOne(x$24036), Option.None) =>
                        k$24029(Nec.ViewLeft.OneLeft(x$24036))
                    case (Nec.NecOne(x$24038), Option.Some(rs1$24040)) =>
                        k$24029(Nec.ViewLeft.SomeLeft(x$24038, rs1$24040))
                    case (Nec.Nec(l$24048, r$24050), Option.None) =>
                        loop$24015(l$24048)(Option.Some(r$24050))(k$24029)
                    case (Nec.Nec(l$24056, r$24058), Option.Some(rs1$24060)) =>
                        loop$24015(
                            l$24056
                        )(Option.Some(Nec.append(r$24058, rs1$24060)))(k$24029)
                };
    loop$24015(c$24013)(Option.None)(x$24069 -> x$24069)
}

def Nec.viewRight(c$24077: Nec[a]): ViewRight[a] = {
    letrec loop$24090: (
        Nec[a] ->
            Option[Nec[a]] -> ((ViewRight[a] -> ViewRight[a]) -> ViewRight[a])
    ) = c1$24092 ->
        rs$24094 ->
            k$24098 ->
                match (c1$24092, rs$24094) {
                    case (Nec.NecOne(x$24104), Option.None) =>
                        k$24098(Nec.ViewRight.OneRight(x$24104))
                    case (Nec.NecOne(x$24109), Option.Some(rs1$24111)) =>
                        k$24098(Nec.ViewRight.SomeRight(rs1$24111, x$24109))
                    case (Nec.Nec(l$24117, r$24119), Option.None) =>
                        loop$24090(r$24119)(Option.Some(l$24117))(k$24098)
                    case (Nec.Nec(l$24129, r$24131), Option.Some(rs1$24138)) =>
                        loop$24090(
                            r$24131
                        )(Option.Some(Nec.append(rs1$24138, l$24129)))(k$24098)
                };
    loop$24090(c$24077)(Option.None)(x$24142 -> x$24142)
}

def Nec.zip(c1$29885: Nec[a], c2$29891: Nec[b]): Nec[(a, b)] = {
    letrec loop$29895: (
        Nec[a] -> Nec[b] -> ((Nec[(a, b)] -> Nec[(a, b)]) -> Nec[(a, b)])
    ) = nec1$29897 ->
        nec2$29899 ->
            k$29901 ->
                match (Nec.viewLeft(nec1$29897), Nec.viewLeft(nec2$29899)) {
                    case (
                        Nec.ViewLeft.SomeLeft(x$29905, xs$29907),
                        Nec.ViewLeft.SomeLeft(y$29909, ys$29911)
                    ) =>
                        loop$29895(
                            xs$29907
                        )(
                            ys$29911
                        )(
                            ks$29915 ->
                                k$29901(Nec.cons((x$29905, y$29909), ks$29915))
                        )
                    case (
                        Nec.ViewLeft.OneLeft(x$29917),
                        Nec.ViewLeft.OneLeft(y$29919)
                    ) =>
                        k$29901(Nec.NecOne(x$29917, y$29919))
                    case (
                        Nec.ViewLeft.SomeLeft(x$29925, _),
                        Nec.ViewLeft.OneLeft(y$29927)
                    ) =>
                        k$29901(Nec.NecOne(x$29925, y$29927))
                    case (
                        Nec.ViewLeft.OneLeft(x$29935),
                        Nec.ViewLeft.SomeLeft(y$29937, _)
                    ) =>
                        k$29901(Nec.NecOne(x$29935, y$29937))
                };
    loop$29895(c1$29885)(c2$29891)(k$29941 -> k$29941)
}

def Nec.zipWith(
    f$29965: a -> b -> c \ ef,
    c1$29967: Nec[a],
    c2$29971: Nec[b]
): Nec[c] \ ef = {
    letrec loop$29973: (
        Nec[a] -> Nec[b] -> ((Nec[c] -> Nec[c] \ ef) -> Nec[c] \ ef)
    ) = nec1$29975 ->
        nec2$29981 ->
            k$29983 ->
                match (Nec.viewLeft(nec1$29975), Nec.viewLeft(nec2$29981)) {
                    case (
                        Nec.ViewLeft.OneLeft(x$29985),
                        Nec.ViewLeft.OneLeft(y$29987)
                    ) =>
                        let a$29989: c = f$29965(x$29985)(y$29987);
                        k$29983(Nec.singleton(a$29989))
                    case (
                        Nec.ViewLeft.OneLeft(x$29991),
                        Nec.ViewLeft.SomeLeft(y$29993, _)
                    ) =>
                        let a$29995: c = f$29965(x$29991)(y$29993);
                        k$29983(Nec.singleton(a$29995))
                    case (
                        Nec.ViewLeft.SomeLeft(x$29997, _),
                        Nec.ViewLeft.OneLeft(y$29999)
                    ) =>
                        let a$30001: c = f$29965(x$29997)(y$29999);
                        k$29983(Nec.singleton(a$30001))
                    case (
                        Nec.ViewLeft.SomeLeft(x$30003, rs$30005),
                        Nec.ViewLeft.SomeLeft(y$30007, qs$30009)
                    ) =>
                        let a$30011: c = f$29965(x$30003)(y$30007);
                        loop$29973(
                            rs$30005
                        )(
                            qs$30009
                        )(ks$30013 -> k$29983(Nec.cons(a$30011, ks$30013)))
                };
    loop$29973(c1$29967)(c2$29971)($0$46274 -> eidentity($0$46274))
}

def Nec.zipWithA(
    f$30137: a -> b -> f[c] \ ef,
    xs$30142: Nec[a],
    ys$30144: Nec[b]
): f[Nec[c]] \ ef = {
    letrec loop$30157: (
        ViewLeft[a] ->
            ViewLeft[b] -> ((f[Nec[c]] -> f[Nec[c]] \ (e119350 + ef) & ef) -> f[Nec[c]] \ ef)
    ) = v1$30160 ->
        v2$30162 ->
            k$30166 ->
                match (v1$30160, v2$30162) {
                    case (
                        Nec.ViewLeft.SomeLeft(x$30168, c1$30170),
                        Nec.ViewLeft.SomeLeft(y$30172, c2$30174)
                    ) =>
                        loop$30157(
                            Nec.viewLeft(c1$30170)
                        )(
                            Nec.viewLeft(c2$30174)
                        )(
                            ks$30176 ->
                                k$30166(
                                    Applicative.<*>(
                                        Functor.<$>(
                                            $0$46296 ->
                                                $1$46298 ->
                                                    Nec.cons(
                                                        $0$46296,
                                                        $1$46298
                                                    ),
                                            f$30137(x$30168)(y$30172)
                                        ),
                                        ks$30176
                                    )
                                )
                        )
                    case (
                        Nec.ViewLeft.SomeLeft(x$30178, _),
                        Nec.ViewLeft.OneLeft(y$30180)
                    ) =>
                        k$30166(
                            Functor.<$>(
                                $0$46302 ->
                                    Nec.singleton($0$46302),
                                f$30137(x$30178)(y$30180)
                            )
                        )
                    case (
                        Nec.ViewLeft.OneLeft(x$30182),
                        Nec.ViewLeft.SomeLeft(y$30184, _)
                    ) =>
                        k$30166(
                            Functor.<$>(
                                $0$46304 ->
                                    Nec.singleton($0$46304),
                                f$30137(x$30182)(y$30184)
                            )
                        )
                    case (
                        Nec.ViewLeft.OneLeft(x$30186),
                        Nec.ViewLeft.OneLeft(y$30188)
                    ) =>
                        k$30166(
                            Functor.<$>(
                                $0$46306 ->
                                    Nec.singleton($0$46306),
                                f$30137(x$30186)(y$30188)
                            )
                        )
                };
    loop$30157(
        Nec.viewLeft(xs$30142)
    )(Nec.viewLeft(ys$30144))($0$46308 -> eidentity($0$46308))
}

def Nec.zipWithIndex(c$30098: Nec[a]): Nec[(Int32, a)] = {
    letrec loop$30102: (
        Nec[a] ->
            (Nec[(Int32, a)] -> Nec[(Int32, a)]) -> (Int32 -> Nec[(Int32, a)])
    ) = c1$30105 ->
        k$30107 ->
            i$30109 ->
                match Nec.viewLeft(c1$30105) {
                    case Nec.ViewLeft.OneLeft(x$30113) =>
                        k$30107(Nec.NecOne(i$30109, x$30113))
                    case Nec.ViewLeft.SomeLeft(x$30117, rs$30119) =>
                        loop$30102(
                            rs$30119
                        )(
                            ks$30121 ->
                                k$30107(Nec.cons((i$30109, x$30117), ks$30121))
                        )(<[unknown exp]>(i$30109, 1i32))
                };
    loop$30102(c$30098)(k$30123 -> k$30123)(0i32)
}

enum Nec.ViewLeft[a] {case OneLeft(a) case SomeLeft(a, Nec[a])}

enum Nec.ViewRight[a] {case OneRight(a) case SomeRight(Nec[a], a)}

enum Nel[a] {case Nel(a, List[a])}

def Nel.ap(f$32095: Nel[a -> b \ ef], l$32097: Nel[a]): Nel[b] \ ef = {
    letrec loop$32099: (
        a -> b \ ef -> List[a -> b \ ef] -> ((Nel[b] -> Nel[b]) -> Nel[b] \ ef)
    ) = f1$32101 ->
        fs$32103 ->
            k$32105 ->
                match fs$32103 {
                    case List.Nil =>
                        k$32105(Nel.map(f1$32101, l$32097))
                    case List.Cons(f2$32116, rs$32118) =>
                        let ks1$32120: Nel[b] = Nel.map(f1$32101, l$32097);
                        loop$32099(
                            f2$32116
                        )(
                            rs$32118
                        )(
                            ks2$32122 ->
                                k$32105(Nel.append(ks1$32120, ks2$32122))
                        )
                };
    match f$32095 {
        case Nel.Nel(f1$32126, List.Nil) =>
            Nel.map(f1$32126, l$32097)
        case Nel.Nel(f1$32132, rs$32134) =>
            loop$32099(f1$32132)(rs$32134)($0$45995 -> identity($0$45995))
    }
}

def Nel.append(l1$29322: Nel[a], l2$29327: Nel[a]): Nel[a] = {
    match (l1$29322, l2$29327) {
        case (Nel.Nel(x$29339, xs$29341), Nel.Nel(y$29343, ys$29345)) =>
            Nel.Nel(
                x$29339,
                List.append(xs$29341, List.Cons(y$29343, ys$29345))
            )
    }
}

def Nel.cons(x$19387: a, l$19399: Nel[a]): Nel[a] = {
    match l$19399 {
        case Nel.Nel(y$19792, ys$19898) =>
            Nel.Nel(x$19387, List.Cons(y$19792, ys$19898))
    }
}

def Nel.count(f$32806: a -> Bool, l$32808: Nel[a]): Int32 \ ef = {
    match l$32808 {
        case Nel.Nel(x$32816, xs$32819) =>
            <[unknown exp]>(
                if (f$32806(x$32816)) {1i32} else {0i32},
                List.count(f$32806, xs$32819)
            )
    }
}

def Nel.dropWhile(f$33967: a -> Bool, l$33971: Nel[a]): List[a] \ ef = {
    match l$33971 {
        case Nel.Nel(x$33975, xs$33977) =>
            List.dropWhile(f$33967, List.Cons(x$33975, xs$33977))
    }
}

def Nel.enumerator(
    rc$33819: Region[r],
    l$33824: Nel[a]
): Iterator[(Int32, a), r, r] \ r = {
    |>(
        Nel.iterator(rc$33819, l$33824),
        $0$46101 ->
            Iterator.zipWithIndex($0$46101)
    )
}

def Nel.exists(f$32955: a -> Bool, l$32959: Nel[a]): Bool \ ef = {
    match l$32959 {
        case Nel.Nel(x$32963, xs$32965) =>
            if (f$32955(x$32963)) {true} else {List.exists(f$32955, xs$32965)}
    }
}

def Nel.filter(f$33047: a -> Bool, l$33051: Nel[a]): List[a] = {
    match l$33051 {
        case Nel.Nel(x$33078, xs$33080) =>
            if (f$33047(x$33078)) {
                List.Cons(x$33078, List.filter(f$33047, xs$33080))
            } else {
                List.filter(f$33047, xs$33080)
            }
    }
}

def Nel.find(f$31893: a -> Bool, l$31897: Nel[a]): Option[a] \ ef = {
    Nel.findLeft(f$31893, l$31897)
}

def Nel.findLeft(f$31922: a -> Bool, l$31924: Nel[a]): Option[a] \ ef = {
    match l$31924 {
        case Nel.Nel(x$31926, xs$31928) =>
            if (f$31922(x$31926)) {
                Option.Some(x$31926)
            } else {
                List.findLeft(f$31922, xs$31928)
            }
    }
}

def Nel.findRight(f$31956: a -> Bool, l$31972: Nel[a]): Option[a] \ ef = {
    match l$31972 {
        case Nel.Nel(x$31988, xs$31990) =>
            match List.findRight(f$31956, xs$31990) {
                case Option.None =>
                    if (f$31956(x$31988)) {
                        Option.Some(x$31988)
                    } else {
                        Option.None
                    }
                case Option.Some(y$31996) =>
                    Option.Some(y$31996)
            }
    }
}

def Nel.flatMap(f$32164: a -> Nel[b], l$32184: Nel[a]): Nel[b] \ ef = {
    match l$32184 {
        case Nel.Nel(x$32198, xs$32200) =>
            match f$32164(x$32198) {
                case Nel.Nel(y$32202, ys$32204) =>
                    Nel.Nel(
                        y$32202,
                        List.append(
                            ys$32204,
                            List.flatMap(
                                z$32206 ->
                                    Nel.toList(f$32164(z$32206)),
                                xs$32200
                            )
                        )
                    )
            }
    }
}

def Nel.flatten(l$32920: Nel[Nel[a]]): Nel[a] = {
    match l$32920 {
        case Nel.Nel(Nel.Nel(y$32922, ys$32924), xs$32926) =>
            Nel.Nel(
                y$32922,
                List.append(
                    ys$32924,
                    List.flatMap($0$46045 -> Nel.toList($0$46045), xs$32926)
                )
            )
    }
}

def Nel.fold(l$32319: Nel[a]): a = {Foldable.fold(l$32319)}

def Nel.foldLeft(
    f$32332: b -> a -> b \ ef,
    s$32334: b,
    l$32336: Nel[a]
): b \ ef = {
    match l$32336 {
        case Nel.Nel(x$32338, xs$32340) =>
            List.foldLeft(f$32332, f$32332(s$32334)(x$32338), xs$32340)
    }
}

def Nel.foldMap(f$32555: a -> b, l$32561: Nel[a]): b \ ef = {
    Nel.foldLeft(
        acc$32572 ->
            x$32576 ->
                <[unknown exp]>(acc$32572, f$32555(x$32576)),
        <[unknown exp]>(()),
        l$32561
    )
}

def Nel.foldRight(
    f$32355: a -> b -> b \ ef,
    s$32357: b,
    l$32359: Nel[a]
): b \ ef = {
    match l$32359 {
        case Nel.Nel(x$32361, xs$32363) =>
            f$32355(x$32361)(List.foldRight(f$32355, s$32357, xs$32363))
    }
}

def Nel.foldRightWithCont(
    f$32517: a -> (Unit -> b \ ef) -> b \ ef,
    z$32520: b,
    l$32523: Nel[a]
): b \ ef = {
    match l$32523 {
        case Nel.Nel(x$32529, xs$32531) =>
            f$32517(
                x$32529
            )(_$32533 -> List.foldRightWithCont(f$32517, z$32520, xs$32531))
    }
}

def Nel.forAll(f$32999: a -> Bool, l$33001: Nel[a]): Bool \ ef = {
    match l$33001 {
        case Nel.Nel(x$33022, xs$33024) =>
            if (f$32999(x$33022)) {List.forAll(f$32999, xs$33024)} else {false}
    }
}

def Nel.forEach(f$33645: a -> Unit, l$33647: Nel[a]): Unit \ ef = {
    match l$33647 {
        case Nel.Nel(x$33656, xs$33658) =>
            f$33645(x$33656); List.forEach(f$33645, xs$33658)
    }
}

def Nel.forEachWithIndex(
    f$33676: Int32 -> a -> Unit \ ef,
    l$33686: Nel[a]
): Unit \ ef = {
    match l$33686 {
        case Nel.Nel(x$33694, xs$33696) =>
            List.forEachWithIndex(f$33676, List.Cons(x$33694, xs$33696))
    }
}

def Nel.head(l$20689: Nel[a]): a = {
    match l$20689 {case Nel.Nel(x$20744, _) => x$20744}
}

def Nel.init(l$21748: Nel[a]): List[a] = {
    match l$21748 {
        case Nel.Nel(_, List.Nil) =>
            List.Nil
        case Nel.Nel(x$21767, xs$21770) =>
            match List.reverse(xs$21770) {
                case List.Nil =>
                    List.Cons(x$21767, List.Nil)
                case List.Cons(_, ys$22881) =>
                    List.Cons(x$21767, List.reverse(ys$22881))
            }
    }
}

def Nel.intersperse(a$32306: a, l$32308: Nel[a]): Nel[a] = {
    match l$32308 {
        case Nel.Nel(x$32310, List.Nil) =>
            Nel.Nel(x$32310, List.Nil)
        case Nel.Nel(x$32312, xs$32314) =>
            Nel.Nel(
                x$32312,
                List.Cons(a$32306, List.intersperse(a$32306, xs$32314))
            )
    }
}

def Nel.iterator(
    rc$33800: Region[r],
    l$33802: Nel[a]
): Iterator[a, r, r] \ r = {
    match l$33802 {
        case Nel.Nel(x$33810, xs$33812) =>
            List.iterator(rc$33800, List.Cons(x$33810, xs$33812))
    }
}

def Nel.join(sep$33934: String, l$33936: Nel[a]): String = {
    <[unknown exp]>(sep$33934, l$33936)
}

def Nel.joinWith(
    f$33947: a -> String,
    sep$33949: String,
    l$33951: Nel[a]
): String \ ef = {
    <[unknown exp]>(f$33947, sep$33949, l$33951)
}

def Nel.last(l$21280: Nel[a]): a = {
    match l$21280 {
        case Nel.Nel(x$21711, xs$21713) =>
            Option.getWithDefault(x$21711, List.last(xs$21713))
    }
}

def Nel.length(l$28660: Nel[a]): Int32 = {
    match l$28660 {
        case Nel.Nel(_, xs$28668) =>
            <[unknown exp]>(1i32, List.length(xs$28668))
    }
}

def Nel.map(f$32004: a -> b, l$32006: Nel[a]): Nel[b] \ ef = {
    match l$32006 {
        case Nel.Nel(x$32012, xs$32017) =>
            Nel.Nel(f$32004(x$32012), List.map(f$32004, xs$32017))
    }
}

def Nel.mapWithIndex(
    f$32039: Int32 -> a -> b \ ef,
    l$32045: Nel[a]
): Nel[b] \ ef = {
    match l$32045 {
        case Nel.Nel(x$32049, xs$32053) =>
            match List.mapWithIndex(f$32039, List.Cons(x$32049, xs$32053)) {
                case List.Cons(y$32076, ys$32081) =>
                    Nel.Nel(y$32076, ys$32081)
                case _ =>
                    unreachable!(())
            }
    }
}

def Nel.maximum(l$31797: Nel[a]): a = {
    Nel.reduceLeft(
        $0$45961 ->
            $1$45963 ->
                <[unknown exp]>($0$45961, $1$45963),
        l$31797
    )
}

def Nel.maximumBy(cmp$31864: a -> a -> Comparison, l$31866: Nel[a]): a = {
    Nel.reduceLeft(
        (
            $0$45967 ->
                $1$45969 ->
                    $2$45971 ->
                        Order.maxBy($0$45967, $1$45969, $2$45971)
        )(cmp$31864),
        l$31866
    )
}

def Nel.memberOf(a$29370: a, l$29373: Nel[a]): Bool = {
    match l$29373 {
        case Nel.Nel(x$29383, xs$29386) =>
            if (<[unknown exp]>(x$29383, a$29370)) {
                true
            } else {
                List.memberOf(a$29370, xs$29386)
            }
    }
}

def Nel.minimum(l$29444: Nel[a]): a = {
    Nel.reduceLeft(
        $0$45949 ->
            $1$45951 ->
                <[unknown exp]>($0$45949, $1$45951),
        l$29444
    )
}

def Nel.minimumBy(cmp$30848: a -> a -> Comparison, l$31284: Nel[a]): a = {
    Nel.reduceLeft(
        (
            $0$45953 ->
                $1$45955 ->
                    $2$45957 ->
                        Order.minBy($0$45953, $1$45955, $2$45957)
        )(cmp$30848),
        l$31284
    )
}

def Nel.permutations(l$32252: Nel[a]): Nel[List[a]] = {
    match l$32252 {
        case Nel.Nel(x$32268, xs$32270) =>
            match List.permutations(List.Cons(x$32268, xs$32270)) {
                case List.Cons(y$32272, ys$32274) =>
                    Nel.Nel(y$32272, ys$32274)
                case List.Nil =>
                    unreachable!(())
            }
    }
}

def Nel.reduce(l$32682: Nel[a]): a = {
    match l$32682 {
        case Nel.Nel(x$32684, xs$32686) =>
            <[unknown exp]>(
                acc$32688 ->
                    y$32690 ->
                        <[unknown exp]>(acc$32688, y$32690),
                x$32684,
                xs$32686
            )
    }
}

def Nel.reduceLeft(f$32704: a -> a -> a \ ef, l$32710: Nel[a]): a \ ef = {
    match l$32710 {
        case Nel.Nel(x$32724, xs$32726) =>
            List.foldLeft(f$32704, x$32724, xs$32726)
    }
}

def Nel.reduceLeftTo(
    f$32619: b -> a -> b \ ef1,
    g$32621: a -> b,
    l$32623: Nel[a]
): b \ ef1 + ef2 = {
    match l$32623 {
        case Nel.Nel(x$32625, xs$32627) =>
            List.foldLeft(f$32619, g$32621(x$32625), xs$32627)
    }
}

def Nel.reduceRight(f$32741: a -> a -> a \ ef, l$32753: Nel[a]): a \ ef = {
    match l$32753 {
        case Nel.Nel(x$32755, xs$32758) =>
            match List.reduceRight(f$32741, List.Cons(x$32755, xs$32758)) {
                case Option.None =>
                    unreachable!(())
                case Option.Some(v$32768) =>
                    v$32768
            }
    }
}

def Nel.reduceRightTo(
    f$32633: a -> b -> b \ ef1,
    g$32645: a -> b,
    l$32647: Nel[a]
): b \ ef1 + ef2 = {
    letrec loop$32651: (
        List[a] -> (b -> b \ ef1 + (ef2 & e114462)) -> b \ ef1 + ef2 + ef1 + ef2
    ) = ll$32653 ->
        k$32655 ->
            match ll$32653 {
                case List.Cons(x$32657, List.Nil) =>
                    k$32655(g$32645(x$32657))
                case List.Cons(x$32659, xs$32661) =>
                    loop$32651(
                        xs$32661
                    )(ks$32663 -> k$32655(f$32633(x$32659)(ks$32663)))
                case _ =>
                    unreachable!(())
            };
    match l$32647 {
        case Nel.Nel(x$32675, xs$32677) =>
            loop$32651(
                List.Cons(x$32675, xs$32677)
            )($0$46035 -> eidentity($0$46035))
    }
}

def Nel.replace(
    src$32241: { src = a },
    dst$32243: { dst = a },
    l$32245: Nel[a]
): Nel[a] = {
    Nel.map(
        e$32247 ->
            if (<[unknown exp]>(e$32247, src$32241.src)) {
                dst$32243.dst
            } else {
                e$32247
            },
        l$32245
    )
}

def Nel.reverse(l$32220: Nel[a]): Nel[a] = {
    match l$32220 {
        case Nel.Nel(x$32222, xs$32224) =>
            match List.reverse(List.Cons(x$32222, xs$32224)) {
                case List.Cons(y$32226, ys$32228) =>
                    Nel.Nel(y$32226, ys$32228)
                case _ =>
                    unreachable!(())
            }
    }
}

def Nel.sequence(l$33841: Nel[m[a]]): m[Nel[a]] = {
    match l$33841 {
        case Nel.Nel(x$33851, xs$33853) =>
            <[unknown exp]>(
                <[unknown exp]>(
                    y$33855 ->
                        ys$33857 ->
                            Nel.Nel(y$33855, ys$33857),
                    x$33851
                ),
                <[unknown exp]>(xs$33853)
            )
    }
}

def Nel.shuffle(rnd$34012: Random, l$34014: Nel[a]): Option[Nel[a]] \ IO = {
    region rc$34018 {
        |>(
            !>(
                Nel.toArray(rc$34018, l$34014),
                (
                    $0$46166 ->
                        $1$46168 ->
                            Array.shuffle($0$46166, $1$46168)
                )(rnd$34012)
            ),
            $0$46170 ->
                Array.toNel($0$46170)
        )
    }
}

def Nel.singleton(x$18751: a): Nel[a] = {Nel.Nel(x$18751, List.Nil)}

def Nel.sort(l$33724: Nel[a]): Nel[a] = {
    region rc$33728 {
        let list$33731: List[a] = |>(
            !>(
                Nel.toArray(rc$33728, l$33724),
                $0$46085 ->
                    Array.sort!($0$46085)
            ),
            $0$46087 ->
                Array.toList($0$46087)
        );
        match list$33731 {
            case List.Cons(x$33737, xs$33741) =>
                Nel.Nel(x$33737, xs$33741)
            case _ =>
                unreachable!(())
        }
    }
}

def Nel.sortBy(f$33759: a -> b, l$33761: Nel[a]): Nel[a] = {
    region rc$33763 {
        let list$33766: List[a] = |>(
            !>(
                Nel.toArray(rc$33763, l$33761),
                (
                    $0$46089 ->
                        $1$46091 ->
                            Array.sortBy!($0$46089, $1$46091)
                )(f$33759)
            ),
            $0$46093 ->
                Array.toList($0$46093)
        );
        match list$33766 {
            case List.Cons(x$33768, xs$33770) =>
                Nel.Nel(x$33768, xs$33770)
            case _ =>
                unreachable!(())
        }
    }
}

def Nel.sortWith(cmp$33774: a -> a -> Comparison, l$33776: Nel[a]): Nel[a] = {
    region rc$33778 {
        let list$33781: List[a] = |>(
            !>(
                Nel.toArray(rc$33778, l$33776),
                (
                    $0$46095 ->
                        $1$46097 ->
                            Array.sortWith!($0$46095, $1$46097)
                )(cmp$33774)
            ),
            $0$46099 ->
                Array.toList($0$46099)
        );
        match list$33781 {
            case List.Cons(x$33783, xs$33785) =>
                Nel.Nel(x$33783, xs$33785)
            case _ =>
                unreachable!(())
        }
    }
}

def Nel.subsequences(l$32281: Nel[a]): Nel[List[a]] = {
    match l$32281 {
        case Nel.Nel(x$32285, xs$32287) =>
            match List.subsequences(List.Cons(x$32285, xs$32287)) {
                case List.Cons(y$32289, ys$32291) =>
                    Nel.Nel(y$32289, ys$32291)
                case List.Nil =>
                    unreachable!(())
            }
    }
}

def Nel.sum(l$32849: Nel[Int32]): Int32 = {<[unknown exp]>(l$32849)}

def Nel.sumWith(f$32874: a -> Int32, l$32882: Nel[a]): Int32 \ ef = {
    <[unknown exp]>(f$32874, l$32882)
}

def Nel.tail(l$28650: Nel[a]): List[a] = {
    match l$28650 {case Nel.Nel(_, xs$28652) => xs$28652}
}

def Nel.takeWhile(f$33987: a -> Bool, l$33991: Nel[a]): List[a] \ ef = {
    match l$33991 {
        case Nel.Nel(x$33993, xs$33995) =>
            List.takeWhile(f$33987, List.Cons(x$33993, xs$33995))
    }
}

def Nel.toArray(rc$33515: Region[r], l$33519: Nel[a]): Array[a, r] \ r = {
    |>(
        |>(l$33519, $0$46073 -> Nel.toList($0$46073)),
        ($0$46075 -> $1$46077 -> List.toArray($0$46075, $1$46077))(rc$33515)
    )
}

def Nel.toList(l$33484: Nel[a]): List[a] = {
    match l$33484 {
        case Nel.Nel(x$33486, xs$33488) =>
            List.Cons(x$33486, xs$33488)
    }
}

def Nel.toMapWith(f$33914: a -> b, l$33916: Nel[a]): Map[a, b] = {
    Nel.foldRight(
        x$33919 ->
            acc$33921 ->
                Map.insert(x$33919, f$33914(x$33919), acc$33921),
        Map.empty(()),
        l$33916
    )
}

def Nel.toMutDeque(rc$33597: Region[r], l$33599: Nel[a]): MutDeque[a, r] \ r = {
    let d$33605: MutDeque[a, r] = MutDeque.empty(rc$33597);
    Nel.forEach(x$33614 -> MutDeque.pushBack(x$33614, d$33605), l$33599);
    d$33605
}

def Nel.toString(l$18677: Nel[a]): String = {
    region rc$18687 {
        match l$18677 {
            case Nel.Nel(x$18695, xs$18699) =>
                let sb$18702: StringBuilder[rc] = StringBuilder.empty(rc$18687);
                StringBuilder.appendString!(
                    (
                        ("""""" + """Nel(""") + <[unknown exp]>(x$18695)
                    ) + """, """,
                    sb$18702
                );
                let list$18711: String = List.toString(xs$18699);
                StringBuilder.appendString!(list$18711, sb$18702);
                StringBuilder.appendString!(""")""", sb$18702);
                StringBuilder.toString(sb$18702)
        }
    }
}

def Nel.toVector(l$33565: Nel[a]): Vector[a] = {
    region rc$33571 {
        let arr$33574: Array[a, rc] = Array.empty(
            rc$33571,
            Nel.length(l$33565)
        );
        Nel.forEachWithIndex(
            i$33577 ->
                x$33579 ->
                    Array.put(x$33579, i$33577, arr$33574),
            l$33565
        );
        Array.toVector(arr$33574)
    }
}

def Nel.traverse(f$33870: a -> m[b], l$33876: Nel[a]): m[Nel[b]] \ ef = {
    match l$33876 {
        case Nel.Nel(x$33884, xs$33886) =>
            <[unknown exp]>(
                <[unknown exp]>(
                    y$33890 ->
                        ys$33892 ->
                            Nel.Nel(y$33890, ys$33892),
                    f$33870(x$33884)
                ),
                <[unknown exp]>(f$33870, xs$33886)
            )
    }
}

def Nel.unzip(l$33234: Nel[(a, b)]): (Nel[a], Nel[b]) = {
    match l$33234 {
        case Nel.Nel((a$33236, b$33238), xs$33240) =>
            match List.unzip(xs$33240) {
                case (l1$33247, l2$33249) =>
                    (Nel.Nel(a$33236, l1$33247), Nel.Nel(b$33238, l2$33249))
            }
    }
}

def Nel.zip(l1$33109: Nel[a], l2$33117: Nel[b]): Nel[(a, b)] = {
    match (l1$33109, l2$33117) {
        case (Nel.Nel(x$33127, xs$33129), Nel.Nel(y$33131, ys$33133)) =>
            Nel.Nel((x$33127, y$33131), List.zip(xs$33129, ys$33133))
    }
}

def Nel.zipWith(
    f$33177: a -> b -> c \ ef,
    l1$33179: Nel[a],
    l2$33181: Nel[b]
): Nel[c] \ ef = {
    match (l1$33179, l2$33181) {
        case (Nel.Nel(x$33190, xs$33192), Nel.Nel(y$33194, ys$33196)) =>
            Nel.Nel(
                f$33177(x$33190)(y$33194),
                List.zipWith(f$33177, xs$33192, ys$33196)
            )
    }
}

def Nel.zipWithA(
    f$33387: a -> b -> m[c] \ ef,
    xs$33392: Nel[a],
    ys$33395: Nel[b]
): m[Nel[c]] \ ef = {
    <[unknown exp]>
}

def Nel.zipWithIndex(l$33296: Nel[a]): Nel[(Int32, a)] = {
    letrec loop$33300: (
        List[a] ->
            (List[(Int32, a)] -> List[(Int32, a)]) -> (Int32 -> List[(Int32, a)])
    ) = ll$33302 ->
        k$33306 ->
            i$33308 ->
                match ll$33302 {
                    case List.Cons(x$33311, xs$33313) =>
                        loop$33300(
                            xs$33313
                        )(
                            ks$33318 ->
                                k$33306(List.Cons((i$33308, x$33311), ks$33318))
                        )(<[unknown exp]>(i$33308, 1i32))
                    case List.Nil =>
                        k$33306(List.Nil)
                };
    match l$33296 {
        case Nel.Nel(x$33343, xs$33345) =>
            Nel.Nel(
                (0i32, x$33343),
                loop$33300(xs$33345)($0$46065 -> identity($0$46065))(1i32)
            )
    }
}

def Object.isNull(x$20200: a): Bool = {<[unknown exp]>}

def Object.toOption(x$20267: a): Option[a] = {
    if (Object.isNull(x$20267)) {Option.None} else {Option.Some(x$20267)}
}

enum Option[t] {case None(Unit) case Some(t)}

def Option.ap(
    f$35936: Option[a -> b \ ef],
    x$35938: Option[a]
): Option[b] \ ef = {
    match f$35936 {
        case Option.None =>
            Option.None
        case Option.Some(g$35953) =>
            match x$35938 {
                case Option.None =>
                    Option.None
                case Option.Some(y$35957) =>
                    Option.Some(g$35953(y$35957))
            }
    }
}

def Option.count(f$36064: a -> Bool, o$36066: Option[a]): Int32 \ ef = {
    match o$36066 {
        case Option.None =>
            0i32
        case Option.Some(v$36098) =>
            if (f$36064(v$36098)) {1i32} else {0i32}
    }
}

def Option.empty(_unit$35366: Unit): Option[a] = {Option.None}

def Option.enumerator(
    rc$38029: Region[r],
    o$38031: Option[a]
): Iterator[(Int32, a), r, r] \ r = {
    |>(
        Option.iterator(rc$38029, o$38031),
        $0$46674 ->
            Iterator.zipWithIndex($0$46674)
    )
}

def Option.exists(f$35647: a -> Bool, o$35655: Option[a]): Bool \ ef = {
    match o$35655 {
        case Option.None =>
            false
        case Option.Some(v$35672) =>
            f$35647(v$35672)
    }
}

def Option.filter(f$35772: a -> Bool, o$35774: Option[a]): Option[a] \ ef = {
    match o$35774 {
        case Option.None =>
            Option.None
        case Option.Some(v$35776) =>
            if (f$35772(v$35776)) {o$35774} else {Option.None}
    }
}

def Option.find(f$36220: a -> Bool, o$36222: Option[a]): Option[a] = {
    match o$36222 {
        case Option.None =>
            Option.None
        case Option.Some(v$36224) =>
            if (f$36220(v$36224)) {o$36222} else {Option.None}
    }
}

def Option.flatMap(
    f$36037: a -> Option[b],
    o$36040: Option[a]
): Option[b] \ ef = {
    match o$36040 {
        case Option.None =>
            Option.None
        case Option.Some(v$36042) =>
            f$36037(v$36042)
    }
}

def Option.flatten(o$36275: Option[Option[a]]): Option[a] = {
    match o$36275 {
        case Option.None =>
            Option.None
        case Option.Some(v$36343) =>
            v$36343
    }
}

def Option.fold(o$36360: Option[a]): a = {Foldable.fold(o$36360)}

def Option.foldLeft(
    f$36375: b -> a -> b \ ef,
    z$36393: b,
    o$36395: Option[a]
): b \ ef = {
    match o$36395 {
        case Option.None =>
            z$36393
        case Option.Some(v$36403) =>
            f$36375(z$36393)(v$36403)
    }
}

def Option.foldLeftM(
    f$36834: b -> a -> Option[b] \ ef,
    s$36838: b,
    l$36844: List[a]
): Option[b] \ ef = {
    match l$36844 {
        case List.Nil =>
            Option.Some(s$36838)
        case List.Cons(x$36864, xs$36867) =>
            match f$36834(s$36838)(x$36864) {
                case Option.Some(s1$36873) =>
                    Option.foldLeftM(f$36834, s1$36873, xs$36867)
                case Option.None =>
                    Option.None
            }
    }
}

def Option.foldMap(f$36472: a -> b, o$36476: Option[a]): b \ ef = {
    Option.foldLeft(
        acc$36482 ->
            x$36484 ->
                <[unknown exp]>(acc$36482, f$36472(x$36484)),
        <[unknown exp]>(()),
        o$36476
    )
}

def Option.foldRight(
    f$36412: a -> b -> b \ ef,
    o$36420: Option[a],
    z$36422: b
): b \ ef = {
    match o$36420 {
        case Option.None =>
            z$36422
        case Option.Some(v$36424) =>
            f$36412(v$36424)(z$36422)
    }
}

def Option.foldRightM(
    f$36915: a -> b -> Option[b] \ ef,
    s$36923: b,
    l$36925: List[a]
): Option[b] \ ef = {
    letrec loop$36929: (
        List[a] ->
            (b -> Option[b] \ ef & ((~(e111291 + ef)) + e54254 + ef)) -> Option[b] \ ((e111291 + ef) & ef) + ef
    ) = ll$36931 ->
        k$36933 ->
            match ll$36931 {
                case List.Nil =>
                    k$36933(s$36923)
                case List.Cons(x$36935, xs$36937) =>
                    loop$36929(
                        xs$36937
                    )(
                        s1$36939 ->
                            match f$36915(x$36935)(s1$36939) {
                                case Option.Some(s2$36941) =>
                                    k$36933(s2$36941)
                                case Option.None =>
                                    Option.None
                            }
                    )
            };
    loop$36929(l$36925)(s1$36960 -> <[unknown exp]>)
}

def Option.foldRightWithCont(
    f$36445: a -> (Unit -> b \ ef) -> b \ ef,
    o$36461: Option[a],
    z$36463: b
): b \ ef = {
    match o$36461 {
        case Option.None =>
            z$36463
        case Option.Some(v$36467) =>
            f$36445(v$36467)(constant(z$36463))
    }
}

def Option.forAll(f$35680: a -> Bool, o$35682: Option[a]): Bool \ ef = {
    match o$35682 {
        case Option.None =>
            true
        case Option.Some(v$35692) =>
            f$35680(v$35692)
    }
}

def Option.forEach(f$37590: a -> Unit, o$37593: Option[a]): Unit \ ef = {
    match o$37593 {
        case Option.None =>
            ()
        case Option.Some(v$37595) =>
            f$37590(v$37595)
    }
}

def Option.getWithDefault(d$35428: a, o$35430: Option[a]): a = {
    match o$35430 {
        case Option.None =>
            d$35428
        case Option.Some(v$35451) =>
            v$35451
    }
}

def Option.isEmpty(o$35383: Option[a]): Bool = {
    match o$35383 {case Option.None => true case Option.Some(_) => false}
}

def Option.iterator(
    rc$38007: Region[r],
    o$38009: Option[a]
): Iterator[a, r, r] \ r = {
    match o$38009 {
        case Option.None =>
            Iterator.empty(rc$38007)
        case Option.Some(x$38017) =>
            Iterator.singleton(rc$38007, x$38017)
    }
}

def Option.map(f$35830: a -> b, o$35838: Option[a]): Option[b] \ ef = {
    match o$35838 {
        case Option.None =>
            Option.None
        case Option.Some(v$35864) =>
            Option.Some(f$35830(v$35864))
    }
}

def Option.map10(
    f$37965: t1 ->
        t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> (t8 -> (t9 -> (t10 -> u \ ef)))))))),
    o1$37967: Option[t1],
    o2$37969: Option[t2],
    o3$37971: Option[t3],
    o4$37973: Option[t4],
    o5$37975: Option[t5],
    o6$37979: Option[t6],
    o7$37981: Option[t7],
    o8$37983: Option[t8],
    o9$37987: Option[t9],
    o10$37989: Option[t10]
): Option[u] \ ef = {
    Option.ap(
        Option.map9(
            f$37965,
            o1$37967,
            o2$37969,
            o3$37971,
            o4$37973,
            o5$37975,
            o6$37979,
            o7$37981,
            o8$37983,
            o9$37987
        ),
        o10$37989
    )
}

def Option.map2(
    f$37615: t1 -> t2 -> u \ ef,
    o1$37621: Option[t1],
    o2$37623: Option[t2]
): Option[u] \ ef = {
    Option.ap(Option.map(f$37615, o1$37621), o2$37623)
}

def Option.map3(
    f$37641: t1 -> t2 -> (t3 -> u \ ef),
    o1$37643: Option[t1],
    o2$37645: Option[t2],
    o3$37647: Option[t3]
): Option[u] \ ef = {
    Option.ap(Option.map2(f$37641, o1$37643, o2$37645), o3$37647)
}

def Option.map4(
    f$37668: t1 -> t2 -> (t3 -> (t4 -> u \ ef)),
    o1$37672: Option[t1],
    o2$37675: Option[t2],
    o3$37677: Option[t3],
    o4$37681: Option[t4]
): Option[u] \ ef = {
    Option.ap(Option.map3(f$37668, o1$37672, o2$37675, o3$37677), o4$37681)
}

def Option.map5(
    f$37697: t1 -> t2 -> (t3 -> (t4 -> (t5 -> u \ ef))),
    o1$37706: Option[t1],
    o2$37708: Option[t2],
    o3$37710: Option[t3],
    o4$37712: Option[t4],
    o5$37714: Option[t5]
): Option[u] \ ef = {
    Option.ap(
        Option.map4(f$37697, o1$37706, o2$37708, o3$37710, o4$37712),
        o5$37714
    )
}

def Option.map6(
    f$37753: t1 -> t2 -> (t3 -> (t4 -> (t5 -> (t6 -> u \ ef)))),
    o1$37762: Option[t1],
    o2$37765: Option[t2],
    o3$37767: Option[t3],
    o4$37769: Option[t4],
    o5$37771: Option[t5],
    o6$37775: Option[t6]
): Option[u] \ ef = {
    Option.ap(
        Option.map5(f$37753, o1$37762, o2$37765, o3$37767, o4$37769, o5$37771),
        o6$37775
    )
}

def Option.map7(
    f$37799: t1 -> t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> u \ ef))))),
    o1$37811: Option[t1],
    o2$37813: Option[t2],
    o3$37815: Option[t3],
    o4$37817: Option[t4],
    o5$37819: Option[t5],
    o6$37821: Option[t6],
    o7$37823: Option[t7]
): Option[u] \ ef = {
    Option.ap(
        Option.map6(
            f$37799,
            o1$37811,
            o2$37813,
            o3$37815,
            o4$37817,
            o5$37819,
            o6$37821
        ),
        o7$37823
    )
}

def Option.map8(
    f$37843: t1 -> t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> (t8 -> u \ ef)))))),
    o1$37846: Option[t1],
    o2$37848: Option[t2],
    o3$37850: Option[t3],
    o4$37852: Option[t4],
    o5$37855: Option[t5],
    o6$37858: Option[t6],
    o7$37862: Option[t7],
    o8$37866: Option[t8]
): Option[u] \ ef = {
    Option.ap(
        Option.map7(
            f$37843,
            o1$37846,
            o2$37848,
            o3$37850,
            o4$37852,
            o5$37855,
            o6$37858,
            o7$37862
        ),
        o8$37866
    )
}

def Option.map9(
    f$37888: t1 ->
        t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> (t8 -> (t9 -> u \ ef))))))),
    o1$37900: Option[t1],
    o2$37902: Option[t2],
    o3$37909: Option[t3],
    o4$37911: Option[t4],
    o5$37913: Option[t5],
    o6$37916: Option[t6],
    o7$37919: Option[t7],
    o8$37922: Option[t8],
    o9$37927: Option[t9]
): Option[u] \ ef = {
    Option.ap(
        Option.map8(
            f$37888,
            o1$37900,
            o2$37902,
            o3$37909,
            o4$37911,
            o5$37913,
            o6$37916,
            o7$37919,
            o8$37922
        ),
        o9$37927
    )
}

def Option.nonEmpty(o$35425: Option[a]): Bool = {!Option.isEmpty(o$35425)}

def Option.point(x$35892: a): Option[a] = {Option.Some(x$35892)}

def Option.replace(
    src$35557: { src = a },
    dst$35563: { dst = a },
    o$35565: Option[a]
): Option[a] = {
    match o$35565 {
        case Option.None =>
            o$35565
        case Option.Some(v$35577) =>
            Option.Some(
                if (<[unknown exp]>(v$35577, src$35557.src)) {
                    dst$35563.dst
                } else {
                    v$35577
                }
            )
    }
}

def Option.sequence(l$36495: List[Option[a]]): Option[List[a]] = {
    letrec loop$36497: (
        List[Option[a]] -> (List[a] -> Option[List[a]]) -> Option[List[a]]
    ) = ll$36499 ->
        k$36501 ->
            match ll$36499 {
                case List.Nil =>
                    k$36501(List.Nil)
                case List.Cons(Option.None, _) =>
                    Option.None
                case List.Cons(Option.Some(x$36515), xs$36517) =>
                    loop$36497(
                        xs$36517
                    )(ks$36519 -> k$36501(List.Cons(x$36515, ks$36519)))
            };
    loop$36497(l$36495)(ks$36523 -> Option.Some(ks$36523))
}

def Option.sum(o$36126: Option[Int32]): Int32 = {<[unknown exp]>(o$36126)}

def Option.sumWith(f$36176: a -> Int32, o$36184: Option[a]): Int32 \ ef = {
    <[unknown exp]>(f$36176, o$36184)
}

def Option.toErr(d$37404: t, o$37410: Option[e]): Result[e, t] = {
    match o$37410 {
        case Option.None =>
            Result.Ok(d$37404)
        case Option.Some(e$37418) =>
            Result.Err(e$37418)
    }
}

def Option.toFailure(d$37490: t, o$37492: Option[e]): Validation[e, t] = {
    match o$37492 {
        case Option.None =>
            Validation.Success(d$37490)
        case Option.Some(e$37499) =>
            Validation.Failure(Nec.singleton(e$37499))
    }
}

def Option.toList(o$37046: Option[a]): List[a] = {
    match o$37046 {
        case Option.None =>
            List.Nil
        case Option.Some(v$37064) =>
            List.Cons(v$37064, List.Nil)
    }
}

def Option.toMap(o$37238: Option[(k, v)]): Map[k, v] = {
    match o$37238 {
        case Option.None =>
            Map.empty(())
        case Option.Some(k$37265, v$37267) =>
            Map.singleton(k$37265, v$37267)
    }
}

def Option.toMapWith(f$37290: a -> b, s$37292: Option[a]): Map[a, b] = {
    Option.foldRight(
        x$37308 ->
            acc$37312 ->
                Map.insert(x$37308, f$37290(x$37308), acc$37312),
        s$37292,
        Map.empty(())
    )
}

def Option.toOk(e$37351: e, o$37353: Option[t]): Result[e, t] = {
    match o$37353 {
        case Option.None =>
            Result.Err(e$37351)
        case Option.Some(a$37355) =>
            Result.Ok(a$37355)
    }
}

def Option.toSet(o$37114: Option[a]): Set[a] = {
    match o$37114 {
        case Option.None =>
            Set.empty(())
        case Option.Some(v$37116) =>
            Set.singleton(v$37116)
    }
}

def Option.toSuccess(e$37438: e, o$37443: Option[t]): Validation[e, t] = {
    match o$37443 {
        case Option.None =>
            Validation.Failure(Nec.singleton(e$37438))
        case Option.Some(a$37462) =>
            Validation.Success(a$37462)
    }
}

def Option.traverse(
    f$36599: a -> Option[b],
    l$36611: List[a]
): Option[List[b]] \ ef = {
    letrec loop$36615: (
        List[a] -> (List[b] -> Option[List[b]]) -> Option[List[b]] \ ef
    ) = ll$36617 ->
        k$36621 ->
            match ll$36617 {
                case List.Nil =>
                    k$36621(List.Nil)
                case List.Cons(x$36627, xs$36629) =>
                    match f$36599(x$36627) {
                        case Option.None =>
                            Option.None
                        case Option.Some(y$36631) =>
                            loop$36615(
                                xs$36629
                            )(ys$36633 -> k$36621(List.Cons(y$36631, ys$36633)))
                    }
            };
    loop$36615(l$36611)(ks$36654 -> Option.Some(ks$36654))
}

def Option.traverseX(
    f$36752: a -> Option[b],
    l$36758: List[a]
): Option[Unit] \ ef = {
    match l$36758 {
        case List.Nil =>
            Option.Some
        case List.Cons(x$36771, xs$36773) =>
            match f$36752(x$36771) {
                case Option.None =>
                    Option.None
                case Option.Some(_) =>
                    Option.traverseX(f$36752, xs$36773)
            }
    }
}

def Option.unzip(o$37563: Option[(a, b)]): (Option[a], Option[b]) = {
    match o$37563 {
        case Option.None =>
            (Option.None, Option.None)
        case Option.Some(v1$37570, v2$37573) =>
            (Option.Some(v1$37570), Option.Some(v2$37573))
    }
}

def Option.withDefault(
    default$35482: { default = Option[a] },
    o$35484: Option[a]
): Option[a] = {
    match o$35484 {
        case Option.None =>
            default$35482.default
        case Option.Some(_) =>
            o$35484
    }
}

def Option.zip(o1$37527: Option[a], o2$37529: Option[b]): Option[(a, b)] = {
    match (o1$37527, o2$37529) {
        case (Option.None, _) =>
            Option.None
        case (_, Option.None) =>
            Option.None
        case (Option.Some(v1$37545), Option.Some(v2$37547)) =>
            Option.Some(v1$37545, v2$37547)
    }
}

def Order.maxBy(cmp$23208: a -> a -> Comparison, x$23216: a, y$23220: a): a = {
    if (<[unknown exp]>(cmp$23208(x$23216)(y$23220), Comparison.LessThan)) {
        y$23220
    } else {
        x$23216
    }
}

def Order.minBy(cmp$23169: a -> a -> Comparison, x$23171: a, y$23175: a): a = {
    if (<[unknown exp]>(cmp$23169(x$23171)(y$23175), Comparison.GreaterThan)) {
        y$23175
    } else {
        x$23171
    }
}

def Order.thenCompare(
    c1$23235: Comparison,
    c2$23237: Lazy[Comparison]
): Comparison = {
    if (<[unknown exp]>(c1$23235, Comparison.EqualTo)) {
        c1$23235
    } else {
        force c2$23237
    }
}

enum Proxy[_] {case Proxy(Unit)}

enum Purity[a, b, ef] {case Pure(a -> b) case Impure(a -> b)}

enum Purity2[a, b, c, ef] {case Pure(a -> b -> c) case Impure(a -> b -> c \ ef)}

enum Purity3[a, b, c, d, ef] {
    case Pure(a -> b -> (c -> d))
    case Impure(a -> b -> (c -> d \ ef))
}

enum Random {case Random(java.util.Random)}

def Random.fresh(_unit$37076: Unit): Random \ IO = {
    let newRandom$37090: (Unit -> java.util.Random) = _$37093 ->
        ##java.util.Random();
    Random.Random(newRandom$37090(()))
}

def Random.freshWithSeed(s$37123: Int64): Random \ IO = {
    let newRandom$37142: (Int64 -> java.util.Random) = a0$37144 ->
        ##java.util.Random(a0$37144);
    Random.Random(newRandom$37142(s$37123))
}

def Random.nextBool(r$37269: Random): Bool \ IO = {
    let nextBoolean$37275: (java.util.Random -> Bool) = obj$$37277 ->
        obj$$37277..nextBoolean();
    match r$37269 {case Random.Random(o$37280) => nextBoolean$37275(o$37280)}
}

def Random.nextFloat32(r$37318: Random): Float32 \ IO = {
    let nextFloat$37328: (java.util.Random -> Float32) = obj$$37330 ->
        obj$$37330..nextFloat();
    match r$37318 {case Random.Random(o$37347) => nextFloat$37328(o$37347)}
}

def Random.nextFloat64(r$37365: Random): Float64 \ IO = {
    let nextDouble$37367: (java.util.Random -> Float64) = obj$$37369 ->
        obj$$37369..nextDouble();
    match r$37365 {case Random.Random(o$37379) => nextDouble$37367(o$37379)}
}

def Random.nextGaussian(r$37501: Random): Float64 \ IO = {
    let nextGaussian$37505: (java.util.Random -> Float64) = obj$$37507 ->
        obj$$37507..nextGaussian();
    match r$37501 {case Random.Random(o$37521) => nextGaussian$37505(o$37521)}
}

def Random.nextInt32(r$37412: Random): Int32 \ IO = {
    let nextInt$37426: (java.util.Random -> Int32) = obj$$37428 ->
        obj$$37428..nextInt();
    match r$37412 {case Random.Random(o$37432) => nextInt$37426(o$37432)}
}

def Random.nextInt64(r$37449: Random): Int64 \ IO = {
    let nextLong$37464: (java.util.Random -> Int64) = obj$$37466 ->
        obj$$37466..nextLong();
    match r$37449 {case Random.Random(o$37483) => nextLong$37464(o$37483)}
}

def Random.nextNatWithMax(r$37531: Random, m$37533: Int32): Int32 \ IO = {
    let nextInt$37537: (java.util.Random -> Int32 -> Int32 \ IO) = obj$$37539 ->
        a0$$37541 ->
            obj$$37539..nextInt(a0$$37541);
    match r$37531 {
        case Random.Random(o$37555) =>
            nextInt$37537(o$37555)(m$37533)
    }
}

def Random.oneOf(r$37209: Random, a$37211: Array[a, r]): Option[a] \ IO + r = {
    if (<[unknown exp]>(Array.length(a$37211), 0i32)) {
        Option.None
    } else {
        let m$37222: Int32 = Array.length(a$37211);
        let i$37224: Int32 = Random.nextNatWithMax(r$37209, m$37222);
        Option.Some(Array.get(i$37224, a$37211))
    }
}

enum RedBlackTree[k, v] {
    case Leaf(Unit)
    case DoubleBlackLeaf(Unit)
    case Node(Color, RedBlackTree[k, v], k, v, RedBlackTree[k, v])
}

def RedBlackTree.balance(t$41260: RedBlackTree[k, v]): RedBlackTree[k, v] = {
    match t$41260 {
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    a$41266,
                    k1$41268,
                    v1$41270,
                    b$41272
                ),
                k2$41274,
                v2$41276,
                c$41278
            ),
            k3$41280,
            v3$41282,
            d$41284
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$41266,
                    k1$41268,
                    v1$41270,
                    b$41272
                ),
                k2$41274,
                v2$41276,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    c$41278,
                    k3$41280,
                    v3$41282,
                    d$41284
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                a$41292,
                k1$41294,
                v1$41296,
                RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    b$41298,
                    k2$41300,
                    v2$41302,
                    c$41304
                )
            ),
            k3$41306,
            v3$41308,
            d$41310
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$41292,
                    k1$41294,
                    v1$41296,
                    b$41298
                ),
                k2$41300,
                v2$41302,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    c$41304,
                    k3$41306,
                    v3$41308,
                    d$41310
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            a$41314,
            k1$41316,
            v1$41318,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    b$41320,
                    k2$41322,
                    v2$41324,
                    c$41326
                ),
                k3$41328,
                v3$41330,
                d$41332
            )
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$41314,
                    k1$41316,
                    v1$41318,
                    b$41320
                ),
                k2$41322,
                v2$41324,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    c$41326,
                    k3$41328,
                    v3$41330,
                    d$41332
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            a$41342,
            k1$41344,
            v1$41346,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                b$41349,
                k2$41352,
                v2$41354,
                RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    c$41356,
                    k3$41360,
                    v3$41362,
                    d$41364
                )
            )
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$41342,
                    k1$41344,
                    v1$41346,
                    b$41349
                ),
                k2$41352,
                v2$41354,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    c$41356,
                    k3$41360,
                    v3$41362,
                    d$41364
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.DoubleBlack,
            a$41367,
            k1$41369,
            v1$41371,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    b$41373,
                    k2$41375,
                    v2$41377,
                    c$41379
                ),
                k3$41381,
                v3$41383,
                d$41385
            )
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$41367,
                    k1$41369,
                    v1$41371,
                    b$41373
                ),
                k2$41375,
                v2$41377,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    c$41379,
                    k3$41381,
                    v3$41383,
                    d$41385
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.DoubleBlack,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                a$41394,
                k1$41396,
                v1$41398,
                RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    b$41400,
                    k2$41402,
                    v2$41404,
                    c$41406
                )
            ),
            k3$41408,
            v3$41410,
            d$41412
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$41394,
                    k1$41396,
                    v1$41398,
                    b$41400
                ),
                k2$41402,
                v2$41404,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    c$41406,
                    k3$41408,
                    v3$41410,
                    d$41412
                )
            )
        case _ =>
            t$41260
    }
}

def RedBlackTree.blackHeight(t$42410: RedBlackTree[k, v]): Int32 = {
    letrec loop$42412: (RedBlackTree[k, v] -> Int32 -> Int32) = tt$42414 ->
        acc$42416 ->
            match tt$42414 {
                case RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$42418,
                    _,
                    _,
                    _
                ) =>
                    loop$42412(a$42418)(<[unknown exp]>(1i32, acc$42416))
                case RedBlackTree.Node(_, a$42420, _, _, _) =>
                    loop$42412(a$42420)(acc$42416)
                case _ =>
                    acc$42416
            };
    loop$42412(t$42410)(0i32)
}

def RedBlackTree.blacken(t$41428: RedBlackTree[k, v]): RedBlackTree[k, v] = {
    match t$41428 {
        case RedBlackTree.Node(
            RedBlackTree.Color.Red,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                a$41442,
                k1$41446,
                v1$41448,
                b$41450
            ),
            k2$41452,
            v2$41454,
            c$41456
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    a$41442,
                    k1$41446,
                    v1$41448,
                    b$41450
                ),
                k2$41452,
                v2$41454,
                c$41456
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Red,
            a$41463,
            k1$41465,
            v1$41467,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                b$41469,
                k2$41471,
                v2$41473,
                c$41475
            )
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                a$41463,
                k1$41465,
                v1$41467,
                RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    b$41469,
                    k2$41471,
                    v2$41473,
                    c$41475
                )
            )
        case _ =>
            t$41428
    }
}

def RedBlackTree.empty(_unit$38388: Unit): RedBlackTree[k, v] = {
    RedBlackTree.Leaf
}

def RedBlackTree.exists(
    f$40237: k -> v -> Bool \ ef,
    t$40243: RedBlackTree[k, v]
): Bool \ ef = {
    match t$40243 {
        case RedBlackTree.Node(_, a$40249, k$40251, v$40253, b$40255) =>
            if (f$40237(k$40251)(v$40253)) {
                true
            } else {
                RedBlackTree.exists(
                    f$40237,
                    a$40249
                ) or RedBlackTree.exists(f$40237, b$40255)
            }
        case _ =>
            false
    }
}

def RedBlackTree.filter(
    f$42852: v -> Bool,
    t$42854: RedBlackTree[k, v]
): RedBlackTree[k, v] \ ef = {
    RedBlackTree.filterImplementation(f$42852, t$42854)
}

def RedBlackTree.filterImplementation(
    f$42859: v -> Bool,
    t$42861: RedBlackTree[k, v]
): RedBlackTree[k, v] \ ef = {
    RedBlackTree.foldLeft(
        acc$42863 ->
            k$42865 ->
                v$42867 ->
                    if (f$42859(v$42867)) {
                        RedBlackTree.insert(k$42865, v$42867, acc$42863)
                    } else {
                        acc$42863
                    },
        RedBlackTree.empty(()),
        t$42861
    )
}

def RedBlackTree.filterMap(
    f$42877: a -> Option[b],
    t$42879: RedBlackTree[k, a]
): RedBlackTree[k, b] \ ef = {
    RedBlackTree.filterMapImplementation(f$42877, t$42879)
}

def RedBlackTree.filterMapImplementation(
    f$42885: a -> Option[b],
    t$42887: RedBlackTree[k, a]
): RedBlackTree[k, b] \ ef = {
    let step$42889: (
        RedBlackTree[k, b] -> k -> (a -> RedBlackTree[k, b] \ ef)
    ) = acc$42891 ->
        k$42893 ->
            a$42895 ->
                match f$42885(a$42895) {
                    case Option.Some(b$42897) =>
                        RedBlackTree.insert(k$42893, b$42897, acc$42891)
                    case Option.None =>
                        acc$42891
                };
    RedBlackTree.foldLeft(step$42889, RedBlackTree.empty(()), t$42887)
}

def RedBlackTree.findLeft(
    f$39366: k -> v -> Bool \ ef,
    t$39368: RedBlackTree[k, v]
): Option[(k, v)] \ ef = {
    letrec loop$39391: (
        RedBlackTree[k, v] ->
            (Option[(k, v)] -> Option[(k, v)] \ (e108343 + ef) & ef) -> Option[(k, v)] \ ((e108343 + ef) & ef) + ef
    ) = tt$39393 ->
        sk$39396 ->
            match tt$39393 {
                case RedBlackTree.Node(_, a$39398, k$39400, v$39402, b$39404) =>
                    loop$39391(
                        a$39398
                    )(
                        kl$39406 ->
                            match kl$39406 {
                                case Option.None =>
                                    if (f$39366(k$39400)(v$39402)) {
                                        Option.Some(k$39400, v$39402)
                                    } else {
                                        loop$39391(
                                            b$39404
                                        )(
                                            kr$39408 ->
                                                match kr$39408 {
                                                    case Option.None =>
                                                        sk$39396(Option.None)
                                                    case _ =>
                                                        kr$39408
                                                }
                                        )
                                    }
                                case _ =>
                                    kl$39406
                            }
                    )
                case _ =>
                    sk$39396(Option.None)
            };
    loop$39391(t$39368)($0$46691 -> eidentity($0$46691))
}

def RedBlackTree.findRight(
    f$39450: k -> v -> Bool \ ef,
    t$39462: RedBlackTree[k, v]
): Option[(k, v)] \ ef = {
    letrec loop$39476: (
        RedBlackTree[k, v] ->
            (Option[(k, v)] -> Option[(k, v)] \ (e127618 + ef) & ef) -> Option[(k, v)] \ ((e127618 + ef) & ef) + ef
    ) = tt$39478 ->
        sk$39480 ->
            match tt$39478 {
                case RedBlackTree.Node(_, a$39482, k$39484, v$39486, b$39488) =>
                    loop$39476(
                        b$39488
                    )(
                        kr$39490 ->
                            match kr$39490 {
                                case Option.None =>
                                    if (f$39450(k$39484)(v$39486)) {
                                        Option.Some(k$39484, v$39486)
                                    } else {
                                        loop$39476(
                                            a$39482
                                        )(
                                            kl$39494 ->
                                                match kl$39494 {
                                                    case Option.None =>
                                                        sk$39480(Option.None)
                                                    case _ =>
                                                        kl$39494
                                                }
                                        )
                                    }
                                case _ =>
                                    kr$39490
                            }
                    )
                case _ =>
                    sk$39480(Option.None)
            };
    loop$39476(t$39462)($0$46699 -> eidentity($0$46699))
}

def RedBlackTree.foldLeft(
    f$39542: b -> k -> (v -> b \ ef),
    s$39545: b,
    t$39547: RedBlackTree[k, v]
): b \ ef = {
    match t$39547 {
        case RedBlackTree.Node(_, a$39549, k$39551, v$39553, b$39555) =>
            RedBlackTree.foldLeft(
                f$39542,
                f$39542(
                    RedBlackTree.foldLeft(f$39542, s$39545, a$39549)
                )(k$39551)(v$39553),
                b$39555
            )
        case _ =>
            s$39545
    }
}

def RedBlackTree.foldMap(
    f$39650: k -> v -> b \ ef,
    t$39664: RedBlackTree[k, v]
): b \ ef = {
    RedBlackTree.foldLeft(
        acc$39679 ->
            k$39681 ->
                v$39683 ->
                    <[unknown exp]>(acc$39679, f$39650(k$39681)(v$39683)),
        <[unknown exp]>(()),
        t$39664
    )
}

def RedBlackTree.foldRight(
    f$39590: k -> v -> (b -> b \ ef),
    s$39593: b,
    t$39595: RedBlackTree[k, v]
): b \ ef = {
    match t$39595 {
        case RedBlackTree.Node(_, a$39609, k$39611, v$39613, b$39615) =>
            RedBlackTree.foldRight(
                f$39590,
                f$39590(
                    k$39611
                )(v$39613)(RedBlackTree.foldRight(f$39590, s$39593, b$39615)),
                a$39609
            )
        case _ =>
            s$39593
    }
}

def RedBlackTree.foldRightWithCont(
    f$39727: k -> v -> ((Unit -> b \ ef) -> b \ ef),
    z$39734: b,
    t$39741: RedBlackTree[k, v]
): b \ ef = {
    match t$39741 {
        case RedBlackTree.Node(_, a$39751, k$39754, v$39757, b$39761) =>
            RedBlackTree.foldRightWithCont(
                f$39727,
                f$39727(
                    k$39754
                )(
                    v$39757
                )(
                    _$39763 ->
                        RedBlackTree.foldRightWithCont(
                            f$39727,
                            z$39734,
                            b$39761
                        )
                ),
                a$39751
            )
        case _ =>
            z$39734
    }
}

def RedBlackTree.forAll(
    f$40883: k -> v -> Bool \ ef,
    t$40885: RedBlackTree[k, v]
): Bool \ ef = {
    match t$40885 {
        case RedBlackTree.Node(_, a$40887, k$40889, v$40891, b$40893) =>
            if (f$40883(k$40889)(v$40891)) {
                RedBlackTree.forAll(
                    f$40883,
                    a$40887
                ) and RedBlackTree.forAll(f$40883, b$40893)
            } else {
                false
            }
        case _ =>
            true
    }
}

def RedBlackTree.forEach(
    f$41105: k -> v -> Unit \ ef,
    t$41107: RedBlackTree[k, v]
): Unit \ ef = {
    match t$41107 {
        case RedBlackTree.Node(_, a$41125, k$41127, v$41131, b$41133) =>
            RedBlackTree.forEach(f$41105, a$41125);
            f$41105(k$41127)(v$41131);
            RedBlackTree.forEach(f$41105, b$41133)
        case _ =>
            ()
    }
}

def RedBlackTree.forEachWithIndex(
    f$41208: Int32 -> k -> (v -> Unit \ ef),
    t$41212: RedBlackTree[k, v]
): Unit \ ef = {
    region rc$41222 {
        let ix$41225: Ref[Int32, rc] = (ref 0i32) @ rc$41222;
        letrec loop$41227: (RedBlackTree[k, v] -> Unit) = tt$41229 ->
            match tt$41229 {
                case RedBlackTree.Node(_, a$41232, k$41234, v$41236, b$41238) =>
                    loop$41227(a$41232);
                    let i$41240: Int32 = deref ix$41225;
                    f$41208(i$41240)(k$41234)(v$41236);
                    Ref.put(<[unknown exp]>(i$41240, 1i32), ix$41225);
                    loop$41227(b$41238)
                case _ =>
                    ()
            };
        loop$41227(t$41212)
    }
}

def RedBlackTree.get(k$39250: k, t$39253: RedBlackTree[k, v]): Option[v] = {
    match t$39253 {
        case RedBlackTree.Node(_, a$39264, k1$39266, v$39268, b$39270) =>
            match <[unknown exp]>(k$39250, k1$39266) {
                case Comparison.LessThan =>
                    RedBlackTree.get(k$39250, a$39264)
                case Comparison.EqualTo =>
                    Option.Some(v$39268)
                case Comparison.GreaterThan =>
                    RedBlackTree.get(k$39250, b$39270)
            }
        case _ =>
            Option.None
    }
}

def RedBlackTree.insert(
    k$38575: k,
    v$38589: v,
    t$38591: RedBlackTree[k, v]
): RedBlackTree[k, v] = {
    letrec loop$38609: (
        RedBlackTree[k, v] ->
            (RedBlackTree[k, v] -> RedBlackTree[k, v]) -> RedBlackTree[k, v]
    ) = tt$38611 ->
        sk$38613 ->
            match tt$38611 {
                case RedBlackTree.Leaf =>
                    sk$38613(
                        RedBlackTree.Node(
                            RedBlackTree.Color.Red,
                            RedBlackTree.Leaf,
                            k$38575,
                            v$38589,
                            RedBlackTree.Leaf
                        )
                    )
                case RedBlackTree.Node(
                    c$38623,
                    a$38625,
                    k1$38627,
                    v1$38629,
                    b$38631
                ) =>
                    match <[unknown exp]>(k$38575, k1$38627) {
                        case Comparison.LessThan =>
                            loop$38609(
                                a$38625
                            )(
                                ks$38640 ->
                                    sk$38613(
                                        RedBlackTree.balance(
                                            RedBlackTree.Node(
                                                c$38623,
                                                ks$38640,
                                                k1$38627,
                                                v1$38629,
                                                b$38631
                                            )
                                        )
                                    )
                            )
                        case Comparison.EqualTo =>
                            sk$38613(
                                RedBlackTree.Node(
                                    c$38623,
                                    a$38625,
                                    k$38575,
                                    v$38589,
                                    b$38631
                                )
                            )
                        case Comparison.GreaterThan =>
                            loop$38609(
                                b$38631
                            )(
                                ks$38654 ->
                                    sk$38613(
                                        RedBlackTree.balance(
                                            RedBlackTree.Node(
                                                c$38623,
                                                a$38625,
                                                k1$38627,
                                                v1$38629,
                                                ks$38654
                                            )
                                        )
                                    )
                            )
                    }
                case _ =>
                    sk$38613(tt$38611)
            };
    RedBlackTree.blacken(loop$38609(t$38591)($0$46636 -> identity($0$46636)))
}

def RedBlackTree.insertWith(
    f$38742: k -> v -> (v -> v \ ef),
    k$38758: k,
    v$38763: v,
    t$38765: RedBlackTree[k, v]
): RedBlackTree[k, v] \ ef = {
    letrec loop$38774: (
        RedBlackTree[k, v] ->
            (RedBlackTree[k, v] -> RedBlackTree[k, v]) -> RedBlackTree[k, v] \ ef
    ) = tt$38776 ->
        sk$38778 ->
            match tt$38776 {
                case RedBlackTree.Leaf =>
                    sk$38778(
                        RedBlackTree.Node(
                            RedBlackTree.Color.Red,
                            RedBlackTree.Leaf,
                            k$38758,
                            v$38763,
                            RedBlackTree.Leaf
                        )
                    )
                case RedBlackTree.Node(
                    c$38794,
                    a$38796,
                    k1$38798,
                    v1$38800,
                    b$38802
                ) =>
                    match <[unknown exp]>(k$38758, k1$38798) {
                        case Comparison.LessThan =>
                            loop$38774(
                                a$38796
                            )(
                                ks$38804 ->
                                    sk$38778(
                                        RedBlackTree.balance(
                                            RedBlackTree.Node(
                                                c$38794,
                                                ks$38804,
                                                k1$38798,
                                                v1$38800,
                                                b$38802
                                            )
                                        )
                                    )
                            )
                        case Comparison.EqualTo =>
                            sk$38778(
                                RedBlackTree.Node(
                                    c$38794,
                                    a$38796,
                                    k$38758,
                                    f$38742(k$38758)(v$38763)(v1$38800),
                                    b$38802
                                )
                            )
                        case Comparison.GreaterThan =>
                            loop$38774(
                                b$38802
                            )(
                                ks$38818 ->
                                    sk$38778(
                                        RedBlackTree.balance(
                                            RedBlackTree.Node(
                                                c$38794,
                                                a$38796,
                                                k1$38798,
                                                v1$38800,
                                                ks$38818
                                            )
                                        )
                                    )
                            )
                    }
                case _ =>
                    sk$38778(tt$38776)
            };
    RedBlackTree.blacken(loop$38774(t$38765)($0$46638 -> identity($0$46638)))
}

def RedBlackTree.isEmpty(t$38409: RedBlackTree[k, v]): Bool = {
    match t$38409 {case RedBlackTree.Leaf => true case _ => false}
}

def RedBlackTree.iterator(
    rc$42902: Region[r],
    t$42904: RedBlackTree[k, v]
): Iterator[(k, v), r, r] \ r = {
    let stack1$42906: IterStack2[k, v] = RedBlackTree.leftmost(
        t$42904,
        List.Nil
    );
    let state$42908: Ref[IterStack2[k, v], r] = (ref stack1$42906) @ rc$42902;
    let next$42910: (Unit -> Option[(k, v)]) = _unit$42912 ->
        match deref state$42908 {
            case List.Nil =>
                Option.None
            case List.Cons((k$42914, v$42916, rtree$42918), es$42920) =>
                Ref.put(
                    RedBlackTree.leftmost(rtree$42918, es$42920),
                    state$42908
                );
                Option.Some(k$42914, v$42916)
        };
    Iterator.iterate(rc$42902, next$42910)
}

def RedBlackTree.joinKeys(
    sep$42807: String,
    t$42809: RedBlackTree[k, v]
): String = {
    RedBlackTree.joinWith(
        k$42811 ->
            _$42813 ->
                <[unknown exp]>(k$42811),
        sep$42807,
        t$42809
    )
}

def RedBlackTree.joinValues(
    sep$42817: String,
    t$42819: RedBlackTree[k, v]
): String = {
    RedBlackTree.joinWith(
        _$42821 ->
            v$42823 ->
                <[unknown exp]>(v$42823),
        sep$42817,
        t$42819
    )
}

def RedBlackTree.joinWith(
    f$42828: k -> v -> String \ ef,
    sep$42830: String,
    t$42832: RedBlackTree[k, v]
): String \ ef = {
    region rc$42834 {<[unknown exp]>}
}

def RedBlackTree.leftmost(
    t$42926: RedBlackTree[k, v],
    es$42928: IterStack2[k, v]
): IterStack2[k, v] = {
    match t$42926 {
        case RedBlackTree.Leaf =>
            es$42928
        case RedBlackTree.DoubleBlackLeaf =>
            es$42928
        case RedBlackTree.Node(_, ltree$42930, k$42932, v$42934, rtree$42936) =>
            RedBlackTree.leftmost(
                ltree$42930,
                List.Cons((k$42932, v$42934, rtree$42936), es$42928)
            )
    }
}

def RedBlackTree.mapAWithKey(
    f$42678: k -> v1 -> m[v2] \ ef,
    t$42680: RedBlackTree[k, v1]
): m[RedBlackTree[k, v2]] \ ef = {
    letrec loop$42682: (
        RedBlackTree[k, v1] ->
            (m[RedBlackTree[k, v2]] -> m[RedBlackTree[k, v2]] \ (e108466 + ef) & ef) -> m[RedBlackTree[k, v2]] \ ((e108466 + ef) & ef) + ef
    ) = tt$42684 ->
        k$42686 ->
            match tt$42684 {
                case RedBlackTree.Node(
                    color$42688,
                    left$42690,
                    key$42692,
                    v$42694,
                    right$42696
                ) =>
                    loop$42682(
                        left$42690
                    )(
                        kl$42698 ->
                            {
                                let ans$42700: m[v2] = f$42678(
                                    key$42692
                                )(v$42694);
                                loop$42682(
                                    right$42696
                                )(
                                    kr$42702 ->
                                        k$42686(
                                            RedBlackTree.nodeA(
                                                color$42688,
                                                kl$42698,
                                                key$42692,
                                                ans$42700,
                                                kr$42702
                                            )
                                        )
                                )
                            }
                    )
                case _ =>
                    k$42686(<[unknown exp]>(RedBlackTree.Leaf))
            };
    loop$42682(t$42680)($0$46852 -> eidentity($0$46852))
}

def RedBlackTree.mapWithKey(
    f$42426: k -> v1 -> v2 \ ef,
    t$42428: RedBlackTree[k, v1]
): RedBlackTree[k, v2] \ ef = {
    match purityOf2(f$42426) {
        case Purity2.Pure(g$42430) =>
            if (RedBlackTree.useParallelEvaluation(t$42428)) {
                RedBlackTree.parMapWithKey(
                    <[unknown exp]>(RedBlackTree.threads(()), 1i32),
                    g$42430,
                    t$42428
                )
            } else {
                RedBlackTree.seqMapWithKey(f$42426, t$42428)
            }
        case Purity2.Impure(_) =>
            RedBlackTree.seqMapWithKey(f$42426, t$42428)
    }
}

def RedBlackTree.maximumKey(t$42397: RedBlackTree[k, v]): Option[(k, v)] = {
    match t$42397 {
        case RedBlackTree.Node(_, _, k$42401, v$42403, RedBlackTree.Leaf) =>
            Option.Some(k$42401, v$42403)
        case RedBlackTree.Node(_, _, _, _, b$42406) =>
            RedBlackTree.maximumKey(b$42406)
        case _ =>
            Option.None
    }
}

def RedBlackTree.memberOf(k$39305: k, t$39307: RedBlackTree[k, v]): Bool = {
    match t$39307 {
        case RedBlackTree.Node(_, a$39331, k1$39334, _, b$39336) =>
            match <[unknown exp]>(k$39305, k1$39334) {
                case Comparison.LessThan =>
                    RedBlackTree.memberOf(k$39305, a$39331)
                case Comparison.EqualTo =>
                    true
                case Comparison.GreaterThan =>
                    RedBlackTree.memberOf(k$39305, b$39336)
            }
        case _ =>
            false
    }
}

def RedBlackTree.minDelete(
    t$42067: RedBlackTree[k, v]
): (k, v, RedBlackTree[k, v]) = {
    letrec loop$42071: (
        RedBlackTree[k, v] ->
            (((k, v, RedBlackTree[k, v])) -> (k, v, RedBlackTree[k, v])) -> (k, v, RedBlackTree[k, v])
    ) = tt$42073 ->
        sk$42079 ->
            match tt$42073 {
                case RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    RedBlackTree.Leaf,
                    k1$42105,
                    v1$42111,
                    RedBlackTree.Leaf
                ) =>
                    sk$42079((k1$42105, v1$42111, RedBlackTree.Leaf))
                case RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    RedBlackTree.Leaf,
                    k1$42114,
                    v1$42117,
                    RedBlackTree.Leaf
                ) =>
                    sk$42079((k1$42114, v1$42117, RedBlackTree.DoubleBlackLeaf))
                case RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    RedBlackTree.Leaf,
                    k1$42119,
                    v1$42121,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        RedBlackTree.Leaf,
                        k2$42123,
                        v2$42125,
                        RedBlackTree.Leaf
                    )
                ) =>
                    sk$42079(
                        (
                            k1$42119,
                            v1$42121,
                            RedBlackTree.Node(
                                RedBlackTree.Color.Black,
                                RedBlackTree.Leaf,
                                k2$42123,
                                v2$42125,
                                RedBlackTree.Leaf
                            )
                        )
                    )
                case RedBlackTree.Node(
                    c$42128,
                    a$42130,
                    k1$42132,
                    v1$42134,
                    b$42136
                ) =>
                    loop$42071(
                        a$42130
                    )(
                        pat$120$42142 ->
                            match pat$120$42142 {
                                case (k3$42146, v3$42148, e$42150) =>
                                    sk$42079(
                                        (
                                            k3$42146,
                                            v3$42148,
                                            RedBlackTree.rotate(
                                                RedBlackTree.Node(
                                                    c$42128,
                                                    e$42150,
                                                    k1$42132,
                                                    v1$42134,
                                                    b$42136
                                                )
                                            )
                                        )
                                    )
                            }
                    )
                case _ =>
                    unreachable!(())
            };
    loop$42071(t$42067)($0$46756 -> identity($0$46756))
}

def RedBlackTree.minimumKey(t$42357: RedBlackTree[k, v]): Option[(k, v)] = {
    match t$42357 {
        case RedBlackTree.Node(_, RedBlackTree.Leaf, k$42364, v$42366, _) =>
            Option.Some(k$42364, v$42366)
        case RedBlackTree.Node(_, a$42373, _, _, _) =>
            RedBlackTree.minimumKey(a$42373)
        case _ =>
            Option.None
    }
}

def RedBlackTree.nodeA(
    color$42657: Color,
    left$42659: m[RedBlackTree[k, v]],
    k$42661: k,
    value$42663: m[v],
    right$42665: m[RedBlackTree[k, v]]
): m[RedBlackTree[k, v]] = {
    <[unknown exp]>
}

def RedBlackTree.nonEmpty(t$38532: RedBlackTree[k, v]): Bool = {
    !RedBlackTree.isEmpty(t$38532)
}

def RedBlackTree.parCount(
    n$42506: Int32,
    f$42508: k -> v -> Bool,
    t$42510: RedBlackTree[k, v]
): Int32 = {
    if (<[unknown exp]>(n$42506, 1i32)) {
        RedBlackTree.seqCount(f$42508, t$42510)
    } else {
        match t$42510 {
            case RedBlackTree.Leaf =>
                0i32
            case RedBlackTree.DoubleBlackLeaf =>
                0i32
            case RedBlackTree.Node(_, a$42512, k$42514, v$42516, b$42518) =>
                <[unknown exp]>
        }
    }
}

def RedBlackTree.parExists(
    n$40289: Int32,
    f$40293: k -> v -> Bool,
    t$40305: RedBlackTree[k, v]
): Bool = {
    if (<[unknown exp]>(n$40289, 1i32)) {
        RedBlackTree.seqExists(f$40293, t$40305)
    } else {
        match t$40305 {
            case RedBlackTree.Node(_, a$40319, k$40321, v$40323, b$40325) =>
                if (f$40293(k$40321)(v$40323)) {true} else {<[unknown exp]>}
            case _ =>
                false
        }
    }
}

def RedBlackTree.parForAll(
    n$40964: Int32,
    f$40969: k -> v -> Bool,
    t$40981: RedBlackTree[k, v]
): Bool = {
    if (<[unknown exp]>(n$40964, 1i32)) {
        RedBlackTree.seqForAll(f$40969, t$40981)
    } else {
        match t$40981 {
            case RedBlackTree.Node(_, a$40983, k$40985, v$40987, b$40989) =>
                if (!f$40969(k$40985)(v$40987)) {false} else {<[unknown exp]>}
            case _ =>
                false
        }
    }
}

def RedBlackTree.parLimitBy(
    n$42738: Int32,
    cmp$42740: k -> v -> (k -> (v -> (k, v))),
    t$42742: RedBlackTree[k, v]
): Option[(k, v)] = {
    if (<[unknown exp]>(n$42738, 0i32)) {
        RedBlackTree.seqLimitBy(cmp$42740, t$42742)
    } else {
        match t$42742 {
            case RedBlackTree.Leaf =>
                Option.None
            case RedBlackTree.DoubleBlackLeaf =>
                Option.None
            case RedBlackTree.Node(_, a$42744, k$42746, v$42748, b$42750) =>
                <[unknown exp]>
        }
    }
}

def RedBlackTree.parMapWithKey(
    n$42435: Int32,
    f$42437: k -> v1 -> v2,
    t$42439: RedBlackTree[k, v1]
): RedBlackTree[k, v2] = {
    if (<[unknown exp]>(n$42435, 1i32)) {
        RedBlackTree.parSeqMapWithKey(f$42437, t$42439)
    } else {
        match t$42439 {
            case RedBlackTree.Leaf =>
                RedBlackTree.Leaf
            case RedBlackTree.DoubleBlackLeaf =>
                RedBlackTree.DoubleBlackLeaf
            case RedBlackTree.Node(
                c$42441,
                a$42443,
                k$42445,
                v$42447,
                b$42449
            ) =>
                <[unknown exp]>
        }
    }
}

def RedBlackTree.parMaximumBy(
    n$42722: Int32,
    cmp$42724: k -> v -> (k -> (v -> Comparison)),
    t$42726: RedBlackTree[k, v]
): Option[(k, v)] = {
    RedBlackTree.parLimitBy(
        n$42722,
        kl$42728 ->
            vl$42730 ->
                kr$42732 ->
                    vr$42734 ->
                        if (
                            <[unknown exp]>(
                                cmp$42724(
                                    kl$42728
                                )(vl$42730)(kr$42732)(vr$42734),
                                Comparison.GreaterThan
                            )
                        ) {
                            (kl$42728, vl$42730)
                        } else {
                            (kr$42732, vr$42734)
                        },
        t$42726
    )
}

def RedBlackTree.parMinimumBy(
    n$42706: Int32,
    cmp$42708: k -> v -> (k -> (v -> Comparison)),
    t$42710: RedBlackTree[k, v]
): Option[(k, v)] = {
    RedBlackTree.parLimitBy(
        n$42706,
        kl$42712 ->
            vl$42714 ->
                kr$42716 ->
                    vr$42718 ->
                        if (
                            <[unknown exp]>(
                                cmp$42708(
                                    kl$42712
                                )(vl$42714)(kr$42716)(vr$42718),
                                Comparison.LessThan
                            )
                        ) {
                            (kl$42712, vl$42714)
                        } else {
                            (kr$42716, vr$42718)
                        },
        t$42710
    )
}

def RedBlackTree.parSeqMapWithKey(
    f$42460: k -> v1 -> v2,
    t$42462: RedBlackTree[k, v1]
): RedBlackTree[k, v2] = {
    match t$42462 {
        case RedBlackTree.Leaf =>
            RedBlackTree.Leaf
        case RedBlackTree.DoubleBlackLeaf =>
            RedBlackTree.DoubleBlackLeaf
        case RedBlackTree.Node(c$42464, a$42466, k$42468, v$42470, b$42472) =>
            let a1$42474: RedBlackTree[k, v2] = RedBlackTree.seqMapWithKey(
                f$42460,
                a$42466
            );
            let v1$42476: v2 = f$42460(k$42468)(v$42470);
            let b1$42478: RedBlackTree[k, v2] = RedBlackTree.seqMapWithKey(
                f$42460,
                b$42472
            );
            RedBlackTree.Node(c$42464, a1$42474, k$42468, v1$42476, b1$42478)
    }
}

def RedBlackTree.parSumWith(
    n$42589: Int32,
    f$42591: k -> v -> Int32,
    t$42593: RedBlackTree[k, v]
): Int32 = {
    if (<[unknown exp]>(n$42589, 1i32)) {
        RedBlackTree.seqSumWith(f$42591, t$42593)
    } else {
        match t$42593 {
            case RedBlackTree.Leaf =>
                0i32
            case RedBlackTree.DoubleBlackLeaf =>
                0i32
            case RedBlackTree.Node(_, a$42595, k$42597, v$42599, b$42601) =>
                <[unknown exp]>
        }
    }
}

def RedBlackTree.rangeQuery(
    p$42328: k -> Comparison,
    f$42330: k -> v -> a \ ef2,
    t$42332: RedBlackTree[k, v]
): List[a] \ ef1 + ef2 = {
    region rc$42334 {
        let buffer$42339: MutList[a, rc] = MutList.empty(rc$42334);
        let g$42343: (k -> v -> Unit \ rc + ef2) = k$42345 ->
            v$42349 ->
                MutList.push!(f$42330(k$42345)(v$42349), buffer$42339);
        RedBlackTree.rangeQueryWith(p$42328, g$42343, t$42332);
        MutList.toList(buffer$42339)
    }
}

def RedBlackTree.rangeQueryWith(
    p$42169: k -> Comparison,
    f$42171: k -> v -> Unit \ ef2,
    t$42184: RedBlackTree[k, v]
): Unit \ ef1 + ef2 = {
    match t$42184 {
        case RedBlackTree.Node(_, a$42188, k$42190, v$42192, b$42194) =>
            match p$42169(k$42190) {
                case Comparison.LessThan =>
                    RedBlackTree.rangeQueryWith(p$42169, f$42171, b$42194)
                case Comparison.EqualTo =>
                    RedBlackTree.rangeQueryWith(p$42169, f$42171, a$42188);
                    f$42171(k$42190)(v$42192);
                    RedBlackTree.rangeQueryWith(p$42169, f$42171, b$42194)
                case Comparison.GreaterThan =>
                    RedBlackTree.rangeQueryWith(p$42169, f$42171, a$42188)
            }
        case _ =>
            ()
    }
}

def RedBlackTree.redden(t$41997: RedBlackTree[k, v]): RedBlackTree[k, v] = {
    match t$41997 {
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                a$42021,
                k1$42023,
                v1$42025,
                b$42027
            ),
            k2$42029,
            v2$42031,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                c$42033,
                k3$42035,
                v3$42037,
                d$42039
            )
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$42021,
                    k1$42023,
                    v1$42025,
                    b$42027
                ),
                k2$42029,
                v2$42031,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    c$42033,
                    k3$42035,
                    v3$42037,
                    d$42039
                )
            )
        case RedBlackTree.DoubleBlackLeaf =>
            RedBlackTree.Leaf
        case _ =>
            t$41997
    }
}

def RedBlackTree.reduceLeft(
    f$39801: k -> v -> (k -> (v -> (k, v) \ ef)),
    t$39813: RedBlackTree[k, v]
): Option[(k, v)] \ ef = {
    RedBlackTree.foldLeft(
        x$39819 ->
            k1$39823 ->
                v1$39825 ->
                    match x$39819 {
                        case Option.Some(k2$39829, v2$39831) =>
                            Option.Some(
                                f$39801(k2$39829)(v2$39831)(k1$39823)(v1$39825)
                            )
                        case Option.None =>
                            Option.Some(k1$39823, v1$39825)
                    },
        Option.None,
        t$39813
    )
}

def RedBlackTree.reduceRight(
    f$39863: k -> v -> (k -> (v -> (k, v) \ ef)),
    t$39889: RedBlackTree[k, v]
): Option[(k, v)] \ ef = {
    RedBlackTree.foldRight(
        k1$39894 ->
            v1$39896 ->
                acc$39898 ->
                    match acc$39898 {
                        case Option.Some(k2$39905, v2$39908) =>
                            Option.Some(
                                f$39863(k1$39894)(v1$39896)(k2$39905)(v2$39908)
                            )
                        case Option.None =>
                            Option.Some(k1$39894, v1$39896)
                    },
        Option.None,
        t$39889
    )
}

def RedBlackTree.remove(
    k$39067: k,
    t$39069: RedBlackTree[k, v]
): RedBlackTree[k, v] = {
    letrec loop$39088: (
        RedBlackTree[k, v] ->
            (RedBlackTree[k, v] -> RedBlackTree[k, v]) -> RedBlackTree[k, v]
    ) = tt$39094 ->
        sk$39098 ->
            match tt$39094 {
                case RedBlackTree.Node(
                    RedBlackTree.Color.Red,
                    RedBlackTree.Leaf,
                    k1$39109,
                    _,
                    RedBlackTree.Leaf
                ) =>
                    sk$39098(
                        if (
                            <[unknown exp]>(
                                <[unknown exp]>(k$39067, k1$39109),
                                Comparison.EqualTo
                            )
                        ) {
                            RedBlackTree.Leaf
                        } else {
                            tt$39094
                        }
                    )
                case RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    RedBlackTree.Leaf,
                    k1$39126,
                    _,
                    RedBlackTree.Leaf
                ) =>
                    sk$39098(
                        if (
                            <[unknown exp]>(
                                <[unknown exp]>(k$39067, k1$39126),
                                Comparison.EqualTo
                            )
                        ) {
                            RedBlackTree.DoubleBlackLeaf
                        } else {
                            tt$39094
                        }
                    )
                case RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        RedBlackTree.Leaf,
                        k1$39128,
                        v1$39130,
                        RedBlackTree.Leaf
                    ),
                    k2$39132,
                    v2$39134,
                    RedBlackTree.Leaf
                ) =>
                    match <[unknown exp]>(k$39067, k2$39132) {
                        case Comparison.LessThan =>
                            loop$39088(
                                RedBlackTree.Node(
                                    RedBlackTree.Color.Red,
                                    RedBlackTree.Leaf,
                                    k1$39128,
                                    v1$39130,
                                    RedBlackTree.Leaf
                                )
                            )(
                                ks$39137 ->
                                    sk$39098(
                                        RedBlackTree.Node(
                                            RedBlackTree.Color.Black,
                                            ks$39137,
                                            k2$39132,
                                            v2$39134,
                                            RedBlackTree.Leaf
                                        )
                                    )
                            )
                        case Comparison.EqualTo =>
                            sk$39098(
                                RedBlackTree.Node(
                                    RedBlackTree.Color.Black,
                                    RedBlackTree.Leaf,
                                    k1$39128,
                                    v1$39130,
                                    RedBlackTree.Leaf
                                )
                            )
                        case Comparison.GreaterThan =>
                            sk$39098(
                                RedBlackTree.Node(
                                    RedBlackTree.Color.Black,
                                    RedBlackTree.Node(
                                        RedBlackTree.Color.Red,
                                        RedBlackTree.Leaf,
                                        k1$39128,
                                        v1$39130,
                                        RedBlackTree.Leaf
                                    ),
                                    k2$39132,
                                    v2$39134,
                                    RedBlackTree.Leaf
                                )
                            )
                    }
                case RedBlackTree.Node(
                    c$39174,
                    a$39178,
                    k1$39180,
                    v1$39182,
                    b$39184
                ) =>
                    match <[unknown exp]>(k$39067, k1$39180) {
                        case Comparison.LessThan =>
                            loop$39088(
                                a$39178
                            )(
                                ks$39186 ->
                                    sk$39098(
                                        RedBlackTree.rotate(
                                            RedBlackTree.Node(
                                                c$39174,
                                                ks$39186,
                                                k1$39180,
                                                v1$39182,
                                                b$39184
                                            )
                                        )
                                    )
                            )
                        case Comparison.EqualTo =>
                            match RedBlackTree.minDelete(b$39184) {
                                case (k2$39204, v2$39207, e$39210) =>
                                    sk$39098(
                                        RedBlackTree.rotate(
                                            RedBlackTree.Node(
                                                c$39174,
                                                a$39178,
                                                k2$39204,
                                                v2$39207,
                                                e$39210
                                            )
                                        )
                                    )
                            }
                        case Comparison.GreaterThan =>
                            loop$39088(
                                b$39184
                            )(
                                ks$39218 ->
                                    sk$39098(
                                        RedBlackTree.rotate(
                                            RedBlackTree.Node(
                                                c$39174,
                                                a$39178,
                                                k1$39180,
                                                v1$39182,
                                                ks$39218
                                            )
                                        )
                                    )
                            )
                    }
                case _ =>
                    sk$39098(tt$39094)
            };
    RedBlackTree.redden(loop$39088(t$39069)($0$46678 -> identity($0$46678)))
}

def RedBlackTree.rotate(t$41488: RedBlackTree[k, v]): RedBlackTree[k, v] = {
    match t$41488 {
        case RedBlackTree.Node(
            RedBlackTree.Color.Red,
            RedBlackTree.Node(
                RedBlackTree.Color.DoubleBlack,
                a$41493,
                k1$41495,
                v1$41497,
                b$41499
            ),
            k2$41501,
            v2$41503,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                c$41506,
                k3$41508,
                v3$41510,
                d$41512
            )
        ) =>
            RedBlackTree.balance(
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        RedBlackTree.Node(
                            RedBlackTree.Color.Black,
                            a$41493,
                            k1$41495,
                            v1$41497,
                            b$41499
                        ),
                        k2$41501,
                        v2$41503,
                        c$41506
                    ),
                    k3$41508,
                    v3$41510,
                    d$41512
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Red,
            RedBlackTree.DoubleBlackLeaf,
            k2$41523,
            v2$41525,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                c$41527,
                k3$41529,
                v3$41531,
                d$41533
            )
        ) =>
            RedBlackTree.balance(
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        RedBlackTree.Leaf,
                        k2$41523,
                        v2$41525,
                        c$41527
                    ),
                    k3$41529,
                    v3$41531,
                    d$41533
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Red,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                a$41538,
                k1$41540,
                v1$41542,
                b$41544
            ),
            k2$41546,
            v2$41548,
            RedBlackTree.Node(
                RedBlackTree.Color.DoubleBlack,
                c$41552,
                k3$41554,
                v3$41556,
                d$41558
            )
        ) =>
            RedBlackTree.balance(
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$41538,
                    k1$41540,
                    v1$41542,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        b$41544,
                        k2$41546,
                        v2$41548,
                        RedBlackTree.Node(
                            RedBlackTree.Color.Black,
                            c$41552,
                            k3$41554,
                            v3$41556,
                            d$41558
                        )
                    )
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Red,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                a$41566,
                k1$41568,
                v1$41570,
                b$41572
            ),
            k2$41574,
            v2$41576,
            RedBlackTree.DoubleBlackLeaf
        ) =>
            RedBlackTree.balance(
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    a$41566,
                    k1$41568,
                    v1$41570,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        b$41572,
                        k2$41574,
                        v2$41576,
                        RedBlackTree.Leaf
                    )
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.Node(
                RedBlackTree.Color.DoubleBlack,
                a$41582,
                k1$41584,
                v1$41586,
                b$41588
            ),
            k2$41590,
            v2$41593,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                c$41606,
                k3$41608,
                v3$41610,
                d$41612
            )
        ) =>
            RedBlackTree.balance(
                RedBlackTree.Node(
                    RedBlackTree.Color.DoubleBlack,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        RedBlackTree.Node(
                            RedBlackTree.Color.Black,
                            a$41582,
                            k1$41584,
                            v1$41586,
                            b$41588
                        ),
                        k2$41590,
                        v2$41593,
                        c$41606
                    ),
                    k3$41608,
                    v3$41610,
                    d$41612
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.DoubleBlackLeaf,
            k2$41614,
            v2$41616,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                c$41676,
                k3$41678,
                v3$41680,
                d$41682
            )
        ) =>
            RedBlackTree.balance(
                RedBlackTree.Node(
                    RedBlackTree.Color.DoubleBlack,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        RedBlackTree.Leaf,
                        k2$41614,
                        v2$41616,
                        c$41676
                    ),
                    k3$41678,
                    v3$41680,
                    d$41682
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                a$41723,
                k1$41727,
                v1$41729,
                b$41731
            ),
            k2$41733,
            v2$41735,
            RedBlackTree.Node(
                RedBlackTree.Color.DoubleBlack,
                c$41737,
                k3$41739,
                v3$41741,
                d$41743
            )
        ) =>
            RedBlackTree.balance(
                RedBlackTree.Node(
                    RedBlackTree.Color.DoubleBlack,
                    a$41723,
                    k1$41727,
                    v1$41729,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        b$41731,
                        k2$41733,
                        v2$41735,
                        RedBlackTree.Node(
                            RedBlackTree.Color.Black,
                            c$41737,
                            k3$41739,
                            v3$41741,
                            d$41743
                        )
                    )
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                a$41754,
                k1$41756,
                v1$41758,
                b$41760
            ),
            k2$41762,
            v2$41764,
            RedBlackTree.DoubleBlackLeaf
        ) =>
            RedBlackTree.balance(
                RedBlackTree.Node(
                    RedBlackTree.Color.DoubleBlack,
                    a$41754,
                    k1$41756,
                    v1$41758,
                    RedBlackTree.Node(
                        RedBlackTree.Color.Red,
                        b$41760,
                        k2$41762,
                        v2$41764,
                        RedBlackTree.Leaf
                    )
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.Node(
                RedBlackTree.Color.DoubleBlack,
                a$41819,
                k4$41821,
                v4$41823,
                b$41825
            ),
            k1$41827,
            v1$41829,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    c$41831,
                    k2$41833,
                    v2$41835,
                    d$41837
                ),
                k3$41839,
                v3$41841,
                e$41843
            )
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                RedBlackTree.balance(
                    RedBlackTree.Node(
                        RedBlackTree.Color.Black,
                        RedBlackTree.Node(
                            RedBlackTree.Color.Red,
                            RedBlackTree.Node(
                                RedBlackTree.Color.Black,
                                a$41819,
                                k4$41821,
                                v4$41823,
                                b$41825
                            ),
                            k1$41827,
                            v1$41829,
                            c$41831
                        ),
                        k2$41833,
                        v2$41835,
                        d$41837
                    )
                ),
                k3$41839,
                v3$41841,
                e$41843
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.DoubleBlackLeaf,
            k1$41851,
            v1$41853,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    c$41855,
                    k2$41857,
                    v2$41859,
                    d$41861
                ),
                k3$41863,
                v3$41865,
                e$41867
            )
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                RedBlackTree.balance(
                    RedBlackTree.Node(
                        RedBlackTree.Color.Black,
                        RedBlackTree.Node(
                            RedBlackTree.Color.Red,
                            RedBlackTree.Leaf,
                            k1$41851,
                            v1$41853,
                            c$41855
                        ),
                        k2$41857,
                        v2$41859,
                        d$41861
                    )
                ),
                k3$41863,
                v3$41865,
                e$41867
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                a$41877,
                k4$41879,
                v4$41881,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    b$41883,
                    k1$41885,
                    v1$41887,
                    c$41889
                )
            ),
            k2$41891,
            v2$41893,
            RedBlackTree.Node(
                RedBlackTree.Color.DoubleBlack,
                d$41895,
                k3$41897,
                v3$41899,
                e$41901
            )
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                a$41877,
                k4$41879,
                v4$41881,
                RedBlackTree.balance(
                    RedBlackTree.Node(
                        RedBlackTree.Color.Black,
                        b$41883,
                        k1$41885,
                        v1$41887,
                        RedBlackTree.Node(
                            RedBlackTree.Color.Red,
                            c$41889,
                            k2$41891,
                            v2$41893,
                            RedBlackTree.Node(
                                RedBlackTree.Color.Black,
                                d$41895,
                                k3$41897,
                                v3$41899,
                                e$41901
                            )
                        )
                    )
                )
            )
        case RedBlackTree.Node(
            RedBlackTree.Color.Black,
            RedBlackTree.Node(
                RedBlackTree.Color.Red,
                a$41933,
                k4$41935,
                v4$41937,
                RedBlackTree.Node(
                    RedBlackTree.Color.Black,
                    b$41939,
                    k1$41941,
                    v1$41943,
                    c$41945
                )
            ),
            k2$41947,
            v2$41949,
            RedBlackTree.DoubleBlackLeaf
        ) =>
            RedBlackTree.Node(
                RedBlackTree.Color.Black,
                a$41933,
                k4$41935,
                v4$41937,
                RedBlackTree.balance(
                    RedBlackTree.Node(
                        RedBlackTree.Color.Black,
                        b$41939,
                        k1$41941,
                        v1$41943,
                        RedBlackTree.Node(
                            RedBlackTree.Color.Red,
                            c$41945,
                            k2$41947,
                            v2$41949,
                            RedBlackTree.Leaf
                        )
                    )
                )
            )
        case _ =>
            t$41488
    }
}

def RedBlackTree.seqCount(
    f$42532: k -> v -> Bool,
    t$42536: RedBlackTree[k, v]
): Int32 = {
    match t$42536 {
        case RedBlackTree.Leaf =>
            0i32
        case RedBlackTree.DoubleBlackLeaf =>
            0i32
        case RedBlackTree.Node(_, a$42538, k$42540, v$42542, b$42544) =>
            let a1$42546: Int32 = RedBlackTree.seqCount(f$42532, a$42538);
            let v1$42548: Int32 = if (f$42532(k$42540)(v$42542)) {
                1i32
            } else {
                0i32
            };
            let b1$42550: Int32 = RedBlackTree.seqCount(f$42532, b$42544);
            <[unknown exp]>(<[unknown exp]>(a1$42546, v1$42548), b1$42550)
    }
}

def RedBlackTree.seqExists(
    f$40555: k -> v -> Bool,
    t$40566: RedBlackTree[k, v]
): Bool = {
    match t$40566 {
        case RedBlackTree.Node(_, a$40573, k$40577, v$40580, b$40582) =>
            if (f$40555(k$40577)(v$40580)) {
                true
            } else {
                RedBlackTree.seqExists(
                    f$40555,
                    a$40573
                ) or RedBlackTree.seqExists(f$40555, b$40582)
            }
        case _ =>
            false
    }
}

def RedBlackTree.seqForAll(
    f$41047: k -> v -> Bool,
    t$41050: RedBlackTree[k, v]
): Bool = {
    match t$41050 {
        case RedBlackTree.Node(_, a$41052, k$41055, v$41057, b$41059) =>
            if (f$41047(k$41055)(v$41057)) {
                RedBlackTree.seqForAll(
                    f$41047,
                    a$41052
                ) and RedBlackTree.seqForAll(f$41047, b$41059)
            } else {
                false
            }
        case _ =>
            true
    }
}

def RedBlackTree.seqLimitBy(
    cmp$42779: k -> v -> (k -> (v -> (k, v) \ ef)),
    t$42781: RedBlackTree[k, v]
): Option[(k, v)] \ ef = {
    match t$42781 {
        case RedBlackTree.Node(_, a$42783, k$42785, v$42787, b$42789) =>
            let res$42791: (
                k,
                v
            ) = match RedBlackTree.seqLimitBy(cmp$42779, a$42783) {
                case Option.None =>
                    (k$42785, v$42787)
                case Option.Some(kl$42793, vl$42795) =>
                    cmp$42779(kl$42793)(vl$42795)(k$42785)(v$42787)
            };
            match RedBlackTree.seqLimitBy(cmp$42779, b$42789) {
                case Option.None =>
                    Option.Some(res$42791)
                case Option.Some(kr$42797, vr$42799) =>
                    match res$42791 {
                        case (ks$42801, vs$42803) =>
                            Option.Some(
                                cmp$42779(
                                    ks$42801
                                )(vs$42803)(kr$42797)(vr$42799)
                            )
                    }
            }
        case _ =>
            Option.None
    }
}

def RedBlackTree.seqMapWithKey(
    f$42484: k -> v1 -> v2 \ ef,
    t$42486: RedBlackTree[k, v1]
): RedBlackTree[k, v2] \ ef = {
    match t$42486 {
        case RedBlackTree.Leaf =>
            RedBlackTree.Leaf
        case RedBlackTree.DoubleBlackLeaf =>
            RedBlackTree.DoubleBlackLeaf
        case RedBlackTree.Node(c$42488, a$42490, k$42492, v$42494, b$42496) =>
            let a1$42498: RedBlackTree[k, v2] = RedBlackTree.seqMapWithKey(
                f$42484,
                a$42490
            );
            let v1$42500: v2 = f$42484(k$42492)(v$42494);
            let b1$42502: RedBlackTree[k, v2] = RedBlackTree.seqMapWithKey(
                f$42484,
                b$42496
            );
            RedBlackTree.Node(c$42488, a1$42498, k$42492, v1$42500, b1$42502)
    }
}

def RedBlackTree.seqSumWith(
    f$42611: k -> v -> Int32,
    t$42613: RedBlackTree[k, v]
): Int32 = {
    match t$42613 {
        case RedBlackTree.Leaf =>
            0i32
        case RedBlackTree.DoubleBlackLeaf =>
            0i32
        case RedBlackTree.Node(_, a$42615, k$42617, v$42619, b$42621) =>
            let x$42623: Int32 = RedBlackTree.seqSumWith(f$42611, a$42615);
            let y$42625: Int32 = f$42611(k$42617)(v$42619);
            let z$42627: Int32 = RedBlackTree.seqSumWith(f$42611, b$42621);
            <[unknown exp]>(<[unknown exp]>(x$42623, y$42625), z$42627)
    }
}

def RedBlackTree.size(t$38326: RedBlackTree[k, v]): Int32 = {
    letrec loop$38340: (
        RedBlackTree[k, v] -> (Int32 -> Int32) -> Int32
    ) = tt$38342 ->
        k$38344 ->
            match tt$38342 {
                case RedBlackTree.Node(_, a$38346, _, _, b$38348) =>
                    loop$38340(
                        a$38346
                    )(
                        ks$38350 ->
                            k$38344(
                                loop$38340(
                                    b$38348
                                )(
                                    ys$38352 ->
                                        <[unknown exp]>(
                                            <[unknown exp]>(ks$38350, ys$38352),
                                            1i32
                                        )
                                )
                            )
                    )
                case _ =>
                    k$38344(0i32)
            };
    loop$38340(t$38326)($0$46634 -> identity($0$46634))
}

def RedBlackTree.sumKeys(t$42553: RedBlackTree[Int32, v]): Int32 = {
    RedBlackTree.sumWith(k$42555 -> _$42557 -> k$42555, t$42553)
}

def RedBlackTree.sumValues(t$42560: RedBlackTree[k, Int32]): Int32 = {
    RedBlackTree.sumWith(_$42562 -> v$42564 -> v$42564, t$42560)
}

def RedBlackTree.sumWith(
    f$42569: k -> v -> Int32 \ ef,
    t$42571: RedBlackTree[k, v]
): Int32 \ ef = {
    match t$42571 {
        case RedBlackTree.Leaf =>
            0i32
        case RedBlackTree.DoubleBlackLeaf =>
            0i32
        case RedBlackTree.Node(_, a$42573, k$42575, v$42577, b$42579) =>
            let x$42581: Int32 = RedBlackTree.sumWith(f$42569, a$42573);
            let y$42583: Int32 = f$42569(k$42575)(v$42577);
            let z$42585: Int32 = RedBlackTree.sumWith(f$42569, b$42579);
            <[unknown exp]>(<[unknown exp]>(x$42581, y$42583), z$42585)
    }
}

def RedBlackTree.threads(_unit$38271: Unit): Int32 = {
    let multiplier$38284: Int32 = 4i32;
    <[unknown exp]>(multiplier$38284, Environment.getVirtualProcessors(()))
}

def RedBlackTree.toList(t$42631: RedBlackTree[k, v]): List[(k, v)] = {
    RedBlackTree.foldRight(
        k$42633 ->
            v$42635 ->
                acc$42637 ->
                    List.Cons((k$42633, v$42635), acc$42637),
        List.Nil,
        t$42631
    )
}

def RedBlackTree.toMutDeque(
    rc$42642: Region[r],
    t$42644: RedBlackTree[k, v]
): MutDeque[(k, v), r] \ r = {
    let d$42646: MutDeque[(k, v), r] = MutDeque.empty(rc$42642);
    RedBlackTree.forEach(
        k$42648 ->
            v$42650 ->
                {
                    let x$42652: (k, v) = (k$42648, v$42650);
                    MutDeque.pushBack(x$42652, d$42646)
                },
        t$42644
    );
    d$42646
}

def RedBlackTree.updateWith(
    f$38915: k -> v -> Option[v] \ ef,
    k$38925: k,
    t$38927: RedBlackTree[k, v]
): RedBlackTree[k, v] \ ef = {
    letrec loop$38929: (
        RedBlackTree[k, v] ->
            (RedBlackTree[k, v] -> RedBlackTree[k, v]) -> RedBlackTree[k, v] \ ef
    ) = tt$38931 ->
        sk$38933 ->
            match tt$38931 {
                case RedBlackTree.Leaf =>
                    sk$38933(tt$38931)
                case RedBlackTree.Node(
                    c$38942,
                    a$38944,
                    k1$38946,
                    v1$38948,
                    b$38950
                ) =>
                    match <[unknown exp]>(k$38925, k1$38946) {
                        case Comparison.LessThan =>
                            loop$38929(
                                a$38944
                            )(
                                ks$38957 ->
                                    sk$38933(
                                        RedBlackTree.balance(
                                            RedBlackTree.Node(
                                                c$38942,
                                                ks$38957,
                                                k1$38946,
                                                v1$38948,
                                                b$38950
                                            )
                                        )
                                    )
                            )
                        case Comparison.EqualTo =>
                            match f$38915(k1$38946)(v1$38948) {
                                case Option.None =>
                                    sk$38933(tt$38931)
                                case Option.Some(v$38973) =>
                                    sk$38933(
                                        RedBlackTree.Node(
                                            c$38942,
                                            a$38944,
                                            k$38925,
                                            v$38973,
                                            b$38950
                                        )
                                    )
                            }
                        case Comparison.GreaterThan =>
                            loop$38929(
                                b$38950
                            )(
                                ks$38985 ->
                                    sk$38933(
                                        RedBlackTree.balance(
                                            RedBlackTree.Node(
                                                c$38942,
                                                a$38944,
                                                k1$38946,
                                                v1$38948,
                                                ks$38985
                                            )
                                        )
                                    )
                            )
                    }
                case _ =>
                    sk$38933(tt$38931)
            };
    RedBlackTree.blacken(loop$38929(t$38927)($0$46656 -> identity($0$46656)))
}

def RedBlackTree.useParallelEvaluation(t$38302: RedBlackTree[k, v]): Bool = {
    let minSize$38304: Int32 = Int32.pow(
        2i32,
        RedBlackTree.blackHeight(t$38302)
    );
    <[unknown exp]>(minSize$38304, 1024i32)
}

enum RedBlackTree.Color {case Red(Unit) case Black(Unit) case DoubleBlack(Unit)}

def Ref.fresh(rc$32543: Region[r], x$32545: a): Ref[a, r] \ r = {
    (ref x$32545) @ rc$32543
}

def Ref.get(rf$32565: Ref[a, r]): a \ r = {deref rf$32565}

def Ref.put(x$32597: a, rf$32600: Ref[a, r]): Unit \ r = {rf$32600 := x$32597}

def Ref.transform(f$38280: a -> a, rf$38286: Ref[a, r]): Unit \ r + ef = {
    Ref.put(f$38280(Ref.get(rf$38286)), rf$38286)
}

def Reflect.default(_unit$16632: Unit): a = {<[unknown exp]>}

def Regex.breakAfterFirst(
    substr$39729: { substr = Regex },
    s$39731: String
): (String, String) = {
    region rc$39737 {
        let m$39743: Matcher[rc] = Regex.newMatcher(
            rc$39737,
            substr$39729.substr,
            s$39731
        );
        match Regex.firstSubmatch(
            $0$46916 ->
                Regex.matcherRange($0$46916),
            m$39743
        ) {
            case Result.Err(_) =>
                (s$39731, """""")
            case Result.Ok(r$39749) =>
                (
                    String.sliceLeft({+end = r$39749.end | {}}, s$39731),
                    String.sliceRight({+start = r$39749.end | {}}, s$39731)
                )
        }
    }
}

def Regex.breakBeforeLast(
    substr$39805: { substr = Regex },
    s$39811: String
): (String, String) = {
    region rc$39815 {
        let m$39818: Matcher[rc] = Regex.newMatcher(
            rc$39815,
            substr$39805.substr,
            s$39811
        );
        match Regex.lastSubmatch(
            $0$46924 ->
                Regex.matcherRange($0$46924),
            m$39818
        ) {
            case Result.Err(_) =>
                (s$39811, """""")
            case Result.Ok(r$39835) =>
                (
                    String.sliceLeft({+end = r$39835.start | {}}, s$39811),
                    String.sliceRight({+start = r$39835.start | {}}, s$39811)
                )
        }
    }
}

def Regex.breakOnFirst(
    substr$39689: { substr = Regex },
    s$39691: String
): (String, String) = {
    region rc$39699 {
        let m$39702: Matcher[rc] = Regex.newMatcher(
            rc$39699,
            substr$39689.substr,
            s$39691
        );
        match Regex.firstSubmatch(
            $0$46910 ->
                Regex.matcherRange($0$46910),
            m$39702
        ) {
            case Result.Err(_) =>
                (s$39691, """""")
            case Result.Ok(r$39708) =>
                (
                    String.sliceLeft({+end = r$39708.start | {}}, s$39691),
                    String.sliceRight({+start = r$39708.start | {}}, s$39691)
                )
        }
    }
}

def Regex.breakOnLast(
    substr$39774: { substr = Regex },
    s$39776: String
): (String, String) = {
    region rc$39778 {
        let m$39781: Matcher[rc] = Regex.newMatcher(
            rc$39778,
            substr$39774.substr,
            s$39776
        );
        match Regex.lastSubmatch(
            $0$46918 ->
                Regex.matcherRange($0$46918),
            m$39781
        ) {
            case Result.Err(_) =>
                (s$39776, """""")
            case Result.Ok(r$39783) =>
                (
                    String.sliceLeft({+end = r$39783.end | {}}, s$39776),
                    String.sliceRight({+start = r$39783.end | {}}, s$39776)
                )
        }
    }
}

def Regex.countSubmatches(
    substr$38894: { substr = Regex },
    s$38904: String
): Int32 = {
    region rc$38910 {
        let m$38913: Matcher[rc] = Regex.newMatcher(
            rc$38910,
            substr$38894.substr,
            s$38904
        );
        match Regex.foldSubmatches(
            acc$38918 ->
                _$38920 ->
                    <[unknown exp]>(acc$38918, 1i32),
            0i32,
            $0$46778 ->
                Regex.matcherStart($0$46778),
            m$38913
        ) {
            case Result.Ok(n$38922) =>
                n$38922
            case Result.Err(_) =>
                0i32
        }
    }
}

def Regex.countSubmatchesWithBounds(
    substr$39993: { substr = Regex },
    start$39995: { start = Int32 },
    end$40000: { end = Int32 },
    s$40003: String
): Int32 = {
    region rc$40009 {
        match Regex.newMatcherWithBounds(
            rc$40009,
            substr$39993.substr,
            start$39995,
            end$40000,
            s$40003
        ) {
            case Result.Ok(m$40012) =>
                match Regex.foldSubmatches(
                    acc$40014 ->
                        _$40016 ->
                            <[unknown exp]>(acc$40014, 1i32),
                    0i32,
                    $0$46948 ->
                        Regex.matcherStart($0$46948),
                    m$40012
                ) {
                    case Result.Ok(n$40035) =>
                        n$40035
                    case Result.Err(_) =>
                        0i32
                }
            case Result.Err(_) =>
                0i32
        }
    }
}

def Regex.endsWith(suffix$39139: { suffix = Regex }, s$39148: String): Bool = {
    region rc$39156 {
        let m$39159: Matcher[rc] = Regex.newMatcher(
            rc$39156,
            suffix$39139.suffix,
            s$39148
        );
        match Regex.lastSubmatch(
            $0$46796 ->
                Regex.matcherRange($0$46796),
            m$39159
        ) {
            case Result.Err(_) =>
                false
            case Result.Ok(rng$39165) =>
                <[unknown exp]>(String.length(s$39148), rng$39165.end)
        }
    }
}

def Regex.find!(m$40313: Matcher[r]): Bool \ r = {
    let find$40329: (java.util.regex.Matcher -> Bool) = obj$$40332 ->
        <[unknown exp]>;
    match m$40313 {case Regex.Matcher.Matcher(m1$40345) => find$40329(m1$40345)}
}

def Regex.findFrom!(pos$40351: Int32, m$40355: Matcher[r]): Bool \ r = {
    |>(
        Result.tryCatch(
            _$40361 ->
                {
                    let find$40363: (
                        java.util.regex.Matcher -> Int32 -> Bool \ r
                    ) = obj$$40365 ->
                        a0$$40369 ->
                            <[unknown exp]>;
                    match m$40355 {
                        case Regex.Matcher.Matcher(m1$40371) =>
                            find$40363(m1$40371)(pos$40351)
                    }
                }
        ),
        (
            $0$46966 ->
                $1$46968 ->
                    Result.getWithDefault($0$46966, $1$46968)
        )(false)
    )
}

def Regex.findLast!(m$40395: Matcher[r]): Bool \ r = {
    letrec loop$40409: (
        Result[String, Int32] -> Result[String, Int32]
    ) = lastPos$40411 ->
        match Regex.find!(m$40395) {
            case true =>
                let pos1$40413: Result[String, Int32] = Regex.matcherStart(
                    m$40395
                );
                loop$40409(pos1$40413)
            case false =>
                lastPos$40411
        };
    match Regex.find!(m$40395) {
        case false =>
            false
        case true =>
            let pos$40415: Result[String, Int32] = Regex.matcherStart(m$40395);
            match loop$40409(pos$40415) {
                case Result.Err(_) =>
                    false
                case Result.Ok(startOfLast$40417) =>
                    Regex.findFrom!(startOfLast$40417, m$40395)
            }
    }
}

def Regex.firstSubmatch(
    asks$40872: MatchQuery[a, r],
    m$40874: Matcher[r]
): Result[String, a] \ r = {
    if (Regex.find!(m$40874)) {
        asks$40872(m$40874)
    } else {
        Result.Err("""No match""")
    }
}

def Regex.flags(rgx$38722: Regex): Set[Flag] = {
    let flags$38733: (Regex -> Int32) = obj$$38735 ->
        <[unknown exp]>;
    let i$38746: Int32 = flags$38733(rgx$38722);
    |>(Regex.listFlags(i$38746), $0$46752 -> List.toSet($0$46752))
}

def Regex.foldSubmatches(
    f$40946: b -> a -> b \ ef,
    x$40950: b,
    asks$40952: MatchQuery[a, r],
    m$40955: Matcher[r]
): Result[String, b] \ r + ef = {
    letrec loop$40958: (b -> Result[String, b]) = acc$40961 ->
        match Regex.find!(m$40955) {
            case true =>
                match asks$40952(m$40955) {
                    case Result.Ok(a$40966) =>
                        loop$40958(f$40946(acc$40961)(a$40966))
                    case Result.Err(msg$40973) =>
                        Result.Err(msg$40973)
                }
            case false =>
                Result.Ok(acc$40961)
        };
    loop$40958(x$40950)
}

def Regex.getFirst(
    substr$39443: { substr = Regex },
    s$39448: String
): Option[String] = {
    region rc$39456 {
        let m$39459: Matcher[rc] = Regex.newMatcher(
            rc$39456,
            substr$39443.substr,
            s$39448
        );
        |>(
            Regex.firstSubmatch(
                $0$46854 ->
                    Regex.matcherContent($0$46854),
                m$39459
            ),
            $0$46860 ->
                Result.toOption($0$46860)
        )
    }
}

def Regex.getFirstWithBounds(
    substr$40138: { substr = Regex },
    start$40152: { start = Int32 },
    end$40154: { end = Int32 },
    s$40159: String
): Option[String] = {
    region rc$40169 {
        match Regex.newMatcherWithBounds(
            rc$40169,
            substr$40138.substr,
            start$40152,
            end$40154,
            s$40159
        ) {
            case Result.Ok(m$40172) =>
                |>(
                    Regex.firstSubmatch(
                        $0$46958 ->
                            Regex.matcherContent($0$46958),
                        m$40172
                    ),
                    $0$46960 ->
                        Result.toOption($0$46960)
                )
            case Result.Err(_) =>
                Option.None
        }
    }
}

def Regex.getFirstWithOffset(
    substr$39620: { substr = Regex },
    offset$39623: { offset = Int32 },
    s$39627: String
): Option[String] = {
    region rc$39631 {
        let m$39634: Matcher[rc] = Regex.newMatcher(
            rc$39631,
            substr$39620.substr,
            s$39627
        );
        match Regex.setBounds!(
            {+start = offset$39623.offset | {}},
            {+end = String.length(s$39627) | {}},
            m$39634
        ) {
            case Result.Ok =>
                |>(
                    Regex.firstSubmatch(
                        $0$46888 ->
                            Regex.matcherContent($0$46888),
                        m$39634
                    ),
                    $0$46890 ->
                        Result.toOption($0$46890)
                )
            case Result.Err(_) =>
                Option.None
        }
    }
}

def Regex.getLast(
    substr$39496: { substr = Regex },
    s$39502: String
): Option[String] = {
    region rc$39505 {
        let m$39508: Matcher[rc] = Regex.newMatcher(
            rc$39505,
            substr$39496.substr,
            s$39502
        );
        |>(
            Regex.lastSubmatch(
                $0$46862 ->
                    Regex.matcherContent($0$46862),
                m$39508
            ),
            $0$46864 ->
                Result.toOption($0$46864)
        )
    }
}

def Regex.getLastWithBounds(
    substr$40176: { substr = Regex },
    start$40183: { start = Int32 },
    end$40187: { end = Int32 },
    s$40189: String
): Option[String] = {
    region rc$40195 {
        match Regex.newMatcherWithBounds(
            rc$40195,
            substr$40176.substr,
            start$40183,
            end$40187,
            s$40189
        ) {
            case Result.Ok(m$40200) =>
                |>(
                    Regex.lastSubmatch(
                        $0$46962 ->
                            Regex.matcherContent($0$46962),
                        m$40200
                    ),
                    $0$46964 ->
                        Result.toOption($0$46964)
                )
            case Result.Err(_) =>
                Option.None
        }
    }
}

def Regex.getLastWithOffset(
    substr$39652: { substr = Regex },
    offset$39656: { offset = Int32 },
    s$39659: String
): Option[String] = {
    region rc$39661 {
        let m$39665: Matcher[rc] = Regex.newMatcher(
            rc$39661,
            substr$39652.substr,
            s$39659
        );
        match Regex.setBounds!(
            {+start = offset$39656.offset | {}},
            {+end = String.length(s$39659) | {}},
            m$39665
        ) {
            case Result.Ok =>
                |>(
                    Regex.lastSubmatch(
                        $0$46898 ->
                            Regex.matcherContent($0$46898),
                        m$39665
                    ),
                    $0$46900 ->
                        Result.toOption($0$46900)
                )
            case Result.Err(_) =>
                Option.None
        }
    }
}

def Regex.getPrefix(
    substr$39188: { substr = Regex },
    s$39200: String
): Option[String] = {
    region rc$39220 {
        let m$39223: Matcher[rc] = Regex.newMatcher(
            rc$39220,
            substr$39188.substr,
            s$39200
        );
        match Regex.firstSubmatch(
            $0$46804 ->
                Regex.matcherRange($0$46804),
            m$39223
        ) {
            case Result.Err(_) =>
                Option.None
            case Result.Ok(r$39236) =>
                if (<[unknown exp]>(r$39236.start, 0i32)) {
                    Option.Some(String.takeLeft(r$39236.end, s$39200))
                } else {
                    Option.None
                }
        }
    }
}

def Regex.getSuffix(
    substr$39261: { substr = Regex },
    s$39272: String
): Option[String] = {
    region rc$39274 {
        let m$39277: Matcher[rc] = Regex.newMatcher(
            rc$39274,
            substr$39261.substr,
            s$39272
        );
        match Regex.lastSubmatch(
            $0$46806 ->
                Regex.matcherRange($0$46806),
            m$39277
        ) {
            case Result.Err(_) =>
                Option.None
            case Result.Ok(r$39279) =>
                if (<[unknown exp]>(r$39279.end, String.length(s$39272))) {
                    Option.Some(String.dropLeft(r$39279.start, s$39272))
                } else {
                    Option.None
                }
        }
    }
}

def Regex.indexOfFirst(
    substr$39370: { substr = Regex },
    s$39374: String
): Option[Int32] = {
    region rc$39386 {
        let m$39389: Matcher[rc] = Regex.newMatcher(
            rc$39386,
            substr$39370.substr,
            s$39374
        );
        |>(
            Regex.firstSubmatch(
                $0$46812 ->
                    Regex.matcherStart($0$46812),
                m$39389
            ),
            $0$46814 ->
                Result.toOption($0$46814)
        )
    }
}

def Regex.indexOfFirstWithBounds(
    substr$40059: { substr = Regex },
    start$40063: { start = Int32 },
    end$40065: { end = Int32 },
    s$40067: String
): Option[Int32] = {
    region rc$40069 {
        match Regex.newMatcherWithBounds(
            rc$40069,
            substr$40059.substr,
            start$40063,
            end$40065,
            s$40067
        ) {
            case Result.Ok(m$40072) =>
                |>(
                    Regex.firstSubmatch(
                        $0$46950 ->
                            Regex.matcherStart($0$46950),
                        m$40072
                    ),
                    $0$46952 ->
                        Result.toOption($0$46952)
                )
            case Result.Err(_) =>
                Option.None
        }
    }
}

def Regex.indexOfFirstWithOffset(
    substr$39516: { substr = Regex },
    offset$39523: { offset = Int32 },
    s$39525: String
): Option[Int32] = {
    region rc$39531 {
        let m$39534: Matcher[rc] = Regex.newMatcher(
            rc$39531,
            substr$39516.substr,
            s$39525
        );
        match Regex.setBounds!(
            {+start = offset$39523.offset | {}},
            {+end = String.length(s$39525) | {}},
            m$39534
        ) {
            case Result.Ok =>
                |>(
                    Regex.firstSubmatch(
                        $0$46866 ->
                            Regex.matcherStart($0$46866),
                        m$39534
                    ),
                    $0$46868 ->
                        Result.toOption($0$46868)
                )
            case Result.Err(_) =>
                Option.None
        }
    }
}

def Regex.indexOfLast(
    substr$39410: { substr = Regex },
    s$39416: String
): Option[Int32] = {
    region rc$39426 {
        let m$39429: Matcher[rc] = Regex.newMatcher(
            rc$39426,
            substr$39410.substr,
            s$39416
        );
        |>(
            Regex.lastSubmatch(
                $0$46848 ->
                    Regex.matcherStart($0$46848),
                m$39429
            ),
            $0$46850 ->
                Result.toOption($0$46850)
        )
    }
}

def Regex.indexOfLastWithBounds(
    substr$40092: { substr = Regex },
    start$40096: { start = Int32 },
    end$40100: { end = Int32 },
    s$40102: String
): Option[Int32] = {
    region rc$40106 {
        match Regex.newMatcherWithBounds(
            rc$40106,
            substr$40092.substr,
            start$40096,
            end$40100,
            s$40102
        ) {
            case Result.Ok(m$40111) =>
                |>(
                    Regex.lastSubmatch(
                        $0$46954 ->
                            Regex.matcherStart($0$46954),
                        m$40111
                    ),
                    $0$46956 ->
                        Result.toOption($0$46956)
                )
            case Result.Err(_) =>
                Option.None
        }
    }
}

def Regex.indexOfLastWithOffset(
    substr$39568: { substr = Regex },
    offset$39570: { offset = Int32 },
    s$39573: String
): Option[Int32] = {
    region rc$39576 {
        let m$39580: Matcher[rc] = Regex.newMatcher(
            rc$39576,
            substr$39568.substr,
            s$39573
        );
        match Regex.setBounds!(
            {+start = offset$39570.offset | {}},
            {+end = String.length(s$39573) | {}},
            m$39580
        ) {
            case Result.Ok =>
                |>(
                    Regex.lastSubmatch(
                        $0$46874 ->
                            Regex.matcherStart($0$46874),
                        m$39580
                    ),
                    $0$46876 ->
                        Result.toOption($0$46876)
                )
            case Result.Err(_) =>
                Option.None
        }
    }
}

def Regex.indices(
    substr$38824: { substr = Regex },
    s$38828: String
): List[Int32] = {
    region rc$38834 {
        let m$38837: Matcher[rc] = Regex.newMatcher(
            rc$38834,
            substr$38824.substr,
            s$38828
        );
        match Regex.foldSubmatches(
            $0$46758 ->
                $1$46760 ->
                    Chain.snoc($0$46758, $1$46760),
            Chain.empty(()),
            $0$46762 ->
                Regex.matcherStart($0$46762),
            m$38837
        ) {
            case Result.Ok(c$38845) =>
                Chain.toList(c$38845)
            case Result.Err(_) =>
                List.Nil
        }
    }
}

def Regex.indicesWithBounds(
    substr$39935: { substr = Regex },
    start$39939: { start = Int32 },
    end$39941: { end = Int32 },
    s$39943: String
): List[Int32] = {
    region rc$39949 {
        match Regex.newMatcherWithBounds(
            rc$39949,
            substr$39935.substr,
            start$39939,
            end$39941,
            s$39943
        ) {
            case Result.Ok(m$39952) =>
                match Regex.foldSubmatches(
                    $0$46930 ->
                        $1$46932 ->
                            Chain.snoc($0$46930, $1$46932),
                    Chain.empty(()),
                    $0$46934 ->
                        Regex.matcherStart($0$46934),
                    m$39952
                ) {
                    case Result.Ok(c$39957) =>
                        Chain.toList(c$39957)
                    case Result.Err(_) =>
                        List.Nil
                }
            case Result.Err(_) =>
                List.Nil
        }
    }
}

def Regex.isMatch(rgx$38756: Regex, s$38760: String): Bool = {
    region rc$38767 {
        let matches$38770: (java.util.regex.Matcher -> Bool) = obj$$38772 ->
            <[unknown exp]>;
        match Regex.newMatcher(rc$38767, rgx$38756, s$38760) {
            case Regex.Matcher.Matcher(m1$38780) =>
                matches$38770(m1$38780)
        }
    }
}

def Regex.isMatchWithBounds(
    rgx$39856: Regex,
    start$39861: { start = Int32 },
    end$39865: { end = Int32 },
    s$39867: String
): Bool = {
    region rc$39872 {
        let matches$39875: (java.util.regex.Matcher -> Bool) = obj$$39877 ->
            <[unknown exp]>;
        match Regex.newMatcherWithBounds(
            rc$39872,
            rgx$39856,
            start$39861,
            end$39865,
            s$39867
        ) {
            case Result.Ok(m$39885) =>
                match m$39885 {
                    case Regex.Matcher.Matcher(m1$39887) =>
                        matches$39875(m1$39887)
                }
            case Result.Err(_) =>
                false
        }
    }
}

def Regex.isSubmatch(rgx$38809: Regex, s$38811: String): Bool = {
    region rc$38814 {
        |>(
            Regex.newMatcher(rc$38814, rgx$38809, s$38811),
            $0$46754 ->
                Regex.find!($0$46754)
        )
    }
}

def Regex.isSubmatchWithBounds(
    rgx$39901: Regex,
    start$39904: { start = Int32 },
    end$39910: { end = Int32 },
    s$39912: String
): Bool = {
    region rc$39918 {
        match Regex.newMatcherWithBounds(
            rc$39918,
            rgx$39901,
            start$39904,
            end$39910,
            s$39912
        ) {
            case Result.Ok(m$39925) =>
                Regex.find!(m$39925)
            case Result.Err(_) =>
                false
        }
    }
}

def Regex.lastSubmatch(
    asks$40902: MatchQuery[a, r],
    m$40908: Matcher[r]
): Result[String, a] \ r = {
    if (Regex.findLast!(m$40908)) {
        asks$40902(m$40908)
    } else {
        Result.Err("""No match""")
    }
}

def Regex.listFlags(x$38555: Int32): List[Flag] = {
    let check$38557: (Flag -> Bool) = y$38559 ->
        {
            let y1$38561: Int32 = Regex.toInt(y$38559);
            <[unknown exp]>(Int32.bitwiseAnd(x$38555, y1$38561), y1$38561)
        };
    List.filter(
        check$38557,
        List.Cons(
            Regex.Flag.CanonEq,
            List.Cons(
                Regex.Flag.CaseInsenstive,
                List.Cons(
                    Regex.Flag.Comments,
                    List.Cons(
                        Regex.Flag.Dotall,
                        List.Cons(
                            Regex.Flag.Literal,
                            List.Cons(
                                Regex.Flag.Multiline,
                                List.Cons(
                                    Regex.Flag.UnicodeCase,
                                    List.Cons(
                                        Regex.Flag.UnicodeCharacterClass,
                                        List.Cons(
                                            Regex.Flag.UnixLines,
                                            List.Nil
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
}

def Regex.matcherContent(m$40751: Matcher[r]): Result[String, String] \ r = {
    Result.tryCatch(
        _$40762 ->
            {
                let group$40764: (
                    java.util.regex.Matcher -> String
                ) = obj$$40766 ->
                    <[unknown exp]>;
                match m$40751 {
                    case Regex.Matcher.Matcher(m1$40780) =>
                        group$40764(m1$40780)
                }
            }
    )
}

def Regex.matcherEnd(m$40617: Matcher[r]): Result[String, Int32] \ r = {
    Result.tryCatch(
        _$40625 ->
            {
                let end$40627: (
                    java.util.regex.Matcher -> Int32
                ) = obj$$40629 ->
                    <[unknown exp]>;
                match m$40617 {
                    case Regex.Matcher.Matcher(m1$40641) =>
                        end$40627(m1$40641)
                }
            }
    )
}

def Regex.matcherRange(
    m$40696: Matcher[r]
): Result[String, { end = Int32, start = Int32 }] \ r = {
    <[unknown exp]>(
        pat$136$40711 ->
            match pat$136$40711 {
                case s$40717 =>
                    <[unknown exp]>(
                        pat$135$40723 ->
                            match pat$135$40723 {
                                case e$40727 =>
                                    <[unknown exp]>(
                                        {+start = s$40717, +end = e$40727 | {}}
                                    )
                            },
                        Regex.matcherEnd(m$40696)
                    )
            },
        Regex.matcherStart(m$40696)
    )
}

def Regex.matcherStart(m$40509: Matcher[r]): Result[String, Int32] \ r = {
    Result.tryCatch(
        _$40526 ->
            {
                let start$40530: (
                    java.util.regex.Matcher -> Int32
                ) = obj$$40532 ->
                    <[unknown exp]>;
                match m$40509 {
                    case Regex.Matcher.Matcher(m1$40546) =>
                        start$40530(m1$40546)
                }
            }
    )
}

def Regex.newMatcher(
    _$40217: Region[r],
    rgx$40219: Regex,
    s$40221: String
): Matcher[r] \ r = {
    let matcher$40227: (
        Regex -> java.lang.CharSequence -> java.util.regex.Matcher \ r
    ) = obj$$40231 ->
        a0$$40235 ->
            <[unknown exp]>;
    Regex.Matcher.Matcher(matcher$40227(rgx$40219)(<[unknown exp]>))
}

def Regex.newMatcherWithBounds(
    rc$40264: Region[r],
    rgx$40266: Regex,
    start$40268: { start = Int32 },
    end$40272: { end = Int32 },
    s$40275: String
): Result[String, Matcher[r]] \ r = {
    let m$40280: Matcher[r] = Regex.newMatcher(rc$40264, rgx$40266, s$40275);
    match Regex.setBounds!(start$40268, end$40272, m$40280) {
        case Result.Ok =>
            Result.Ok(m$40280)
        case Result.Err(msg$40284) =>
            Result.Err(msg$40284)
    }
}

def Regex.pattern(rgx$38698: Regex): String = {
    let pattern$38700: (Regex -> String) = obj$$38702 ->
        <[unknown exp]>;
    pattern$38700(rgx$38698)
}

def Regex.quote(s$38658: String): String = {
    let quote$38667: (String -> String) = a0$$38670 ->
        <[unknown exp]>;
    quote$38667(s$38658)
}

def Regex.replace(
    src$39002: { src = Regex },
    dst$39004: { dst = String },
    s$39006: String
): String = {
    region rc$39008 {
        let replaceAll$39011: (
            java.util.regex.Matcher -> String -> String \ rc
        ) = obj$$39013 ->
            a0$$39015 ->
                <[unknown exp]>;
        match Regex.newMatcher(rc$39008, src$39002.src, s$39006) {
            case Regex.Matcher.Matcher(m1$39023) =>
                replaceAll$39011(m1$39023)(dst$39004.dst)
        }
    }
}

def Regex.replaceFirst(
    src$39031: { src = Regex },
    dst$39034: { dst = String },
    s$39036: String
): String = {
    region rc$39038 {
        let replaceFirst$39044: (
            java.util.regex.Matcher -> String -> String \ rc
        ) = obj$$39046 ->
            a0$$39052 ->
                <[unknown exp]>;
        match Regex.newMatcher(rc$39038, src$39031.src, s$39036) {
            case Regex.Matcher.Matcher(m1$39063) =>
                replaceFirst$39044(m1$39063)(dst$39034.dst)
        }
    }
}

def Regex.setBounds!(
    start$40440: { start = Int32 },
    end$40445: { end = Int32 },
    m$40451: Matcher[r]
): Result[String, Unit] \ r = {
    Result.tryCatch(
        _$40459 ->
            {
                let region1$40461: (
                    java.util.regex.Matcher ->
                        Int32 -> (Int32 -> java.util.regex.Matcher \ r)
                ) = obj$$40463 ->
                    a0$$40465 ->
                        a1$$40467 ->
                            <[unknown exp]>;
                match m$40451 {
                    case Regex.Matcher.Matcher(m1$40469) =>
                        discard region1$40461(
                            m1$40469
                        )(start$40440.start)(end$40445.end)
                }
            }
    )
}

def Regex.split(
    regex$38959: { regex = Regex },
    s$38961: String
): List[String] = {
    region rc$38964 {
        let split$38967: (
            Regex -> java.lang.CharSequence -> Array[String, rc] \ rc
        ) = obj$$38969 ->
            a0$$38971 ->
                <[unknown exp]>;
        match rc$38964 {
            case _ =>
                Array.toList(split$38967(regex$38959.regex)(<[unknown exp]>))
        }
    }
}

def Regex.startsWith(
    prefix$39083: { prefix = Regex },
    s$39085: String
): Bool = {
    region rc$39087 {
        let lookingAt$39092: (java.util.regex.Matcher -> Bool) = obj$$39096 ->
            <[unknown exp]>;
        match Regex.newMatcher(rc$39087, prefix$39083.prefix, s$39085) {
            case Regex.Matcher.Matcher(m1$39113) =>
                lookingAt$39092(m1$39113)
        }
    }
}

def Regex.stripPrefix(
    substr$39309: { substr = Regex },
    s$39311: String
): Option[String] = {
    region rc$39313 {
        let m$39316: Matcher[rc] = Regex.newMatcher(
            rc$39313,
            substr$39309.substr,
            s$39311
        );
        match Regex.firstSubmatch(
            $0$46808 ->
                Regex.matcherRange($0$46808),
            m$39316
        ) {
            case Result.Err(_) =>
                Option.None
            case Result.Ok(r$39325) =>
                if (<[unknown exp]>(r$39325.start, 0i32)) {
                    Option.Some(String.dropLeft(r$39325.end, s$39311))
                } else {
                    Option.None
                }
        }
    }
}

def Regex.stripSuffix(
    substr$39341: { substr = Regex },
    s$39343: String
): Option[String] = {
    region rc$39353 {
        let m$39356: Matcher[rc] = Regex.newMatcher(
            rc$39353,
            substr$39341.substr,
            s$39343
        );
        match Regex.lastSubmatch(
            $0$46810 ->
                Regex.matcherRange($0$46810),
            m$39356
        ) {
            case Result.Err(_) =>
                Option.None
            case Result.Ok(r$39360) =>
                if (<[unknown exp]>(r$39360.end, String.length(s$39343))) {
                    Option.Some(String.takeLeft(r$39360.start, s$39343))
                } else {
                    Option.None
                }
        }
    }
}

def Regex.submatches(
    substr$38865: { substr = Regex },
    s$38871: String
): List[String] = {
    region rc$38875 {
        let m$38878: Matcher[rc] = Regex.newMatcher(
            rc$38875,
            substr$38865.substr,
            s$38871
        );
        match Regex.foldSubmatches(
            $0$46764 ->
                $1$46766 ->
                    Chain.snoc($0$46764, $1$46766),
            Chain.empty(()),
            $0$46772 ->
                Regex.matcherContent($0$46772),
            m$38878
        ) {
            case Result.Ok(c$38880) =>
                Chain.toList(c$38880)
            case Result.Err(_) =>
                List.Nil
        }
    }
}

def Regex.submatchesWithBounds(
    substr$39967: { substr = Regex },
    start$39971: { start = Int32 },
    end$39973: { end = Int32 },
    s$39975: String
): List[String] = {
    region rc$39984 {
        match Regex.newMatcherWithBounds(
            rc$39984,
            substr$39967.substr,
            start$39971,
            end$39973,
            s$39975
        ) {
            case Result.Ok(m$39989) =>
                match Regex.foldSubmatches(
                    $0$46942 ->
                        $1$46944 ->
                            Chain.snoc($0$46942, $1$46944),
                    Chain.empty(()),
                    $0$46946 ->
                        Regex.matcherContent($0$46946),
                    m$39989
                ) {
                    case Result.Ok(c$39991) =>
                        Chain.toList(c$39991)
                    case Result.Err(_) =>
                        List.Nil
                }
            case Result.Err(_) =>
                List.Nil
        }
    }
}

def Regex.sumFlags(flags$38528: Set[Flag]): Int32 = {
    Set.foldLeft(
        ac$38534 ->
            e$38536 ->
                <[unknown exp]>(ac$38534, Regex.toInt(e$38536)),
        0i32,
        flags$38528
    )
}

def Regex.toInt(flag$38449: Flag): Int32 = {
    let get_CANON_EQ$38457: (Unit -> Int32) = _$38459 ->
        <[unknown exp]>;
    let get_CASE_INSENSITIVE$38461: (Unit -> Int32) = _$38463 ->
        <[unknown exp]>;
    let get_COMMENTS$38465: (Unit -> Int32) = _$38467 ->
        <[unknown exp]>;
    let get_DOTALL$38469: (Unit -> Int32) = _$38471 ->
        <[unknown exp]>;
    let get_LITERAL$38473: (Unit -> Int32) = _$38475 ->
        <[unknown exp]>;
    let get_MULTILINE$38477: (Unit -> Int32) = _$38479 ->
        <[unknown exp]>;
    let get_UNICODE_CASE$38484: (Unit -> Int32) = _$38486 ->
        <[unknown exp]>;
    let get_UNICODE_CHARACTER_CLASS$38488: (Unit -> Int32) = _$38490 ->
        <[unknown exp]>;
    let get_UNIX_LINES$38492: (Unit -> Int32) = _$38494 ->
        <[unknown exp]>;
    match flag$38449 {
        case Regex.Flag.CanonEq =>
            get_CANON_EQ$38457(())
        case Regex.Flag.CaseInsenstive =>
            get_CASE_INSENSITIVE$38461(())
        case Regex.Flag.Comments =>
            get_COMMENTS$38465(())
        case Regex.Flag.Dotall =>
            get_DOTALL$38469(())
        case Regex.Flag.Literal =>
            get_LITERAL$38473(())
        case Regex.Flag.Multiline =>
            get_MULTILINE$38477(())
        case Regex.Flag.UnicodeCase =>
            get_UNICODE_CASE$38484(())
        case Regex.Flag.UnicodeCharacterClass =>
            get_UNICODE_CHARACTER_CLASS$38488(())
        case Regex.Flag.UnixLines =>
            get_UNIX_LINES$38492(())
    }
}

def Regex.unmatchable(_unit$38605: Unit): Regex = {
    try {
        let compile$38615: (String -> Regex) = a0$$38619 ->
            <[unknown exp]>;
        compile$38615("""^\b$""")
    } catch {case _$38644: ##java.lang.Exception => unreachable!(())}
}

enum Regex.Flag {
    case Literal(Unit)
    case Comments(Unit)
    case Multiline(Unit)
    case UnicodeCase(Unit)
    case UnicodeCharacterClass(Unit)
    case UnixLines(Unit)
    case Dotall(Unit)
    case CaseInsenstive(Unit)
    case CanonEq(Unit)
}

enum Regex.Matcher[_] {case Matcher(java.util.regex.Matcher)}

enum Result[e, t] {case Ok(t) case Err(e)}

def Result.ap(
    r1$7605: Result[e, t -> u \ ef],
    r2$7611: Result[e, t]
): Result[e, u] \ ef = {
    match r1$7605 {
        case Result.Err(e$7615) =>
            Result.Err(e$7615)
        case Result.Ok(f$7621) =>
            match r2$7611 {
                case Result.Ok(a$7625) =>
                    Result.Ok(f$7621(a$7625))
                case Result.Err(e$7629) =>
                    Result.Err(e$7629)
            }
    }
}

def Result.count(f$6853: t -> Bool, r$6856: Result[e, t]): Int32 \ ef = {
    match r$6856 {
        case Result.Ok(v$6861) =>
            if (f$6853(v$6861)) {1i32} else {0i32}
        case Result.Err(_) =>
            0i32
    }
}

def Result.enumerator(
    rc$8769: Region[r],
    r$8785: Result[e, t]
): Iterator[(Int32, t), r, r] \ r = {
    |>(
        Result.iterator(rc$8769, r$8785),
        $0$45614 ->
            Iterator.zipWithIndex($0$45614)
    )
}

def Result.exists(f$6626: t -> Bool, r$6633: Result[e, t]): Bool \ ef = {
    match r$6633 {
        case Result.Ok(t$6640) =>
            f$6626(t$6640)
        case Result.Err(_) =>
            false
    }
}

def Result.find(f$6917: t -> Bool, r$6927: Result[e, t]): Option[t] = {
    match r$6927 {
        case Result.Ok(v$6942) =>
            if (f$6917(v$6942)) {Option.Some(v$6942)} else {Option.None}
        case Result.Err(_) =>
            Option.None
    }
}

def Result.flatMap(
    f$6786: t1 -> Result[e, t2],
    r$6792: Result[e, t1]
): Result[e, t2] \ ef = {
    match r$6792 {
        case Result.Ok(v$6794) =>
            f$6786(v$6794)
        case Result.Err(w$6803) =>
            Result.Err(w$6803)
    }
}

def Result.flatten(r$6818: Result[e, Result[e, t]]): Result[e, t] = {
    match r$6818 {
        case Result.Ok(v$6827) =>
            v$6827
        case Result.Err(w$6829) =>
            Result.Err(w$6829)
    }
}

def Result.foldLeft(
    f$6973: a -> t -> a \ ef,
    z$6975: a,
    r$6977: Result[e, t]
): a \ ef = {
    match r$6977 {
        case Result.Ok(v$6983) =>
            f$6973(z$6975)(v$6983)
        case Result.Err(_) =>
            z$6975
    }
}

def Result.foldLeftM(
    f$7294: b -> a -> Result[e, b] \ ef,
    s$7296: b,
    l$7298: List[a]
): Result[e, b] \ ef = {
    match l$7298 {
        case List.Nil =>
            Result.Ok(s$7296)
        case List.Cons(x$7307, xs$7309) =>
            match f$7294(s$7296)(x$7307) {
                case Result.Ok(s1$7311) =>
                    Result.foldLeftM(f$7294, s1$7311, xs$7309)
                case Result.Err(e$7316) =>
                    Result.Err(e$7316)
            }
    }
}

def Result.foldRight(
    f$7018: t -> a -> a \ ef,
    z$7024: a,
    r$7026: Result[e, t]
): a \ ef = {
    match r$7026 {
        case Result.Ok(v$7030) =>
            f$7018(v$7030)(z$7024)
        case Result.Err(_) =>
            z$7024
    }
}

def Result.foldRightM(
    f$7337: a -> b -> Result[e, b] \ ef,
    s$7342: b,
    l$7344: List[a]
): Result[e, b] \ ef = {
    letrec loop$7350: (
        List[a] ->
            (b -> Result[e, b] \ ef & ((~(e111831 + ef)) + e55150 + ef)) -> Result[e, b] \ ((e111831 + ef) & ef) + ef
    ) = ll$7355 ->
        k$7357 ->
            match ll$7355 {
                case List.Nil =>
                    k$7357(s$7342)
                case List.Cons(x$7359, xs$7361) =>
                    loop$7350(
                        xs$7361
                    )(
                        s1$7363 ->
                            match f$7337(x$7359)(s1$7363) {
                                case Result.Ok(s2$7366) =>
                                    k$7357(s2$7366)
                                case Result.Err(e$7368) =>
                                    Result.Err(e$7368)
                            }
                    )
            };
    loop$7350(l$7344)(s1$7373 -> <[unknown exp]>)
}

def Result.foldRightWithCont(
    f$7056: t -> (Unit -> a \ ef) -> a \ ef,
    z$7065: a,
    r$7067: Result[e, t]
): a \ ef = {
    match r$7067 {
        case Result.Ok(v$7074) =>
            f$7056(v$7074)(constant(z$7065))
        case Result.Err(_) =>
            z$7065
    }
}

def Result.forAll(f$6662: t -> Bool, r$6668: Result[e, t]): Bool \ ef = {
    match r$6668 {
        case Result.Ok(t$6680) =>
            f$6662(t$6680)
        case Result.Err(_) =>
            true
    }
}

def Result.forEach(f$7572: t -> Unit, r$7576: Result[e, t]): Unit \ ef = {
    match r$7576 {
        case Result.Ok(v$7583) =>
            f$7572(v$7583)
        case Result.Err(_) =>
            ()
    }
}

def Result.getWithDefault(d$6515: t, r$6518: Result[e, t]): t = {
    match r$6518 {case Result.Ok(v$6530) => v$6530 case Result.Err(_) => d$6515}
}

def Result.isErr(r$6498: Result[e, t]): Bool = {
    match r$6498 {case Result.Ok(_) => false case Result.Err(_) => true}
}

def Result.isOk(r$6483: Result[e, t]): Bool = {
    match r$6483 {case Result.Ok(_) => true case Result.Err(_) => false}
}

def Result.iterator(
    rc$8737: Region[r],
    r$8744: Result[e, t]
): Iterator[t, r, r] \ r = {
    match r$8744 {
        case Result.Err(_) =>
            Iterator.empty(rc$8737)
        case Result.Ok(x$8754) =>
            Iterator.singleton(rc$8737, x$8754)
    }
}

def Result.map(f$6687: t1 -> t2, r$6692: Result[e, t1]): Result[e, t2] \ ef = {
    match r$6692 {
        case Result.Ok(v$6704) =>
            Result.Ok(f$6687(v$6704))
        case Result.Err(w$6706) =>
            Result.Err(w$6706)
    }
}

def Result.map10(
    f$8593: t1 ->
        t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> (t8 -> (t9 -> (t10 -> u \ ef)))))))),
    r1$8621: Result[e, t1],
    r2$8624: Result[e, t2],
    r3$8627: Result[e, t3],
    r4$8631: Result[e, t4],
    r5$8635: Result[e, t5],
    r6$8637: Result[e, t6],
    r7$8639: Result[e, t7],
    r8$8647: Result[e, t8],
    r9$8656: Result[e, t9],
    r10$8659: Result[e, t10]
): Result[e, u] \ ef = {
    Result.ap(
        Result.map9(
            f$8593,
            r1$8621,
            r2$8624,
            r3$8627,
            r4$8631,
            r5$8635,
            r6$8637,
            r7$8639,
            r8$8647,
            r9$8656
        ),
        r10$8659
    )
}

def Result.map2(
    f$7657: t1 -> t2 -> u \ ef,
    r1$7661: Result[e, t1],
    r2$7663: Result[e, t2]
): Result[e, u] \ ef = {
    Result.ap(Result.map(f$7657, r1$7661), r2$7663)
}

def Result.map3(
    f$7697: t1 -> t2 -> (t3 -> u \ ef),
    r1$7706: Result[e, t1],
    r2$7710: Result[e, t2],
    r3$7712: Result[e, t3]
): Result[e, u] \ ef = {
    Result.ap(Result.map2(f$7697, r1$7706, r2$7710), r3$7712)
}

def Result.map4(
    f$7755: t1 -> t2 -> (t3 -> (t4 -> u \ ef)),
    r1$7757: Result[e, t1],
    r2$7764: Result[e, t2],
    r3$7766: Result[e, t3],
    r4$7772: Result[e, t4]
): Result[e, u] \ ef = {
    Result.ap(Result.map3(f$7755, r1$7757, r2$7764, r3$7766), r4$7772)
}

def Result.map5(
    f$7820: t1 -> t2 -> (t3 -> (t4 -> (t5 -> u \ ef))),
    r1$7826: Result[e, t1],
    r2$7832: Result[e, t2],
    r3$7845: Result[e, t3],
    r4$7855: Result[e, t4],
    r5$7861: Result[e, t5]
): Result[e, u] \ ef = {
    Result.ap(Result.map4(f$7820, r1$7826, r2$7832, r3$7845, r4$7855), r5$7861)
}

def Result.map6(
    f$7892: t1 -> t2 -> (t3 -> (t4 -> (t5 -> (t6 -> u \ ef)))),
    r1$7907: Result[e, t1],
    r2$7918: Result[e, t2],
    r3$7924: Result[e, t3],
    r4$7930: Result[e, t4],
    r5$7932: Result[e, t5],
    r6$7942: Result[e, t6]
): Result[e, u] \ ef = {
    Result.ap(
        Result.map5(f$7892, r1$7907, r2$7918, r3$7924, r4$7930, r5$7932),
        r6$7942
    )
}

def Result.map7(
    f$7985: t1 -> t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> u \ ef))))),
    r1$7989: Result[e, t1],
    r2$7995: Result[e, t2],
    r3$8003: Result[e, t3],
    r4$8011: Result[e, t4],
    r5$8013: Result[e, t5],
    r6$8017: Result[e, t6],
    r7$8019: Result[e, t7]
): Result[e, u] \ ef = {
    Result.ap(
        Result.map6(
            f$7985,
            r1$7989,
            r2$7995,
            r3$8003,
            r4$8011,
            r5$8013,
            r6$8017
        ),
        r7$8019
    )
}

def Result.map8(
    f$8059: t1 -> t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> (t8 -> u \ ef)))))),
    r1$8063: Result[e, t1],
    r2$8065: Result[e, t2],
    r3$8070: Result[e, t3],
    r4$8076: Result[e, t4],
    r5$8080: Result[e, t5],
    r6$8300: Result[e, t6],
    r7$8305: Result[e, t7],
    r8$8322: Result[e, t8]
): Result[e, u] \ ef = {
    Result.ap(
        Result.map7(
            f$8059,
            r1$8063,
            r2$8065,
            r3$8070,
            r4$8076,
            r5$8080,
            r6$8300,
            r7$8305
        ),
        r8$8322
    )
}

def Result.map9(
    f$8457: t1 ->
        t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> (t8 -> (t9 -> u \ ef))))))),
    r1$8490: Result[e, t1],
    r2$8496: Result[e, t2],
    r3$8501: Result[e, t3],
    r4$8503: Result[e, t4],
    r5$8508: Result[e, t5],
    r6$8514: Result[e, t6],
    r7$8516: Result[e, t7],
    r8$8518: Result[e, t8],
    r9$8520: Result[e, t9]
): Result[e, u] \ ef = {
    Result.ap(
        Result.map8(
            f$8457,
            r1$8490,
            r2$8496,
            r3$8501,
            r4$8503,
            r5$8508,
            r6$8514,
            r7$8516,
            r8$8518
        ),
        r9$8520
    )
}

def Result.mapErr(
    f$6757: e1 -> e2,
    r$6761: Result[e1, t]
): Result[e2, t] \ ef = {
    match r$6761 {
        case Result.Ok(v$6765) =>
            Result.Ok(v$6765)
        case Result.Err(w$6770) =>
            Result.Err(f$6757(w$6770))
    }
}

def Result.replace(
    src$6589: { src = t },
    dst$6592: { dst = t },
    r$6594: Result[e, t]
): Result[e, t] = {
    match r$6594 {
        case Result.Ok(v$6598) =>
            Result.Ok(
                if (<[unknown exp]>(v$6598, src$6589.src)) {
                    dst$6592.dst
                } else {
                    v$6598
                }
            )
        case Result.Err(_) =>
            r$6594
    }
}

def Result.sequence(l$7082: List[Result[e, a]]): Result[e, List[a]] = {
    letrec loop$7084: (
        List[Result[e, a]] ->
            (List[a] -> Result[e, List[a]]) -> Result[e, List[a]]
    ) = ll$7086 ->
        k$7089 ->
            match ll$7086 {
                case List.Nil =>
                    k$7089(List.Nil)
                case List.Cons(Result.Err(e$7093), _) =>
                    Result.Err(e$7093)
                case List.Cons(Result.Ok(x$7098), xs$7100) =>
                    loop$7084(
                        xs$7100
                    )(ks$7102 -> k$7089(List.Cons(x$7098, ks$7102)))
            };
    loop$7084(l$7082)(ks$7110 -> Result.Ok(ks$7110))
}

def Result.sum(r$6874: Result[e, Int32]): Int32 = {
    Result.foldLeft(
        acc$6881 ->
            x$6883 ->
                <[unknown exp]>(acc$6881, x$6883),
        0i32,
        r$6874
    )
}

def Result.sumWith(f$6898: t -> Int32, r$6900: Result[e, t]): Int32 \ ef = {
    Result.foldLeft(
        acc$6903 ->
            x$6905 ->
                <[unknown exp]>(acc$6903, f$6898(x$6905)),
        0i32,
        r$6900
    )
}

def Result.toList(r$7388: Result[e, t]): List[t] = {
    match r$7388 {
        case Result.Ok(v$7394) =>
            List.Cons(v$7394, List.Nil)
        case Result.Err(_) =>
            List.Nil
    }
}

def Result.toMap(r$7445: Result[e, (k, v)]): Map[k, v] = {
    match r$7445 {
        case Result.Ok(k$7453, v$7455) =>
            Map.singleton(k$7453, v$7455)
        case Result.Err(_) =>
            Map.empty(())
    }
}

def Result.toMapWith(f$7476: a -> b, s$7481: Result[a, a]): Map[a, b] = {
    Result.foldRight(
        x$7487 ->
            acc$7489 ->
                Map.insert(x$7487, f$7476(x$7487), acc$7489),
        Map.empty(()),
        s$7481
    )
}

def Result.toOption(r$7506: Result[e, t]): Option[t] = {
    match r$7506 {
        case Result.Ok(v$7522) =>
            Option.Some(v$7522)
        case Result.Err(_) =>
            Option.None
    }
}

def Result.toSet(r$7419: Result[e, t]): Set[t] = {
    match r$7419 {
        case Result.Ok(v$7423) =>
            Set.singleton(v$7423)
        case Result.Err(_) =>
            Set.empty(())
    }
}

def Result.toValidation(r$7532: Result[e, t]): Validation[e, t] = {
    match r$7532 {
        case Result.Ok(v$7540) =>
            Validation.Success(v$7540)
        case Result.Err(t$7548) =>
            Validation.Failure(Nec.singleton(t$7548))
    }
}

def Result.traverse(
    f$7149: a -> Result[e, b],
    l$7189: List[a]
): Result[e, List[b]] \ ef = {
    letrec loop$7192: (
        List[a] -> (List[b] -> Result[e, List[b]]) -> Result[e, List[b]] \ ef
    ) = ll$7194 ->
        k$7196 ->
            match ll$7194 {
                case List.Nil =>
                    k$7196(List.Nil)
                case List.Cons(x$7205, xs$7209) =>
                    match f$7149(x$7205) {
                        case Result.Ok(y$7211) =>
                            loop$7192(
                                xs$7209
                            )(ks$7213 -> k$7196(List.Cons(y$7211, ks$7213)))
                        case Result.Err(e$7216) =>
                            Result.Err(e$7216)
                    }
            };
    loop$7192(l$7189)(ks$7218 -> Result.Ok(ks$7218))
}

def Result.traverseX(
    f$7238: a -> Result[e, b],
    l$7243: List[a]
): Result[e, Unit] \ ef = {
    match l$7243 {
        case List.Nil =>
            Result.Ok
        case List.Cons(x$7254, xs$7256) =>
            match f$7238(x$7254) {
                case Result.Ok(_) =>
                    Result.traverseX(f$7238, xs$7256)
                case Result.Err(e$7261) =>
                    Result.Err(e$7261)
            }
    }
}

def Result.tryCatch(f$8845: Unit -> a): Result[String, a] \ ef = {
    try {
        Result.Ok(f$8845(()))
    } catch {
        case e$8855: ##java.lang.Exception =>
            let getMessage$8857: (java.lang.Throwable -> String) = obj$$8859 ->
                <[unknown exp]>;
            Result.Err(getMessage$8857(<[unknown exp]>))
    }
}

def Result.withDefault(
    default$6554: { default = Result[e2, t] },
    r$6567: Result[e1, t]
): Result[e2, t] = {
    match r$6567 {
        case Result.Ok(v$6569) =>
            Result.Ok(v$6569)
        case Result.Err(_) =>
            default$6554.default
    }
}

enum SemiGroup.All {case All(Bool)}

enum SemiGroup.Any {case Any(Bool)}

enum Set[t] {case Set(RedBlackTree[t, Unit])}

def Set.count(f$40752: a -> Bool, s$40758: Set[a]): Int32 \ ef = {
    match purityOf(f$40752) {
        case Purity.Pure(g$40768) =>
            if (Set.useParallelEvaluation(s$40758)) {
                let h$40770: (a -> Unit -> Bool) = k$40772 ->
                    _$40774 ->
                        g$40768(k$40772);
                match s$40758 {
                    case Set.Set(t$40778) =>
                        RedBlackTree.parCount(
                            <[unknown exp]>(Set.threads(()), 1i32),
                            h$40770,
                            t$40778
                        )
                }
            } else {
                Set.foldLeft(
                    b$40788 ->
                        k$40790 ->
                            if (f$40752(k$40790)) {
                                <[unknown exp]>(b$40788, 1i32)
                            } else {
                                b$40788
                            },
                    0i32,
                    s$40758
                )
            }
        case Purity.Impure(g$40805) =>
            Set.foldLeft(
                b$40807 ->
                    k$40809 ->
                        if (g$40805(k$40809)) {
                            <[unknown exp]>(b$40807, 1i32)
                        } else {
                            b$40807
                        },
                0i32,
                s$40758
            )
    }
}

def Set.difference(s1$41143: Set[a], s2$41147: Set[a]): Set[a] = {
    Set.foldLeft(
        acc$41149 ->
            x$41151 ->
                if (!Set.memberOf(x$41151, s2$41147)) {
                    Set.insert(x$41151, acc$41149)
                } else {
                    acc$41149
                },
        Set.empty(()),
        s1$41143
    )
}

def Set.empty(_unit$39766: Unit): Set[a] = {Set.Set(RedBlackTree.empty(()))}

def Set.enumerator(
    rc$42341: Region[r],
    s$42347: Set[a]
): Iterator[(Int32, a), r, r] \ r = {
    |>(
        Set.iterator(rc$42341, s$42347),
        $0$46886 ->
            Iterator.zipWithIndex($0$46886)
    )
}

def Set.exists(f$41002: a -> Bool, s$41004: Set[a]): Bool \ ef = {
    match s$41004 {
        case Set.Set(t$41007) =>
            RedBlackTree.exists(x$41009 -> _$41011 -> f$41002(x$41009), t$41007)
    }
}

def Set.filter(f$41181: a -> Bool, s$41186: Set[a]): Set[a] \ ef = {
    Set.foldLeft(
        acc$41189 ->
            x$41191 ->
                if (f$41181(x$41191)) {
                    Set.insert(x$41191, acc$41189)
                } else {
                    acc$41189
                },
        Set.empty(()),
        s$41186
    )
}

def Set.filterMap(f$41289: a -> Option[b], s$41312: Set[a]): Set[b] \ ef = {
    let step$41334: (Set[b] -> a -> Set[b] \ ef) = acc$41336 ->
        x$41338 ->
            match f$41289(x$41338) {
                case Option.None =>
                    acc$41336
                case Option.Some(v$41340) =>
                    Set.insert(v$41340, acc$41336)
            };
    Set.foldLeft(step$41334, Set.empty(()), s$41312)
}

def Set.find(f$40225: a -> Bool, s$40228: Set[a]): Option[a] \ ef = {
    Set.findLeft(f$40225, s$40228)
}

def Set.findLeft(f$40259: a -> Bool, s$40261: Set[a]): Option[a] \ ef = {
    match s$40261 {
        case Set.Set(t$40270) =>
            |>(
                RedBlackTree.findLeft(
                    x$40274 ->
                        _$40278 ->
                            f$40259(x$40274),
                    t$40270
                ),
                (
                    $0$46790 ->
                        $1$46792 ->
                            Option.map($0$46790, $1$46792)
                )($0$46794 -> fst($0$46794))
            )
    }
}

def Set.findRight(f$40308: a -> Bool, s$40315: Set[a]): Option[a] \ ef = {
    match s$40315 {
        case Set.Set(t$40335) =>
            |>(
                RedBlackTree.findRight(
                    x$40339 ->
                        _$40341 ->
                            f$40308(x$40339),
                    t$40335
                ),
                (
                    $0$46798 ->
                        $1$46800 ->
                            Option.map($0$46798, $1$46800)
                )($0$46802 -> fst($0$46802))
            )
    }
}

def Set.flatMap(f$41245: a -> Set[b], s$41247: Set[a]): Set[b] \ ef = {
    Set.foldLeft(
        acc$41254 ->
            x$41256 ->
                Set.union(acc$41254, f$41245(x$41256)),
        Set.empty(()),
        s$41247
    )
}

def Set.flatten(s$40960: Set[Set[a]]): Set[a] = {
    Set.foldLeft(
        acc$40975 ->
            x$40979 ->
                Set.union(acc$40975, x$40979),
        Set.empty(()),
        s$40960
    )
}

def Set.fold(s$40352: Set[a]): a = {Foldable.fold(s$40352)}

def Set.foldLeft(
    f$40379: b -> a -> b \ ef,
    s$40383: b,
    s1$40385: Set[a]
): b \ ef = {
    match s1$40385 {
        case Set.Set(t$40397) =>
            RedBlackTree.foldLeft(
                acc$40401 ->
                    k$40403 ->
                        _$40407 ->
                            f$40379(acc$40401)(k$40403),
                s$40383,
                t$40397
            )
    }
}

def Set.foldMap(f$40562: a -> b, s$40568: Set[a]): b \ ef = {
    Set.foldLeft(
        acc$40589 ->
            x$40593 ->
                <[unknown exp]>(acc$40589, f$40562(x$40593)),
        <[unknown exp]>(()),
        s$40568
    )
}

def Set.foldRight(
    f$40427: a -> b -> b \ ef,
    s$40429: b,
    s1$40433: Set[a]
): b \ ef = {
    match s1$40433 {
        case Set.Set(t$40447) =>
            RedBlackTree.foldRight(
                k$40452 ->
                    _$40455 ->
                        c$40457 ->
                            f$40427(k$40452)(c$40457),
                s$40429,
                t$40447
            )
    }
}

def Set.foldRightWithCont(
    f$40490: a -> (Unit -> b \ ef) -> b \ ef,
    z$40498: b,
    s$40500: Set[a]
): b \ ef = {
    match s$40500 {
        case Set.Set(t$40510) =>
            RedBlackTree.foldRightWithCont(
                k$40513 ->
                    _$40515 ->
                        c$40517 ->
                            f$40490(k$40513)(c$40517),
                z$40498,
                t$40510
            )
    }
}

def Set.forAll(f$41030: a -> Bool, s$41033: Set[a]): Bool \ ef = {
    match s$41033 {
        case Set.Set(t$41037) =>
            RedBlackTree.forAll(x$41041 -> _$41043 -> f$41030(x$41041), t$41037)
    }
}

def Set.forEach(f$41803: a -> Unit, s$41812: Set[a]): Unit \ ef = {
    match s$41812 {
        case Set.Set(t$41845) =>
            RedBlackTree.forEach(
                x$41847 ->
                    _$41849 ->
                        f$41803(x$41847),
                t$41845
            )
    }
}

def Set.forEachWithIndex(
    f$41959: Int32 -> a -> Unit \ ef,
    s$41965: Set[a]
): Unit \ ef = {
    match s$41965 {
        case Set.Set(t$41967) =>
            RedBlackTree.forEachWithIndex(
                i$41969 ->
                    x$41971 ->
                        _$41973 ->
                            f$41959(i$41969)(x$41971),
                t$41967
            )
    }
}

def Set.insert(x$39788: a, s$39790: Set[a]): Set[a] = {
    match s$39790 {
        case Set.Set(t$39799) =>
            Set.Set(RedBlackTree.insert(x$39788, (), t$39799))
    }
}

def Set.intersection(s1$41111: Set[a], s2$41115: Set[a]): Set[a] = {
    Set.foldLeft(
        acc$41121 ->
            x$41123 ->
                if (Set.memberOf(x$41123, s1$41111)) {
                    Set.insert(x$41123, acc$41121)
                } else {
                    acc$41121
                },
        Set.empty(()),
        s2$41115
    )
}

def Set.isEmpty(s$39848: Set[a]): Bool = {
    match s$39848 {case Set.Set(t$39854) => RedBlackTree.isEmpty(t$39854)}
}

def Set.isProperSubsetOf(s1$40205: Set[a], s2$40207: Set[a]): Bool = {
    <[unknown exp]>(
        Set.size(s1$40205),
        Set.size(s2$40207)
    ) and Set.isSubsetOf(s1$40205, s2$40207)
}

def Set.isSubsetOf(s1$40181: Set[a], s2$40184: Set[a]): Bool = {
    Set.forAll(x$40198 -> Set.memberOf(x$40198, s2$40184), s1$40181)
}

def Set.iterator(
    rc$42317: Region[r],
    s$42319: Set[a]
): Iterator[a, r, r] \ r = {
    match s$42319 {
        case Set.Set(t$42321) =>
            |>(
                RedBlackTree.iterator(rc$42317, t$42321),
                (
                    $0$46878 ->
                        $1$46880 ->
                            Iterator.map($0$46878, $1$46880)
                )($0$46882 -> fst($0$46882))
            )
    }
}

def Set.join(sep$42369: String, s$42371: Set[a]): String = {
    <[unknown exp]>(sep$42369, s$42371)
}

def Set.joinWith(
    f$42389: a -> String,
    sep$42391: String,
    s$42393: Set[a]
): String \ ef = {
    <[unknown exp]>(f$42389, sep$42391, s$42393)
}

def Set.map(f$41200: a -> b, s$41210: Set[a]): Set[b] \ ef = {
    Set.foldLeft(
        acc$41216 ->
            x$41218 ->
                Set.insert(f$41200(x$41218), acc$41216),
        Set.empty(()),
        s$41210
    )
}

def Set.maximum(s$40075: Set[a]): Option[a] = {
    match s$40075 {
        case Set.Set(t$40086) =>
            |>(
                RedBlackTree.maximumKey(t$40086),
                (
                    $0$46782 ->
                        $1$46784 ->
                            Option.map($0$46782, $1$46784)
                )($0$46786 -> fst($0$46786))
            )
    }
}

def Set.maximumBy(
    cmp$40113: a -> a -> Comparison \ ef,
    s$40115: Set[a]
): Option[a] \ ef = {
    letrec max$40119: (Unit -> Option[a]) = _unit$40121 ->
        Set.reduceLeft(
            x$40123 ->
                y$40125 ->
                    if (
                        <[unknown exp]>(
                            cmp$40113(x$40123)(y$40125),
                            Comparison.GreaterThan
                        )
                    ) {
                        x$40123
                    } else {
                        y$40125
                    },
            s$40115
        );
    match purityOf2(cmp$40113) {
        case Purity2.Pure(g$40136) =>
            if (Set.useParallelEvaluation(s$40115)) {
                let h$40142: (
                    a -> Unit -> (a -> (Unit -> Comparison))
                ) = kl$40144 ->
                    _$40146 ->
                        kr$40148 ->
                            _$40150 ->
                                g$40136(kl$40144)(kr$40148);
                match s$40115 {
                    case Set.Set(t$40161) =>
                        let o$40163: Option[(a, Unit)] = RedBlackTree.parMaximumBy(
                            <[unknown exp]>(Set.threads(()), 1i32),
                            h$40142,
                            t$40161
                        );
                        Option.map($0$46788 -> fst($0$46788), o$40163)
                }
            } else {
                max$40119(())
            }
        case Purity2.Impure(_) =>
            max$40119(())
    }
}

def Set.memberOf(x$39959: a, s$39961: Set[a]): Bool = {
    match s$39961 {
        case Set.Set(t$39965) =>
            RedBlackTree.memberOf(x$39959, t$39965)
    }
}

def Set.minimum(s$39982: Set[a]): Option[a] = {
    match s$39982 {
        case Set.Set(t$39987) =>
            |>(
                RedBlackTree.minimumKey(t$39987),
                (
                    $0$46768 ->
                        $1$46770 ->
                            Option.map($0$46768, $1$46770)
                )($0$46774 -> fst($0$46774))
            )
    }
}

def Set.minimumBy(
    cmp$39999: a -> a -> Comparison \ ef,
    s$40007: Set[a]
): Option[a] \ ef = {
    letrec min$40018: (Unit -> Option[a]) = _unit$40021 ->
        Set.reduceLeft(
            x$40029 ->
                y$40033 ->
                    if (
                        <[unknown exp]>(
                            cmp$39999(x$40029)(y$40033),
                            Comparison.LessThan
                        )
                    ) {
                        x$40029
                    } else {
                        y$40033
                    },
            s$40007
        );
    match purityOf2(cmp$39999) {
        case Purity2.Pure(g$40039) =>
            if (Set.useParallelEvaluation(s$40007)) {
                let h$40041: (
                    a -> Unit -> (a -> (Unit -> Comparison))
                ) = kl$40043 ->
                    _$40045 ->
                        kr$40047 ->
                            _$40049 ->
                                g$40039(kl$40043)(kr$40047);
                match s$40007 {
                    case Set.Set(t$40051) =>
                        let o$40053: Option[(a, Unit)] = RedBlackTree.parMinimumBy(
                            <[unknown exp]>(Set.threads(()), 1i32),
                            h$40041,
                            t$40051
                        );
                        Option.map($0$46780 -> fst($0$46780), o$40053)
                }
            } else {
                min$40018(())
            }
        case Purity2.Impure(_) =>
            min$40018(())
    }
}

def Set.nonEmpty(s$39870: Set[a]): Bool = {!Set.isEmpty(s$39870)}

def Set.partition(
    f$41432: a -> Bool,
    s$41434: Set[a]
): (Set[a], Set[a]) \ ef = {
    Set.foldLeft(
        acc$41440 ->
            x$41444 ->
                match acc$41440 {
                    case (a$41458, b$41460) =>
                        if (f$41432(x$41444)) {
                            (Set.insert(x$41444, a$41458), b$41460)
                        } else {
                            (a$41458, Set.insert(x$41444, b$41460))
                        }
                },
        (Set.empty(()), Set.empty(())),
        s$41434
    )
}

def Set.range(b$39921: Int32, e$39923: Int32): Set[Int32] = {
    letrec loop$39927: (Int32 -> Set[Int32] -> Set[Int32]) = i$39929 ->
        s$39931 ->
            if (<[unknown exp]>(i$39929, e$39923)) {
                s$39931
            } else {
                loop$39927(
                    <[unknown exp]>(i$39929, 1i32)
                )(Set.insert(i$39929, s$39931))
            };
    loop$39927(b$39921)(Set.empty(()))
}

def Set.reduceLeft(
    f$40621: a -> a -> a \ ef,
    s$40633: Set[a]
): Option[a] \ ef = {
    match s$40633 {
        case Set.Set(t$40642) =>
            |>(
                RedBlackTree.reduceLeft(
                    x$40645 ->
                        _$40649 ->
                            y$40655 ->
                                _$40661 ->
                                    (f$40621(x$40645)(y$40655), ()),
                    t$40642
                ),
                (
                    $0$46816 ->
                        $1$46818 ->
                            Option.map($0$46816, $1$46818)
                )($0$46824 -> fst($0$46824))
            )
    }
}

def Set.reduceRight(
    f$40695: a -> a -> a \ ef,
    s$40699: Set[a]
): Option[a] \ ef = {
    match s$40699 {
        case Set.Set(t$40712) =>
            |>(
                RedBlackTree.reduceRight(
                    x$40715 ->
                        _$40719 ->
                            y$40721 ->
                                _$40724 ->
                                    (f$40695(x$40715)(y$40721), ()),
                    t$40712
                ),
                (
                    $0$46832 ->
                        $1$46834 ->
                            Option.map($0$46832, $1$46834)
                )($0$46836 -> fst($0$46836))
            )
    }
}

def Set.remove(x$39827: a, s$39833: Set[a]): Set[a] = {
    match s$39833 {
        case Set.Set(t$39839) =>
            Set.Set(RedBlackTree.remove(x$39827, t$39839))
    }
}

def Set.replace(
    src$41388: { src = a },
    dst$41390: { dst = a },
    s$41392: Set[a]
): Set[a] = {
    if (Set.memberOf(src$41388.src, s$41392)) {
        Set.insert(dst$41390.dst, Set.remove(src$41388.src, s$41392))
    } else {
        s$41392
    }
}

def Set.singleton(x$39892: a): Set[a] = {Set.insert(x$39892, Set.empty(()))}

def Set.size(s$39736: Set[a]): Int32 = {
    match s$39736 {case Set.Set(t$39747) => RedBlackTree.size(t$39747)}
}

def Set.subsets(s$41160: Set[a]): Set[Set[a]] = {
    Set.foldLeft(
        acc$41164 ->
            x$41166 ->
                Set.union(
                    Set.map(y$41168 -> Set.insert(x$41166, y$41168), acc$41164),
                    acc$41164
                ),
        Set.insert(Set.empty(()), Set.empty(())),
        s$41160
    )
}

def Set.sum(s$40863: Set[Int32]): Int32 = {<[unknown exp]>(s$40863)}

def Set.sumWith(f$40901: a -> Int32, s$40914: Set[a]): Int32 \ ef = {
    match s$40914 {
        case Set.Set(t$40918) =>
            letrec sw$40920: (Unit -> Int32) = _unit$40922 ->
                RedBlackTree.sumWith(
                    k$40924 ->
                        _$40926 ->
                            f$40901(k$40924),
                    t$40918
                );
            match purityOf(f$40901) {
                case Purity.Pure(g$40936) =>
                    if (Set.useParallelEvaluation(s$40914)) {
                        RedBlackTree.parSumWith(
                            <[unknown exp]>(Set.threads(()), 1i32),
                            k$40938 ->
                                _$40940 ->
                                    g$40936(k$40938),
                            t$40918
                        )
                    } else {
                        sw$40920(())
                    }
                case Purity.Impure(_) =>
                    sw$40920(())
            }
    }
}

def Set.threads(_unit$39692: Unit): Int32 = {
    let multiplier$39697: Int32 = 4i32;
    <[unknown exp]>(multiplier$39697, Environment.getVirtualProcessors(()))
}

def Set.toArray(rc$41519: Region[r], s$41521: Set[a]): Array[a, r] \ r = {
    match Set.size(s$41521) {
        case 0i32 =>
            [] @ rc$41519
        case sz$41562 =>
            let a$41564: Array[a, r] = Array.empty(rc$41519, sz$41562);
            Iterator.forEachWithIndex(
                i$41578 ->
                    b$41580 ->
                        Array.put(b$41580, i$41578, a$41564),
                Set.iterator(rc$41519, s$41521)
            );
            a$41564
    }
}

def Set.toChain(s$41641: Set[a]): Chain[a] = {
    Set.foldLeft(
        acc$41655 ->
            x$41657 ->
                Chain.snoc(acc$41655, x$41657),
        Chain.empty(()),
        s$41641
    )
}

def Set.toDelayList(s$42254: Set[a]): DelayList[a] = {
    Set.foldRight(
        x$42270 ->
            acc$42272 ->
                DelayList.ECons(x$42270, acc$42272),
        DelayList.ENil,
        s$42254
    )
}

def Set.toList(s$41478: Set[a]): List[a] = {
    Set.foldRight(
        x$41486 ->
            acc$41490 ->
                List.Cons(x$41486, acc$41490),
        List.Nil,
        s$41478
    )
}

def Set.toMap(s$41662: Set[(a, b)]): Map[a, b] = {
    Set.foldRight(
        x$41668 ->
            acc$41670 ->
                match x$41668 {
                    case (k$41672, v$41674) =>
                        Map.insert(k$41672, v$41674, acc$41670)
                },
        Map.empty(()),
        s$41662
    )
}

def Set.toMapWith(f$41694: a -> b, s$41696: Set[a]): Map[a, b] = {
    Set.foldRight(
        x$41714 ->
            acc$41716 ->
                Map.insert(x$41714, f$41694(x$41714), acc$41716),
        Map.empty(()),
        s$41696
    )
}

def Set.toMutDeque(rc$41721: Region[r], s$41725: Set[a]): MutDeque[a, r] \ r = {
    let d$41745: MutDeque[a, r] = MutDeque.empty(rc$41721);
    Set.forEach(x$41747 -> MutDeque.pushBack(x$41747, d$41745), s$41725);
    d$41745
}

def Set.toMutSet(rc$41775: Region[r], s$41777: Set[a]): MutSet[a, r] \ r = {
    MutSet.MutSet(rc$41775, (ref s$41777) @ rc$41775)
}

def Set.toString(s$39655: Set[a]): String = {
    region rc$39668 {
        let sb$39671: StringBuilder[rc] = StringBuilder.empty(rc$39668);
        StringBuilder.appendString!("""Set#{""", sb$39671);
        Set.forEachWithIndex(
            i$39673 ->
                x$39675 ->
                    if (<[unknown exp]>(i$39673, 0i32)) {
                        StringBuilder.appendString!(
                            """""" + <[unknown exp]>(x$39675),
                            sb$39671
                        )
                    } else {
                        StringBuilder.appendString!(
                            ("""""" + """, """) + <[unknown exp]>(x$39675),
                            sb$39671
                        )
                    },
            s$39655
        );
        StringBuilder.appendString!("""}""", sb$39671);
        StringBuilder.toString(sb$39671)
    }
}

def Set.toVector(s$41619: Set[a]): Vector[a] = {
    region rc$41624 {
        let arr$41627: Array[a, rc] = Array.empty(rc$41624, Set.size(s$41619));
        Iterator.forEachWithIndex(
            i$41629 ->
                x$41631 ->
                    Array.put(x$41631, i$41629, arr$41627),
            Set.iterator(rc$41624, s$41619)
        );
        Array.toVector(arr$41627)
    }
}

def Set.unfold(f$42069: s -> Option[(a, s)], st$42113: s): Set[a] \ ef = {
    letrec loop$42138: (
        s -> Set[a] -> Set[a] \ (e58844 & ef) + ef + ef
    ) = sst$42140 ->
        s$42143 ->
            match f$42069(sst$42140) {
                case Option.None =>
                    s$42143
                case Option.Some(a$42152, st1$42154) =>
                    loop$42138(st1$42154)(Set.insert(a$42152, s$42143))
            };
    loop$42138(st$42113)(Set.empty(()))
}

def Set.unfoldWithIter(next$42230: Unit -> Option[a]): Set[a] \ ef = {
    letrec loop$42237: (Set[a] -> Set[a]) = s$42239 ->
        match next$42230(()) {
            case Option.None =>
                s$42239
            case Option.Some(a$42241) =>
                loop$42237(Set.insert(a$42241, s$42239))
        };
    loop$42237(Set.empty(()))
}

def Set.union(s1$41064: Set[a], s2$41068: Set[a]): Set[a] = {<[unknown exp]>}

def Set.useParallelEvaluation(s$39711: Set[a]): Bool = {
    match s$39711 {
        case Set.Set(t$39713) =>
            let minSize$39715: Int32 = Int32.pow(
                2i32,
                RedBlackTree.blackHeight(t$39713)
            );
            <[unknown exp]>(minSize$39715, 1024i32)
    }
}

def String.abbreviateLeft(w$26334: Int32, s$26336: String): String = {
    match String.length(s$26336) {
        case len$26346 if <[unknown exp]>(len$26346, w$26334) =>
            s$26336
        case _ if <[unknown exp]>(w$26334, 3i32) =>
            """"""
        case len$26359 =>
            let start$26361: Int32 = <[unknown exp]>(
                <[unknown exp]>(len$26359, w$26334),
                3i32
            );
            <[unknown exp]>(
                """...""",
                String.slice(
                    {+start = start$26361 | {}},
                    {+end = len$26359 | {}},
                    s$26336
                )
            )
    }
}

def String.abbreviateRight(w$26431: Int32, s$26437: String): String = {
    match String.length(s$26437) {
        case len$26439 if <[unknown exp]>(len$26439, w$26431) =>
            s$26437
        case _ if <[unknown exp]>(w$26431, 3i32) =>
            """"""
        case _ =>
            <[unknown exp]>(
                String.slice(
                    {+start = 0i32 | {}},
                    {+end = <[unknown exp]>(w$26431, 3i32) | {}},
                    s$26437
                ),
                """..."""
            )
    }
}

def String.arraySwap(
    a$26596: Array[Int32, r1],
    b$26600: Array[Int32, r2]
): Unit \ r2 + r1 = {
    String.forIndex(
        0i32,
        <[unknown exp]>(Array.length(a$26596), 1i32),
        i$26609 ->
            Array.put(Array.get(i$26609, b$26600), i$26609, a$26596)
    )
}

def String.breakOnLeft(
    substr$27014: { substr = String },
    s$27025: String
): (String, String) = {
    match String.indexOfLeft({+substr = substr$27014.substr | {}}, s$27025) {
        case Option.None =>
            (s$27025, """""")
        case Option.Some(i$27040) =>
            (
                String.sliceLeft({+end = i$27040 | {}}, s$27025),
                String.sliceRight({+start = i$27040 | {}}, s$27025)
            )
    }
}

def String.breakOnRight(
    substr$27059: { substr = String },
    s$27063: String
): (String, String) = {
    let sublen$27067: Int32 = String.length(substr$27059.substr);
    match String.indexOfRight({+substr = substr$27059.substr | {}}, s$27063) {
        case Option.None =>
            (s$27063, """""")
        case Option.Some(i$27075) =>
            (
                String.sliceLeft(
                    {+end = <[unknown exp]>(i$27075, sublen$27067) | {}},
                    s$27063
                ),
                String.sliceRight(
                    {+start = <[unknown exp]>(i$27075, sublen$27067) | {}},
                    s$27063
                )
            )
    }
}

def String.center(w$25306: Int32, c$25308: Char, s$25310: String): String = {
    region rc$25312 {
        let space$25315: Int32 = <[unknown exp]>(
            w$25306,
            String.length(s$25310)
        );
        let floor$25318: Int32 = <[unknown exp]>(space$25315, 2i32);
        let ceil$25320: Int32 = <[unknown exp]>(
            <[unknown exp]>(space$25315, 2i32),
            Int32.remainder(space$25315, 2i32)
        );
        let prefix$25322: String = String.repeat(
            floor$25318,
            Char.toString(c$25308)
        );
        let postfix$25324: String = String.repeat(
            ceil$25320,
            Char.toString(c$25308)
        );
        let sb$25326: StringBuilder[rc] = StringBuilder.empty(rc$25312);
        StringBuilder.appendString!(prefix$25322, sb$25326);
        StringBuilder.appendString!(s$25310, sb$25326);
        StringBuilder.appendString!(postfix$25324, sb$25326);
        StringBuilder.toString(sb$25326)
    }
}

def String.charAt(i$22492: Int32, s$22494: String): Char = {
    let charAt$22496: (String -> Int32 -> Char) = obj$$22498 ->
        a0$$22501 ->
            <[unknown exp]>;
    charAt$22496(s$22494)(i$22492)
}

def String.codePointAt(i$22557: Int32, s$22562: String): Int32 = {
    let codePointAt$22573: (String -> Int32 -> Int32) = obj$$22577 ->
        a0$$22582 ->
            <[unknown exp]>;
    codePointAt$22573(s$22562)(i$22557)
}

def String.commonPrefix(s1$26242: String, s2$26246: String): String = {
    let len1$26250: Int32 = String.length(s1$26242);
    let len2$26252: Int32 = String.length(s2$26246);
    letrec loop$26254: (Int32 -> String) = ix$26256 ->
        if (
            <[unknown exp]>(
                ix$26256,
                len1$26250
            ) or <[unknown exp]>(ix$26256, len2$26252)
        ) {
            String.takeLeft(ix$26256, s1$26242)
        } else {
            let c1$26258: Char = String.charAt(ix$26256, s1$26242);
            let c2$26260: Char = String.charAt(ix$26256, s2$26246);
            if (<[unknown exp]>(c1$26258, c2$26260)) {
                String.takeLeft(ix$26256, s1$26242)
            } else {
                loop$26254(<[unknown exp]>(ix$26256, 1i32))
            }
        };
    loop$26254(0i32)
}

def String.commonSuffix(s1$26281: String, s2$26283: String): String = {
    letrec loop$26287: (Int32 -> Int32 -> (Int32 -> String)) = i$26290 ->
        j$26292 ->
            acc$26296 ->
                if (<[unknown exp]>(i$26290, 0i32)) {
                    s1$26281
                } else {
                    if (<[unknown exp]>(j$26292, 0i32)) {
                        s2$26283
                    } else {
                        let c1$26298: Char = String.charAt(i$26290, s1$26281);
                        let c2$26300: Char = String.charAt(j$26292, s2$26283);
                        if (<[unknown exp]>(c1$26298, c2$26300)) {
                            String.takeRight(acc$26296, s1$26281)
                        } else {
                            loop$26287(
                                <[unknown exp]>(i$26290, 1i32)
                            )(
                                <[unknown exp]>(j$26292, 1i32)
                            )(<[unknown exp]>(acc$26296, 1i32))
                        }
                    }
                };
    let start1$26310: Int32 = <[unknown exp]>(String.length(s1$26281), 1i32);
    let start2$26312: Int32 = <[unknown exp]>(String.length(s2$26283), 1i32);
    loop$26287(start1$26310)(start2$26312)(0i32)
}

def String.concat(s1$22623: String, s2$22625: String): String = {
    let concat$22631: (String -> String -> String) = obj$$22633 ->
        a0$$22638 ->
            <[unknown exp]>;
    concat$22631(s1$22623)(s2$22625)
}

def String.contains(
    substr$26220: { substr = String },
    s$26222: String
): Bool = {
    if (String.isEmpty(substr$26220.substr)) {
        true
    } else {
        let a$26228: Option[Int32] = String.indexOfLeft(
            {+substr = substr$26220.substr | {}},
            s$26222
        );
        !Option.isEmpty(a$26228)
    }
}

def String.countSubstring(
    substr$27084: { substr = String },
    s$27089: String
): Int32 = {
    let sublen$27096: Int32 = String.length(substr$27084.substr);
    letrec loop$27099: (Int32 -> Int32 -> Int32) = offset$27103 ->
        count$27105 ->
            match String.indexOfLeftWithOffset(
                {+substr = substr$27084.substr | {}},
                {+offset = offset$27103 | {}},
                s$27089
            ) {
                case Option.None =>
                    count$27105
                case Option.Some(i$27117) =>
                    loop$27099(
                        <[unknown exp]>(i$27117, sublen$27096)
                    )(<[unknown exp]>(count$27105, 1i32))
            };
    if (<[unknown exp]>(sublen$27096, 0i32)) {
        0i32
    } else {
        loop$27099(0i32)(0i32)
    }
}

def String.drop(n$23852: Int32, s$23856: String): String = {
    String.dropLeft(n$23852, s$23856)
}

def String.dropLeft(n$23879: Int32, s$23881: String): String = {
    if (<[unknown exp]>(n$23879, 0i32)) {
        s$23881
    } else {
        String.slice(
            {+start = n$23879 | {}},
            {+end = String.length(s$23881) | {}},
            s$23881
        )
    }
}

def String.dropRight(n$23894: Int32, s$23899: String): String = {
    if (<[unknown exp]>(n$23894, 0i32)) {
        let len$23913: Int32 = String.length(s$23899);
        String.slice(
            {+start = 0i32 | {}},
            {+end = <[unknown exp]>(len$23913, n$23894) | {}},
            s$23899
        )
    } else {
        s$23899
    }
}

def String.dropWhile(f$23995: Char -> Bool, s$24007: String): String = {
    String.dropWhileLeft(f$23995, s$24007)
}

def String.dropWhileAround(f$24144: Char -> Bool, s$24149: String): String = {
    match (
        String.findIndexOfLeft(x$24154 -> !f$24144(x$24154), s$24149),
        String.findIndexOfRight(x$24158 -> !f$24144(x$24158), s$24149)
    ) {
        case (Option.None, Option.None) =>
            """"""
        case (Option.Some(l$24161), Option.None) =>
            String.sliceRight({+start = l$24161 | {}}, s$24149)
        case (Option.None, Option.Some(r$24163)) =>
            String.sliceLeft({+end = r$24163 | {}}, s$24149)
        case (Option.Some(l$24174), Option.Some(r$24177)) =>
            String.slice(
                {+start = l$24174 | {}},
                {+end = <[unknown exp]>(r$24177, 1i32) | {}},
                s$24149
            )
    }
}

def String.dropWhileLeft(f$24046: Char -> Bool, s$24052: String): String = {
    match String.findIndexOfLeft(x$24087 -> !f$24046(x$24087), s$24052) {
        case Option.None =>
            """"""
        case Option.Some(i$24096) =>
            String.sliceRight({+start = i$24096 | {}}, s$24052)
    }
}

def String.dropWhileRight(f$24113: Char -> Bool, s$24115: String): String = {
    match String.findIndexOfRight(x$24126 -> !f$24113(x$24126), s$24115) {
        case Option.None =>
            """"""
        case Option.Some(i$24135) =>
            String.sliceLeft(
                {+end = <[unknown exp]>(i$24135, 1i32) | {}},
                s$24115
            )
    }
}

def String.endsWith(
    suffix$22759: { suffix = String },
    s$22761: String
): Bool = {
    let endsWith$22768: (String -> String -> Bool) = obj$$22772 ->
        a0$$22775 ->
            <[unknown exp]>;
    endsWith$22768(s$22761)(suffix$22759.suffix)
}

def String.enumerator(
    rc$27536: Region[r],
    s$27544: String
): Iterator[(Int32, Char), r, r] \ r = {
    |>(
        String.iterator(rc$27536, s$27544),
        $0$46427 ->
            Iterator.zipWithIndex($0$46427)
    )
}

def String.exists(f$24732: Char -> Bool, s$24734: String): Bool \ ef = {
    match String.findIndexOfLeft(f$24732, s$24734) {
        case Option.None =>
            false
        case Option.Some(_) =>
            true
    }
}

def String.findIndexOfLeft(
    f$23616: Char -> Bool,
    s$23623: String
): Option[Int32] \ ef = {
    let len$23627: Int32 = String.length(s$23623);
    letrec loop$23630: (Int32 -> Int32) = i$23632 ->
        if (<[unknown exp]>(i$23632, len$23627)) {
            -1i32
        } else {
            if (f$23616(String.charAt(i$23632, s$23623))) {
                i$23632
            } else {
                loop$23630(<[unknown exp]>(i$23632, 1i32))
            }
        };
    let i$23636: Int32 = loop$23630(0i32);
    if (<[unknown exp]>(i$23636, 0i32)) {
        Option.None
    } else {
        Option.Some(i$23636)
    }
}

def String.findIndexOfRight(
    f$23653: Char -> Bool,
    s$23656: String
): Option[Int32] = {
    letrec loop$23665: (Int32 -> Int32) = i$23667 ->
        if (<[unknown exp]>(i$23667, 0i32)) {
            -1i32
        } else {
            if (f$23653(String.charAt(i$23667, s$23656))) {
                i$23667
            } else {
                loop$23665(<[unknown exp]>(i$23667, 1i32))
            }
        };
    let end$23678: Int32 = <[unknown exp]>(String.length(s$23656), 1i32);
    let i$23681: Int32 = loop$23665(end$23678);
    if (<[unknown exp]>(i$23681, 0i32)) {
        Option.None
    } else {
        Option.Some(i$23681)
    }
}

def String.findIndices(f$23691: Char -> Bool, s$23695: String): List[Int32] = {
    let len$23706: Int32 = String.length(s$23695);
    letrec loop$23708: (
        Int32 -> (List[Int32] -> List[Int32]) -> List[Int32]
    ) = i$23712 ->
        k$23714 ->
            if (<[unknown exp]>(i$23712, len$23706)) {
                k$23714(List.Nil)
            } else {
                if (f$23691(String.charAt(i$23712, s$23695))) {
                    loop$23708(
                        <[unknown exp]>(i$23712, 1i32)
                    )(ks$23716 -> k$23714(List.Cons(i$23712, ks$23716)))
                } else {
                    loop$23708(<[unknown exp]>(i$23712, 1i32))(k$23714)
                }
            };
    loop$23708(0i32)($0$46397 -> identity($0$46397))
}

def String.flatten(xs$23123: List[String]): String = {
    region rc$23131 {
        let sb$23134: StringBuilder[rc] = StringBuilder.empty(rc$23131);
        List.forEach(
            x$23136 ->
                StringBuilder.appendString!(x$23136, sb$23134),
            xs$23123
        );
        StringBuilder.toString(sb$23134)
    }
}

def String.foldLeft(
    f$24232: b -> Char -> b \ ef,
    x$24235: b,
    s$24237: String
): b \ ef = {
    let len$24239: Int32 = String.length(s$24237);
    letrec loop$24241: (
        b -> Int32 -> b \ ef + (ef & (e66130 + ef))
    ) = acc$24243 ->
        i$24245 ->
            if (<[unknown exp]>(i$24245, len$24239)) {
                acc$24243
            } else {
                let acc1$24247: b = f$24232(
                    acc$24243
                )(String.charAt(i$24245, s$24237));
                loop$24241(acc1$24247)(<[unknown exp]>(i$24245, 1i32))
            };
    loop$24241(x$24235)(0i32)
}

def String.foldLeft2(
    f$24309: b -> Char -> (Char -> b \ ef),
    x$24317: b,
    s$24319: String,
    t$24322: String
): b \ ef = {
    let len$24326: Int32 = Int32.min(
        String.length(s$24319),
        String.length(t$24322)
    );
    letrec loop$24328: (
        b -> Int32 -> b \ ef + (ef & (e85750 + ef))
    ) = acc$24330 ->
        i$24332 ->
            if (<[unknown exp]>(i$24332, len$24326)) {
                acc$24330
            } else {
                let acc1$24334: b = f$24309(
                    acc$24330
                )(
                    String.charAt(i$24332, s$24319)
                )(String.charAt(i$24332, t$24322));
                loop$24328(acc1$24334)(<[unknown exp]>(i$24332, 1i32))
            };
    loop$24328(x$24317)(0i32)
}

def String.foldRight(
    f$24269: Char -> b -> b \ ef,
    x$24271: b,
    s$24276: String
): b \ ef = {
    letrec loop$24282: (
        b -> Int32 -> b \ ef + ((e86870 + ef) & ef)
    ) = acc$24284 ->
        i$24286 ->
            if (<[unknown exp]>(i$24286, 0i32)) {
                acc$24284
            } else {
                let acc1$24289: b = f$24269(
                    String.charAt(i$24286, s$24276)
                )(acc$24284);
                loop$24282(acc1$24289)(<[unknown exp]>(i$24286, 1i32))
            };
    let end$24291: Int32 = <[unknown exp]>(String.length(s$24276), 1i32);
    loop$24282(x$24271)(end$24291)
}

def String.foldRight2(
    f$24358: Char -> Char -> (b -> b \ ef),
    x$24370: b,
    s$24373: String,
    t$24376: String
): b \ ef = {
    let sn$24380: Int32 = <[unknown exp]>(String.length(s$24373), 1i32);
    let tn$24386: Int32 = <[unknown exp]>(String.length(t$24376), 1i32);
    letrec loop$24390: (b -> Int32 -> (Int32 -> b \ ef)) = acc$24392 ->
        i$24394 ->
            j$24396 ->
                if (
                    <[unknown exp]>(
                        i$24394,
                        0i32
                    ) or <[unknown exp]>(j$24396, 0i32)
                ) {
                    acc$24392
                } else {
                    let acc1$24398: b = f$24358(
                        String.charAt(i$24394, s$24373)
                    )(String.charAt(j$24396, t$24376))(acc$24392);
                    loop$24390(
                        acc1$24398
                    )(
                        <[unknown exp]>(i$24394, 1i32)
                    )(<[unknown exp]>(j$24396, 1i32))
                };
    loop$24390(x$24370)(sn$24380)(tn$24386)
}

def String.forAll(f$24757: Char -> Bool, s$24759: String): Bool \ ef = {
    match String.findIndexOfLeft(x$24762 -> !f$24757(x$24762), s$24759) {
        case Option.None =>
            true
        case Option.Some(_) =>
            false
    }
}

def String.forIndex(
    b$26559: Int32,
    e$26563: Int32,
    f$26565: Int32 -> Unit
): Unit \ ef = {
    if (<[unknown exp]>(b$26559, e$26563)) {
        f$26565(b$26559);
        String.forIndex(<[unknown exp]>(b$26559, 1i32), e$26563, f$26565)
    } else {
        ()
    }
}

def String.indent(n$25640: Int32, s$25642: String): String = {
    if (
        <[unknown exp]>(
            n$25640,
            0i32
        ) or <[unknown exp]>(String.length(s$25642), 0i32)
    ) {
        s$25642
    } else {
        String.indentHelper(n$25640, s$25642)
    }
}

def String.indentHelper(n$25673: Int32, s$25675: String): String = {
    region rc$25689 {
        let sb$25698: StringBuilder[rc] = StringBuilder.empty(rc$25689);
        let prefix$25708: String = String.repeat(n$25673, """ """);
        let step$25714: (String -> Unit) = x$25718 ->
            {
                StringBuilder.appendString!(prefix$25708, sb$25698);
                StringBuilder.appendLine!(x$25718, sb$25698)
            };
        List.forEach(step$25714, String.lines(s$25675));
        StringBuilder.toString(sb$25698)
    }
}

def String.indexOf(
    substr$26017: { substr = String },
    s$26026: String
): Option[Int32] = {
    String.indexOfLeft({+substr = substr$26017.substr | {}}, s$26026)
}

def String.indexOfLeft(
    substr$26051: { substr = String },
    s$26053: String
): Option[Int32] = {
    let indexOf$26063: (String -> String -> Int32) = obj$$26065 ->
        a0$$26069 ->
            <[unknown exp]>;
    if (String.isEmpty(substr$26051.substr)) {
        Option.None
    } else {
        let i$26088: Int32 = indexOf$26063(s$26053)(substr$26051.substr);
        if (<[unknown exp]>(i$26088, 0i32)) {
            Option.None
        } else {
            Option.Some(i$26088)
        }
    }
}

def String.indexOfLeftWithOffset(
    substr$26771: { substr = String },
    offset$26777: { offset = Int32 },
    s$26783: String
): Option[Int32] = {
    let indexOf$26805: (String -> String -> (Int32 -> Int32)) = obj$$26810 ->
        a0$$26814 ->
            a1$$26816 ->
                <[unknown exp]>;
    if (String.isEmpty(substr$26771.substr)) {
        Option.None
    } else {
        let ix$26829: Int32 = indexOf$26805(
            s$26783
        )(substr$26771.substr)(offset$26777.offset);
        if (<[unknown exp]>(ix$26829, 0i32)) {
            Option.None
        } else {
            Option.Some(ix$26829)
        }
    }
}

def String.indexOfRight(
    substr$26126: { substr = String },
    s$26128: String
): Option[Int32] = {
    let lastIndexOf$26160: (String -> String -> Int32) = obj$$26164 ->
        a0$$26172 ->
            <[unknown exp]>;
    if (String.isEmpty(substr$26126.substr)) {
        Option.None
    } else {
        let i$26204: Int32 = lastIndexOf$26160(s$26128)(substr$26126.substr);
        if (<[unknown exp]>(i$26204, 0i32)) {
            Option.None
        } else {
            Option.Some(i$26204)
        }
    }
}

def String.indexOfRightWithOffset(
    substr$26833: { substr = String },
    offset$26836: { offset = Int32 },
    s$26845: String
): Option[Int32] = {
    let lastIndexOf$26855: (
        String -> String -> (Int32 -> Int32)
    ) = obj$$26859 ->
        a0$$26861 ->
            a1$$26863 ->
                <[unknown exp]>;
    if (String.isEmpty(substr$26833.substr)) {
        Option.None
    } else {
        let ix$26878: Int32 = lastIndexOf$26855(
            s$26845
        )(substr$26833.substr)(offset$26836.offset);
        if (<[unknown exp]>(ix$26878, 0i32)) {
            Option.None
        } else {
            Option.Some(ix$26878)
        }
    }
}

def String.indices(
    substr$23728: { substr = String },
    s$23735: String
): List[Int32] = {
    let sublen$23742: Int32 = String.length(substr$23728.substr);
    let step$23744: (Int32 -> Option[(Int32, Int32)]) = ix$23748 ->
        match String.indexOfLeftWithOffset(
            {+substr = substr$23728.substr | {}},
            {+offset = ix$23748 | {}},
            s$23735
        ) {
            case Option.None =>
                Option.None
            case Option.Some(ix2$23754) =>
                Option.Some(ix2$23754, <[unknown exp]>(ix2$23754, sublen$23742))
        };
    List.unfold(step$23744, 0i32)
}

def String.init(f$23064: Int32 -> Char, len$23067: Int32): String \ ef = {
    if (<[unknown exp]>(len$23067, 0i32)) {
        """"""
    } else {
        String.initHelper(f$23064, len$23067)
    }
}

def String.initHelper(f$23087: Int32 -> Char, len$23090: Int32): String \ ef = {
    region rc$23100 {
        let sb$23103: StringBuilder[rc] = StringBuilder.empty(rc$23100);
        letrec loop$23105: (Int32 -> String) = i$23107 ->
            if (<[unknown exp]>(i$23107, len$23090)) {
                StringBuilder.toString(sb$23103)
            } else {
                let c$23109: Char = f$23087(i$23107);
                StringBuilder.append!(c$23109, sb$23103);
                loop$23105(<[unknown exp]>(i$23107, 1i32))
            };
        loop$23105(0i32)
    }
}

def String.intercalate(sep$23143: String, xs$23148: List[String]): String = {
    region rc$23154 {
        let sb$23157: StringBuilder[rc] = StringBuilder.empty(rc$23154);
        let arr$23159: Array[String, rc] = List.toArray(rc$23154, xs$23148);
        StringBuilder.intercalate!(sep$23143, arr$23159, sb$23157);
        StringBuilder.toString(sb$23157)
    }
}

def String.intercalateChar(sep$23173: Char, xs$23179: List[String]): String = {
    match xs$23179 {
        case List.Nil =>
            """"""
        case List.Cons(x$23188, rs$23192) =>
            region rc$23194 {
                let sb$23197: StringBuilder[rc] = StringBuilder.empty(rc$23194);
                StringBuilder.appendString!(x$23188, sb$23197);
                let appendStep$23199: (String -> Unit) = s$23201 ->
                    {
                        StringBuilder.append!(sep$23173, sb$23197);
                        StringBuilder.appendString!(s$23201, sb$23197)
                    };
                List.forEach(appendStep$23199, rs$23192);
                StringBuilder.toString(sb$23197)
            }
    }
}

def String.isAscii(s$25135: String): Bool = {
    String.forAll($0$46399 -> Char.isAscii($0$46399), s$25135)
}

def String.isEmpty(s$22662: String): Bool = {
    let isEmpty$22667: (String -> Bool) = obj$$22669 ->
        <[unknown exp]>;
    isEmpty$22667(s$22662)
}

def String.isMatch(regex$23375: { regex = String }, s$23377: String): Bool = {
    let matches$23380: (String -> String -> Bool) = obj$$23386 ->
        a0$$23391 ->
            <[unknown exp]>;
    try {
        matches$23380(s$23377)(regex$23375.regex)
    } catch {case _$23399: ##java.util.regex.PatternSyntaxException => false}
}

def String.isSubmatch(
    regex$23416: { regex = String },
    s$23421: String
): Bool = {
    String.isSubmatchHelper(regex$23416.regex, s$23421)
}

def String.isSubmatchHelper(pattern$23433: String, s$23438: String): Bool = {
    region rc$23441 {
        let compile$23444: (String -> Regex) = a0$$23446 ->
            <[unknown exp]>;
        let matcher$23450: (
            Regex -> java.lang.CharSequence -> java.util.regex.Matcher \ rc
        ) = obj$$23452 ->
            a0$$23454 ->
                <[unknown exp]>;
        let find$23460: (
            java.util.regex.Matcher -> Int32 -> Bool \ rc
        ) = obj$$23462 ->
            a0$$23464 ->
                <[unknown exp]>;
        match rc$23441 {
            case _ =>
                try {
                    let p1$23470: Regex = compile$23444(pattern$23433);
                    let m1$23475: java.util.regex.Matcher = matcher$23450(
                        p1$23470
                    )(<[unknown exp]>);
                    find$23460(m1$23475)(0i32)
                } catch {
                    case _$23484: ##java.util.regex.PatternSyntaxException =>
                        false
                }
        }
    }
}

def String.isWhiteSpace(s$25156: String): Bool = {
    String.forAll($0$46401 -> Char.isWhiteSpace($0$46401), s$25156)
}

def String.iterator(
    rc$27504: Region[r],
    s$27506: String
): Iterator[Char, r, r] \ r = {
    |>(
        Iterator.range(rc$27504, 0i32, String.length(s$27506)),
        (
            $0$46423 ->
                $1$46425 ->
                    Iterator.map($0$46423, $1$46425)
        )(i$27510 -> String.charAt(i$27510, s$27506))
    )
}

def String.length(s$22705: String): Int32 = {
    let length$22707: (String -> Int32) = obj$$22709 ->
        <[unknown exp]>;
    length$22707(s$22705)
}

def String.levenshteinDistance(s$26460: String, t$26462: String): Int32 = {
    region rc$26464 {
        let m$26467: Int32 = String.length(s$26460);
        let n$26469: Int32 = String.length(t$26462);
        let v0$26471: Array[Int32, rc] = Array.repeat(
            rc$26464,
            <[unknown exp]>(n$26469, 1i32),
            0i32
        );
        let v1$26477: Array[Int32, rc] = Array.repeat(
            rc$26464,
            <[unknown exp]>(n$26469, 1i32),
            0i32
        );
        String.forIndex(
            0i32,
            n$26469,
            i$26481 ->
                Array.put(i$26481, i$26481, v0$26471)
        );
        String.forIndex(
            0i32,
            <[unknown exp]>(m$26467, 1i32),
            i$26484 ->
                {
                    Array.put(<[unknown exp]>(i$26484, 1i32), 0i32, v1$26477);
                    String.forIndex(
                        0i32,
                        <[unknown exp]>(n$26469, 1i32),
                        j$26490 ->
                            {
                                let substitutionCost$26495: Int32 = if (
                                    <[unknown exp]>(
                                        String.charAt(i$26484, s$26460),
                                        String.charAt(j$26490, t$26462)
                                    )
                                ) {
                                    0i32
                                } else {
                                    1i32
                                };
                                let a$26499: Int32 = <[unknown exp]>(
                                    Array.get(j$26490, v1$26477),
                                    1i32
                                );
                                let b$26501: Int32 = <[unknown exp]>(
                                    Array.get(
                                        <[unknown exp]>(j$26490, 1i32),
                                        v0$26471
                                    ),
                                    1i32
                                );
                                let c$26507: Int32 = <[unknown exp]>(
                                    Array.get(j$26490, v0$26471),
                                    substitutionCost$26495
                                );
                                Array.put(
                                    Int32.min(
                                        a$26499,
                                        Int32.min(b$26501, c$26507)
                                    ),
                                    <[unknown exp]>(j$26490, 1i32),
                                    v1$26477
                                )
                            }
                    );
                    String.arraySwap(v0$26471, v1$26477)
                }
        );
        Array.get(n$26469, v0$26471)
    }
}

def String.lineSeparator(_unit$22934: Unit): String = {
    let lineSeparator$22942: (Unit -> String) = _$22944 ->
        <[unknown exp]>;
    lineSeparator$22942(())
}

def String.lines(s$25846: String): List[String] = {
    if (String.isEmpty(s$25846)) {
        List.Nil
    } else {
        String.split({+regex = """\R""" | {}}, s$25846)
    }
}

def String.linesWithNewLine(s$27241: String): List[String] = {
    if (String.isEmpty(s$27241)) {
        List.Nil
    } else {
        String.split({+regex = """(?<=\R)""" | {}}, s$27241)
    }
}

def String.map(f$23214: Char -> Char, s$23218: String): String \ ef = {
    let len$23226: Int32 = String.length(s$23218);
    String.init(i$23228 -> f$23214(String.charAt(i$23228, s$23218)), len$23226)
}

def String.mapWithIndex(
    f$23242: Int32 -> Char -> Char \ ef,
    s$23244: String
): String \ ef = {
    let len$23249: Int32 = String.length(s$23244);
    String.init(
        i$23251 ->
            f$23242(i$23251)(String.charAt(i$23251, s$23244)),
        len$23249
    )
}

def String.nonEmpty(s$22683: String): Bool = {!String.isEmpty(s$22683)}

def String.nth(i$22535: Int32, s$22538: String): Option[Char] = {
    if (
        <[unknown exp]>(
            0i32,
            i$22535
        ) and <[unknown exp]>(i$22535, String.length(s$22538))
    ) {
        Option.Some(String.charAt(i$22535, s$22538))
    } else {
        Option.None
    }
}

def String.nthCodePoint(i$22596: Int32, s$22598: String): Option[Int32] = {
    if (
        <[unknown exp]>(
            0i32,
            i$22596
        ) and <[unknown exp]>(i$22596, String.length(s$22598))
    ) {
        Option.Some(String.codePointAt(i$22596, s$22598))
    } else {
        Option.None
    }
}

def String.padLeft(w$25271: Int32, c$25273: Char, s$25275: String): String = {
    let len$25282: Int32 = String.length(s$25275);
    if (<[unknown exp]>(len$25282, w$25271)) {
        s$25275
    } else {
        <[unknown exp]>(
            String.repeat(
                <[unknown exp]>(w$25271, len$25282),
                Char.toString(c$25273)
            ),
            s$25275
        )
    }
}

def String.padRight(w$25285: Int32, c$25287: Char, s$25289: String): String = {
    let len$25293: Int32 = String.length(s$25289);
    if (<[unknown exp]>(len$25293, w$25285)) {
        s$25289
    } else {
        <[unknown exp]>(
            s$25289,
            String.repeat(
                <[unknown exp]>(w$25285, len$25293),
                Char.toString(c$25287)
            )
        )
    }
}

def String.patch(
    i$25611: Int32,
    n$25613: Int32,
    sub$25615: String,
    s$25619: String
): String = {
    let sublen$25629: Int32 = String.length(sub$25615);
    let f$25631: (Int32 -> Char) = ix$25633 ->
        if (
            <[unknown exp]>(
                ix$25633,
                i$25611
            ) and <[unknown exp]>(ix$25633, <[unknown exp]>(i$25611, n$25613))
        ) {
            let offset$25636: Int32 = <[unknown exp]>(ix$25633, i$25611);
            if (
                <[unknown exp]>(
                    offset$25636,
                    0i32
                ) or <[unknown exp]>(offset$25636, sublen$25629)
            ) {
                String.charAt(ix$25633, s$25619)
            } else {
                String.charAt(offset$25636, sub$25615)
            }
        } else {
            String.charAt(ix$25633, s$25619)
        };
    String.init(f$25631, String.length(s$25619))
}

def String.repeat(n$25211: Int32, s$25217: String): String = {
    let repeat$25221: (String -> Int32 -> String) = obj$$25223 ->
        a0$$25225 ->
            <[unknown exp]>;
    if (<[unknown exp]>(n$25211, 0i32)) {
        """"""
    } else {
        repeat$25221(s$25217)(n$25211)
    }
}

def String.replace(
    src$25349: { src = String },
    dst$25372: { dst = String },
    s$25382: String
): String = {
    let replace$25399: (
        String -> java.lang.CharSequence -> (java.lang.CharSequence -> String)
    ) = obj$$25401 ->
        a0$$25403 ->
            a1$$25405 ->
                <[unknown exp]>;
    replace$25399(s$25382)(<[unknown exp]>)(<[unknown exp]>)
}

def String.replaceChar(
    src$25421: { src = Char },
    dst$25425: { dst = Char },
    s$25430: String
): String = {
    let replace$25432: (String -> Char -> (Char -> String)) = obj$$25434 ->
        a0$$25436 ->
            a1$$25438 ->
                <[unknown exp]>;
    replace$25432(s$25430)(src$25421.src)(dst$25425.dst)
}

def String.replaceFirstMatch(
    regex$25514: { regex = String },
    to$25536: { to = String },
    s$25542: String
): String = {
    let replaceFirst$25564: (
        String -> String -> (String -> String)
    ) = obj$$25566 ->
        a0$$25568 ->
            a1$$25570 ->
                <[unknown exp]>;
    replaceFirst$25564(s$25542)(regex$25514.regex)(to$25536.to)
}

def String.replaceMatches(
    regex$25457: { regex = String },
    to$25463: { to = String },
    s$25465: String
): String = {
    let replaceAll$25471: (
        String -> String -> (String -> String)
    ) = obj$$25473 ->
        a0$$25479 ->
            a1$$25481 ->
                <[unknown exp]>;
    replaceAll$25471(s$25465)(regex$25457.regex)(to$25463.to)
}

def String.reverse(s$23257: String): String = {
    let start$23263: Int32 = <[unknown exp]>(String.length(s$23257), 1i32);
    String.init(
        i$23265 ->
            String.charAt(<[unknown exp]>(start$23263, i$23265), s$23257),
        <[unknown exp]>(start$23263, 1i32)
    )
}

def String.rotateLeft(n$23277: Int32, s$23279: String): String = {
    if (<[unknown exp]>(String.length(s$23279), 1i32)) {
        """"""
    } else {
        if (<[unknown exp]>(n$23277, 0i32)) {
            String.rotateRightHelper(Int32.abs(n$23277), s$23279)
        } else {
            String.rotateLeftHelper(n$23277, s$23279)
        }
    }
}

def String.rotateLeftHelper(n$23291: Int32, s$23295: String): String = {
    let len$23301: Int32 = String.length(s$23295);
    let f$23303: (Int32 -> Char) = i$23305 ->
        {
            let i1$23307: Int32 = <[unknown exp]>(n$23291, i$23305);
            String.charAt(Int32.remainder(i1$23307, len$23301), s$23295)
        };
    String.init(f$23303, len$23301)
}

def String.rotateRight(n$23320: Int32, s$23323: String): String = {
    if (<[unknown exp]>(String.length(s$23323), 1i32)) {
        """"""
    } else {
        if (<[unknown exp]>(n$23320, 0i32)) {
            String.rotateLeftHelper(Int32.abs(n$23320), s$23323)
        } else {
            String.rotateRightHelper(n$23320, s$23323)
        }
    }
}

def String.rotateRightHelper(n$23337: Int32, s$23339: String): String = {
    let len$23341: Int32 = String.length(s$23339);
    let n1$23345: Int32 = Int32.remainder(n$23337, len$23341);
    let start$23348: Int32 = <[unknown exp]>(len$23341, n1$23345);
    let f$23352: (Int32 -> Char) = i$23354 ->
        {
            let i1$23356: Int32 = <[unknown exp]>(start$23348, i$23354);
            String.charAt(Int32.remainder(i1$23356, len$23341), s$23339)
        };
    String.init(f$23352, len$23341)
}

def String.slice(
    start$23500: { start = Int32 },
    end$23508: { end = Int32 },
    s$23511: String
): String = {
    try {
        let substring$23517: (
            String -> Int32 -> (Int32 -> String)
        ) = obj$$23519 ->
            a0$$23524 ->
                a1$$23528 ->
                    <[unknown exp]>;
        substring$23517(s$23511)(start$23500.start)(end$23508.end)
    } catch {case _$23533: ##java.lang.IndexOutOfBoundsException => """"""}
}

def String.sliceLeft(end$23554: { end = Int32 }, s$23557: String): String = {
    match String.length(s$23557) {
        case len$23561 if <[unknown exp]>(end$23554.end, len$23561) =>
            """"""
        case _ if <[unknown exp]>(end$23554.end, 0i32) =>
            """"""
        case _ =>
            String.slice({+start = 0i32 | {}}, end$23554, s$23557)
    }
}

def String.sliceRight(
    start$23579: { start = Int32 },
    s$23587: String
): String = {
    match String.length(s$23587) {
        case len$23590 if <[unknown exp]>(start$23579.start, len$23590) =>
            """"""
        case _ if <[unknown exp]>(start$23579.start, 0i32) =>
            """"""
        case len$23595 =>
            String.slice(start$23579, {+end = len$23595 | {}}, s$23587)
    }
}

def String.split(
    regex$22792: { regex = String },
    s$22798: String
): List[String] = {
    region rc$22804 {
        let split$22807: (
            String -> String -> Array[String, rc] \ rc
        ) = obj$$22811 ->
            a0$$22813 ->
                <[unknown exp]>;
        match rc$22804 {
            case _ =>
                Array.toList(split$22807(s$22798)(regex$22792.regex))
        }
    }
}

def String.splitAt(n$24196: Int32, s$24198: String): (String, String) = {
    match String.length(s$24198) {
        case _ if <[unknown exp]>(n$24196, 0i32) =>
            ("""""", s$24198)
        case len$24208 if <[unknown exp]>(n$24196, len$24208) =>
            (s$24198, """""")
        case _ =>
            (
                String.sliceLeft({+end = n$24196 | {}}, s$24198),
                String.sliceRight({+start = n$24196 | {}}, s$24198)
            )
    }
}

def String.splitOn(
    substr$26712: { substr = String },
    s$26714: String
): List[String] = {
    let maxlen$26716: Int32 = String.length(s$26714);
    let sublen$26718: Int32 = String.length(substr$26712.substr);
    let step$26720: (Int32 -> Option[(String, Int32)]) = ix$26723 ->
        if (<[unknown exp]>(ix$26723, maxlen$26716)) {
            Option.None
        } else {
            match String.indexOfLeftWithOffset(
                {+substr = substr$26712.substr | {}},
                {+offset = ix$26723 | {}},
                s$26714
            ) {
                case Option.None =>
                    let s1$26732: String = String.sliceRight(
                        {+start = ix$26723 | {}},
                        s$26714
                    );
                    Option.Some(s1$26732, <[unknown exp]>(maxlen$26716, 1i32))
                case Option.Some(ix2$26744) =>
                    let s1$26746: String = String.slice(
                        {+start = ix$26723 | {}},
                        {+end = ix2$26744 | {}},
                        s$26714
                    );
                    Option.Some(
                        s1$26746,
                        <[unknown exp]>(ix2$26744, sublen$26718)
                    )
            }
        };
    List.unfold(step$26720, 0i32)
}

def String.startsWith(
    prefix$22727: { prefix = String },
    s$22730: String
): Bool = {
    let startsWith$22732: (String -> String -> Bool) = obj$$22735 ->
        a0$$22738 ->
            <[unknown exp]>;
    startsWith$22732(s$22730)(prefix$22727.prefix)
}

def String.stripIndent(n$25756: Int32, s$25758: String): String = {
    if (
        <[unknown exp]>(
            n$25756,
            0i32
        ) or <[unknown exp]>(String.length(s$25758), 0i32)
    ) {
        s$25758
    } else {
        String.stripIndentHelper(n$25756, s$25758)
    }
}

def String.stripIndentHelper(n$25767: Int32, s$25769: String): String = {
    region rc$25778 {
        let sb$25783: StringBuilder[rc] = StringBuilder.empty(rc$25778);
        let limit$25785: Int32 = Int32.min(n$25767, String.length(s$25769));
        letrec loop$25789: (String -> Int32 -> String) = s1$25793 ->
            ix$25796 ->
                if (<[unknown exp]>(ix$25796, limit$25785)) {
                    String.sliceRight({+start = ix$25796 | {}}, s1$25793)
                } else {
                    if (!Char.isWhiteSpace(String.charAt(ix$25796, s1$25793))) {
                        String.sliceRight({+start = ix$25796 | {}}, s1$25793)
                    } else {
                        loop$25789(s1$25793)(<[unknown exp]>(ix$25796, 1i32))
                    }
                };
        let step$25822: (String -> Unit) = s1$25824 ->
            {
                let line$25826: String = loop$25789(s1$25824)(0i32);
                StringBuilder.appendLine!(line$25826, sb$25783)
            };
        List.forEach(step$25822, String.lines(s$25769));
        StringBuilder.toString(sb$25783)
    }
}

def String.stripMargin(s$27138: String): String = {
    String.stripMarginWith({+margin = """|""" | {}}, s$27138)
}

def String.stripMarginWith(
    margin$27156: { margin = String },
    s$27164: String
): String = {
    let l$27170: List[String] = String.linesWithNewLine(s$27164);
    String.intercalate(
        """""",
        List.map(
            (
                $0$46411 ->
                    $1$46413 ->
                        String.stripMarginWithSingleLine($0$46411, $1$46413)
            )(margin$27156),
            l$27170
        )
    )
}

def String.stripMarginWithSingleLine(
    margin$27192: { margin = String },
    s$27198: String
): String = {
    let marginLen$27200: Int32 = String.length(margin$27192.margin);
    let trimmed$27203: String = String.dropWhile(
        c$27209 ->
            <[unknown exp]>(c$27209, ''' '''),
        s$27198
    );
    if (
        String.startsWith({+prefix = margin$27192.margin | {}}, trimmed$27203)
    ) {
        String.sliceRight({+start = marginLen$27200 | {}}, trimmed$27203)
    } else {
        s$27198
    }
}

def String.stripPrefix(
    substr$27270: { substr = String },
    s$27272: String
): Option[String] = {
    if (!String.startsWith({+prefix = substr$27270.substr | {}}, s$27272)) {
        Option.None
    } else {
        Option.Some(
            String.dropLeft(String.length(substr$27270.substr), s$27272)
        )
    }
}

def String.stripSuffix(
    substr$27358: { substr = String },
    s$27360: String
): Option[String] = {
    if (!String.endsWith({+suffix = substr$27358.substr | {}}, s$27360)) {
        Option.None
    } else {
        Option.Some(
            String.dropRight(String.length(substr$27358.substr), s$27360)
        )
    }
}

def String.take(n$23775: Int32, s$23777: String): String = {
    String.takeLeft(n$23775, s$23777)
}

def String.takeLeft(n$23801: Int32, s$23805: String): String = {
    if (<[unknown exp]>(n$23801, String.length(s$23805))) {
        s$23805
    } else {
        String.slice({+start = 0i32 | {}}, {+end = n$23801 | {}}, s$23805)
    }
}

def String.takeRight(n$23816: Int32, s$23829: String): String = {
    let len$23838: Int32 = String.length(s$23829);
    if (<[unknown exp]>(n$23816, len$23838)) {
        s$23829
    } else {
        String.slice(
            {+start = <[unknown exp]>(len$23838, n$23816) | {}},
            {+end = len$23838 | {}},
            s$23829
        )
    }
}

def String.takeWhile(f$23921: Char -> Bool, s$23926: String): String = {
    String.takeWhileLeft(f$23921, s$23926)
}

def String.takeWhileLeft(f$23934: Char -> Bool, s$23940: String): String = {
    match String.findIndexOfLeft(x$23946 -> !f$23934(x$23946), s$23940) {
        case Option.None =>
            s$23940
        case Option.Some(i$23952) =>
            String.take(i$23952, s$23940)
    }
}

def String.takeWhileRight(f$23968: Char -> Bool, s$23971: String): String = {
    match String.findIndexOfRight(x$23978 -> !f$23968(x$23978), s$23971) {
        case Option.None =>
            s$23971
        case Option.Some(i$23986) =>
            String.slice(
                {+start = <[unknown exp]>(i$23986, 1i32) | {}},
                {+end = String.length(s$23971) | {}},
                s$23971
            )
    }
}

def String.toArray(rc$22961: Region[r], s$22967: String): Array[Char, r] \ r = {
    Array.init(
        rc$22961,
        i$22973 ->
            String.charAt(i$22973, s$22967),
        String.length(s$22967)
    )
}

def String.toChunks(k$26932: Int32, s$26942: String): List[String] = {
    if (<[unknown exp]>(k$26932, 0i32)) {
        List.Nil
    } else {
        String.toChunksHelper(k$26932, s$26942)
    }
}

def String.toChunksHelper(size$26970: Int32, s$26972: String): List[String] = {
    let len$26982: Int32 = String.length(s$26972);
    let step$26984: (Int32 -> Option[(String, Int32)]) = pos$26986 ->
        match pos$26986 {
            case i$26988 if <[unknown exp]>(i$26988, len$26982) =>
                Option.None
            case i$26998 if <[unknown exp]>(
                <[unknown exp]>(i$26998, size$26970),
                len$26982
            ) =>
                Option.Some(
                    String.sliceRight({+start = i$26998 | {}}, s$26972),
                    len$26982
                )
            case i$27003 =>
                Option.Some(
                    String.slice(
                        {+start = i$27003 | {}},
                        {+end = <[unknown exp]>(i$27003, size$26970) | {}},
                        s$26972
                    ),
                    <[unknown exp]>(i$27003, size$26970)
                )
        };
    List.unfold(step$26984, 0i32)
}

def String.toList(s$22886: String): List[Char] = {
    List.map(
        i$22896 ->
            String.charAt(i$22896, s$22886),
        List.range(0i32, String.length(s$22886))
    )
}

def String.toLowerCase(s$22833: String): String = {
    let toLowerCase$22841: (String -> String) = obj$$22844 ->
        <[unknown exp]>;
    toLowerCase$22841(s$22833)
}

def String.toRegex(regex$23008: String): Result[String, Regex] = {
    Result.tryCatch(
        _$23014 ->
            {
                let compile$23016: (String -> Regex) = a0$$23020 ->
                    <[unknown exp]>;
                compile$23016(regex$23008)
            }
    )
}

def String.toRegexWithFlags(
    flags$23030: Set[Flag],
    regex$23032: String
): Result[String, Regex] = {
    Result.tryCatch(
        _$23038 ->
            {
                let compile$23040: (String -> Int32 -> Regex) = a0$$23045 ->
                    a1$$23049 ->
                        <[unknown exp]>;
                compile$23040(regex$23032)(Regex.sumFlags(flags$23030))
            }
    )
}

def String.toUpperCase(s$22856: String): String = {
    let toUpperCase$22864: (String -> String) = obj$$22866 ->
        <[unknown exp]>;
    toUpperCase$22864(s$22856)
}

def String.toVector(s$22985: String): Vector[Char] = {
    region rc$22989 {
        let arr$22992: Array[Char, rc] = String.toArray(rc$22989, s$22985);
        Array.toVector(arr$22992)
    }
}

def String.trim(s$22908: String): String = {
    let trim$22910: (String -> String) = obj$$22912 ->
        <[unknown exp]>;
    trim$22910(s$22908)
}

def String.trimLeft(s$25161: String): String = {
    String.dropWhileLeft($0$46403 -> Char.isWhiteSpace($0$46403), s$25161)
}

def String.trimRight(s$25181: String): String = {
    String.dropWhileRight($0$46405 -> Char.isWhiteSpace($0$46405), s$25181)
}

def String.unfold(f$24423: b -> Option[(Char, b)], x$24425: b): String \ ef = {
    region rc$24428 {
        let sb$24431: StringBuilder[rc] = StringBuilder.empty(rc$24428);
        letrec loop$24433: (b -> String) = a$24435 ->
            {
                let a1$24437: Option[(Char, b)] = f$24423(a$24435);
                match a1$24437 {
                    case Option.None =>
                        StringBuilder.toString(sb$24431)
                    case Option.Some(c$24441, st1$24443) =>
                        StringBuilder.append!(c$24441, sb$24431);
                        loop$24433(st1$24443)
                }
            };
        loop$24433(x$24425)
    }
}

def String.unfoldString(
    f$24513: b -> Option[(String, b)],
    x$24527: b
): String \ ef = {
    region rc$24529 {
        let sb$24532: StringBuilder[rc] = StringBuilder.empty(rc$24529);
        letrec loop$24534: (b -> String) = a$24538 ->
            {
                let a1$24540: Option[(String, b)] = f$24513(a$24538);
                match a1$24540 {
                    case Option.None =>
                        StringBuilder.toString(sb$24532)
                    case Option.Some(s$24542, st1$24544) =>
                        StringBuilder.appendString!(s$24542, sb$24532);
                        loop$24534(st1$24544)
                }
            };
        loop$24534(x$24527)
    }
}

def String.unfoldStringWithIter(
    f$24631: Unit -> Option[String]
): String \ ef = {
    region rc$24675 {
        let sb$24680: StringBuilder[rc] = StringBuilder.empty(rc$24675);
        letrec loop$24682: (Unit -> String) = _unit$24684 ->
            match f$24631(()) {
                case Option.None =>
                    StringBuilder.toString(sb$24680)
                case Option.Some(s$24696) =>
                    StringBuilder.appendString!(s$24696, sb$24680);
                    loop$24682(())
            };
        loop$24682(())
    }
}

def String.unfoldWithIter(f$24471: Unit -> Option[Char]): String \ ef = {
    region rc$24473 {
        let sb$24476: StringBuilder[rc] = StringBuilder.empty(rc$24473);
        letrec loop$24478: (Unit -> String) = _unit$24480 ->
            match f$24471(()) {
                case Option.None =>
                    StringBuilder.toString(sb$24476)
                case Option.Some(c$24486) =>
                    StringBuilder.append!(c$24486, sb$24476); loop$24478(())
            };
        loop$24478(())
    }
}

def String.unlines(a$25871: List[String]): String = {
    region rc$25880 {
        let sb$25886: StringBuilder[rc] = StringBuilder.empty(rc$25880);
        List.forEach(
            x$25890 ->
                StringBuilder.appendLine!(x$25890, sb$25886),
            a$25871
        );
        StringBuilder.toString(sb$25886)
    }
}

def String.unwords(l$25987: List[String]): String = {
    match l$25987 {
        case List.Nil =>
            """"""
        case List.Cons(x$25990, xs$25992) =>
            region rc$25994 {
                let sb$25997: StringBuilder[rc] = StringBuilder.empty(rc$25994);
                StringBuilder.appendString!(x$25990, sb$25997);
                let f$25999: (String -> Unit) = s$26002 ->
                    {
                        StringBuilder.append!(''' ''', sb$25997);
                        StringBuilder.appendString!(s$26002, sb$25997)
                    };
                List.forEach(f$25999, xs$25992);
                StringBuilder.toString(sb$25997)
            }
    }
}

def String.unwrap(s$27463: String): String = {
    Regex.replace({+src = Regex("[
]+") | {}}, {+dst = """ """ | {}}, s$27463)
}

def String.update(i$25585: Int32, a$25587: Char, s$25589: String): String = {
    let f$25591: (Int32 -> Char) = ix$25593 ->
        if (<[unknown exp]>(ix$25593, i$25585)) {
            a$25587
        } else {
            String.charAt(ix$25593, s$25589)
        };
    String.init(f$25591, String.length(s$25589))
}

def String.words(s$25920: String): List[String] = {
    match String.trim(s$25920) {
        case s1$25956 if String.isEmpty(s1$25956) =>
            List.Nil
        case s1$25975 =>
            String.split({+regex = """\s+""" | {}}, s1$25975)
    }
}

def String.wrap(w$27388: Int32, s$27392: String): String = {
    if (<[unknown exp]>(w$27388, 0i32)) {
        """"""
    } else {
        let lines$27408: List[String] = List.flatMap(
            l$27411 ->
                String.wrapLine(w$27388, l$27411),
            String.lines(s$27392)
        );
        String.intercalate(String.lineSeparator(()), lines$27408)
    }
}

def String.wrapLine(w$27418: Int32, s$27420: String): List[String] = {
    if (<[unknown exp]>(String.length(s$27420), w$27418)) {
        List.Cons(s$27420, List.Nil)
    } else {
        let endOpt$27437: Option[Int32] = Regex.indexOfLastWithBounds(
            {+substr = Regex("(?<!\s)\s") | {}},
            {+start = 0i32 | {}},
            {+end = w$27418 | {}},
            s$27420
        );
        let end$27442: Int32 = match endOpt$27437 {
            case Option.Some(end$27445) =>
                end$27445
            case Option.None =>
                w$27418
        };
        List.Cons(
            String.sliceLeft({+end = end$27442 | {}}, s$27420),
            String.wrapLine(
                w$27418,
                String.trimLeft(
                    String.sliceRight({+start = end$27442 | {}}, s$27420)
                )
            )
        )
    }
}

def String.zip(a$26615: String, b$26621: String): List[(Char, Char)] = {
    let len$26638: Int32 = Int32.min(
        String.length(a$26615),
        String.length(b$26621)
    );
    List.unfold(
        i$26640 ->
            if (<[unknown exp]>(i$26640, len$26638)) {
                Option.None
            } else {
                Option.Some(
                    (
                        String.charAt(i$26640, a$26615),
                        String.charAt(i$26640, b$26621)
                    ),
                    <[unknown exp]>(i$26640, 1i32)
                )
            },
        0i32
    )
}

def String.zipWith(
    f$26661: Char -> Char -> Char \ ef,
    a$26672: String,
    b$26675: String
): String \ ef = {
    let len$26687: Int32 = Int32.min(
        String.length(a$26672),
        String.length(b$26675)
    );
    String.init(
        i$26695 ->
            f$26661(
                String.charAt(i$26695, a$26672)
            )(String.charAt(i$26695, b$26675)),
        len$26687
    )
}

enum StringBuilder[_] {case StringBuilder(java.lang.StringBuilder)}

def StringBuilder.append!(x$9684: a, sb$9686: StringBuilder[r]): Unit \ r = {
    let s$9688: String = <[unknown exp]>(x$9684);
    StringBuilder.appendString!(s$9688, sb$9686);
    ()
}

def StringBuilder.appendCodePoint!(
    cp$9765: Int32,
    sb$9767: StringBuilder[r]
): Unit \ r = {
    let appendCodePoint$9779: (
        java.lang.StringBuilder -> Int32 -> java.lang.StringBuilder \ r
    ) = obj$$9785 ->
        a0$$9790 ->
            <[unknown exp]>;
    match sb$9767 {
        case StringBuilder.StringBuilder(msb$9805) =>
            discard appendCodePoint$9779(msb$9805)(cp$9765); ()
    }
}

def StringBuilder.appendLine!(
    s$9866: String,
    sb$9870: StringBuilder[r]
): Unit \ r = {
    StringBuilder.appendString!(s$9866, sb$9870);
    StringBuilder.appendLineSeparator!(sb$9870)
}

def StringBuilder.appendLineSeparator!(sb$9834: StringBuilder[r]): Unit \ r = {
    StringBuilder.appendString!(String.lineSeparator(()), sb$9834)
}

def StringBuilder.appendLineWith!(
    f$9919: a -> String,
    x$9931: a,
    sb$9933: StringBuilder[r]
): Unit \ ef + r = {
    StringBuilder.appendString!(f$9919(x$9931), sb$9933);
    StringBuilder.appendLineSeparator!(sb$9933)
}

def StringBuilder.appendLines!(
    a$9975: Array[String, r1],
    sb$9979: StringBuilder[r2]
): Unit \ r1 + r2 = {
    Array.forEach(x$9993 -> StringBuilder.appendLine!(x$9993, sb$9979), a$9975)
}

def StringBuilder.appendLinesWith(
    f$10036: a -> String,
    t$10039: t[a],
    sb$10041: StringBuilder[r]
): Unit \ ef + r = {
    <[unknown exp]>(
        x$10048 ->
            StringBuilder.appendLineWith!(f$10036, x$10048, sb$10041),
        t$10039
    )
}

def StringBuilder.appendLinesWith!(
    f$10083: a -> String,
    a$10094: Array[a, r1],
    sb$10106: StringBuilder[r2]
): Unit \ ef + r1 + r2 = {
    Array.forEach(
        x$10120 ->
            StringBuilder.appendLineWith!(f$10083, x$10120, sb$10106),
        a$10094
    )
}

def StringBuilder.appendString!(
    s$9713: String,
    sb$9717: StringBuilder[r]
): Unit \ r = {
    let append$9720: (
        java.lang.StringBuilder -> String -> java.lang.StringBuilder \ r
    ) = obj$$9722 ->
        a0$$9727 ->
            <[unknown exp]>;
    match sb$9717 {
        case StringBuilder.StringBuilder(msb$9742) =>
            discard append$9720(msb$9742)(s$9713); ()
    }
}

def StringBuilder.empty(_$9656: Region[r]): StringBuilder[r] \ r = {
    let newStringBuilder$9662: (Unit -> java.lang.StringBuilder) = _$9664 ->
        <[unknown exp]>;
    StringBuilder.StringBuilder(newStringBuilder$9662(()))
}

def StringBuilder.enumerator(
    rc1$10291: Region[r1],
    sb$10293: StringBuilder[r2]
): Iterator[(Int32, Char), r1 + r2, r1] \ r1 + r2 = {
    |>(
        StringBuilder.iterator(rc1$10291, sb$10293),
        $0$45670 ->
            Iterator.zipWithIndex($0$45670)
    )
}

def StringBuilder.intercalate!(
    sep$10172: String,
    a$10176: Array[String, r1],
    sb$10183: StringBuilder[r2]
): Unit \ r1 + r2 = {
    let append1!$10191: (Int32 -> String -> Unit \ r2) = i$10193 ->
        s$10195 ->
            if (<[unknown exp]>(i$10193, 0i32)) {
                StringBuilder.appendString!(sep$10172, sb$10183);
                StringBuilder.appendString!(s$10195, sb$10183)
            } else {
                StringBuilder.appendString!(s$10195, sb$10183)
            };
    Array.forEachWithIndex(append1!$10191, a$10176)
}

def StringBuilder.iterator(
    rc$10230: Region[r1],
    sb$10232: StringBuilder[r2]
): Iterator[Char, r1 + r2, r1] \ r1 + r2 = {
    let charAt$10236: (
        java.lang.StringBuilder -> Int32 -> Char \ r2
    ) = obj$$10238 ->
        a0$$10242 ->
            <[unknown exp]>;
    match sb$10232 {
        case StringBuilder.StringBuilder(msb$10250) =>
            |>(
                Iterator.range(rc$10230, 0i32, StringBuilder.length(sb$10232)),
                (
                    $0$45664 ->
                        $1$45666 ->
                            Iterator.map($0$45664, $1$45666)
                )(i$10260 -> charAt$10236(msb$10250)(i$10260))
            )
    }
}

def StringBuilder.length(sb$10318: StringBuilder[r]): Int32 \ r = {
    let length$10324: (java.lang.StringBuilder -> Int32) = obj$$10328 ->
        <[unknown exp]>;
    match sb$10318 {
        case StringBuilder.StringBuilder(msb$10336) =>
            length$10324(msb$10336)
    }
}

def StringBuilder.setLength!(
    newLength$10354: Int32,
    sb$10358: StringBuilder[r]
): Unit \ r = {
    let setLength$10363: (
        java.lang.StringBuilder -> Int32 -> Unit \ r
    ) = obj$$10365 ->
        a0$$10370 ->
            <[unknown exp]>;
    match sb$10358 {
        case StringBuilder.StringBuilder(msb$10380) =>
            setLength$10363(msb$10380)(newLength$10354)
    }
}

def StringBuilder.toString(sb$10405: StringBuilder[r]): String \ r = {
    let toString$10410: (java.lang.StringBuilder -> String) = obj$$10414 ->
        <[unknown exp]>;
    match sb$10405 {
        case StringBuilder.StringBuilder(msb$10426) =>
            toString$10410(msb$10426)
    }
}

def System.StdErr.flush(_unit$1777: Unit): Unit \ IO = {
    let flush$1779: (java.io.PrintStream -> Unit) = obj$$1781 ->
        obj$$1781..flush();
    |>(System.StdErr.getErrorStream(()), flush$1779)
}

def System.StdErr.getErrorStream(_unit$1783: Unit): java.io.PrintStream \ IO = {
    let getErr$1785: (Unit -> java.io.PrintStream) = _$1787 ->
        ##java.lang.System.err;
    getErr$1785(())
}

def System.StdErr.newLine(_unit$1771: Unit): Unit \ IO = {
    let println$1773: (java.io.PrintStream -> Unit) = obj$$1775 ->
        obj$$1775..println();
    |>(System.StdErr.getErrorStream(()), println$1773)
}

def System.StdErr.print(s$1755: String): Unit \ IO = {
    let print$1757: (java.io.PrintStream -> String -> Unit \ IO) = obj$$1759 ->
        a0$$1761 ->
            obj$$1759..print(a0$$1761);
    |>(s$1755, print$1757(System.StdErr.getErrorStream(())))
}

def System.StdErr.println(s$1763: String): Unit \ IO = {
    let println$1765: (
        java.io.PrintStream -> String -> Unit \ IO
    ) = obj$$1767 ->
        a0$$1769 ->
            obj$$1767..println(a0$$1769);
    |>(s$1763, println$1765(System.StdErr.getErrorStream(())))
}

def System.StdIn.readLines(
    rc$163: Region[r]
): Iterator[String, IO + r, r] \ r + IO = {
    let getSystemIn$197: (Unit -> java.io.InputStream) = _$203 ->
        ##java.lang.System.in;
    let newInputStream$299: (
        java.io.InputStream -> java.io.InputStreamReader
    ) = a0$301 ->
        ##java.io.InputStreamReader(a0$301);
    let newBufferedReader$491: (
        java.io.Reader -> java.io.BufferedReader
    ) = a0$493 ->
        ##java.io.BufferedReader(a0$493);
    let brReadLine$497: (java.io.BufferedReader -> String) = obj$$499 ->
        obj$$499..readLine();
    let br$501: java.io.BufferedReader = newBufferedReader$491(<[unknown exp]>);
    let nextLine$503: Ref[Option[String], r] = (ref Option.None) @ rc$163;
    let next$505: (Unit -> Option[String]) = _unit$507 ->
        {
            let l$509: Option[String] = match deref nextLine$503 {
                case Option.Some(line$536) =>
                    if (Object.isNull(line$536)) {
                        Option.None
                    } else {
                        Option.Some(line$536)
                    }
                case Option.None =>
                    let n$538: String = brReadLine$497(br$501);
                    Ref.put(Option.Some(n$538), nextLine$503);
                    if (Object.isNull(n$538)) {
                        Option.None
                    } else {
                        Option.Some(n$538)
                    }
            };
            Ref.put(Option.None, nextLine$503);
            l$509
        };
    Iterator.iterate(rc$163, next$505)
}

def System.StdOut.flush(_unit$1743: Unit): Unit \ IO = {
    let flush$1745: (java.io.PrintStream -> Unit) = obj$$1747 ->
        obj$$1747..flush();
    |>(System.StdOut.getOutputStream(()), flush$1745)
}

def System.StdOut.getOutputStream(
    _unit$1749: Unit
): java.io.PrintStream \ IO = {
    let getOut$1751: (Unit -> java.io.PrintStream) = _$1753 ->
        ##java.lang.System.out;
    getOut$1751(())
}

def System.StdOut.newLine(_unit$1737: Unit): Unit \ IO = {
    let println$1739: (java.io.PrintStream -> Unit) = obj$$1741 ->
        obj$$1741..println();
    |>(System.StdOut.getOutputStream(()), println$1739)
}

def System.StdOut.print(s$1721: String): Unit \ IO = {
    let print$1723: (java.io.PrintStream -> String -> Unit \ IO) = obj$$1725 ->
        a0$$1727 ->
            obj$$1725..print(a0$$1727);
    |>(s$1721, print$1723(System.StdOut.getOutputStream(())))
}

def System.StdOut.println(s$1729: String): Unit \ IO = {
    let println$1731: (
        java.io.PrintStream -> String -> Unit \ IO
    ) = obj$$1733 ->
        a0$$1735 ->
            obj$$1733..println(a0$$1735);
    |>(s$1729, println$1731(System.StdOut.getOutputStream(())))
}

def Thread.sleep(d$38318: Duration): Unit \ IO = {
    let jsleep$38329: (Int64 -> Int32 -> Unit \ IO) = a0$$38333 ->
        a1$$38338 ->
            ##java.lang.Thread.sleep(a0$$38333, a1$$38338);
    let valueOf$38354: (Int64 -> java.lang.Long) = a0$$38356 ->
        <[unknown exp]>;
    let intValue$38359: (java.lang.Long -> Int32) = obj$$38361 ->
        <[unknown exp]>;
    match d$38318 {
        case Time.Duration.Duration(nsTotal$38365) =>
            let ms$38368: Int64 = <[unknown exp]>(nsTotal$38365, 1000000i64);
            let ns$38373: Int32 = (
                if (<[unknown exp]>(nsTotal$38365, 0i64)) {
                    intValue$38359(valueOf$38354(nsTotal$38365 rem 1000000i64))
                } else {
                    0i32
                }
            ): Int32;
            jsleep$38329(ms$38368)(ns$38373)
    }
}

enum Time.Duration {case Duration(Int64)}

def Time.Duration.fromMicroSeconds(n$38415: Int32): Duration = {
    Time.Duration.Duration(<[unknown exp]>(Int32.toInt64(n$38415), 1000i64))
}

def Time.Duration.fromMilliSeconds(n$38423: Int32): Duration = {
    Time.Duration.Duration(<[unknown exp]>(Int32.toInt64(n$38423), 1000000i64))
}

def Time.Duration.fromNanoSeconds(n$38380: Int32): Duration = {
    Time.Duration.Duration(Int32.toInt64(n$38380))
}

def Time.Duration.fromSeconds(n$38438: Int32): Duration = {
    Time.Duration.Duration(
        <[unknown exp]>(Int32.toInt64(n$38438), 1000000000i64)
    )
}

def Time.Epoch.microseconds(_unit$29074: Unit): Int64 \ IO = {
    <[unknown exp]>(Time.Epoch.nanoseconds(()), 1000i64)
}

def Time.Epoch.milliseconds(_unit$29093: Unit): Int64 \ IO = {
    <[unknown exp]>(Time.Epoch.microseconds(()), 1000i64)
}

def Time.Epoch.nanoseconds(_unit$29049: Unit): Int64 \ IO = {
    let nanoTime$29058: (Unit -> Int64) = _$29060 ->
        ##java.lang.System.nanoTime();
    nanoTime$29058(())
}

def Time.Epoch.seconds(_unit$29099: Unit): Int64 \ IO = {
    <[unknown exp]>(Time.Epoch.milliseconds(()), 1000i64)
}

enum Time.Instant {case Instant(java.time.Instant)}

def Time.Instant.after(x$16827: Instant, y$16832: Instant): Bool = {
    let isAfter$16844: (
        java.time.Instant -> java.time.Instant -> Bool
    ) = obj$$16846 ->
        a0$$16850 ->
            <[unknown exp]>;
    match x$16827 {
        case Time.Instant.Instant(t1$16854) =>
            match y$16832 {
                case Time.Instant.Instant(t2$16858) =>
                    isAfter$16844(t1$16854)(t2$16858)
            }
    }
}

def Time.Instant.before(x$16792: Instant, y$16794: Instant): Bool = {
    let isBefore$16798: (
        java.time.Instant -> java.time.Instant -> Bool
    ) = obj$$16800 ->
        a0$$16806 ->
            <[unknown exp]>;
    match x$16792 {
        case Time.Instant.Instant(t1$16814) =>
            match y$16794 {
                case Time.Instant.Instant(t2$16818) =>
                    isBefore$16798(t1$16814)(t2$16818)
            }
    }
}

def Time.Instant.minus(x$16921: Instant, d$16929: Int64): Instant = {
    let minusNanos$16940: (
        java.time.Instant -> Int64 -> java.time.Instant
    ) = obj$$16945 ->
        a0$$16951 ->
            <[unknown exp]>;
    match x$16921 {
        case Time.Instant.Instant(t$16957) =>
            Time.Instant.Instant(minusNanos$16940(t$16957)(d$16929))
    }
}

def Time.Instant.now(_unit$16771: Unit): Instant \ IO = {
    let now$16775: (Unit -> java.time.Instant) = _$16777 ->
        ##java.time.Instant.now();
    Time.Instant.Instant(now$16775(()))
}

def Time.Instant.plus(x$16881: Instant, d$16887: Int64): Instant = {
    let plusNanos$16891: (
        java.time.Instant -> Int64 -> java.time.Instant
    ) = obj$$16895 ->
        a0$$16901 ->
            <[unknown exp]>;
    match x$16881 {
        case Time.Instant.Instant(t$16906) =>
            Time.Instant.Instant(plusNanos$16891(t$16906)(d$16887))
    }
}

def Time.Instant.toString(x$16977: Instant): String = {
    let str$16985: (java.time.Instant -> String) = obj$$16989 ->
        <[unknown exp]>;
    match x$16977 {case Time.Instant.Instant(t$16999) => str$16985(t$16999)}
}

def Traversable.for(t$4498: t[a], f$4500: a -> m[b]): m[t[b]] \ ef = {
    <[unknown exp]>(f$4500, t$4498)
}

def Traversable.mapAccumLeft(
    f$4521: acc -> a -> (acc, b) \ ef,
    start$4528: acc,
    t$4533: t[a]
): (acc, t[b]) \ ef = {
    region rc$4549 {
        let acc$4552: Ref[acc, rc] = (ref start$4528) @ rc$4549;
        match |>(
            t$4533,
            (
                $0$45451 ->
                    $1$45453 ->
                        <[unknown exp]>($0$45451, $1$45453)
            )(
                x$4560 ->
                    {
                        let st$4562: acc = deref acc$4552;
                        match f$4521(st$4562)(x$4560) {
                            case (acc1$4566, b$4568) =>
                                Ref.put(acc1$4566, acc$4552);
                                Identity.Identity(b$4568)
                        }
                    }
            )
        ) {
            case Identity.Identity(tb$4578) =>
                (deref acc$4552, tb$4578)
        }
    }
}

enum Validation[e, t] {case Success(t) case Failure(Nec[e])}

def Validation.ap(
    v1$34337: Validation[e, t -> u \ ef],
    v2$34343: Validation[e, t]
): Validation[e, u] \ ef = {
    match (v1$34337, v2$34343) {
        case (Validation.Success(f$34353), Validation.Success(v$34355)) =>
            Validation.Success(f$34353(v$34355))
        case (Validation.Success(_), Validation.Failure(e$34361)) =>
            Validation.Failure(e$34361)
        case (Validation.Failure(e$34368), Validation.Success(_)) =>
            Validation.Failure(e$34368)
        case (Validation.Failure(x$34377), Validation.Failure(y$34380)) =>
            Validation.Failure(Nec.append(x$34377, y$34380))
    }
}

def Validation.collectFailuresWith(
    f$35151: a -> Validation[e, b],
    l$35163: List[a],
    acc$35165: Nec[e]
): Validation[e, c] \ ef = {
    match l$35163 {
        case List.Nil =>
            Validation.Failure(acc$35165)
        case List.Cons(x$35170, xs$35172) =>
            match f$35151(x$35170) {
                case Validation.Success(_) =>
                    Validation.collectFailuresWith(f$35151, xs$35172, acc$35165)
                case Validation.Failure(e$35174) =>
                    Validation.collectFailuresWith(
                        f$35151,
                        xs$35172,
                        Nec.append(acc$35165, e$35174)
                    )
            }
    }
}

def Validation.exists(
    f$34827: t -> Bool,
    v$34840: Validation[e, t]
): Bool \ ef = {
    match v$34840 {
        case Validation.Success(t$34848) =>
            f$34827(t$34848)
        case Validation.Failure(_) =>
            false
    }
}

def Validation.forAll(
    f$34862: t -> Bool,
    v$34864: Validation[e, t]
): Bool \ ef = {
    match v$34864 {
        case Validation.Success(t$34889) =>
            f$34862(t$34889)
        case Validation.Failure(_) =>
            true
    }
}

def Validation.getWithDefault(d$34726: t, v$34728: Validation[e, t]): t = {
    match v$34728 {
        case Validation.Success(t$34741) =>
            t$34741
        case Validation.Failure(_) =>
            d$34726
    }
}

def Validation.map(
    f$34906: t -> u,
    v$34908: Validation[e, t]
): Validation[e, u] \ ef = {
    match v$34908 {
        case Validation.Success(t$34921) =>
            Validation.Success(f$34906(t$34921))
        case Validation.Failure(e$34927) =>
            Validation.Failure(e$34927)
    }
}

def Validation.map10(
    f$35954: t1 ->
        t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> (t8 -> (t9 -> (t10 -> u \ ef)))))))),
    v1$35995: Validation[e, t1],
    v2$36005: Validation[e, t2],
    v3$36009: Validation[e, t3],
    v4$36011: Validation[e, t4],
    v5$36015: Validation[e, t5],
    v6$36017: Validation[e, t6],
    v7$36019: Validation[e, t7],
    v8$36021: Validation[e, t8],
    v9$36025: Validation[e, t9],
    v10$36027: Validation[e, t10]
): Validation[e, u] \ ef = {
    Validation.ap(
        Validation.map9(
            f$35954,
            v1$35995,
            v2$36005,
            v3$36009,
            v4$36011,
            v5$36015,
            v6$36017,
            v7$36019,
            v8$36021,
            v9$36025
        ),
        v10$36027
    )
}

def Validation.map2(
    f$35307: t1 -> t2 -> u \ ef,
    v1$35309: Validation[e, t1],
    v2$35311: Validation[e, t2]
): Validation[e, u] \ ef = {
    Validation.ap(Validation.map(f$35307, v1$35309), v2$35311)
}

def Validation.map3(
    f$35350: t1 -> t2 -> (t3 -> u \ ef),
    v1$35352: Validation[e, t1],
    v2$35354: Validation[e, t2],
    v3$35356: Validation[e, t3]
): Validation[e, u] \ ef = {
    Validation.ap(Validation.map2(f$35350, v1$35352, v2$35354), v3$35356)
}

def Validation.map4(
    f$35389: t1 -> t2 -> (t3 -> (t4 -> u \ ef)),
    v1$35400: Validation[e, t1],
    v2$35406: Validation[e, t2],
    v3$35410: Validation[e, t3],
    v4$35414: Validation[e, t4]
): Validation[e, u] \ ef = {
    Validation.ap(
        Validation.map3(f$35389, v1$35400, v2$35406, v3$35410),
        v4$35414
    )
}

def Validation.map5(
    f$35449: t1 -> t2 -> (t3 -> (t4 -> (t5 -> u \ ef))),
    v1$35457: Validation[e, t1],
    v2$35465: Validation[e, t2],
    v3$35469: Validation[e, t3],
    v4$35474: Validation[e, t4],
    v5$35479: Validation[e, t5]
): Validation[e, u] \ ef = {
    Validation.ap(
        Validation.map4(f$35449, v1$35457, v2$35465, v3$35469, v4$35474),
        v5$35479
    )
}

def Validation.map6(
    f$35528: t1 -> t2 -> (t3 -> (t4 -> (t5 -> (t6 -> u \ ef)))),
    v1$35544: Validation[e, t1],
    v2$35546: Validation[e, t2],
    v3$35548: Validation[e, t3],
    v4$35550: Validation[e, t4],
    v5$35552: Validation[e, t5],
    v6$35554: Validation[e, t6]
): Validation[e, u] \ ef = {
    Validation.ap(
        Validation.map5(
            f$35528,
            v1$35544,
            v2$35546,
            v3$35548,
            v4$35550,
            v5$35552
        ),
        v6$35554
    )
}

def Validation.map7(
    f$35605: t1 -> t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> u \ ef))))),
    v1$35649: Validation[e, t1],
    v2$35651: Validation[e, t2],
    v3$35653: Validation[e, t3],
    v4$35656: Validation[e, t4],
    v5$35659: Validation[e, t5],
    v6$35661: Validation[e, t6],
    v7$35663: Validation[e, t7]
): Validation[e, u] \ ef = {
    Validation.ap(
        Validation.map6(
            f$35605,
            v1$35649,
            v2$35651,
            v3$35653,
            v4$35656,
            v5$35659,
            v6$35661
        ),
        v7$35663
    )
}

def Validation.map8(
    f$35714: t1 -> t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> (t8 -> u \ ef)))))),
    v1$35740: Validation[e, t1],
    v2$35752: Validation[e, t2],
    v3$35754: Validation[e, t3],
    v4$35758: Validation[e, t4],
    v5$35760: Validation[e, t5],
    v6$35764: Validation[e, t6],
    v7$35766: Validation[e, t7],
    v8$35768: Validation[e, t8]
): Validation[e, u] \ ef = {
    Validation.ap(
        Validation.map7(
            f$35714,
            v1$35740,
            v2$35752,
            v3$35754,
            v4$35758,
            v5$35760,
            v6$35764,
            v7$35766
        ),
        v8$35768
    )
}

def Validation.map9(
    f$35860: t1 ->
        t2 -> (t3 -> (t4 -> (t5 -> (t6 -> (t7 -> (t8 -> (t9 -> u \ ef))))))),
    v1$35866: Validation[e, t1],
    v2$35868: Validation[e, t2],
    v3$35870: Validation[e, t3],
    v4$35872: Validation[e, t4],
    v5$35874: Validation[e, t5],
    v6$35876: Validation[e, t6],
    v7$35878: Validation[e, t7],
    v8$35880: Validation[e, t8],
    v9$35882: Validation[e, t9]
): Validation[e, u] \ ef = {
    Validation.ap(
        Validation.map8(
            f$35860,
            v1$35866,
            v2$35868,
            v3$35870,
            v4$35872,
            v5$35874,
            v6$35876,
            v7$35878,
            v8$35880
        ),
        v9$35882
    )
}

def Validation.product(
    fa$34418: Validation[e, t1],
    fb$34422: Validation[e, t2]
): Validation[e, (t1, t2)] = {
    Validation.ap(
        Validation.map(a$34427 -> b$34430 -> (a$34427, b$34430), fa$34418),
        fb$34422
    )
}

def Validation.product3(
    fa$34486: Validation[e, t1],
    fb$34490: Validation[e, t2],
    fc$34492: Validation[e, t3]
): Validation[e, (t1, t2, t3)] = {
    Validation.ap(
        Validation.ap(
            Validation.map(
                a$34516 ->
                    b$34520 ->
                        c$34522 ->
                            (a$34516, b$34520, c$34522),
                fa$34486
            ),
            fb$34490
        ),
        fc$34492
    )
}

def Validation.product4(
    fa$34562: Validation[e, t1],
    fb$34568: Validation[e, t2],
    fc$34572: Validation[e, t3],
    fd$34574: Validation[e, t4]
): Validation[e, (t1, t2, t3, t4)] = {
    Validation.ap(
        Validation.ap(
            Validation.ap(
                Validation.map(
                    a$34596 ->
                        b$34598 ->
                            c$34600 ->
                                d$34602 ->
                                    (a$34596, b$34598, c$34600, d$34602),
                    fa$34562
                ),
                fb$34568
            ),
            fc$34572
        ),
        fd$34574
    )
}

def Validation.product5(
    fa$34641: Validation[e, t1],
    fb$34651: Validation[e, t2],
    fc$34661: Validation[e, t3],
    fd$34668: Validation[e, t4],
    fe$34675: Validation[e, t5]
): Validation[e, (t1, t2, t3, t4, t5)] = {
    Validation.ap(
        Validation.ap(
            Validation.ap(
                Validation.ap(
                    Validation.map(
                        a$34683 ->
                            b$34685 ->
                                c$34687 ->
                                    d$34689 ->
                                        e$34691 ->
                                            (
                                                a$34683,
                                                b$34685,
                                                c$34687,
                                                d$34689,
                                                e$34691
                                            ),
                        fa$34641
                    ),
                    fb$34651
                ),
                fc$34661
            ),
            fd$34668
        ),
        fe$34675
    )
}

def Validation.sequence(
    l$34955: List[Validation[e, t]]
): Validation[e, List[t]] = {
    letrec loop$34959: (
        List[Validation[e, t]] ->
            (List[t] -> Validation[e, List[t]]) -> Validation[e, List[t]]
    ) = ll$34961 ->
        k$34963 ->
            match ll$34961 {
                case List.Nil =>
                    k$34963(List.Nil)
                case List.Cons(Validation.Success(x$34971), xs$34975) =>
                    loop$34959(
                        xs$34975
                    )(ks$34977 -> k$34963(List.Cons(x$34971, ks$34977)))
                case List.Cons(Validation.Failure(e$34979), xs$34981) =>
                    Validation.collectFailuresWith(
                        $0$46622 ->
                            identity($0$46622),
                        xs$34981,
                        e$34979
                    )
            };
    loop$34959(l$34955)(ks$34990 -> Validation.Success(ks$34990))
}

def Validation.toList(v$35258: Validation[e, t]): List[t] = {
    match v$35258 {
        case Validation.Success(t$35269) =>
            List.Cons(t$35269, List.Nil)
        case Validation.Failure(_) =>
            List.Nil
    }
}

def Validation.toOption(v$35189: Validation[e, t]): Option[t] = {
    match v$35189 {
        case Validation.Success(t$35193) =>
            Option.Some(t$35193)
        case Validation.Failure(_) =>
            Option.None
    }
}

def Validation.toResult(v$35230: Validation[e, t]): Result[Nec[e], t] = {
    match v$35230 {
        case Validation.Success(t$35241) =>
            Result.Ok(t$35241)
        case Validation.Failure(e$35250) =>
            Result.Err(e$35250)
    }
}

def Validation.traverse(
    f$35016: a -> Validation[e, b],
    l$35018: List[a]
): Validation[e, List[b]] \ ef = {
    letrec loop$35026: (
        List[a] ->
            (List[b] -> Validation[e, List[b]]) -> Validation[e, List[b]] \ ef
    ) = ll$35030 ->
        k$35035 ->
            match ll$35030 {
                case List.Nil =>
                    k$35035(List.Nil)
                case List.Cons(x$35043, xs$35045) =>
                    match f$35016(x$35043) {
                        case Validation.Success(y$35049) =>
                            loop$35026(
                                xs$35045
                            )(ks$35053 -> k$35035(List.Cons(y$35049, ks$35053)))
                        case Validation.Failure(y$35055) =>
                            Validation.collectFailuresWith(
                                f$35016,
                                xs$35045,
                                y$35055
                            )
                    }
            };
    loop$35026(l$35018)(ks$35065 -> Validation.Success(ks$35065))
}

def Validation.traverseX(
    f$35095: a -> Validation[e, b],
    l$35101: List[a]
): Validation[e, Unit] \ ef = {
    match l$35101 {
        case List.Nil =>
            Validation.Success
        case List.Cons(x$35106, xs$35108) =>
            match f$35095(x$35106) {
                case Validation.Success(_) =>
                    Validation.traverseX(f$35095, xs$35108)
                case Validation.Failure(e$35110) =>
                    Validation.collectFailuresWith(f$35095, xs$35108, e$35110)
            }
    }
}

def Validation.withDefault(
    default$34758: { default = Validation[e, t] },
    v$34769: Validation[e, t]
): Validation[e, t] = {
    match v$34769 {
        case Validation.Success(_) =>
            v$34769
        case Validation.Failure(_) =>
            default$34758.default
    }
}

def Vector.agreeHelper(
    f$43873: a -> a -> Bool,
    a$43875: a,
    xs$43877: List[a]
): Bool = {
    match xs$43877 {
        case List.Nil =>
            true
        case List.Cons(x$43879, rs$43881) =>
            if (
                <[unknown exp]>(
                    f$43873(x$43879)(a$43875) and f$43873(a$43875)(x$43879),
                    false
                )
            ) {
                false
            } else {
                Vector.agreeHelper(f$43873, a$43875, rs$43881)
            }
    }
}

def Vector.ap(
    f$43294: Vector[a -> b \ ef],
    v$43296: Vector[a]
): Vector[b] \ ef = {
    |>(
        Vector.map(g$43298 -> Vector.map(g$43298, v$43296), f$43294),
        $0$47028 ->
            Vector.flatten($0$47028)
    )
}

def Vector.append(v1$43022: Vector[a], v2$43024: Vector[a]): Vector[a] = {
    region rc$43026 {
        let arr$43029: Array[a, rc] = Array.empty(
            rc$43026,
            <[unknown exp]>(Vector.length(v1$43022), Vector.length(v2$43024))
        );
        Vector.arrayUpdateSeqV!(0i32, v1$43022, arr$43029);
        Vector.arrayUpdateSeqV!(Vector.length(v1$43022), v2$43024, arr$43029);
        Array.toVector(arr$43029)
    }
}

def Vector.arrayUpdateSeqV!(
    i$38577: Int32,
    sub$38579: Vector[a],
    arr$38581: Array[a, r]
): Unit \ r = {
    let end$38593: Int32 = Array.length(arr$38581);
    let subLen$38595: Int32 = Vector.length(sub$38579);
    letrec loop$38597: (Int32 -> Int32 -> Unit \ r) = ri$38599 ->
        wi$38601 ->
            if (
                <[unknown exp]>(
                    wi$38601,
                    end$38593
                ) or <[unknown exp]>(ri$38599, subLen$38595)
            ) {
                ()
            } else {
                if (<[unknown exp]>(wi$38601, 0i32)) {
                    loop$38597(
                        <[unknown exp]>(ri$38599, 1i32)
                    )(<[unknown exp]>(wi$38601, 1i32))
                } else {
                    let x$38607: a = Vector.get(ri$38599, sub$38579);
                    Array.put(x$38607, wi$38601, arr$38581);
                    loop$38597(
                        <[unknown exp]>(ri$38599, 1i32)
                    )(<[unknown exp]>(wi$38601, 1i32))
                }
            };
    loop$38597(0i32)(i$38577)
}

def Vector.compare(a$38441: Vector[a], b$38443: Vector[a]): Comparison = {
    let len$38447: Int32 = Int32.min(
        Vector.length(a$38441),
        Vector.length(b$38443)
    );
    letrec loop$38451: (Int32 -> Comparison) = i$38453 ->
        if (<[unknown exp]>(i$38453, len$38447)) {
            let cmp$38455: Comparison = <[unknown exp]>(
                Vector.get(i$38453, a$38441),
                Vector.get(i$38453, b$38443)
            );
            if (<[unknown exp]>(cmp$38455, Comparison.EqualTo)) {
                loop$38451(<[unknown exp]>(i$38453, 1i32))
            } else {
                cmp$38455
            }
        } else {
            if (<[unknown exp]>(i$38453, Vector.length(a$38441))) {
                Comparison.GreaterThan
            } else {
                if (<[unknown exp]>(i$38453, Vector.length(b$38443))) {
                    Comparison.LessThan
                } else {
                    Comparison.EqualTo
                }
            }
        };
    loop$38451(0i32)
}

def Vector.count(f$43621: a -> Bool, v$43623: Vector[a]): Int32 \ ef = {
    Vector.foldLeft(
        b$43625 ->
            x$43627 ->
                if (f$43621(x$43627)) {
                    <[unknown exp]>(b$43625, 1i32)
                } else {
                    b$43625
                },
        0i32,
        v$43623
    )
}

def Vector.drop(n$43729: Int32, v$43731: Vector[a]): Vector[a] = {
    Vector.dropLeft(n$43729, v$43731)
}

def Vector.dropLeft(n$43734: Int32, v$43736: Vector[a]): Vector[a] = {
    let len$43738: Int32 = Vector.length(v$43736);
    if (<[unknown exp]>(n$43734, len$43738)) {
        Vector.empty(())
    } else {
        let start$43740: Int32 = if (<[unknown exp]>(n$43734, 0i32)) {
            0i32
        } else {
            n$43734
        };
        Vector.slice(
            {+start = start$43740 | {}},
            {+end = len$43738 | {}},
            v$43736
        )
    }
}

def Vector.dropRight(n$43743: Int32, v$43745: Vector[a]): Vector[a] = {
    let len$43749: Int32 = Vector.length(v$43745);
    if (<[unknown exp]>(n$43743, len$43749)) {
        Vector.empty(())
    } else {
        let end$43751: Int32 = if (<[unknown exp]>(n$43743, 0i32)) {
            len$43749
        } else {
            <[unknown exp]>(len$43749, n$43743)
        };
        Vector.slice({+start = 0i32 | {}}, {+end = end$43751 | {}}, v$43745)
    }
}

def Vector.dropWhile(f$43755: a -> Bool, v$43757: Vector[a]): Vector[a] \ ef = {
    Vector.dropWhileLeft(f$43755, v$43757)
}

def Vector.dropWhileLeft(
    f$43761: a -> Bool,
    v$43763: Vector[a]
): Vector[a] \ ef = {
    match Vector.findIndexOfLeft(x$43765 -> !f$43761(x$43765), v$43763) {
        case Option.None =>
            Vector.empty(())
        case Option.Some(i$43767) =>
            Vector.dropLeft(i$43767, v$43763)
    }
}

def Vector.dropWhileRight(
    f$43771: a -> Bool,
    v$43773: Vector[a]
): Vector[a] \ ef = {
    match Vector.findIndexOfRight(x$43775 -> !f$43771(x$43775), v$43773) {
        case Option.None =>
            Vector.empty(())
        case Option.Some(i$43777) =>
            Vector.slice(
                {+start = 0i32 | {}},
                {+end = <[unknown exp]>(i$43777, 1i32) | {}},
                v$43773
            )
    }
}

def Vector.empty(_unit$38661: Unit): Vector[a] = {
    region rc$38681 {
        let arr$38684: Array[a, rc] = [] @ rc$38681; Array.toVector(arr$38684)
    }
}

def Vector.enumerator(
    rc$44120: Region[r],
    v$44122: Vector[a]
): Iterator[(Int32, a), r, r] \ r = {
    |>(
        Vector.iterator(rc$44120, v$44122),
        $0$47089 ->
            Iterator.zipWithIndex($0$47089)
    )
}

def Vector.equals(a$44098: Vector[a], b$44100: Vector[a]): Bool = {
    let alen$44102: Int32 = Vector.length(a$44098);
    let blen$44104: Int32 = Vector.length(b$44100);
    letrec loop$44106: (Int32 -> Bool) = i$44108 ->
        if (<[unknown exp]>(i$44108, alen$44102)) {
            true
        } else {
            if (
                <[unknown exp]>(
                    Vector.get(i$44108, a$44098),
                    Vector.get(i$44108, b$44100)
                )
            ) {
                false
            } else {
                loop$44106(<[unknown exp]>(i$44108, 1i32))
            }
        };
    if (<[unknown exp]>(alen$44102, blen$44104)) {loop$44106(0i32)} else {false}
}

def Vector.exists(f$43663: a -> Bool, v$43665: Vector[a]): Bool \ ef = {
    let len$43667: Int32 = Vector.length(v$43665);
    letrec loop$43669: (Int32 -> Bool) = i$43671 ->
        if (<[unknown exp]>(i$43671, len$43667)) {
            false
        } else {
            if (f$43663(Vector.get(i$43671, v$43665))) {
                true
            } else {
                loop$43669(<[unknown exp]>(i$43671, 1i32))
            }
        };
    loop$43669(0i32)
}

def Vector.extractHelper(
    f$43858: a -> a -> Bool,
    xs$43860: List[a],
    ps$43862: List[a],
    ns$43864: List[a]
): (Vector[a], List[a]) = {
    match xs$43860 {
        case List.Nil =>
            let a$43866: List[a] = List.reverse(ps$43862);
            (List.toVector(a$43866), List.reverse(ns$43864))
        case List.Cons(x$43868, rs$43870) =>
            if (Vector.agreeHelper(f$43858, x$43868, ps$43862)) {
                Vector.extractHelper(
                    f$43858,
                    rs$43870,
                    List.Cons(x$43868, ps$43862),
                    ns$43864
                )
            } else {
                Vector.extractHelper(
                    f$43858,
                    rs$43870,
                    ps$43862,
                    List.Cons(x$43868, ns$43864)
                )
            }
    }
}

def Vector.filter(f$43687: a -> Bool, v$43689: Vector[a]): Vector[a] \ ef = {
    region rc$43691 {
        let m$43694: MutList[a, rc] = MutList.empty(rc$43691);
        Vector.forEach(
            a$43696 ->
                if (f$43687(a$43696)) {
                    MutList.push!(a$43696, m$43694)
                } else {
                    ()
                },
            v$43689
        );
        MutList.toVector(m$43694)
    }
}

def Vector.filterMap(
    f$43989: a -> Option[b],
    v$43991: Vector[a]
): Vector[b] \ ef = {
    |>(
        Vector.foldRight(
            x$43993 ->
                xs$43995 ->
                    match f$43989(x$43993) {
                        case Option.None =>
                            xs$43995
                        case Option.Some(b$43997) =>
                            List.Cons(b$43997, xs$43995)
                    },
            List.Nil,
            v$43991
        ),
        $0$47074 ->
            List.toVector($0$47074)
    )
}

def Vector.find(f$43090: a -> Bool, v$43092: Vector[a]): Option[a] \ ef = {
    Vector.findLeft(f$43090, v$43092)
}

def Vector.findIndexOf(
    f$44035: a -> Bool,
    v$44037: Vector[a]
): Option[Int32] \ ef = {
    Vector.findIndexOfLeft(f$44035, v$44037)
}

def Vector.findIndexOfLeft(
    f$44041: a -> Bool,
    v$44043: Vector[a]
): Option[Int32] \ ef = {
    let len$44045: Int32 = Vector.length(v$44043);
    if (<[unknown exp]>(len$44045, 1i32)) {
        Option.None
    } else {
        letrec loop$44047: (Int32 -> Int32) = i$44049 ->
            if (<[unknown exp]>(i$44049, len$44045)) {
                -1i32
            } else {
                if (f$44041(Vector.get(i$44049, v$44043))) {
                    i$44049
                } else {
                    loop$44047(<[unknown exp]>(i$44049, 1i32))
                }
            };
        let i$44051: Int32 = loop$44047(0i32);
        if (<[unknown exp]>(i$44051, 0i32)) {
            Option.None
        } else {
            Option.Some(i$44051)
        }
    }
}

def Vector.findIndexOfRight(
    f$44055: a -> Bool,
    v$44057: Vector[a]
): Option[Int32] \ ef = {
    let len$44059: Int32 = Vector.length(v$44057);
    letrec loop$44061: (Int32 -> Int32) = i$44063 ->
        if (<[unknown exp]>(i$44063, 0i32)) {
            -1i32
        } else {
            if (f$44055(Vector.get(i$44063, v$44057))) {
                i$44063
            } else {
                loop$44061(<[unknown exp]>(i$44063, 1i32))
            }
        };
    let i$44065: Int32 = loop$44061(<[unknown exp]>(len$44059, 1i32));
    if (<[unknown exp]>(i$44065, 0i32)) {
        Option.None
    } else {
        Option.Some(i$44065)
    }
}

def Vector.findIndices(
    f$44069: a -> Bool,
    v$44071: Vector[a]
): Vector[Int32] \ ef = {
    region rc$44073 {
        let l$44076: MutList[Int32, rc] = MutList.empty(rc$44073);
        Vector.forEachWithIndex(
            i$44078 ->
                x$44080 ->
                    if (f$44069(x$44080)) {
                        MutList.push!(i$44078, l$44076)
                    } else {
                        ()
                    },
            v$44071
        );
        MutList.toVector(l$44076)
    }
}

def Vector.findLeft(f$43096: a -> Bool, v$43098: Vector[a]): Option[a] \ ef = {
    match Vector.findIndexOfLeft(f$43096, v$43098) {
        case Option.None =>
            Option.None
        case Option.Some(i$43100) =>
            Option.Some(Vector.get(i$43100, v$43098))
    }
}

def Vector.findMap(
    f$44002: a -> Option[b],
    v$44004: Vector[a]
): Option[b] \ ef = {
    let len$44006: Int32 = Vector.length(v$44004);
    letrec loop$44008: (Int32 -> Option[b]) = i$44010 ->
        if (<[unknown exp]>(i$44010, len$44006)) {
            Option.None
        } else {
            let x$44012: Option[b] = f$44002(Vector.get(i$44010, v$44004));
            match x$44012 {
                case Option.Some(a$44014) =>
                    Option.Some(a$44014)
                case Option.None =>
                    loop$44008(<[unknown exp]>(i$44010, 1i32))
            }
        };
    loop$44008(0i32)
}

def Vector.findRight(f$43104: a -> Bool, v$43106: Vector[a]): Option[a] \ ef = {
    match Vector.findIndexOfRight(x$43108 -> f$43104(x$43108), v$43106) {
        case Option.None =>
            Option.None
        case Option.Some(i$43110) =>
            Option.Some(Vector.get(i$43110, v$43106))
    }
}

def Vector.flatMap(
    f$43303: a -> Vector[b],
    v$43305: Vector[a]
): Vector[b] \ ef = {
    |>(
        Vector.init(
            i$43307 ->
                f$43303(Vector.get(i$43307, v$43305)),
            Vector.length(v$43305)
        ),
        $0$47030 ->
            Vector.flatten($0$47030)
    )
}

def Vector.flatten(vs$43646: Vector[Vector[a]]): Vector[a] = {
    region rc$43648 {
        let len$43651: Int32 = Vector.sumLengths(vs$43646);
        let pos$43653: Ref[Int32, rc] = (ref 0i32) @ rc$43648;
        let arr$43655: Array[a, rc] = Array.empty(rc$43648, len$43651);
        Vector.forEach(
            v$43657 ->
                {
                    let i$43659: Int32 = deref pos$43653;
                    Ref.put(
                        <[unknown exp]>(i$43659, Vector.length(v$43657)),
                        pos$43653
                    );
                    Vector.arrayUpdateSeqV!(i$43659, v$43657, arr$43655)
                },
            vs$43646
        );
        Array.toVector(arr$43655)
    }
}

def Vector.fold(v$43531: Vector[a]): a = {
    Vector.foldLeft(
        $0$47068 ->
            $1$47070 ->
                <[unknown exp]>($0$47068, $1$47070),
        <[unknown exp]>(()),
        v$43531
    )
}

def Vector.fold2(
    f$43932: c -> a -> (b -> c \ ef),
    c$43934: c,
    a$43936: Vector[a],
    b$43938: Vector[b]
): c \ ef = {
    Vector.foldLeft2(f$43932, c$43934, a$43936, b$43938)
}

def Vector.foldLeft(
    f$43536: b -> a -> b \ ef,
    s$43538: b,
    v$43540: Vector[a]
): b \ ef = {
    let len$43542: Int32 = Vector.length(v$43540);
    letrec loop$43544: (Int32 -> b -> b \ ef) = i$43546 ->
        acc$43548 ->
            if (<[unknown exp]>(i$43546, len$43542)) {
                acc$43548
            } else {
                loop$43544(
                    <[unknown exp]>(i$43546, 1i32)
                )(f$43536(acc$43548)(Vector.get(i$43546, v$43540)))
            };
    loop$43544(0i32)(s$43538)
}

def Vector.foldLeft2(
    f$43944: c -> a -> (b -> c \ ef),
    c$43946: c,
    a$43948: Vector[a],
    b$43950: Vector[b]
): c \ ef = {
    let lena$43952: Int32 = Vector.length(a$43948);
    let lenb$43954: Int32 = Vector.length(b$43950);
    letrec loop$43956: (Int32 -> c -> c \ ef) = i$43958 ->
        acc$43960 ->
            if (
                <[unknown exp]>(
                    i$43958,
                    lena$43952
                ) or <[unknown exp]>(i$43958, lenb$43954)
            ) {
                acc$43960
            } else {
                loop$43956(
                    <[unknown exp]>(i$43958, 1i32)
                )(
                    f$43944(
                        acc$43960
                    )(
                        Vector.get(i$43958, a$43948)
                    )(Vector.get(i$43958, b$43950))
                )
            };
    loop$43956(0i32)(c$43946)
}

def Vector.foldMap(f$43583: a -> b, v$43585: Vector[a]): b \ ef = {
    Vector.foldLeft(
        acc$43587 ->
            x$43589 ->
                <[unknown exp]>(acc$43587, f$43583(x$43589)),
        <[unknown exp]>(()),
        v$43585
    )
}

def Vector.foldRight(
    f$43553: a -> b -> b \ ef,
    s$43555: b,
    v$43557: Vector[a]
): b \ ef = {
    letrec loop$43559: (Int32 -> b -> b \ ef) = i$43561 ->
        acc$43563 ->
            if (<[unknown exp]>(i$43561, 0i32)) {
                acc$43563
            } else {
                loop$43559(
                    <[unknown exp]>(i$43561, 1i32)
                )(f$43553(Vector.get(i$43561, v$43557))(acc$43563))
            };
    loop$43559(<[unknown exp]>(Vector.length(v$43557), 1i32))(s$43555)
}

def Vector.foldRight2(
    f$43966: a -> b -> (c -> c \ ef),
    c$43968: c,
    a$43970: Vector[a],
    b$43972: Vector[b]
): c \ ef = {
    letrec loop$43974: (Int32 -> Int32 -> (c -> c \ ef)) = i$43976 ->
        j$43978 ->
            acc$43980 ->
                if (
                    <[unknown exp]>(
                        i$43976,
                        0i32
                    ) or <[unknown exp]>(j$43978, 0i32)
                ) {
                    acc$43980
                } else {
                    loop$43974(
                        <[unknown exp]>(i$43976, 1i32)
                    )(
                        <[unknown exp]>(j$43978, 1i32)
                    )(
                        f$43966(
                            Vector.get(i$43976, a$43970)
                        )(Vector.get(j$43978, b$43972))(acc$43980)
                    )
                };
    let starta$43982: Int32 = <[unknown exp]>(Vector.length(a$43970), 1i32);
    let startb$43984: Int32 = <[unknown exp]>(Vector.length(b$43972), 1i32);
    loop$43974(starta$43982)(startb$43984)(c$43968)
}

def Vector.foldRightWithCont(
    f$43568: a -> (Unit -> b \ ef) -> b \ ef,
    z$43570: b,
    v$43572: Vector[a]
): b \ ef = {
    letrec loop$43574: (Int32 -> b) = i$43576 ->
        if (<[unknown exp]>(i$43576, Vector.length(v$43572))) {
            z$43570
        } else {
            f$43568(
                Vector.get(i$43576, v$43572)
            )(_$43578 -> loop$43574(<[unknown exp]>(i$43576, 1i32)))
        };
    loop$43574(0i32)
}

def Vector.forAll(f$43675: a -> Bool, v$43677: Vector[a]): Bool \ ef = {
    let len$43679: Int32 = Vector.length(v$43677);
    letrec loop$43681: (Int32 -> Bool) = i$43683 ->
        if (<[unknown exp]>(i$43683, len$43679)) {
            true
        } else {
            if (f$43675(Vector.get(i$43683, v$43677))) {
                loop$43681(<[unknown exp]>(i$43683, 1i32))
            } else {
                false
            }
        };
    loop$43681(0i32)
}

def Vector.forEach(f$44126: a -> Unit, v$44128: Vector[a]): Unit \ ef = {
    let len$44130: Int32 = Vector.length(v$44128);
    letrec loop$44132: (Int32 -> Unit) = i$44134 ->
        if (<[unknown exp]>(i$44134, len$44130)) {
            ()
        } else {
            f$44126(Vector.get(i$44134, v$44128));
            loop$44132(<[unknown exp]>(i$44134, 1i32))
        };
    loop$44132(0i32)
}

def Vector.forEachWithIndex(
    f$44138: Int32 -> a -> Unit \ ef,
    v$44140: Vector[a]
): Unit \ ef = {
    let len$44142: Int32 = Vector.length(v$44140);
    letrec loop$44144: (Int32 -> Unit) = i$44146 ->
        if (<[unknown exp]>(i$44146, len$44142)) {
            ()
        } else {
            f$44138(i$44146)(Vector.get(i$44146, v$44140));
            loop$44144(<[unknown exp]>(i$44146, 1i32))
        };
    loop$44144(0i32)
}

def Vector.get(i$38725: Int32, v$38727: Vector[a]): a = {v$38727[|i$38725|]}

def Vector.groupBy(
    f$43836: a -> a -> Bool,
    v$43838: Vector[a]
): Vector[Vector[a]] = {
    let xs$43840: List[a] = Vector.toList(v$43838);
    |>(
        Vector.groupByHelper(f$43836, xs$43840, List.Nil),
        $0$47072 ->
            List.toVector($0$47072)
    )
}

def Vector.groupByHelper(
    f$43843: a -> a -> Bool,
    xs$43845: List[a],
    ac$43847: List[Vector[a]]
): List[Vector[a]] = {
    match xs$43845 {
        case List.Nil =>
            List.reverse(ac$43847)
        case List.Cons(x$43849, rs$43851) =>
            match Vector.extractHelper(
                f$43843,
                rs$43851,
                List.Cons(x$43849, List.Nil),
                List.Nil
            ) {
                case (r1$43853, r2$43855) =>
                    Vector.groupByHelper(
                        f$43843,
                        r2$43855,
                        List.Cons(r1$43853, ac$43847)
                    )
            }
    }
}

def Vector.head(v$43016: Vector[a]): Option[a] = {Vector.nth(0i32, v$43016)}

def Vector.indexOf(x$43055: a, v$43057: Vector[a]): Option[Int32] = {
    Vector.indexOfLeft(x$43055, v$43057)
}

def Vector.indexOfLeft(a$43060: a, v$43062: Vector[a]): Option[Int32] = {
    letrec loop$43064: (Int32 -> Int32) = i$43066 ->
        if (<[unknown exp]>(i$43066, Vector.length(v$43062))) {
            -1i32
        } else {
            if (<[unknown exp]>(Vector.get(i$43066, v$43062), a$43060)) {
                i$43066
            } else {
                loop$43064(<[unknown exp]>(i$43066, 1i32))
            }
        };
    let i$43068: Int32 = loop$43064(0i32);
    if (<[unknown exp]>(i$43068, 0i32)) {
        Option.None
    } else {
        Option.Some(i$43068)
    }
}

def Vector.indexOfRight(a$43071: a, v$43073: Vector[a]): Option[Int32] = {
    letrec loop$43075: (Int32 -> Int32) = i$43077 ->
        if (<[unknown exp]>(i$43077, 0i32)) {
            -1i32
        } else {
            if (<[unknown exp]>(Vector.get(i$43077, v$43073), a$43071)) {
                i$43077
            } else {
                loop$43075(<[unknown exp]>(i$43077, 1i32))
            }
        };
    let i$43079: Int32 = loop$43075(
        <[unknown exp]>(Vector.length(v$43073), 1i32)
    );
    if (<[unknown exp]>(i$43079, 0i32)) {
        Option.None
    } else {
        Option.Some(i$43079)
    }
}

def Vector.indices(a$43082: a, v$43084: Vector[a]): Vector[Int32] = {
    Vector.findIndices(b$43086 -> <[unknown exp]>(a$43082, b$43086), v$43084)
}

def Vector.init(f$44084: Int32 -> a, len$44086: Int32): Vector[a] \ ef = {
    region rc$44088 {
        let arr$44091: Array[a, rc] = if (<[unknown exp]>(len$44086, 0i32)) {
            Array.empty(rc$44088, len$44086)
        } else {
            [] @ rc$44088
        };
        letrec loop$44093: (Int32 -> Unit) = i$44095 ->
            if (<[unknown exp]>(i$44095, len$44086)) {
                Array.put(f$44084(i$44095), i$44095, arr$44091);
                loop$44093(<[unknown exp]>(i$44095, 1i32))
            } else {
                ()
            };
        loop$44093(0i32);
        Array.toVector(arr$44091)
    }
}

def Vector.intercalate(
    sep$43400: Vector[a],
    vs$43402: Vector[Vector[a]]
): Vector[a] = {
    region rc$43404 {
        let count$43407: Int32 = Vector.length(vs$43402);
        let sepLength$43409: Int32 = Vector.length(sep$43400);
        let sepCount$43411: Int32 = if (<[unknown exp]>(count$43407, 2i32)) {
            0i32
        } else {
            <[unknown exp]>(count$43407, 1i32)
        };
        let len$43413: Int32 = <[unknown exp]>(
            Vector.sumLengths(vs$43402),
            <[unknown exp]>(sepCount$43411, sepLength$43409)
        );
        let pos$43415: Ref[Int32, rc] = (ref 0i32) @ rc$43404;
        let arr$43417: Array[a, rc] = Array.empty(rc$43404, len$43413);
        let f$43419: (Int32 -> Vector[a] -> Unit \ rc) = i$43421 ->
            v$43423 ->
                if (<[unknown exp]>(i$43421, 0i32)) {
                    Vector.arrayUpdateSeqV!(0i32, v$43423, arr$43417);
                    Ref.put(Vector.length(v$43423), pos$43415)
                } else {
                    let ix$43425: Int32 = deref pos$43415;
                    Vector.arrayUpdateSeqV!(ix$43425, sep$43400, arr$43417);
                    let ix1$43431: Int32 = <[unknown exp]>(
                        ix$43425,
                        sepLength$43409
                    );
                    Vector.arrayUpdateSeqV!(ix1$43431, v$43423, arr$43417);
                    Ref.put(
                        <[unknown exp]>(ix1$43431, Vector.length(v$43423)),
                        pos$43415
                    )
                };
        Vector.forEachWithIndex(f$43419, vs$43402);
        Array.toVector(arr$43417)
    }
}

def Vector.intersperse(sep$43381: a, v$43383: Vector[a]): Vector[a] = {
    let len1$43385: Int32 = Vector.length(v$43383);
    let len2$43387: Int32 = <[unknown exp]>(
        <[unknown exp]>(len1$43385, len1$43385),
        1i32
    );
    let f$43389: (Int32 -> a) = ix$43391 ->
        match ix$43391 {
            case 0i32 =>
                Vector.get(0i32, v$43383)
            case n$43393 if <[unknown exp]>(
                Int32.remainder(n$43393, 2i32),
                0i32
            ) =>
                sep$43381
            case n$43395 =>
                let i$43397: Int32 = <[unknown exp]>(n$43395, 2i32);
                Vector.get(i$43397, v$43383)
        };
    Vector.init(f$43389, len2$43387)
}

def Vector.isEmpty(v$41930: Vector[a]): Bool = {
    <[unknown exp]>(Vector.length(v$41930), 0i32)
}

def Vector.isInfixOf(a$43483: Vector[a], b$43485: Vector[a]): Bool = {
    let len1$43487: Int32 = Vector.length(a$43483);
    let len2$43489: Int32 = Vector.length(b$43485);
    if (<[unknown exp]>(len1$43487, len2$43489)) {
        false
    } else {
        if (<[unknown exp]>(len1$43487, 0i32)) {
            true
        } else {
            Vector.isInfixOfSearch(
                a$43483,
                b$43485,
                len1$43487,
                len2$43489,
                0i32
            )
        }
    }
}

def Vector.isInfixOfCheck(
    a$43503: Vector[a],
    b$43505: Vector[a],
    len1$43507: Int32,
    len2$43509: Int32,
    i$43511: Int32,
    j$43513: Int32
): Bool = {
    if (<[unknown exp]>(i$43511, len1$43507)) {
        true
    } else {
        if (<[unknown exp]>(j$43513, len2$43509)) {
            false
        } else {
            if (
                <[unknown exp]>(
                    Vector.get(i$43511, a$43503),
                    Vector.get(j$43513, b$43505)
                )
            ) {
                Vector.isInfixOfCheck(
                    a$43503,
                    b$43505,
                    len1$43507,
                    len2$43509,
                    <[unknown exp]>(i$43511, 1i32),
                    <[unknown exp]>(j$43513, 1i32)
                )
            } else {
                Vector.isInfixOfSearch(
                    a$43503,
                    b$43505,
                    len1$43507,
                    len2$43509,
                    <[unknown exp]>(j$43513, 1i32)
                )
            }
        }
    }
}

def Vector.isInfixOfSearch(
    a$43492: Vector[a],
    b$43494: Vector[a],
    len1$43496: Int32,
    len2$43498: Int32,
    j$43500: Int32
): Bool = {
    if (<[unknown exp]>(j$43500, len2$43498)) {
        false
    } else {
        if (
            <[unknown exp]>(
                Vector.get(0i32, a$43492),
                Vector.get(j$43500, b$43494)
            )
        ) {
            Vector.isInfixOfCheck(
                a$43492,
                b$43494,
                len1$43496,
                len2$43498,
                1i32,
                <[unknown exp]>(j$43500, 1i32)
            )
        } else {
            Vector.isInfixOfSearch(
                a$43492,
                b$43494,
                len1$43496,
                len2$43498,
                <[unknown exp]>(j$43500, 1i32)
            )
        }
    }
}

def Vector.isPrefixOf(a$43472: Vector[a], b$43474: Vector[a]): Bool = {
    let len1$43476: Int32 = Vector.length(a$43472);
    if (<[unknown exp]>(len1$43476, Vector.length(b$43474))) {
        false
    } else {
        letrec loop$43478: (Int32 -> Bool) = i$43480 ->
            if (<[unknown exp]>(i$43480, len1$43476)) {
                true
            } else {
                if (
                    <[unknown exp]>(
                        Vector.get(i$43480, a$43472),
                        Vector.get(i$43480, b$43474)
                    )
                ) {
                    false
                } else {
                    loop$43478(<[unknown exp]>(i$43480, 1i32))
                }
            };
        loop$43478(0i32)
    }
}

def Vector.isSuffixOf(a$43516: Vector[a], b$43518: Vector[a]): Bool = {
    let len1$43520: Int32 = Vector.length(a$43516);
    let len2$43522: Int32 = Vector.length(b$43518);
    if (<[unknown exp]>(len1$43520, len2$43522)) {
        false
    } else {
        letrec loop$43524: (Int32 -> Int32 -> Bool) = i$43526 ->
            j$43528 ->
                if (<[unknown exp]>(i$43526, 0i32)) {
                    true
                } else {
                    if (
                        <[unknown exp]>(
                            Vector.get(i$43526, a$43516),
                            Vector.get(j$43528, b$43518)
                        )
                    ) {
                        false
                    } else {
                        loop$43524(
                            <[unknown exp]>(i$43526, 1i32)
                        )(<[unknown exp]>(j$43528, 1i32))
                    }
                };
        loop$43524(
            <[unknown exp]>(len1$43520, 1i32)
        )(<[unknown exp]>(len2$43522, 1i32))
    }
}

def Vector.iterator(
    rc$44112: Region[r],
    v$44114: Vector[a]
): Iterator[a, r, r] \ r = {
    |>(
        Iterator.range(rc$44112, 0i32, Vector.length(v$44114)),
        (
            $0$47085 ->
                $1$47087 ->
                    Iterator.map($0$47085, $1$47087)
        )(i$44116 -> Vector.get(i$44116, v$44114))
    )
}

def Vector.join(sep$44164: String, v$44166: Vector[a]): String = {
    Vector.joinWith($0$47091 -> <[unknown exp]>($0$47091), sep$44164, v$44166)
}

def Vector.joinWith(
    f$44176: a -> String,
    sep$44179: String,
    v$44182: Vector[a]
): String \ ef = {
    region rc$44187 {<[unknown exp]>}
}

def Vector.last(v$43019: Vector[a]): Option[a] = {
    Vector.nth(<[unknown exp]>(Vector.length(v$43019), 1i32), v$43019)
}

def Vector.length(v$41985: Vector[a]): Int32 = {v$41985..length}

def Vector.map(f$43187: a -> b, v$43189: Vector[a]): Vector[b] \ ef = {
    Vector.init(
        i$43191 ->
            f$43187(Vector.get(i$43191, v$43189)),
        Vector.length(v$43189)
    )
}

def Vector.mapWithIndex(
    f$43196: Int32 -> a -> b \ ef,
    v$43198: Vector[a]
): Vector[b] \ ef = {
    Vector.init(
        i$43200 ->
            f$43196(i$43200)(Vector.get(i$43200, v$43198)),
        Vector.length(v$43198)
    )
}

def Vector.maximum(v$43047: Vector[a]): Option[a] = {
    Vector.reduceLeft(
        $0$46990 ->
            $1$46992 ->
                <[unknown exp]>($0$46990, $1$46992),
        v$43047
    )
}

def Vector.maximumBy(
    cmp$43050: a -> a -> Comparison,
    v$43052: Vector[a]
): Option[a] = {
    Vector.reduceLeft(
        (
            $0$46994 ->
                $1$46996 ->
                    $2$46998 ->
                        Order.maxBy($0$46994, $1$46996, $2$46998)
        )(cmp$43050),
        v$43052
    )
}

def Vector.memberOf(x$43032: a, v$43034: Vector[a]): Bool = {
    Vector.exists(y$43036 -> <[unknown exp]>(y$43036, x$43032), v$43034)
}

def Vector.minimum(v$43039: Vector[a]): Option[a] = {
    Vector.reduceLeft(
        $0$46980 ->
            $1$46982 ->
                <[unknown exp]>($0$46980, $1$46982),
        v$43039
    )
}

def Vector.minimumBy(
    cmp$43042: a -> a -> Comparison,
    v$43044: Vector[a]
): Option[a] = {
    Vector.reduceLeft(
        (
            $0$46984 ->
                $1$46986 ->
                    $2$46988 ->
                        Order.minBy($0$46984, $1$46986, $2$46988)
        )(cmp$43042),
        v$43044
    )
}

def Vector.nonEmpty(v$41952: Vector[a]): Bool = {!Vector.isEmpty(v$41952)}

def Vector.nonUniform(l$43456: Int32, vs$43458: Vector[Vector[a]]): Bool = {
    Vector.exists(
        x$43460 ->
            <[unknown exp]>(Vector.length(x$43460), l$43456),
        vs$43458
    )
}

def Vector.nth(i$41815: Int32, v$41817: Vector[a]): Option[a] = {
    if (
        <[unknown exp]>(
            0i32,
            i$41815
        ) and <[unknown exp]>(i$41815, Vector.length(v$41817))
    ) {
        Option.Some(Vector.get(i$41815, v$41817))
    } else {
        Option.None
    }
}

def Vector.partition(
    f$43700: a -> Bool,
    v$43702: Vector[a]
): (Vector[a], Vector[a]) \ ef = {
    let step$43704: (
        a -> ((List[a], List[a])) -> (List[a], List[a]) \ ef
    ) = x$43706 ->
        acc$43708 ->
            match acc$43708 {
                case (a1$43710, a2$43712) =>
                    if (f$43700(x$43706)) {
                        (List.Cons(x$43706, a1$43710), a2$43712)
                    } else {
                        (a1$43710, List.Cons(x$43706, a2$43712))
                    }
            };
    match Vector.foldRight(step$43704, (List.Nil, List.Nil), v$43702) {
        case (xs$43714, ys$43716) =>
            (List.toVector(xs$43714), List.toVector(ys$43716))
    }
}

def Vector.patch(
    i$43366: Int32,
    n$43368: Int32,
    a$43370: Vector[a],
    b$43372: Vector[a]
): Vector[a] = {
    let len1$43374: Int32 = Vector.length(a$43370);
    let size$43376: Int32 = if (<[unknown exp]>(n$43368, len1$43374)) {
        len1$43374
    } else {
        n$43368
    };
    let sub$43378: Vector[a] = Vector.slice(
        {+start = 0i32 | {}},
        {+end = size$43376 | {}},
        a$43370
    );
    Vector.updateSequence(i$43366, sub$43378, b$43372)
}

def Vector.putA!(
    mx$43251: m[a],
    i$43253: Int32,
    marr$43255: m[Array[a, r]]
): m[Array[a, r]] \ r = {
    <[unknown exp]>
}

def Vector.range(b$43112: Int32, e$43114: Int32): Vector[Int32] = {
    let len$43116: Int32 = <[unknown exp]>(e$43114, b$43112);
    Vector.init(ix$43118 -> <[unknown exp]>(b$43112, ix$43118), len$43116)
}

def Vector.reduceLeft(
    f$43593: a -> a -> a \ ef,
    v$43595: Vector[a]
): Option[a] \ ef = {
    let len$43597: Int32 = Vector.length(v$43595);
    letrec loop$43599: (Int32 -> a -> a \ (e89271 & ef) + ef) = i$43601 ->
        acc$43603 ->
            if (<[unknown exp]>(i$43601, len$43597)) {
                acc$43603
            } else {
                loop$43599(
                    <[unknown exp]>(i$43601, 1i32)
                )(f$43593(acc$43603)(Vector.get(i$43601, v$43595)))
            };
    if (<[unknown exp]>(len$43597, 0i32)) {
        Option.None
    } else {
        Option.Some(loop$43599(1i32)(Vector.get(0i32, v$43595)))
    }
}

def Vector.reduceRight(
    f$43607: a -> a -> a \ ef,
    v$43609: Vector[a]
): Option[a] \ ef = {
    let len$43611: Int32 = Vector.length(v$43609);
    letrec loop$43613: (Int32 -> a -> a \ (e86012 & ef) + ef) = i$43615 ->
        acc$43617 ->
            if (<[unknown exp]>(i$43615, 0i32)) {
                acc$43617
            } else {
                loop$43613(
                    <[unknown exp]>(i$43615, 1i32)
                )(f$43607(Vector.get(i$43615, v$43609))(acc$43617))
            };
    if (<[unknown exp]>(len$43611, 0i32)) {
        Option.None
    } else {
        Option.Some(
            loop$43613(
                <[unknown exp]>(len$43611, 2i32)
            )(Vector.get(<[unknown exp]>(len$43611, 1i32), v$43609))
        )
    }
}

def Vector.repeat(n$43121: Int32, x$43123: a): Vector[a] = {
    Vector.init(_$43125 -> x$43123, n$43121)
}

def Vector.replace(
    src$43463: { src = a },
    dst$43465: { dst = a },
    v$43467: Vector[a]
): Vector[a] = {
    Vector.map(
        e$43469 ->
            if (<[unknown exp]>(e$43469, src$43463.src)) {
                dst$43465.dst
            } else {
                e$43469
            },
        v$43467
    )
}

def Vector.reverse(v$43310: Vector[a]): Vector[a] = {
    let len$43312: Int32 = Vector.length(v$43310);
    Vector.init(
        ix$43314 ->
            Vector.get(
                <[unknown exp]>(len$43312, <[unknown exp]>(ix$43314, 1i32)),
                v$43310
            ),
        len$43312
    )
}

def Vector.rotateLeft(n$43317: Int32, v$43319: Vector[a]): Vector[a] = {
    let len$43321: Int32 = Vector.length(v$43319);
    if (<[unknown exp]>(len$43321, 1i32)) {
        Vector.empty(())
    } else {
        if (<[unknown exp]>(n$43317, 0i32)) {
            Vector.rotateRightHelper(Int32.abs(n$43317), v$43319)
        } else {
            Vector.rotateLeftHelper(n$43317, v$43319)
        }
    }
}

def Vector.rotateLeftHelper(n$43324: Int32, v$43326: Vector[a]): Vector[a] = {
    let len$43328: Int32 = Vector.length(v$43326);
    let f$43330: (Int32 -> a) = ix$43332 ->
        {
            let readIx$43334: Int32 = Int32.modulo(
                <[unknown exp]>(ix$43332, n$43324),
                len$43328
            );
            Vector.get(readIx$43334, v$43326)
        };
    Vector.init(f$43330, len$43328)
}

def Vector.rotateRight(n$43337: Int32, v$43339: Vector[a]): Vector[a] = {
    if (<[unknown exp]>(Vector.length(v$43339), 1i32)) {
        Vector.empty(())
    } else {
        if (<[unknown exp]>(n$43337, 0i32)) {
            Vector.rotateLeftHelper(Int32.abs(n$43337), v$43339)
        } else {
            Vector.rotateRightHelper(n$43337, v$43339)
        }
    }
}

def Vector.rotateRightHelper(n$43342: Int32, v$43344: Vector[a]): Vector[a] = {
    let len$43346: Int32 = Vector.length(v$43344);
    let f$43348: (Int32 -> a) = ix$43350 ->
        {
            let readIx$43352: Int32 = Int32.modulo(
                <[unknown exp]>(ix$43350, n$43342),
                len$43346
            );
            Vector.get(readIx$43352, v$43344)
        };
    Vector.init(f$43348, len$43346)
}

def Vector.scan(
    f$43130: b -> a -> b \ ef,
    s$43132: b,
    v$43134: Vector[a]
): Vector[b] \ ef = {
    Vector.scanLeft(f$43130, s$43132, v$43134)
}

def Vector.scanLeft(
    f$43139: b -> a -> b \ ef,
    s$43141: b,
    v$43143: Vector[a]
): Vector[b] \ ef = {
    region rc$43145 {
        let arr$43148: Array[b, rc] = Array.empty(
            rc$43145,
            <[unknown exp]>(Vector.length(v$43143), 1i32)
        );
        let acc$43150: Ref[b, rc] = (ref s$43141) @ rc$43145;
        Array.put(s$43141, 0i32, arr$43148);
        let step$43152: (Int32 -> a -> Unit \ ef + rc + rc) = i$43154 ->
            x$43156 ->
                {
                    let s1$43158: b = f$43139(deref acc$43150)(x$43156);
                    Ref.put(s1$43158, acc$43150);
                    Array.put(
                        s1$43158,
                        <[unknown exp]>(i$43154, 1i32),
                        arr$43148
                    )
                };
        Vector.forEachWithIndex(step$43152, v$43143);
        Array.toVector(arr$43148)
    }
}

def Vector.scanRight(
    f$43163: a -> b -> b \ ef,
    s$43165: b,
    v$43167: Vector[a]
): Vector[b] \ ef = {
    region rc$43169 {
        let len$43172: Int32 = Vector.length(v$43167);
        let arr$43174: Array[b, rc] = Array.empty(
            rc$43169,
            <[unknown exp]>(len$43172, 1i32)
        );
        let acc$43176: Ref[b, rc] = (ref s$43165) @ rc$43169;
        Array.put(s$43165, len$43172, arr$43174);
        letrec loop$43178: (Int32 -> Unit) = i$43180 ->
            if (<[unknown exp]>(i$43180, 0i32)) {
                ()
            } else {
                let s1$43182: b = f$43163(
                    Vector.get(i$43180, v$43167)
                )(deref acc$43176);
                Ref.put(s1$43182, acc$43176);
                Array.put(s1$43182, i$43180, arr$43174);
                loop$43178(<[unknown exp]>(i$43180, 1i32))
            };
        loop$43178(<[unknown exp]>(len$43172, 1i32));
        Array.toVector(arr$43174)
    }
}

def Vector.sequence(v$43204: Vector[m[a]]): m[Vector[a]] = {
    region rc$43206 {
        let len$43209: Int32 = Vector.length(v$43204);
        let arr$43211: Array[a, rc] = Array.empty(rc$43206, len$43209);
        letrec loop$43213: (
            Int32 ->
                (m[Array[a, rc]] -> m[Array[a, rc]] \ rc) -> m[Array[a, rc]] \ rc
        ) = i$43215 ->
            k$43217 ->
                if (<[unknown exp]>(i$43215, len$43209)) {
                    k$43217(<[unknown exp]>(arr$43211))
                } else {
                    let mx$43219: m[a] = Vector.get(i$43215, v$43204);
                    loop$43213(
                        <[unknown exp]>(i$43215, 1i32)
                    )(
                        karr$43221 ->
                            k$43217(Vector.putA!(mx$43219, i$43215, karr$43221))
                    )
                };
        <[unknown exp]>(
            $0$47008 ->
                Array.toVector($0$47008),
            loop$43213(0i32)($0$47010 -> eidentity($0$47010))
        )
    }
}

def Vector.shuffle(rnd$44220: Random, v$44222: Vector[a]): Vector[a] \ IO = {
    region rc$44224 {
        let arr$44227: Array[a, rc] = Vector.toArray(rc$44224, v$44222);
        Array.shuffle(rnd$44220, arr$44227);
        Array.toVector(arr$44227)
    }
}

def Vector.singleton(x$38709: a): Vector[a] = {
    Vector.init(_$38717 -> x$38709, 1i32)
}

def Vector.slice(
    start$42943: { start = Int32 },
    end$42945: { end = Int32 },
    v$42947: Vector[a]
): Vector[a] = {
    region rc$42949 {
        let arr$42952: Array[a, rc] = Vector.toArray(rc$42949, v$42947);
        |>(
            Array.slice(rc$42949, start$42943, end$42945, arr$42952),
            $0$46974 ->
                Array.toVector($0$46974)
        )
    }
}

def Vector.sort(v$44201: Vector[a]): Vector[a] = {
    Vector.sortWith(
        $0$47097 ->
            $1$47099 ->
                <[unknown exp]>($0$47097, $1$47099),
        v$44201
    )
}

def Vector.sortBy(f$44205: a -> b, v$44207: Vector[a]): Vector[a] = {
    Vector.sortWith(
        (
            $0$47101 ->
                $1$47103 ->
                    $2$47105 ->
                        $3$47107 ->
                            on($0$47101, $1$47103, $2$47105, $3$47107)
        )($0$47109 -> $1$47111 -> <[unknown exp]>($0$47109, $1$47111))(f$44205),
        v$44207
    )
}

def Vector.sortWith(
    cmp$44210: a -> a -> Comparison,
    v$44212: Vector[a]
): Vector[a] = {
    region rc$44214 {
        let arr$44217: Array[a, rc] = Vector.toArray(rc$44214, v$44212);
        Array.sortWith!(cmp$44210, arr$44217);
        Array.toVector(arr$44217)
    }
}

def Vector.span(
    f$43720: a -> Bool,
    v$43722: Vector[a]
): (Vector[a], Vector[a]) \ ef = {
    match Vector.findIndexOfLeft(x$43724 -> !f$43720(x$43724), v$43722) {
        case Option.None =>
            (Vector.takeLeft(Vector.length(v$43722), v$43722), Vector.empty(()))
        case Option.Some(i$43726) =>
            (
                Vector.takeLeft(i$43726, v$43722),
                Vector.dropLeft(i$43726, v$43722)
            )
    }
}

def Vector.splitAt(
    n$43831: Int32,
    v$43833: Vector[a]
): (Vector[a], Vector[a]) = {
    (Vector.take(n$43831, v$43833), Vector.drop(n$43831, v$43833))
}

def Vector.sum(v$43629: Vector[Int32]): Int32 = {
    Vector.foldLeft(
        acc$43631 ->
            x$43633 ->
                <[unknown exp]>(acc$43631, x$43633),
        0i32,
        v$43629
    )
}

def Vector.sumLengths(vs$43436: Vector[Vector[a]]): Int32 = {
    Vector.foldLeft(
        acc$43438 ->
            a$43440 ->
                <[unknown exp]>(acc$43438, Vector.length(a$43440)),
        0i32,
        vs$43436
    )
}

def Vector.sumWith(f$43637: a -> Int32, v$43639: Vector[a]): Int32 \ ef = {
    Vector.foldLeft(
        acc$43641 ->
            x$43643 ->
                <[unknown exp]>(acc$43641, f$43637(x$43643)),
        0i32,
        v$43639
    )
}

def Vector.take(n$43780: Int32, v$43782: Vector[a]): Vector[a] = {
    Vector.takeLeft(n$43780, v$43782)
}

def Vector.takeLeft(n$43787: Int32, v$43789: Vector[a]): Vector[a] = {
    if (<[unknown exp]>(n$43787, 0i32)) {
        Vector.empty(())
    } else {
        let len$43791: Int32 = Vector.length(v$43789);
        let end$43793: Int32 = if (<[unknown exp]>(n$43787, len$43791)) {
            len$43791
        } else {
            n$43787
        };
        Vector.slice({+start = 0i32 | {}}, {+end = end$43793 | {}}, v$43789)
    }
}

def Vector.takeRight(n$43796: Int32, v$43798: Vector[a]): Vector[a] = {
    if (<[unknown exp]>(n$43796, 0i32)) {
        Vector.empty(())
    } else {
        let len$43800: Int32 = Vector.length(v$43798);
        let start$43802: Int32 = if (<[unknown exp]>(n$43796, len$43800)) {
            0i32
        } else {
            <[unknown exp]>(len$43800, n$43796)
        };
        Vector.slice(
            {+start = start$43802 | {}},
            {+end = len$43800 | {}},
            v$43798
        )
    }
}

def Vector.takeWhile(f$43806: a -> Bool, a$43808: Vector[a]): Vector[a] \ ef = {
    Vector.takeWhileLeft(f$43806, a$43808)
}

def Vector.takeWhileLeft(
    f$43812: a -> Bool,
    v$43814: Vector[a]
): Vector[a] \ ef = {
    match Vector.findIndexOfLeft(x$43816 -> !f$43812(x$43816), v$43814) {
        case Option.None =>
            Vector.slice(
                {+start = 0i32 | {}},
                {+end = Vector.length(v$43814) | {}},
                v$43814
            )
        case Option.Some(i$43818) =>
            Vector.takeLeft(i$43818, v$43814)
    }
}

def Vector.takeWhileRight(
    f$43822: a -> Bool,
    v$43824: Vector[a]
): Vector[a] \ ef = {
    match Vector.findIndexOfRight(x$43826 -> !f$43822(x$43826), v$43824) {
        case Option.None =>
            Vector.slice(
                {+start = 0i32 | {}},
                {+end = Vector.length(v$43824) | {}},
                v$43824
            )
        case Option.Some(i$43828) =>
            Vector.slice(
                {+start = <[unknown exp]>(i$43828, 1i32) | {}},
                {+end = Vector.length(v$43824) | {}},
                v$43824
            )
    }
}

def Vector.toArray(rc$42956: Region[r], v$42958: Vector[a]): Array[a, r] \ r = {
    let arr$42960: Array[a, r] = Array.empty(rc$42956, Vector.length(v$42958));
    Vector.forEachWithIndex(
        i$42962 ->
            x$42964 ->
                Array.put(x$42964, i$42962, arr$42960),
        v$42958
    );
    arr$42960
}

def Vector.toChain(v$42992: Vector[a]): Chain[a] = {
    Vector.foldRight(
        $0$46976 ->
            $1$46978 ->
                Chain.cons($0$46976, $1$46978),
        Chain.empty(()),
        v$42992
    )
}

def Vector.toDelayList(v$42985: Vector[a]): DelayList[a] = {
    Vector.foldRight(
        x$42987 ->
            acc$42989 ->
                DelayList.ECons(x$42987, acc$42989),
        DelayList.ENil,
        v$42985
    )
}

def Vector.toList(v$42967: Vector[a]): List[a] = {
    Vector.foldRight(
        x$42969 ->
            acc$42971 ->
                List.Cons(x$42969, acc$42971),
        List.Nil,
        v$42967
    )
}

def Vector.toMap(v$44021: Vector[(a, b)]): Map[a, b] = {
    Vector.foldRight(
        x$44023 ->
            m$44025 ->
                Map.insert(fst(x$44023), snd(x$44023), m$44025),
        Map.empty(()),
        v$44021
    )
}

def Vector.toMutDeque(
    rc$43007: Region[r],
    v$43009: Vector[a]
): MutDeque[a, r] \ r = {
    let d$43011: MutDeque[a, r] = MutDeque.empty(rc$43007);
    Vector.forEach(x$43013 -> MutDeque.pushBack(x$43013, d$43011), v$43009);
    d$43011
}

def Vector.toMutList(
    rc$44029: Region[r],
    v$44031: Vector[a]
): MutList[a, r] \ r = {
    |>(
        Vector.toArray(rc$44029, v$44031),
        ($0$47080 -> $1$47082 -> Array.toMutList($0$47080, $1$47082))(rc$44029)
    )
}

def Vector.toNec(v$42995: Vector[a]): Option[Nec[a]] = {
    let step$42997: (a -> Option[Nec[a]] -> Option[Nec[a]]) = x$42999 ->
        acc$43001 ->
            match acc$43001 {
                case Option.None =>
                    Option.Some(Nec.singleton(x$42999))
                case Option.Some(c$43003) =>
                    Option.Some(Nec.cons(x$42999, c$43003))
            };
    Vector.foldRight(step$42997, Option.None, v$42995)
}

def Vector.toNel(v$42974: Vector[a]): Option[Nel[a]] = {
    let step$42976: (a -> Option[Nel[a]] -> Option[Nel[a]]) = x$42978 ->
        acc$42980 ->
            match acc$42980 {
                case Option.None =>
                    Option.Some(Nel.singleton(x$42978))
                case Option.Some(c$42982) =>
                    Option.Some(Nel.cons(x$42978, c$42982))
            };
    Vector.foldRight(step$42976, Option.None, v$42974)
}

def Vector.toSet(v$44017: Vector[a]): Set[a] = {
    Vector.foldRight(
        $0$47076 ->
            $1$47078 ->
                Set.insert($0$47076, $1$47078),
        Set.empty(()),
        v$44017
    )
}

def Vector.toString(v$38503: Vector[a]): String = {
    region rc$38515 {
        let sb$38520: StringBuilder[rc] = StringBuilder.empty(rc$38515);
        let first$38522: Ref[Bool, rc] = (ref true) @ rc$38515;
        StringBuilder.appendString!("""Vector#{""", sb$38520);
        let f$38524: (a -> Unit) = x$38526 ->
            {
                if (!(deref first$38522)) {
                    StringBuilder.appendString!(""", """, sb$38520)
                } else {
                    Ref.put(false, first$38522)
                };
                StringBuilder.appendString!(
                    """""" + <[unknown exp]>(x$38526),
                    sb$38520
                )
            };
        Vector.forEach(f$38524, v$38503);
        StringBuilder.appendString!("""}""", sb$38520);
        StringBuilder.toString(sb$38520)
    }
}

def Vector.transpose(vs$43443: Vector[Vector[a]]): Vector[Vector[a]] = {
    let ilen$43445: Int32 = Vector.length(vs$43443);
    if (<[unknown exp]>(ilen$43445, 0i32)) {
        Vector.empty(())
    } else {
        let jlen$43447: Int32 = Vector.length(Vector.get(0i32, vs$43443));
        if (
            <[unknown exp]>(
                jlen$43447,
                0i32
            ) or Vector.nonUniform(jlen$43447, vs$43443)
        ) {
            Vector.init(
                i$43449 ->
                    Vector.slice(
                        {+start = 0i32 | {}},
                        {
                            +end = Vector.length(
                                Vector.get(i$43449, vs$43443)
                            ) |
                            {}
                        },
                        Vector.get(i$43449, vs$43443)
                    ),
                ilen$43445
            )
        } else {
            Vector.init(
                i$43451 ->
                    Vector.init(
                        j$43453 ->
                            Vector.get(i$43451, Vector.get(j$43453, vs$43443)),
                        ilen$43445
                    ),
                jlen$43447
            )
        }
    }
}

def Vector.traverse(
    f$43227: a -> m[b],
    v$43229: Vector[a]
): m[Vector[b]] \ ef = {
    region rc$43231 {
        let len$43234: Int32 = Vector.length(v$43229);
        let arr$43236: Array[b, rc] = Array.empty(rc$43231, len$43234);
        letrec loop$43238: (
            Int32 ->
                (m[Array[b, rc]] -> m[Array[b, rc]] \ ef + rc + (e118243 & e118256 & ef)) -> m[Array[b, rc]] \ ef + rc + ef + rc
        ) = i$43240 ->
            k$43242 ->
                if (<[unknown exp]>(i$43240, len$43234)) {
                    k$43242(<[unknown exp]>(arr$43236))
                } else {
                    let x$43244: a = Vector.get(i$43240, v$43229);
                    loop$43238(
                        <[unknown exp]>(i$43240, 1i32)
                    )(
                        karr$43246 ->
                            k$43242(
                                Vector.putA!(
                                    f$43227(x$43244),
                                    i$43240,
                                    karr$43246
                                )
                            )
                    )
                };
        <[unknown exp]>(
            $0$47012 ->
                Array.toVector($0$47012),
            loop$43238(0i32)($0$47014 -> eidentity($0$47014))
        )
    }
}

def Vector.unzip(v$43909: Vector[(a, b)]): (Vector[a], Vector[b]) = {
    region rc$43911 {
        let len$43914: Int32 = Vector.length(v$43909);
        let arr$43916: Array[a, rc] = Array.empty(rc$43911, len$43914);
        let brr$43918: Array[b, rc] = Array.empty(rc$43911, len$43914);
        Vector.forEachWithIndex(
            i$43920 ->
                x$43922 ->
                    match x$43922 {
                        case (l$43924, r$43926) =>
                            Array.put(l$43924, i$43920, arr$43916);
                            Array.put(r$43926, i$43920, brr$43918)
                    },
            v$43909
        );
        (Array.toVector(arr$43916), Array.toVector(brr$43918))
    }
}

def Vector.update(i$43355: Int32, x$43357: a, v$43359: Vector[a]): Vector[a] = {
    let f$43361: (Int32 -> a) = ix$43363 ->
        if (<[unknown exp]>(ix$43363, i$43355)) {
            x$43357
        } else {
            Vector.get(ix$43363, v$43359)
        };
    Vector.init(f$43361, Vector.length(v$43359))
}

def Vector.updateSequence(
    i$44149: Int32,
    sub$44151: Vector[a],
    v$44153: Vector[a]
): Vector[a] = {
    let end$44155: Int32 = <[unknown exp]>(i$44149, Vector.length(sub$44151));
    let len$44157: Int32 = Vector.length(v$44153);
    let f$44159: (Int32 -> a) = ix$44161 ->
        if (
            <[unknown exp]>(
                ix$44161,
                i$44149
            ) and <[unknown exp]>(ix$44161, end$44155)
        ) {
            Vector.get(<[unknown exp]>(ix$44161, i$44149), sub$44151)
        } else {
            Vector.get(ix$44161, v$44153)
        };
    Vector.init(f$44159, len$44157)
}

def Vector.zip(a$43885: Vector[a], b$43887: Vector[b]): Vector[(a, b)] = {
    let len$43889: Int32 = Int32.min(
        Vector.length(a$43885),
        Vector.length(b$43887)
    );
    Vector.init(
        i$43891 ->
            (Vector.get(i$43891, a$43885), Vector.get(i$43891, b$43887)),
        len$43889
    )
}

def Vector.zipWith(
    f$43897: a -> b -> c \ ef,
    a$43899: Vector[a],
    b$43901: Vector[b]
): Vector[c] \ ef = {
    let len$43903: Int32 = Int32.min(
        Vector.length(a$43899),
        Vector.length(b$43901)
    );
    Vector.init(
        i$43905 ->
            f$43897(Vector.get(i$43905, a$43899))(Vector.get(i$43905, b$43901)),
        len$43903
    )
}

def Vector.zipWithA(
    f$43266: a -> b -> m[c] \ ef,
    v1$43268: Vector[a],
    v2$43270: Vector[b]
): m[Vector[c]] \ ef = {
    region rc$43272 {
        let len$43275: Int32 = Int32.min(
            Vector.length(v1$43268),
            Vector.length(v2$43270)
        );
        let arr$43277: Array[c, rc] = Array.empty(rc$43272, len$43275);
        letrec loop$43279: (
            Int32 ->
                (m[Array[c, rc]] -> m[Array[c, rc]] \ ef + rc + (e109313 & e109328 & ef)) -> m[Array[c, rc]] \ ef + rc + ef + rc
        ) = i$43281 ->
            k$43283 ->
                if (<[unknown exp]>(i$43281, len$43275)) {
                    k$43283(<[unknown exp]>(arr$43277))
                } else {
                    let x$43285: a = Vector.get(i$43281, v1$43268);
                    let y$43287: b = Vector.get(i$43281, v2$43270);
                    loop$43279(
                        <[unknown exp]>(i$43281, 1i32)
                    )(
                        karr$43289 ->
                            k$43283(
                                Vector.putA!(
                                    f$43266(x$43285)(y$43287),
                                    i$43281,
                                    karr$43289
                                )
                            )
                    )
                };
        <[unknown exp]>(
            $0$47022 ->
                Array.toVector($0$47022),
            loop$43279(0i32)($0$47024 -> eidentity($0$47024))
        )
    }
}